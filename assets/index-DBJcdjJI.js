(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))a(r);new MutationObserver(r=>{for(const s of r)if(s.type==="childList")for(const i of s.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&a(i)}).observe(document,{childList:!0,subtree:!0});function n(r){const s={};return r.integrity&&(s.integrity=r.integrity),r.referrerPolicy&&(s.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?s.credentials="include":r.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function a(r){if(r.ep)return;r.ep=!0;const s=n(r);fetch(r.href,s)}})();var B1={exports:{}},vm={};var QA;function IV(){if(QA)return vm;QA=1;var e=Symbol.for("react.transitional.element"),t=Symbol.for("react.fragment");function n(a,r,s){var i=null;if(s!==void 0&&(i=""+s),r.key!==void 0&&(i=""+r.key),"key"in r){s={};for(var o in r)o!=="key"&&(s[o]=r[o])}else s=r;return r=s.ref,{$$typeof:e,type:a,key:i,ref:r!==void 0?r:null,props:s}}return vm.Fragment=t,vm.jsx=n,vm.jsxs=n,vm}var e$;function TV(){return e$||(e$=1,B1.exports=IV()),B1.exports}var P=TV(),P1={exports:{}},ct={};var t$;function EV(){if(t$)return ct;t$=1;var e=Symbol.for("react.transitional.element"),t=Symbol.for("react.portal"),n=Symbol.for("react.fragment"),a=Symbol.for("react.strict_mode"),r=Symbol.for("react.profiler"),s=Symbol.for("react.consumer"),i=Symbol.for("react.context"),o=Symbol.for("react.forward_ref"),u=Symbol.for("react.suspense"),d=Symbol.for("react.memo"),c=Symbol.for("react.lazy"),p=Symbol.for("react.activity"),m=Symbol.iterator;function g(L){return L===null||typeof L!="object"?null:(L=m&&L[m]||L["@@iterator"],typeof L=="function"?L:null)}var b={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},v=Object.assign,x={};function w(L,ee,ie){this.props=L,this.context=ee,this.refs=x,this.updater=ie||b}w.prototype.isReactComponent={},w.prototype.setState=function(L,ee){if(typeof L!="object"&&typeof L!="function"&&L!=null)throw Error("takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,L,ee,"setState")},w.prototype.forceUpdate=function(L){this.updater.enqueueForceUpdate(this,L,"forceUpdate")};function k(){}k.prototype=w.prototype;function N(L,ee,ie){this.props=L,this.context=ee,this.refs=x,this.updater=ie||b}var I=N.prototype=new k;I.constructor=N,v(I,w.prototype),I.isPureReactComponent=!0;var T=Array.isArray;function $(){}var D={H:null,A:null,T:null,S:null},M=Object.prototype.hasOwnProperty;function B(L,ee,ie){var de=ie.ref;return{$$typeof:e,type:L,key:ee,ref:de!==void 0?de:null,props:ie}}function V(L,ee){return B(L.type,ee,L.props)}function W(L){return typeof L=="object"&&L!==null&&L.$$typeof===e}function R(L){var ee={"=":"=0",":":"=2"};return"$"+L.replace(/[=:]/g,function(ie){return ee[ie]})}var H=/\/+/g;function Z(L,ee){return typeof L=="object"&&L!==null&&L.key!=null?R(""+L.key):ee.toString(36)}function ae(L){switch(L.status){case"fulfilled":return L.value;case"rejected":throw L.reason;default:switch(typeof L.status=="string"?L.then($,$):(L.status="pending",L.then(function(ee){L.status==="pending"&&(L.status="fulfilled",L.value=ee)},function(ee){L.status==="pending"&&(L.status="rejected",L.reason=ee)})),L.status){case"fulfilled":return L.value;case"rejected":throw L.reason}}throw L}function j(L,ee,ie,de,we){var Ie=typeof L;(Ie==="undefined"||Ie==="boolean")&&(L=null);var Ee=!1;if(L===null)Ee=!0;else switch(Ie){case"bigint":case"string":case"number":Ee=!0;break;case"object":switch(L.$$typeof){case e:case t:Ee=!0;break;case c:return Ee=L._init,j(Ee(L._payload),ee,ie,de,we)}}if(Ee)return we=we(L),Ee=de===""?"."+Z(L,0):de,T(we)?(ie="",Ee!=null&&(ie=Ee.replace(H,"$&/")+"/"),j(we,ee,ie,"",function(Ke){return Ke})):we!=null&&(W(we)&&(we=V(we,ie+(we.key==null||L&&L.key===we.key?"":(""+we.key).replace(H,"$&/")+"/")+Ee)),ee.push(we)),1;Ee=0;var Ce=de===""?".":de+":";if(T(L))for(var ze=0;ze<L.length;ze++)de=L[ze],Ie=Ce+Z(de,ze),Ee+=j(de,ee,ie,Ie,we);else if(ze=g(L),typeof ze=="function")for(L=ze.call(L),ze=0;!(de=L.next()).done;)de=de.value,Ie=Ce+Z(de,ze++),Ee+=j(de,ee,ie,Ie,we);else if(Ie==="object"){if(typeof L.then=="function")return j(ae(L),ee,ie,de,we);throw ee=String(L),Error("Objects are not valid as a React child (found: "+(ee==="[object Object]"?"object with keys {"+Object.keys(L).join(", ")+"}":ee)+"). If you meant to render a collection of children, use an array instead.")}return Ee}function K(L,ee,ie){if(L==null)return L;var de=[],we=0;return j(L,de,"","",function(Ie){return ee.call(ie,Ie,we++)}),de}function Q(L){if(L._status===-1){var ee=L._result;ee=ee(),ee.then(function(ie){(L._status===0||L._status===-1)&&(L._status=1,L._result=ie)},function(ie){(L._status===0||L._status===-1)&&(L._status=2,L._result=ie)}),L._status===-1&&(L._status=0,L._result=ee)}if(L._status===1)return L._result.default;throw L._result}var ce=typeof reportError=="function"?reportError:function(L){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var ee=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof L=="object"&&L!==null&&typeof L.message=="string"?String(L.message):String(L),error:L});if(!window.dispatchEvent(ee))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",L);return}console.error(L)},me={map:K,forEach:function(L,ee,ie){K(L,function(){ee.apply(this,arguments)},ie)},count:function(L){var ee=0;return K(L,function(){ee++}),ee},toArray:function(L){return K(L,function(ee){return ee})||[]},only:function(L){if(!W(L))throw Error("React.Children.only expected to receive a single React element child.");return L}};return ct.Activity=p,ct.Children=me,ct.Component=w,ct.Fragment=n,ct.Profiler=r,ct.PureComponent=N,ct.StrictMode=a,ct.Suspense=u,ct.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=D,ct.__COMPILER_RUNTIME={__proto__:null,c:function(L){return D.H.useMemoCache(L)}},ct.cache=function(L){return function(){return L.apply(null,arguments)}},ct.cacheSignal=function(){return null},ct.cloneElement=function(L,ee,ie){if(L==null)throw Error("The argument must be a React element, but you passed "+L+".");var de=v({},L.props),we=L.key;if(ee!=null)for(Ie in ee.key!==void 0&&(we=""+ee.key),ee)!M.call(ee,Ie)||Ie==="key"||Ie==="__self"||Ie==="__source"||Ie==="ref"&&ee.ref===void 0||(de[Ie]=ee[Ie]);var Ie=arguments.length-2;if(Ie===1)de.children=ie;else if(1<Ie){for(var Ee=Array(Ie),Ce=0;Ce<Ie;Ce++)Ee[Ce]=arguments[Ce+2];de.children=Ee}return B(L.type,we,de)},ct.createContext=function(L){return L={$$typeof:i,_currentValue:L,_currentValue2:L,_threadCount:0,Provider:null,Consumer:null},L.Provider=L,L.Consumer={$$typeof:s,_context:L},L},ct.createElement=function(L,ee,ie){var de,we={},Ie=null;if(ee!=null)for(de in ee.key!==void 0&&(Ie=""+ee.key),ee)M.call(ee,de)&&de!=="key"&&de!=="__self"&&de!=="__source"&&(we[de]=ee[de]);var Ee=arguments.length-2;if(Ee===1)we.children=ie;else if(1<Ee){for(var Ce=Array(Ee),ze=0;ze<Ee;ze++)Ce[ze]=arguments[ze+2];we.children=Ce}if(L&&L.defaultProps)for(de in Ee=L.defaultProps,Ee)we[de]===void 0&&(we[de]=Ee[de]);return B(L,Ie,we)},ct.createRef=function(){return{current:null}},ct.forwardRef=function(L){return{$$typeof:o,render:L}},ct.isValidElement=W,ct.lazy=function(L){return{$$typeof:c,_payload:{_status:-1,_result:L},_init:Q}},ct.memo=function(L,ee){return{$$typeof:d,type:L,compare:ee===void 0?null:ee}},ct.startTransition=function(L){var ee=D.T,ie={};D.T=ie;try{var de=L(),we=D.S;we!==null&&we(ie,de),typeof de=="object"&&de!==null&&typeof de.then=="function"&&de.then($,ce)}catch(Ie){ce(Ie)}finally{ee!==null&&ie.types!==null&&(ee.types=ie.types),D.T=ee}},ct.unstable_useCacheRefresh=function(){return D.H.useCacheRefresh()},ct.use=function(L){return D.H.use(L)},ct.useActionState=function(L,ee,ie){return D.H.useActionState(L,ee,ie)},ct.useCallback=function(L,ee){return D.H.useCallback(L,ee)},ct.useContext=function(L){return D.H.useContext(L)},ct.useDebugValue=function(){},ct.useDeferredValue=function(L,ee){return D.H.useDeferredValue(L,ee)},ct.useEffect=function(L,ee){return D.H.useEffect(L,ee)},ct.useEffectEvent=function(L){return D.H.useEffectEvent(L)},ct.useId=function(){return D.H.useId()},ct.useImperativeHandle=function(L,ee,ie){return D.H.useImperativeHandle(L,ee,ie)},ct.useInsertionEffect=function(L,ee){return D.H.useInsertionEffect(L,ee)},ct.useLayoutEffect=function(L,ee){return D.H.useLayoutEffect(L,ee)},ct.useMemo=function(L,ee){return D.H.useMemo(L,ee)},ct.useOptimistic=function(L,ee){return D.H.useOptimistic(L,ee)},ct.useReducer=function(L,ee,ie){return D.H.useReducer(L,ee,ie)},ct.useRef=function(L){return D.H.useRef(L)},ct.useState=function(L){return D.H.useState(L)},ct.useSyncExternalStore=function(L,ee,ie){return D.H.useSyncExternalStore(L,ee,ie)},ct.useTransition=function(){return D.H.useTransition()},ct.version="19.2.3",ct}var n$;function Hk(){return n$||(n$=1,P1.exports=EV()),P1.exports}var he=Hk(),U1={exports:{}},xm={},j1={exports:{}},W1={};var a$;function CV(){return a$||(a$=1,(function(e){function t(j,K){var Q=j.length;j.push(K);e:for(;0<Q;){var ce=Q-1>>>1,me=j[ce];if(0<r(me,K))j[ce]=K,j[Q]=me,Q=ce;else break e}}function n(j){return j.length===0?null:j[0]}function a(j){if(j.length===0)return null;var K=j[0],Q=j.pop();if(Q!==K){j[0]=Q;e:for(var ce=0,me=j.length,L=me>>>1;ce<L;){var ee=2*(ce+1)-1,ie=j[ee],de=ee+1,we=j[de];if(0>r(ie,Q))de<me&&0>r(we,ie)?(j[ce]=we,j[de]=Q,ce=de):(j[ce]=ie,j[ee]=Q,ce=ee);else if(de<me&&0>r(we,Q))j[ce]=we,j[de]=Q,ce=de;else break e}}return K}function r(j,K){var Q=j.sortIndex-K.sortIndex;return Q!==0?Q:j.id-K.id}if(e.unstable_now=void 0,typeof performance=="object"&&typeof performance.now=="function"){var s=performance;e.unstable_now=function(){return s.now()}}else{var i=Date,o=i.now();e.unstable_now=function(){return i.now()-o}}var u=[],d=[],c=1,p=null,m=3,g=!1,b=!1,v=!1,x=!1,w=typeof setTimeout=="function"?setTimeout:null,k=typeof clearTimeout=="function"?clearTimeout:null,N=typeof setImmediate<"u"?setImmediate:null;function I(j){for(var K=n(d);K!==null;){if(K.callback===null)a(d);else if(K.startTime<=j)a(d),K.sortIndex=K.expirationTime,t(u,K);else break;K=n(d)}}function T(j){if(v=!1,I(j),!b)if(n(u)!==null)b=!0,$||($=!0,R());else{var K=n(d);K!==null&&ae(T,K.startTime-j)}}var $=!1,D=-1,M=5,B=-1;function V(){return x?!0:!(e.unstable_now()-B<M)}function W(){if(x=!1,$){var j=e.unstable_now();B=j;var K=!0;try{e:{b=!1,v&&(v=!1,k(D),D=-1),g=!0;var Q=m;try{t:{for(I(j),p=n(u);p!==null&&!(p.expirationTime>j&&V());){var ce=p.callback;if(typeof ce=="function"){p.callback=null,m=p.priorityLevel;var me=ce(p.expirationTime<=j);if(j=e.unstable_now(),typeof me=="function"){p.callback=me,I(j),K=!0;break t}p===n(u)&&a(u),I(j)}else a(u);p=n(u)}if(p!==null)K=!0;else{var L=n(d);L!==null&&ae(T,L.startTime-j),K=!1}}break e}finally{p=null,m=Q,g=!1}K=void 0}}finally{K?R():$=!1}}}var R;if(typeof N=="function")R=function(){N(W)};else if(typeof MessageChannel<"u"){var H=new MessageChannel,Z=H.port2;H.port1.onmessage=W,R=function(){Z.postMessage(null)}}else R=function(){w(W,0)};function ae(j,K){D=w(function(){j(e.unstable_now())},K)}e.unstable_IdlePriority=5,e.unstable_ImmediatePriority=1,e.unstable_LowPriority=4,e.unstable_NormalPriority=3,e.unstable_Profiling=null,e.unstable_UserBlockingPriority=2,e.unstable_cancelCallback=function(j){j.callback=null},e.unstable_forceFrameRate=function(j){0>j||125<j?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):M=0<j?Math.floor(1e3/j):5},e.unstable_getCurrentPriorityLevel=function(){return m},e.unstable_next=function(j){switch(m){case 1:case 2:case 3:var K=3;break;default:K=m}var Q=m;m=K;try{return j()}finally{m=Q}},e.unstable_requestPaint=function(){x=!0},e.unstable_runWithPriority=function(j,K){switch(j){case 1:case 2:case 3:case 4:case 5:break;default:j=3}var Q=m;m=j;try{return K()}finally{m=Q}},e.unstable_scheduleCallback=function(j,K,Q){var ce=e.unstable_now();switch(typeof Q=="object"&&Q!==null?(Q=Q.delay,Q=typeof Q=="number"&&0<Q?ce+Q:ce):Q=ce,j){case 1:var me=-1;break;case 2:me=250;break;case 5:me=1073741823;break;case 4:me=1e4;break;default:me=5e3}return me=Q+me,j={id:c++,callback:K,priorityLevel:j,startTime:Q,expirationTime:me,sortIndex:-1},Q>ce?(j.sortIndex=Q,t(d,j),n(u)===null&&j===n(d)&&(v?(k(D),D=-1):v=!0,ae(T,Q-ce))):(j.sortIndex=me,t(u,j),b||g||(b=!0,$||($=!0,R()))),j},e.unstable_shouldYield=V,e.unstable_wrapCallback=function(j){var K=m;return function(){var Q=m;m=K;try{return j.apply(this,arguments)}finally{m=Q}}}})(W1)),W1}var r$;function AV(){return r$||(r$=1,j1.exports=CV()),j1.exports}var V1={exports:{}},Wa={};var s$;function $V(){if(s$)return Wa;s$=1;var e=Hk();function t(u){var d="https://react.dev/errors/"+u;if(1<arguments.length){d+="?args[]="+encodeURIComponent(arguments[1]);for(var c=2;c<arguments.length;c++)d+="&args[]="+encodeURIComponent(arguments[c])}return"Minified React error #"+u+"; visit "+d+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function n(){}var a={d:{f:n,r:function(){throw Error(t(522))},D:n,C:n,L:n,m:n,X:n,S:n,M:n},p:0,findDOMNode:null},r=Symbol.for("react.portal");function s(u,d,c){var p=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:r,key:p==null?null:""+p,children:u,containerInfo:d,implementation:c}}var i=e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;function o(u,d){if(u==="font")return"";if(typeof d=="string")return d==="use-credentials"?d:""}return Wa.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=a,Wa.createPortal=function(u,d){var c=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!d||d.nodeType!==1&&d.nodeType!==9&&d.nodeType!==11)throw Error(t(299));return s(u,d,null,c)},Wa.flushSync=function(u){var d=i.T,c=a.p;try{if(i.T=null,a.p=2,u)return u()}finally{i.T=d,a.p=c,a.d.f()}},Wa.preconnect=function(u,d){typeof u=="string"&&(d?(d=d.crossOrigin,d=typeof d=="string"?d==="use-credentials"?d:"":void 0):d=null,a.d.C(u,d))},Wa.prefetchDNS=function(u){typeof u=="string"&&a.d.D(u)},Wa.preinit=function(u,d){if(typeof u=="string"&&d&&typeof d.as=="string"){var c=d.as,p=o(c,d.crossOrigin),m=typeof d.integrity=="string"?d.integrity:void 0,g=typeof d.fetchPriority=="string"?d.fetchPriority:void 0;c==="style"?a.d.S(u,typeof d.precedence=="string"?d.precedence:void 0,{crossOrigin:p,integrity:m,fetchPriority:g}):c==="script"&&a.d.X(u,{crossOrigin:p,integrity:m,fetchPriority:g,nonce:typeof d.nonce=="string"?d.nonce:void 0})}},Wa.preinitModule=function(u,d){if(typeof u=="string")if(typeof d=="object"&&d!==null){if(d.as==null||d.as==="script"){var c=o(d.as,d.crossOrigin);a.d.M(u,{crossOrigin:c,integrity:typeof d.integrity=="string"?d.integrity:void 0,nonce:typeof d.nonce=="string"?d.nonce:void 0})}}else d==null&&a.d.M(u)},Wa.preload=function(u,d){if(typeof u=="string"&&typeof d=="object"&&d!==null&&typeof d.as=="string"){var c=d.as,p=o(c,d.crossOrigin);a.d.L(u,c,{crossOrigin:p,integrity:typeof d.integrity=="string"?d.integrity:void 0,nonce:typeof d.nonce=="string"?d.nonce:void 0,type:typeof d.type=="string"?d.type:void 0,fetchPriority:typeof d.fetchPriority=="string"?d.fetchPriority:void 0,referrerPolicy:typeof d.referrerPolicy=="string"?d.referrerPolicy:void 0,imageSrcSet:typeof d.imageSrcSet=="string"?d.imageSrcSet:void 0,imageSizes:typeof d.imageSizes=="string"?d.imageSizes:void 0,media:typeof d.media=="string"?d.media:void 0})}},Wa.preloadModule=function(u,d){if(typeof u=="string")if(d){var c=o(d.as,d.crossOrigin);a.d.m(u,{as:typeof d.as=="string"&&d.as!=="script"?d.as:void 0,crossOrigin:c,integrity:typeof d.integrity=="string"?d.integrity:void 0})}else a.d.m(u)},Wa.requestFormReset=function(u){a.d.r(u)},Wa.unstable_batchedUpdates=function(u,d){return u(d)},Wa.useFormState=function(u,d,c){return i.H.useFormState(u,d,c)},Wa.useFormStatus=function(){return i.H.useHostTransitionStatus()},Wa.version="19.2.3",Wa}var i$;function RV(){if(i$)return V1.exports;i$=1;function e(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)}catch(t){console.error(t)}}return e(),V1.exports=$V(),V1.exports}var o$;function DV(){if(o$)return xm;o$=1;var e=AV(),t=Hk(),n=RV();function a(l){var h="https://react.dev/errors/"+l;if(1<arguments.length){h+="?args[]="+encodeURIComponent(arguments[1]);for(var f=2;f<arguments.length;f++)h+="&args[]="+encodeURIComponent(arguments[f])}return"Minified React error #"+l+"; visit "+h+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function r(l){return!(!l||l.nodeType!==1&&l.nodeType!==9&&l.nodeType!==11)}function s(l){var h=l,f=l;if(l.alternate)for(;h.return;)h=h.return;else{l=h;do h=l,(h.flags&4098)!==0&&(f=h.return),l=h.return;while(l)}return h.tag===3?f:null}function i(l){if(l.tag===13){var h=l.memoizedState;if(h===null&&(l=l.alternate,l!==null&&(h=l.memoizedState)),h!==null)return h.dehydrated}return null}function o(l){if(l.tag===31){var h=l.memoizedState;if(h===null&&(l=l.alternate,l!==null&&(h=l.memoizedState)),h!==null)return h.dehydrated}return null}function u(l){if(s(l)!==l)throw Error(a(188))}function d(l){var h=l.alternate;if(!h){if(h=s(l),h===null)throw Error(a(188));return h!==l?null:l}for(var f=l,y=h;;){var S=f.return;if(S===null)break;var _=S.alternate;if(_===null){if(y=S.return,y!==null){f=y;continue}break}if(S.child===_.child){for(_=S.child;_;){if(_===f)return u(S),l;if(_===y)return u(S),h;_=_.sibling}throw Error(a(188))}if(f.return!==y.return)f=S,y=_;else{for(var A=!1,z=S.child;z;){if(z===f){A=!0,f=S,y=_;break}if(z===y){A=!0,y=S,f=_;break}z=z.sibling}if(!A){for(z=_.child;z;){if(z===f){A=!0,f=_,y=S;break}if(z===y){A=!0,y=_,f=S;break}z=z.sibling}if(!A)throw Error(a(189))}}if(f.alternate!==y)throw Error(a(190))}if(f.tag!==3)throw Error(a(188));return f.stateNode.current===f?l:h}function c(l){var h=l.tag;if(h===5||h===26||h===27||h===6)return l;for(l=l.child;l!==null;){if(h=c(l),h!==null)return h;l=l.sibling}return null}var p=Object.assign,m=Symbol.for("react.element"),g=Symbol.for("react.transitional.element"),b=Symbol.for("react.portal"),v=Symbol.for("react.fragment"),x=Symbol.for("react.strict_mode"),w=Symbol.for("react.profiler"),k=Symbol.for("react.consumer"),N=Symbol.for("react.context"),I=Symbol.for("react.forward_ref"),T=Symbol.for("react.suspense"),$=Symbol.for("react.suspense_list"),D=Symbol.for("react.memo"),M=Symbol.for("react.lazy"),B=Symbol.for("react.activity"),V=Symbol.for("react.memo_cache_sentinel"),W=Symbol.iterator;function R(l){return l===null||typeof l!="object"?null:(l=W&&l[W]||l["@@iterator"],typeof l=="function"?l:null)}var H=Symbol.for("react.client.reference");function Z(l){if(l==null)return null;if(typeof l=="function")return l.$$typeof===H?null:l.displayName||l.name||null;if(typeof l=="string")return l;switch(l){case v:return"Fragment";case w:return"Profiler";case x:return"StrictMode";case T:return"Suspense";case $:return"SuspenseList";case B:return"Activity"}if(typeof l=="object")switch(l.$$typeof){case b:return"Portal";case N:return l.displayName||"Context";case k:return(l._context.displayName||"Context")+".Consumer";case I:var h=l.render;return l=l.displayName,l||(l=h.displayName||h.name||"",l=l!==""?"ForwardRef("+l+")":"ForwardRef"),l;case D:return h=l.displayName||null,h!==null?h:Z(l.type)||"Memo";case M:h=l._payload,l=l._init;try{return Z(l(h))}catch{}}return null}var ae=Array.isArray,j=t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,K=n.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,Q={pending:!1,data:null,method:null,action:null},ce=[],me=-1;function L(l){return{current:l}}function ee(l){0>me||(l.current=ce[me],ce[me]=null,me--)}function ie(l,h){me++,ce[me]=l.current,l.current=h}var de=L(null),we=L(null),Ie=L(null),Ee=L(null);function Ce(l,h){switch(ie(Ie,h),ie(we,l),ie(de,null),h.nodeType){case 9:case 11:l=(l=h.documentElement)&&(l=l.namespaceURI)?SA(l):0;break;default:if(l=h.tagName,h=h.namespaceURI)h=SA(h),l=kA(h,l);else switch(l){case"svg":l=1;break;case"math":l=2;break;default:l=0}}ee(de),ie(de,l)}function ze(){ee(de),ee(we),ee(Ie)}function Ke(l){l.memoizedState!==null&&ie(Ee,l);var h=de.current,f=kA(h,l.type);h!==f&&(ie(we,l),ie(de,f))}function at(l){we.current===l&&(ee(de),ee(we)),Ee.current===l&&(ee(Ee),mm._currentValue=Q)}var lt,Dt;function ut(l){if(lt===void 0)try{throw Error()}catch(f){var h=f.stack.trim().match(/\n( *(at )?)/);lt=h&&h[1]||"",Dt=-1<f.stack.indexOf(`
    at`)?" (<anonymous>)":-1<f.stack.indexOf("@")?"@unknown:0:0":""}return`
`+lt+l+Dt}var xt=!1;function tt(l,h){if(!l||xt)return"";xt=!0;var f=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{var y={DetermineComponentFrameRoot:function(){try{if(h){var Ne=function(){throw Error()};if(Object.defineProperty(Ne.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(Ne,[])}catch(be){var ge=be}Reflect.construct(l,[],Ne)}else{try{Ne.call()}catch(be){ge=be}l.call(Ne.prototype)}}else{try{throw Error()}catch(be){ge=be}(Ne=l())&&typeof Ne.catch=="function"&&Ne.catch(function(){})}}catch(be){if(be&&ge&&typeof be.stack=="string")return[be.stack,ge.stack]}return[null,null]}};y.DetermineComponentFrameRoot.displayName="DetermineComponentFrameRoot";var S=Object.getOwnPropertyDescriptor(y.DetermineComponentFrameRoot,"name");S&&S.configurable&&Object.defineProperty(y.DetermineComponentFrameRoot,"name",{value:"DetermineComponentFrameRoot"});var _=y.DetermineComponentFrameRoot(),A=_[0],z=_[1];if(A&&z){var J=A.split(`
`),fe=z.split(`
`);for(S=y=0;y<J.length&&!J[y].includes("DetermineComponentFrameRoot");)y++;for(;S<fe.length&&!fe[S].includes("DetermineComponentFrameRoot");)S++;if(y===J.length||S===fe.length)for(y=J.length-1,S=fe.length-1;1<=y&&0<=S&&J[y]!==fe[S];)S--;for(;1<=y&&0<=S;y--,S--)if(J[y]!==fe[S]){if(y!==1||S!==1)do if(y--,S--,0>S||J[y]!==fe[S]){var Se=`
`+J[y].replace(" at new "," at ");return l.displayName&&Se.includes("<anonymous>")&&(Se=Se.replace("<anonymous>",l.displayName)),Se}while(1<=y&&0<=S);break}}}finally{xt=!1,Error.prepareStackTrace=f}return(f=l?l.displayName||l.name:"")?ut(f):""}function At(l,h){switch(l.tag){case 26:case 27:case 5:return ut(l.type);case 16:return ut("Lazy");case 13:return l.child!==h&&h!==null?ut("Suspense Fallback"):ut("Suspense");case 19:return ut("SuspenseList");case 0:case 15:return tt(l.type,!1);case 11:return tt(l.type.render,!1);case 1:return tt(l.type,!0);case 31:return ut("Activity");default:return""}}function Bt(l){try{var h="",f=null;do h+=At(l,f),f=l,l=l.return;while(l);return h}catch(y){return`
Error generating stack: `+y.message+`
`+y.stack}}var ya=Object.prototype.hasOwnProperty,rn=e.unstable_scheduleCallback,ra=e.unstable_cancelCallback,Hn=e.unstable_shouldYield,Ta=e.unstable_requestPaint,dn=e.unstable_now,Ua=e.unstable_getCurrentPriorityLevel,ba=e.unstable_ImmediatePriority,Mn=e.unstable_UserBlockingPriority,va=e.unstable_NormalPriority,Gs=e.unstable_LowPriority,oo=e.unstable_IdlePriority,_s=e.log,Ol=e.unstable_setDisableYieldValue,ja=null,In=null;function sn(l){if(typeof _s=="function"&&Ol(l),In&&typeof In.setStrictMode=="function")try{In.setStrictMode(ja,l)}catch{}}var xa=Math.clz32?Math.clz32:_d,Sd=Math.log,kd=Math.LN2;function _d(l){return l>>>=0,l===0?32:31-(Sd(l)/kd|0)|0}var fr=256,Ns=262144,vi=4194304;function tr(l){var h=l&42;if(h!==0)return h;switch(l&-l){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:return 64;case 128:return 128;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:return l&261888;case 262144:case 524288:case 1048576:case 2097152:return l&3932160;case 4194304:case 8388608:case 16777216:case 33554432:return l&62914560;case 67108864:return 67108864;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 0;default:return l}}function ts(l,h,f){var y=l.pendingLanes;if(y===0)return 0;var S=0,_=l.suspendedLanes,A=l.pingedLanes;l=l.warmLanes;var z=y&134217727;return z!==0?(y=z&~_,y!==0?S=tr(y):(A&=z,A!==0?S=tr(A):f||(f=z&~l,f!==0&&(S=tr(f))))):(z=y&~_,z!==0?S=tr(z):A!==0?S=tr(A):f||(f=y&~l,f!==0&&(S=tr(f)))),S===0?0:h!==0&&h!==S&&(h&_)===0&&(_=S&-S,f=h&-h,_>=f||_===32&&(f&4194048)!==0)?h:S}function qs(l,h){return(l.pendingLanes&~(l.suspendedLanes&~l.pingedLanes)&h)===0}function xe(l,h){switch(l){case 1:case 2:case 4:case 8:case 64:return h+250;case 16:case 32:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return h+5e3;case 4194304:case 8388608:case 16777216:case 33554432:return-1;case 67108864:case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function Ae(){var l=vi;return vi<<=1,(vi&62914560)===0&&(vi=4194304),l}function Ge(l){for(var h=[],f=0;31>f;f++)h.push(l);return h}function Re(l,h){l.pendingLanes|=h,h!==268435456&&(l.suspendedLanes=0,l.pingedLanes=0,l.warmLanes=0)}function Ht(l,h,f,y,S,_){var A=l.pendingLanes;l.pendingLanes=f,l.suspendedLanes=0,l.pingedLanes=0,l.warmLanes=0,l.expiredLanes&=f,l.entangledLanes&=f,l.errorRecoveryDisabledLanes&=f,l.shellSuspendCounter=0;var z=l.entanglements,J=l.expirationTimes,fe=l.hiddenUpdates;for(f=A&~f;0<f;){var Se=31-xa(f),Ne=1<<Se;z[Se]=0,J[Se]=-1;var ge=fe[Se];if(ge!==null)for(fe[Se]=null,Se=0;Se<ge.length;Se++){var be=ge[Se];be!==null&&(be.lane&=-536870913)}f&=~Ne}y!==0&&Qt(l,y,0),_!==0&&S===0&&l.tag!==0&&(l.suspendedLanes|=_&~(A&~h))}function Qt(l,h,f){l.pendingLanes|=h,l.suspendedLanes&=~h;var y=31-xa(h);l.entangledLanes|=h,l.entanglements[y]=l.entanglements[y]|1073741824|f&261930}function ht(l,h){var f=l.entangledLanes|=h;for(l=l.entanglements;f;){var y=31-xa(f),S=1<<y;S&h|l[y]&h&&(l[y]|=h),f&=~S}}function st(l,h){var f=h&-h;return f=(f&42)!==0?1:pn(f),(f&(l.suspendedLanes|h))!==0?0:f}function pn(l){switch(l){case 2:l=1;break;case 8:l=4;break;case 32:l=16;break;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:l=128;break;case 268435456:l=134217728;break;default:l=0}return l}function Ea(l){return l&=-l,2<l?8<l?(l&134217727)!==0?32:268435456:8:2}function ns(){var l=K.p;return l!==0?l:(l=window.event,l===void 0?32:GA(l.type))}function Ml(l,h){var f=K.p;try{return K.p=l,h()}finally{K.p=f}}var mr=Math.random().toString(36).slice(2),Tn="__reactFiber$"+mr,Ft="__reactProps$"+mr,nr="__reactContainer$"+mr,lo="__reactEvents$"+mr,zx="__reactListeners$"+mr,Nf="__reactHandles$"+mr,$y="__reactResources$"+mr,Fl="__reactMarker$"+mr;function If(l){delete l[Tn],delete l[Ft],delete l[lo],delete l[zx],delete l[Nf]}function as(l){var h=l[Tn];if(h)return h;for(var f=l.parentNode;f;){if(h=f[nr]||f[Tn]){if(f=h.alternate,h.child!==null||f!==null&&f.child!==null)for(l=AA(l);l!==null;){if(f=l[Tn])return f;l=AA(l)}return h}l=f,f=l.parentNode}return null}function uo(l){if(l=l[Tn]||l[nr]){var h=l.tag;if(h===5||h===6||h===13||h===31||h===26||h===27||h===3)return l}return null}function zl(l){var h=l.tag;if(h===5||h===26||h===27||h===6)return l.stateNode;throw Error(a(33))}function xi(l){var h=l[$y];return h||(h=l[$y]={hoistableStyles:new Map,hoistableScripts:new Map}),h}function Gn(l){l[Fl]=!0}var Nd=new Set,Ry={};function wi(l,h){co(l,h),co(l+"Capture",h)}function co(l,h){for(Ry[l]=h,l=0;l<h.length;l++)Nd.add(h[l])}var ho=RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),Id={},Dy={};function Lx(l){return ya.call(Dy,l)?!0:ya.call(Id,l)?!1:ho.test(l)?Dy[l]=!0:(Id[l]=!0,!1)}function Td(l,h,f){if(Lx(h))if(f===null)l.removeAttribute(h);else{switch(typeof f){case"undefined":case"function":case"symbol":l.removeAttribute(h);return;case"boolean":var y=h.toLowerCase().slice(0,5);if(y!=="data-"&&y!=="aria-"){l.removeAttribute(h);return}}l.setAttribute(h,""+f)}}function Ed(l,h,f){if(f===null)l.removeAttribute(h);else{switch(typeof f){case"undefined":case"function":case"symbol":case"boolean":l.removeAttribute(h);return}l.setAttribute(h,""+f)}}function rs(l,h,f,y){if(y===null)l.removeAttribute(f);else{switch(typeof y){case"undefined":case"function":case"symbol":case"boolean":l.removeAttribute(f);return}l.setAttributeNS(h,f,""+y)}}function ar(l){switch(typeof l){case"bigint":case"boolean":case"number":case"string":case"undefined":return l;case"object":return l;default:return""}}function Oy(l){var h=l.type;return(l=l.nodeName)&&l.toLowerCase()==="input"&&(h==="checkbox"||h==="radio")}function Bx(l,h,f){var y=Object.getOwnPropertyDescriptor(l.constructor.prototype,h);if(!l.hasOwnProperty(h)&&typeof y<"u"&&typeof y.get=="function"&&typeof y.set=="function"){var S=y.get,_=y.set;return Object.defineProperty(l,h,{configurable:!0,get:function(){return S.call(this)},set:function(A){f=""+A,_.call(this,A)}}),Object.defineProperty(l,h,{enumerable:y.enumerable}),{getValue:function(){return f},setValue:function(A){f=""+A},stopTracking:function(){l._valueTracker=null,delete l[h]}}}}function Cd(l){if(!l._valueTracker){var h=Oy(l)?"checked":"value";l._valueTracker=Bx(l,h,""+l[h])}}function Tf(l){if(!l)return!1;var h=l._valueTracker;if(!h)return!0;var f=h.getValue(),y="";return l&&(y=Oy(l)?l.checked?"true":"false":l.value),l=y,l!==f?(h.setValue(l),!0):!1}function Ad(l){if(l=l||(typeof document<"u"?document:void 0),typeof l>"u")return null;try{return l.activeElement||l.body}catch{return l.body}}var Px=/[\n"\\]/g;function gr(l){return l.replace(Px,function(h){return"\\"+h.charCodeAt(0).toString(16)+" "})}function Ef(l,h,f,y,S,_,A,z){l.name="",A!=null&&typeof A!="function"&&typeof A!="symbol"&&typeof A!="boolean"?l.type=A:l.removeAttribute("type"),h!=null?A==="number"?(h===0&&l.value===""||l.value!=h)&&(l.value=""+ar(h)):l.value!==""+ar(h)&&(l.value=""+ar(h)):A!=="submit"&&A!=="reset"||l.removeAttribute("value"),h!=null?po(l,A,ar(h)):f!=null?po(l,A,ar(f)):y!=null&&l.removeAttribute("value"),S==null&&_!=null&&(l.defaultChecked=!!_),S!=null&&(l.checked=S&&typeof S!="function"&&typeof S!="symbol"),z!=null&&typeof z!="function"&&typeof z!="symbol"&&typeof z!="boolean"?l.name=""+ar(z):l.removeAttribute("name")}function Cf(l,h,f,y,S,_,A,z){if(_!=null&&typeof _!="function"&&typeof _!="symbol"&&typeof _!="boolean"&&(l.type=_),h!=null||f!=null){if(!(_!=="submit"&&_!=="reset"||h!=null)){Cd(l);return}f=f!=null?""+ar(f):"",h=h!=null?""+ar(h):f,z||h===l.value||(l.value=h),l.defaultValue=h}y=y??S,y=typeof y!="function"&&typeof y!="symbol"&&!!y,l.checked=z?l.checked:!!y,l.defaultChecked=!!y,A!=null&&typeof A!="function"&&typeof A!="symbol"&&typeof A!="boolean"&&(l.name=A),Cd(l)}function po(l,h,f){h==="number"&&Ad(l.ownerDocument)===l||l.defaultValue===""+f||(l.defaultValue=""+f)}function Si(l,h,f,y){if(l=l.options,h){h={};for(var S=0;S<f.length;S++)h["$"+f[S]]=!0;for(f=0;f<l.length;f++)S=h.hasOwnProperty("$"+l[f].value),l[f].selected!==S&&(l[f].selected=S),S&&y&&(l[f].defaultSelected=!0)}else{for(f=""+ar(f),h=null,S=0;S<l.length;S++){if(l[S].value===f){l[S].selected=!0,y&&(l[S].defaultSelected=!0);return}h!==null||l[S].disabled||(h=l[S])}h!==null&&(h.selected=!0)}}function Af(l,h,f){if(h!=null&&(h=""+ar(h),h!==l.value&&(l.value=h),f==null)){l.defaultValue!==h&&(l.defaultValue=h);return}l.defaultValue=f!=null?""+ar(f):""}function $f(l,h,f,y){if(h==null){if(y!=null){if(f!=null)throw Error(a(92));if(ae(y)){if(1<y.length)throw Error(a(93));y=y[0]}f=y}f==null&&(f=""),h=f}f=ar(h),l.defaultValue=f,y=l.textContent,y===f&&y!==""&&y!==null&&(l.value=y),Cd(l)}function Ks(l,h){if(h){var f=l.firstChild;if(f&&f===l.lastChild&&f.nodeType===3){f.nodeValue=h;return}}l.textContent=h}var My=new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));function Rf(l,h,f){var y=h.indexOf("--")===0;f==null||typeof f=="boolean"||f===""?y?l.setProperty(h,""):h==="float"?l.cssFloat="":l[h]="":y?l.setProperty(h,f):typeof f!="number"||f===0||My.has(h)?h==="float"?l.cssFloat=f:l[h]=(""+f).trim():l[h]=f+"px"}function $d(l,h,f){if(h!=null&&typeof h!="object")throw Error(a(62));if(l=l.style,f!=null){for(var y in f)!f.hasOwnProperty(y)||h!=null&&h.hasOwnProperty(y)||(y.indexOf("--")===0?l.setProperty(y,""):y==="float"?l.cssFloat="":l[y]="");for(var S in h)y=h[S],h.hasOwnProperty(S)&&f[S]!==y&&Rf(l,S,y)}else for(var _ in h)h.hasOwnProperty(_)&&Rf(l,_,h[_])}function fo(l){if(l.indexOf("-")===-1)return!1;switch(l){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var Rd=new Map([["acceptCharset","accept-charset"],["htmlFor","for"],["httpEquiv","http-equiv"],["crossOrigin","crossorigin"],["accentHeight","accent-height"],["alignmentBaseline","alignment-baseline"],["arabicForm","arabic-form"],["baselineShift","baseline-shift"],["capHeight","cap-height"],["clipPath","clip-path"],["clipRule","clip-rule"],["colorInterpolation","color-interpolation"],["colorInterpolationFilters","color-interpolation-filters"],["colorProfile","color-profile"],["colorRendering","color-rendering"],["dominantBaseline","dominant-baseline"],["enableBackground","enable-background"],["fillOpacity","fill-opacity"],["fillRule","fill-rule"],["floodColor","flood-color"],["floodOpacity","flood-opacity"],["fontFamily","font-family"],["fontSize","font-size"],["fontSizeAdjust","font-size-adjust"],["fontStretch","font-stretch"],["fontStyle","font-style"],["fontVariant","font-variant"],["fontWeight","font-weight"],["glyphName","glyph-name"],["glyphOrientationHorizontal","glyph-orientation-horizontal"],["glyphOrientationVertical","glyph-orientation-vertical"],["horizAdvX","horiz-adv-x"],["horizOriginX","horiz-origin-x"],["imageRendering","image-rendering"],["letterSpacing","letter-spacing"],["lightingColor","lighting-color"],["markerEnd","marker-end"],["markerMid","marker-mid"],["markerStart","marker-start"],["overlinePosition","overline-position"],["overlineThickness","overline-thickness"],["paintOrder","paint-order"],["panose-1","panose-1"],["pointerEvents","pointer-events"],["renderingIntent","rendering-intent"],["shapeRendering","shape-rendering"],["stopColor","stop-color"],["stopOpacity","stop-opacity"],["strikethroughPosition","strikethrough-position"],["strikethroughThickness","strikethrough-thickness"],["strokeDasharray","stroke-dasharray"],["strokeDashoffset","stroke-dashoffset"],["strokeLinecap","stroke-linecap"],["strokeLinejoin","stroke-linejoin"],["strokeMiterlimit","stroke-miterlimit"],["strokeOpacity","stroke-opacity"],["strokeWidth","stroke-width"],["textAnchor","text-anchor"],["textDecoration","text-decoration"],["textRendering","text-rendering"],["transformOrigin","transform-origin"],["underlinePosition","underline-position"],["underlineThickness","underline-thickness"],["unicodeBidi","unicode-bidi"],["unicodeRange","unicode-range"],["unitsPerEm","units-per-em"],["vAlphabetic","v-alphabetic"],["vHanging","v-hanging"],["vIdeographic","v-ideographic"],["vMathematical","v-mathematical"],["vectorEffect","vector-effect"],["vertAdvY","vert-adv-y"],["vertOriginX","vert-origin-x"],["vertOriginY","vert-origin-y"],["wordSpacing","word-spacing"],["writingMode","writing-mode"],["xmlnsXlink","xmlns:xlink"],["xHeight","x-height"]]),Dd=/^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;function Ll(l){return Dd.test(""+l)?"javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')":l}function yr(){}var mo=null;function Df(l){return l=l.target||l.srcElement||window,l.correspondingUseElement&&(l=l.correspondingUseElement),l.nodeType===3?l.parentNode:l}var G=null,ue=null;function $e(l){var h=uo(l);if(h&&(l=h.stateNode)){var f=l[Ft]||null;e:switch(l=h.stateNode,h.type){case"input":if(Ef(l,f.value,f.defaultValue,f.defaultValue,f.checked,f.defaultChecked,f.type,f.name),h=f.name,f.type==="radio"&&h!=null){for(f=l;f.parentNode;)f=f.parentNode;for(f=f.querySelectorAll('input[name="'+gr(""+h)+'"][type="radio"]'),h=0;h<f.length;h++){var y=f[h];if(y!==l&&y.form===l.form){var S=y[Ft]||null;if(!S)throw Error(a(90));Ef(y,S.value,S.defaultValue,S.defaultValue,S.checked,S.defaultChecked,S.type,S.name)}}for(h=0;h<f.length;h++)y=f[h],y.form===l.form&&Tf(y)}break e;case"textarea":Af(l,f.value,f.defaultValue);break e;case"select":h=f.value,h!=null&&Si(l,!!f.multiple,h,!1)}}}var Xe=!1;function rt(l,h,f){if(Xe)return l(h,f);Xe=!0;try{var y=l(h);return y}finally{if(Xe=!1,(G!==null||ue!==null)&&(vb(),G&&(h=G,l=ue,ue=G=null,$e(h),l)))for(h=0;h<l.length;h++)$e(l[h])}}function nt(l,h){var f=l.stateNode;if(f===null)return null;var y=f[Ft]||null;if(y===null)return null;f=y[h];e:switch(h){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(y=!y.disabled)||(l=l.type,y=!(l==="button"||l==="input"||l==="select"||l==="textarea")),l=!y;break e;default:l=!1}if(l)return null;if(f&&typeof f!="function")throw Error(a(231,h,typeof f));return f}var De=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),We=!1;if(De)try{var Pt={};Object.defineProperty(Pt,"passive",{get:function(){We=!0}}),window.addEventListener("test",Pt,Pt),window.removeEventListener("test",Pt,Pt)}catch{We=!1}var En=null,Mr=null,Bl=null;function Od(){if(Bl)return Bl;var l,h=Mr,f=h.length,y,S="value"in En?En.value:En.textContent,_=S.length;for(l=0;l<f&&h[l]===S[l];l++);var A=f-l;for(y=1;y<=A&&h[f-y]===S[_-y];y++);return Bl=S.slice(l,1<y?1-y:void 0)}function Md(l){var h=l.keyCode;return"charCode"in l?(l=l.charCode,l===0&&h===13&&(l=13)):l=h,l===10&&(l=13),32<=l||l===13?l:0}function wa(){return!0}function ki(){return!1}function Ca(l){function h(f,y,S,_,A){this._reactName=f,this._targetInst=S,this.type=y,this.nativeEvent=_,this.target=A,this.currentTarget=null;for(var z in l)l.hasOwnProperty(z)&&(f=l[z],this[z]=f?f(_):_[z]);return this.isDefaultPrevented=(_.defaultPrevented!=null?_.defaultPrevented:_.returnValue===!1)?wa:ki,this.isPropagationStopped=ki,this}return p(h.prototype,{preventDefault:function(){this.defaultPrevented=!0;var f=this.nativeEvent;f&&(f.preventDefault?f.preventDefault():typeof f.returnValue!="unknown"&&(f.returnValue=!1),this.isDefaultPrevented=wa)},stopPropagation:function(){var f=this.nativeEvent;f&&(f.stopPropagation?f.stopPropagation():typeof f.cancelBubble!="unknown"&&(f.cancelBubble=!0),this.isPropagationStopped=wa)},persist:function(){},isPersistent:wa}),h}var Pl={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(l){return l.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},Fy=Ca(Pl),Of=p({},Pl,{view:0,detail:0}),_j=Ca(Of),Ux,jx,Mf,zy=p({},Of,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:Vx,button:0,buttons:0,relatedTarget:function(l){return l.relatedTarget===void 0?l.fromElement===l.srcElement?l.toElement:l.fromElement:l.relatedTarget},movementX:function(l){return"movementX"in l?l.movementX:(l!==Mf&&(Mf&&l.type==="mousemove"?(Ux=l.screenX-Mf.screenX,jx=l.screenY-Mf.screenY):jx=Ux=0,Mf=l),Ux)},movementY:function(l){return"movementY"in l?l.movementY:jx}}),NT=Ca(zy),Nj=p({},zy,{dataTransfer:0}),Ij=Ca(Nj),Tj=p({},Of,{relatedTarget:0}),Wx=Ca(Tj),Ej=p({},Pl,{animationName:0,elapsedTime:0,pseudoElement:0}),Cj=Ca(Ej),Aj=p({},Pl,{clipboardData:function(l){return"clipboardData"in l?l.clipboardData:window.clipboardData}}),$j=Ca(Aj),Rj=p({},Pl,{data:0}),IT=Ca(Rj),Dj={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},Oj={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Mj={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Fj(l){var h=this.nativeEvent;return h.getModifierState?h.getModifierState(l):(l=Mj[l])?!!h[l]:!1}function Vx(){return Fj}var zj=p({},Of,{key:function(l){if(l.key){var h=Dj[l.key]||l.key;if(h!=="Unidentified")return h}return l.type==="keypress"?(l=Md(l),l===13?"Enter":String.fromCharCode(l)):l.type==="keydown"||l.type==="keyup"?Oj[l.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:Vx,charCode:function(l){return l.type==="keypress"?Md(l):0},keyCode:function(l){return l.type==="keydown"||l.type==="keyup"?l.keyCode:0},which:function(l){return l.type==="keypress"?Md(l):l.type==="keydown"||l.type==="keyup"?l.keyCode:0}}),Lj=Ca(zj),Bj=p({},zy,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),TT=Ca(Bj),Pj=p({},Of,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:Vx}),Uj=Ca(Pj),jj=p({},Pl,{propertyName:0,elapsedTime:0,pseudoElement:0}),Wj=Ca(jj),Vj=p({},zy,{deltaX:function(l){return"deltaX"in l?l.deltaX:"wheelDeltaX"in l?-l.wheelDeltaX:0},deltaY:function(l){return"deltaY"in l?l.deltaY:"wheelDeltaY"in l?-l.wheelDeltaY:"wheelDelta"in l?-l.wheelDelta:0},deltaZ:0,deltaMode:0}),Hj=Ca(Vj),Gj=p({},Pl,{newState:0,oldState:0}),qj=Ca(Gj),Kj=[9,13,27,32],Hx=De&&"CompositionEvent"in window,Ff=null;De&&"documentMode"in document&&(Ff=document.documentMode);var Xj=De&&"TextEvent"in window&&!Ff,ET=De&&(!Hx||Ff&&8<Ff&&11>=Ff),CT=" ",AT=!1;function $T(l,h){switch(l){case"keyup":return Kj.indexOf(h.keyCode)!==-1;case"keydown":return h.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function RT(l){return l=l.detail,typeof l=="object"&&"data"in l?l.data:null}var Fd=!1;function Yj(l,h){switch(l){case"compositionend":return RT(h);case"keypress":return h.which!==32?null:(AT=!0,CT);case"textInput":return l=h.data,l===CT&&AT?null:l;default:return null}}function Jj(l,h){if(Fd)return l==="compositionend"||!Hx&&$T(l,h)?(l=Od(),Bl=Mr=En=null,Fd=!1,l):null;switch(l){case"paste":return null;case"keypress":if(!(h.ctrlKey||h.altKey||h.metaKey)||h.ctrlKey&&h.altKey){if(h.char&&1<h.char.length)return h.char;if(h.which)return String.fromCharCode(h.which)}return null;case"compositionend":return ET&&h.locale!=="ko"?null:h.data;default:return null}}var Zj={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function DT(l){var h=l&&l.nodeName&&l.nodeName.toLowerCase();return h==="input"?!!Zj[l.type]:h==="textarea"}function OT(l,h,f,y){G?ue?ue.push(y):ue=[y]:G=y,h=Ib(h,"onChange"),0<h.length&&(f=new Fy("onChange","change",null,f,y),l.push({event:f,listeners:h}))}var zf=null,Lf=null;function Qj(l){gA(l,0)}function Ly(l){var h=zl(l);if(Tf(h))return l}function MT(l,h){if(l==="change")return h}var FT=!1;if(De){var Gx;if(De){var qx="oninput"in document;if(!qx){var zT=document.createElement("div");zT.setAttribute("oninput","return;"),qx=typeof zT.oninput=="function"}Gx=qx}else Gx=!1;FT=Gx&&(!document.documentMode||9<document.documentMode)}function LT(){zf&&(zf.detachEvent("onpropertychange",BT),Lf=zf=null)}function BT(l){if(l.propertyName==="value"&&Ly(Lf)){var h=[];OT(h,Lf,l,Df(l)),rt(Qj,h)}}function eW(l,h,f){l==="focusin"?(LT(),zf=h,Lf=f,zf.attachEvent("onpropertychange",BT)):l==="focusout"&&LT()}function tW(l){if(l==="selectionchange"||l==="keyup"||l==="keydown")return Ly(Lf)}function nW(l,h){if(l==="click")return Ly(h)}function aW(l,h){if(l==="input"||l==="change")return Ly(h)}function rW(l,h){return l===h&&(l!==0||1/l===1/h)||l!==l&&h!==h}var Fr=typeof Object.is=="function"?Object.is:rW;function Bf(l,h){if(Fr(l,h))return!0;if(typeof l!="object"||l===null||typeof h!="object"||h===null)return!1;var f=Object.keys(l),y=Object.keys(h);if(f.length!==y.length)return!1;for(y=0;y<f.length;y++){var S=f[y];if(!ya.call(h,S)||!Fr(l[S],h[S]))return!1}return!0}function PT(l){for(;l&&l.firstChild;)l=l.firstChild;return l}function UT(l,h){var f=PT(l);l=0;for(var y;f;){if(f.nodeType===3){if(y=l+f.textContent.length,l<=h&&y>=h)return{node:f,offset:h-l};l=y}e:{for(;f;){if(f.nextSibling){f=f.nextSibling;break e}f=f.parentNode}f=void 0}f=PT(f)}}function jT(l,h){return l&&h?l===h?!0:l&&l.nodeType===3?!1:h&&h.nodeType===3?jT(l,h.parentNode):"contains"in l?l.contains(h):l.compareDocumentPosition?!!(l.compareDocumentPosition(h)&16):!1:!1}function WT(l){l=l!=null&&l.ownerDocument!=null&&l.ownerDocument.defaultView!=null?l.ownerDocument.defaultView:window;for(var h=Ad(l.document);h instanceof l.HTMLIFrameElement;){try{var f=typeof h.contentWindow.location.href=="string"}catch{f=!1}if(f)l=h.contentWindow;else break;h=Ad(l.document)}return h}function Kx(l){var h=l&&l.nodeName&&l.nodeName.toLowerCase();return h&&(h==="input"&&(l.type==="text"||l.type==="search"||l.type==="tel"||l.type==="url"||l.type==="password")||h==="textarea"||l.contentEditable==="true")}var sW=De&&"documentMode"in document&&11>=document.documentMode,zd=null,Xx=null,Pf=null,Yx=!1;function VT(l,h,f){var y=f.window===f?f.document:f.nodeType===9?f:f.ownerDocument;Yx||zd==null||zd!==Ad(y)||(y=zd,"selectionStart"in y&&Kx(y)?y={start:y.selectionStart,end:y.selectionEnd}:(y=(y.ownerDocument&&y.ownerDocument.defaultView||window).getSelection(),y={anchorNode:y.anchorNode,anchorOffset:y.anchorOffset,focusNode:y.focusNode,focusOffset:y.focusOffset}),Pf&&Bf(Pf,y)||(Pf=y,y=Ib(Xx,"onSelect"),0<y.length&&(h=new Fy("onSelect","select",null,h,f),l.push({event:h,listeners:y}),h.target=zd)))}function Ul(l,h){var f={};return f[l.toLowerCase()]=h.toLowerCase(),f["Webkit"+l]="webkit"+h,f["Moz"+l]="moz"+h,f}var Ld={animationend:Ul("Animation","AnimationEnd"),animationiteration:Ul("Animation","AnimationIteration"),animationstart:Ul("Animation","AnimationStart"),transitionrun:Ul("Transition","TransitionRun"),transitionstart:Ul("Transition","TransitionStart"),transitioncancel:Ul("Transition","TransitionCancel"),transitionend:Ul("Transition","TransitionEnd")},Jx={},HT={};De&&(HT=document.createElement("div").style,"AnimationEvent"in window||(delete Ld.animationend.animation,delete Ld.animationiteration.animation,delete Ld.animationstart.animation),"TransitionEvent"in window||delete Ld.transitionend.transition);function jl(l){if(Jx[l])return Jx[l];if(!Ld[l])return l;var h=Ld[l],f;for(f in h)if(h.hasOwnProperty(f)&&f in HT)return Jx[l]=h[f];return l}var GT=jl("animationend"),qT=jl("animationiteration"),KT=jl("animationstart"),iW=jl("transitionrun"),oW=jl("transitionstart"),lW=jl("transitioncancel"),XT=jl("transitionend"),YT=new Map,Zx="abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");Zx.push("scrollEnd");function Is(l,h){YT.set(l,h),wi(h,[l])}var By=typeof reportError=="function"?reportError:function(l){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var h=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof l=="object"&&l!==null&&typeof l.message=="string"?String(l.message):String(l),error:l});if(!window.dispatchEvent(h))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",l);return}console.error(l)},ss=[],Bd=0,Qx=0;function Py(){for(var l=Bd,h=Qx=Bd=0;h<l;){var f=ss[h];ss[h++]=null;var y=ss[h];ss[h++]=null;var S=ss[h];ss[h++]=null;var _=ss[h];if(ss[h++]=null,y!==null&&S!==null){var A=y.pending;A===null?S.next=S:(S.next=A.next,A.next=S),y.pending=S}_!==0&&JT(f,S,_)}}function Uy(l,h,f,y){ss[Bd++]=l,ss[Bd++]=h,ss[Bd++]=f,ss[Bd++]=y,Qx|=y,l.lanes|=y,l=l.alternate,l!==null&&(l.lanes|=y)}function ew(l,h,f,y){return Uy(l,h,f,y),jy(l)}function Wl(l,h){return Uy(l,null,null,h),jy(l)}function JT(l,h,f){l.lanes|=f;var y=l.alternate;y!==null&&(y.lanes|=f);for(var S=!1,_=l.return;_!==null;)_.childLanes|=f,y=_.alternate,y!==null&&(y.childLanes|=f),_.tag===22&&(l=_.stateNode,l===null||l._visibility&1||(S=!0)),l=_,_=_.return;return l.tag===3?(_=l.stateNode,S&&h!==null&&(S=31-xa(f),l=_.hiddenUpdates,y=l[S],y===null?l[S]=[h]:y.push(h),h.lane=f|536870912),_):null}function jy(l){if(50<lm)throw lm=0,u1=null,Error(a(185));for(var h=l.return;h!==null;)l=h,h=l.return;return l.tag===3?l.stateNode:null}var Pd={};function uW(l,h,f,y){this.tag=l,this.key=f,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.refCleanup=this.ref=null,this.pendingProps=h,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=y,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function zr(l,h,f,y){return new uW(l,h,f,y)}function tw(l){return l=l.prototype,!(!l||!l.isReactComponent)}function _i(l,h){var f=l.alternate;return f===null?(f=zr(l.tag,h,l.key,l.mode),f.elementType=l.elementType,f.type=l.type,f.stateNode=l.stateNode,f.alternate=l,l.alternate=f):(f.pendingProps=h,f.type=l.type,f.flags=0,f.subtreeFlags=0,f.deletions=null),f.flags=l.flags&65011712,f.childLanes=l.childLanes,f.lanes=l.lanes,f.child=l.child,f.memoizedProps=l.memoizedProps,f.memoizedState=l.memoizedState,f.updateQueue=l.updateQueue,h=l.dependencies,f.dependencies=h===null?null:{lanes:h.lanes,firstContext:h.firstContext},f.sibling=l.sibling,f.index=l.index,f.ref=l.ref,f.refCleanup=l.refCleanup,f}function ZT(l,h){l.flags&=65011714;var f=l.alternate;return f===null?(l.childLanes=0,l.lanes=h,l.child=null,l.subtreeFlags=0,l.memoizedProps=null,l.memoizedState=null,l.updateQueue=null,l.dependencies=null,l.stateNode=null):(l.childLanes=f.childLanes,l.lanes=f.lanes,l.child=f.child,l.subtreeFlags=0,l.deletions=null,l.memoizedProps=f.memoizedProps,l.memoizedState=f.memoizedState,l.updateQueue=f.updateQueue,l.type=f.type,h=f.dependencies,l.dependencies=h===null?null:{lanes:h.lanes,firstContext:h.firstContext}),l}function Wy(l,h,f,y,S,_){var A=0;if(y=l,typeof l=="function")tw(l)&&(A=1);else if(typeof l=="string")A=fV(l,f,de.current)?26:l==="html"||l==="head"||l==="body"?27:5;else e:switch(l){case B:return l=zr(31,f,h,S),l.elementType=B,l.lanes=_,l;case v:return Vl(f.children,S,_,h);case x:A=8,S|=24;break;case w:return l=zr(12,f,h,S|2),l.elementType=w,l.lanes=_,l;case T:return l=zr(13,f,h,S),l.elementType=T,l.lanes=_,l;case $:return l=zr(19,f,h,S),l.elementType=$,l.lanes=_,l;default:if(typeof l=="object"&&l!==null)switch(l.$$typeof){case N:A=10;break e;case k:A=9;break e;case I:A=11;break e;case D:A=14;break e;case M:A=16,y=null;break e}A=29,f=Error(a(130,l===null?"null":typeof l,"")),y=null}return h=zr(A,f,h,S),h.elementType=l,h.type=y,h.lanes=_,h}function Vl(l,h,f,y){return l=zr(7,l,y,h),l.lanes=f,l}function nw(l,h,f){return l=zr(6,l,null,h),l.lanes=f,l}function QT(l){var h=zr(18,null,null,0);return h.stateNode=l,h}function aw(l,h,f){return h=zr(4,l.children!==null?l.children:[],l.key,h),h.lanes=f,h.stateNode={containerInfo:l.containerInfo,pendingChildren:null,implementation:l.implementation},h}var eE=new WeakMap;function is(l,h){if(typeof l=="object"&&l!==null){var f=eE.get(l);return f!==void 0?f:(h={value:l,source:h,stack:Bt(h)},eE.set(l,h),h)}return{value:l,source:h,stack:Bt(h)}}var Ud=[],jd=0,Vy=null,Uf=0,os=[],ls=0,go=null,Xs=1,Ys="";function Ni(l,h){Ud[jd++]=Uf,Ud[jd++]=Vy,Vy=l,Uf=h}function tE(l,h,f){os[ls++]=Xs,os[ls++]=Ys,os[ls++]=go,go=l;var y=Xs;l=Ys;var S=32-xa(y)-1;y&=~(1<<S),f+=1;var _=32-xa(h)+S;if(30<_){var A=S-S%5;_=(y&(1<<A)-1).toString(32),y>>=A,S-=A,Xs=1<<32-xa(h)+S|f<<S|y,Ys=_+l}else Xs=1<<_|f<<S|y,Ys=l}function rw(l){l.return!==null&&(Ni(l,1),tE(l,1,0))}function sw(l){for(;l===Vy;)Vy=Ud[--jd],Ud[jd]=null,Uf=Ud[--jd],Ud[jd]=null;for(;l===go;)go=os[--ls],os[ls]=null,Ys=os[--ls],os[ls]=null,Xs=os[--ls],os[ls]=null}function nE(l,h){os[ls++]=Xs,os[ls++]=Ys,os[ls++]=go,Xs=h.id,Ys=h.overflow,go=l}var Aa=null,fn=null,Et=!1,yo=null,us=!1,iw=Error(a(519));function bo(l){var h=Error(a(418,1<arguments.length&&arguments[1]!==void 0&&arguments[1]?"text":"HTML",""));throw jf(is(h,l)),iw}function aE(l){var h=l.stateNode,f=l.type,y=l.memoizedProps;switch(h[Tn]=l,h[Ft]=y,f){case"dialog":kt("cancel",h),kt("close",h);break;case"iframe":case"object":case"embed":kt("load",h);break;case"video":case"audio":for(f=0;f<cm.length;f++)kt(cm[f],h);break;case"source":kt("error",h);break;case"img":case"image":case"link":kt("error",h),kt("load",h);break;case"details":kt("toggle",h);break;case"input":kt("invalid",h),Cf(h,y.value,y.defaultValue,y.checked,y.defaultChecked,y.type,y.name,!0);break;case"select":kt("invalid",h);break;case"textarea":kt("invalid",h),$f(h,y.value,y.defaultValue,y.children)}f=y.children,typeof f!="string"&&typeof f!="number"&&typeof f!="bigint"||h.textContent===""+f||y.suppressHydrationWarning===!0||xA(h.textContent,f)?(y.popover!=null&&(kt("beforetoggle",h),kt("toggle",h)),y.onScroll!=null&&kt("scroll",h),y.onScrollEnd!=null&&kt("scrollend",h),y.onClick!=null&&(h.onclick=yr),h=!0):h=!1,h||bo(l,!0)}function rE(l){for(Aa=l.return;Aa;)switch(Aa.tag){case 5:case 31:case 13:us=!1;return;case 27:case 3:us=!0;return;default:Aa=Aa.return}}function Wd(l){if(l!==Aa)return!1;if(!Et)return rE(l),Et=!0,!1;var h=l.tag,f;if((f=h!==3&&h!==27)&&((f=h===5)&&(f=l.type,f=!(f!=="form"&&f!=="button")||_1(l.type,l.memoizedProps)),f=!f),f&&fn&&bo(l),rE(l),h===13){if(l=l.memoizedState,l=l!==null?l.dehydrated:null,!l)throw Error(a(317));fn=CA(l)}else if(h===31){if(l=l.memoizedState,l=l!==null?l.dehydrated:null,!l)throw Error(a(317));fn=CA(l)}else h===27?(h=fn,Ro(l.type)?(l=C1,C1=null,fn=l):fn=h):fn=Aa?ds(l.stateNode.nextSibling):null;return!0}function Hl(){fn=Aa=null,Et=!1}function ow(){var l=yo;return l!==null&&(wr===null?wr=l:wr.push.apply(wr,l),yo=null),l}function jf(l){yo===null?yo=[l]:yo.push(l)}var lw=L(null),Gl=null,Ii=null;function vo(l,h,f){ie(lw,h._currentValue),h._currentValue=f}function Ti(l){l._currentValue=lw.current,ee(lw)}function uw(l,h,f){for(;l!==null;){var y=l.alternate;if((l.childLanes&h)!==h?(l.childLanes|=h,y!==null&&(y.childLanes|=h)):y!==null&&(y.childLanes&h)!==h&&(y.childLanes|=h),l===f)break;l=l.return}}function cw(l,h,f,y){var S=l.child;for(S!==null&&(S.return=l);S!==null;){var _=S.dependencies;if(_!==null){var A=S.child;_=_.firstContext;e:for(;_!==null;){var z=_;_=S;for(var J=0;J<h.length;J++)if(z.context===h[J]){_.lanes|=f,z=_.alternate,z!==null&&(z.lanes|=f),uw(_.return,f,l),y||(A=null);break e}_=z.next}}else if(S.tag===18){if(A=S.return,A===null)throw Error(a(341));A.lanes|=f,_=A.alternate,_!==null&&(_.lanes|=f),uw(A,f,l),A=null}else A=S.child;if(A!==null)A.return=S;else for(A=S;A!==null;){if(A===l){A=null;break}if(S=A.sibling,S!==null){S.return=A.return,A=S;break}A=A.return}S=A}}function Vd(l,h,f,y){l=null;for(var S=h,_=!1;S!==null;){if(!_){if((S.flags&524288)!==0)_=!0;else if((S.flags&262144)!==0)break}if(S.tag===10){var A=S.alternate;if(A===null)throw Error(a(387));if(A=A.memoizedProps,A!==null){var z=S.type;Fr(S.pendingProps.value,A.value)||(l!==null?l.push(z):l=[z])}}else if(S===Ee.current){if(A=S.alternate,A===null)throw Error(a(387));A.memoizedState.memoizedState!==S.memoizedState.memoizedState&&(l!==null?l.push(mm):l=[mm])}S=S.return}l!==null&&cw(h,l,f,y),h.flags|=262144}function Hy(l){for(l=l.firstContext;l!==null;){if(!Fr(l.context._currentValue,l.memoizedValue))return!0;l=l.next}return!1}function ql(l){Gl=l,Ii=null,l=l.dependencies,l!==null&&(l.firstContext=null)}function $a(l){return sE(Gl,l)}function Gy(l,h){return Gl===null&&ql(l),sE(l,h)}function sE(l,h){var f=h._currentValue;if(h={context:h,memoizedValue:f,next:null},Ii===null){if(l===null)throw Error(a(308));Ii=h,l.dependencies={lanes:0,firstContext:h},l.flags|=524288}else Ii=Ii.next=h;return f}var cW=typeof AbortController<"u"?AbortController:function(){var l=[],h=this.signal={aborted:!1,addEventListener:function(f,y){l.push(y)}};this.abort=function(){h.aborted=!0,l.forEach(function(f){return f()})}},dW=e.unstable_scheduleCallback,hW=e.unstable_NormalPriority,qn={$$typeof:N,Consumer:null,Provider:null,_currentValue:null,_currentValue2:null,_threadCount:0};function dw(){return{controller:new cW,data:new Map,refCount:0}}function Wf(l){l.refCount--,l.refCount===0&&dW(hW,function(){l.controller.abort()})}var Vf=null,hw=0,Hd=0,Gd=null;function pW(l,h){if(Vf===null){var f=Vf=[];hw=0,Hd=m1(),Gd={status:"pending",value:void 0,then:function(y){f.push(y)}}}return hw++,h.then(iE,iE),h}function iE(){if(--hw===0&&Vf!==null){Gd!==null&&(Gd.status="fulfilled");var l=Vf;Vf=null,Hd=0,Gd=null;for(var h=0;h<l.length;h++)(0,l[h])()}}function fW(l,h){var f=[],y={status:"pending",value:null,reason:null,then:function(S){f.push(S)}};return l.then(function(){y.status="fulfilled",y.value=h;for(var S=0;S<f.length;S++)(0,f[S])(h)},function(S){for(y.status="rejected",y.reason=S,S=0;S<f.length;S++)(0,f[S])(void 0)}),y}var oE=j.S;j.S=function(l,h){VC=dn(),typeof h=="object"&&h!==null&&typeof h.then=="function"&&pW(l,h),oE!==null&&oE(l,h)};var Kl=L(null);function pw(){var l=Kl.current;return l!==null?l:on.pooledCache}function qy(l,h){h===null?ie(Kl,Kl.current):ie(Kl,h.pool)}function lE(){var l=pw();return l===null?null:{parent:qn._currentValue,pool:l}}var qd=Error(a(460)),fw=Error(a(474)),Ky=Error(a(542)),Xy={then:function(){}};function uE(l){return l=l.status,l==="fulfilled"||l==="rejected"}function cE(l,h,f){switch(f=l[f],f===void 0?l.push(h):f!==h&&(h.then(yr,yr),h=f),h.status){case"fulfilled":return h.value;case"rejected":throw l=h.reason,hE(l),l;default:if(typeof h.status=="string")h.then(yr,yr);else{if(l=on,l!==null&&100<l.shellSuspendCounter)throw Error(a(482));l=h,l.status="pending",l.then(function(y){if(h.status==="pending"){var S=h;S.status="fulfilled",S.value=y}},function(y){if(h.status==="pending"){var S=h;S.status="rejected",S.reason=y}})}switch(h.status){case"fulfilled":return h.value;case"rejected":throw l=h.reason,hE(l),l}throw Yl=h,qd}}function Xl(l){try{var h=l._init;return h(l._payload)}catch(f){throw f!==null&&typeof f=="object"&&typeof f.then=="function"?(Yl=f,qd):f}}var Yl=null;function dE(){if(Yl===null)throw Error(a(459));var l=Yl;return Yl=null,l}function hE(l){if(l===qd||l===Ky)throw Error(a(483))}var Kd=null,Hf=0;function Yy(l){var h=Hf;return Hf+=1,Kd===null&&(Kd=[]),cE(Kd,l,h)}function Gf(l,h){h=h.props.ref,l.ref=h!==void 0?h:null}function Jy(l,h){throw h.$$typeof===m?Error(a(525)):(l=Object.prototype.toString.call(h),Error(a(31,l==="[object Object]"?"object with keys {"+Object.keys(h).join(", ")+"}":l)))}function pE(l){function h(le,se){if(l){var pe=le.deletions;pe===null?(le.deletions=[se],le.flags|=16):pe.push(se)}}function f(le,se){if(!l)return null;for(;se!==null;)h(le,se),se=se.sibling;return null}function y(le){for(var se=new Map;le!==null;)le.key!==null?se.set(le.key,le):se.set(le.index,le),le=le.sibling;return se}function S(le,se){return le=_i(le,se),le.index=0,le.sibling=null,le}function _(le,se,pe){return le.index=pe,l?(pe=le.alternate,pe!==null?(pe=pe.index,pe<se?(le.flags|=67108866,se):pe):(le.flags|=67108866,se)):(le.flags|=1048576,se)}function A(le){return l&&le.alternate===null&&(le.flags|=67108866),le}function z(le,se,pe,ke){return se===null||se.tag!==6?(se=nw(pe,le.mode,ke),se.return=le,se):(se=S(se,pe),se.return=le,se)}function J(le,se,pe,ke){var Ye=pe.type;return Ye===v?Se(le,se,pe.props.children,ke,pe.key):se!==null&&(se.elementType===Ye||typeof Ye=="object"&&Ye!==null&&Ye.$$typeof===M&&Xl(Ye)===se.type)?(se=S(se,pe.props),Gf(se,pe),se.return=le,se):(se=Wy(pe.type,pe.key,pe.props,null,le.mode,ke),Gf(se,pe),se.return=le,se)}function fe(le,se,pe,ke){return se===null||se.tag!==4||se.stateNode.containerInfo!==pe.containerInfo||se.stateNode.implementation!==pe.implementation?(se=aw(pe,le.mode,ke),se.return=le,se):(se=S(se,pe.children||[]),se.return=le,se)}function Se(le,se,pe,ke,Ye){return se===null||se.tag!==7?(se=Vl(pe,le.mode,ke,Ye),se.return=le,se):(se=S(se,pe),se.return=le,se)}function Ne(le,se,pe){if(typeof se=="string"&&se!==""||typeof se=="number"||typeof se=="bigint")return se=nw(""+se,le.mode,pe),se.return=le,se;if(typeof se=="object"&&se!==null){switch(se.$$typeof){case g:return pe=Wy(se.type,se.key,se.props,null,le.mode,pe),Gf(pe,se),pe.return=le,pe;case b:return se=aw(se,le.mode,pe),se.return=le,se;case M:return se=Xl(se),Ne(le,se,pe)}if(ae(se)||R(se))return se=Vl(se,le.mode,pe,null),se.return=le,se;if(typeof se.then=="function")return Ne(le,Yy(se),pe);if(se.$$typeof===N)return Ne(le,Gy(le,se),pe);Jy(le,se)}return null}function ge(le,se,pe,ke){var Ye=se!==null?se.key:null;if(typeof pe=="string"&&pe!==""||typeof pe=="number"||typeof pe=="bigint")return Ye!==null?null:z(le,se,""+pe,ke);if(typeof pe=="object"&&pe!==null){switch(pe.$$typeof){case g:return pe.key===Ye?J(le,se,pe,ke):null;case b:return pe.key===Ye?fe(le,se,pe,ke):null;case M:return pe=Xl(pe),ge(le,se,pe,ke)}if(ae(pe)||R(pe))return Ye!==null?null:Se(le,se,pe,ke,null);if(typeof pe.then=="function")return ge(le,se,Yy(pe),ke);if(pe.$$typeof===N)return ge(le,se,Gy(le,pe),ke);Jy(le,pe)}return null}function be(le,se,pe,ke,Ye){if(typeof ke=="string"&&ke!==""||typeof ke=="number"||typeof ke=="bigint")return le=le.get(pe)||null,z(se,le,""+ke,Ye);if(typeof ke=="object"&&ke!==null){switch(ke.$$typeof){case g:return le=le.get(ke.key===null?pe:ke.key)||null,J(se,le,ke,Ye);case b:return le=le.get(ke.key===null?pe:ke.key)||null,fe(se,le,ke,Ye);case M:return ke=Xl(ke),be(le,se,pe,ke,Ye)}if(ae(ke)||R(ke))return le=le.get(pe)||null,Se(se,le,ke,Ye,null);if(typeof ke.then=="function")return be(le,se,pe,Yy(ke),Ye);if(ke.$$typeof===N)return be(le,se,pe,Gy(se,ke),Ye);Jy(se,ke)}return null}function Pe(le,se,pe,ke){for(var Ye=null,Ot=null,Ve=se,yt=se=0,It=null;Ve!==null&&yt<pe.length;yt++){Ve.index>yt?(It=Ve,Ve=null):It=Ve.sibling;var Mt=ge(le,Ve,pe[yt],ke);if(Mt===null){Ve===null&&(Ve=It);break}l&&Ve&&Mt.alternate===null&&h(le,Ve),se=_(Mt,se,yt),Ot===null?Ye=Mt:Ot.sibling=Mt,Ot=Mt,Ve=It}if(yt===pe.length)return f(le,Ve),Et&&Ni(le,yt),Ye;if(Ve===null){for(;yt<pe.length;yt++)Ve=Ne(le,pe[yt],ke),Ve!==null&&(se=_(Ve,se,yt),Ot===null?Ye=Ve:Ot.sibling=Ve,Ot=Ve);return Et&&Ni(le,yt),Ye}for(Ve=y(Ve);yt<pe.length;yt++)It=be(Ve,le,yt,pe[yt],ke),It!==null&&(l&&It.alternate!==null&&Ve.delete(It.key===null?yt:It.key),se=_(It,se,yt),Ot===null?Ye=It:Ot.sibling=It,Ot=It);return l&&Ve.forEach(function(zo){return h(le,zo)}),Et&&Ni(le,yt),Ye}function Je(le,se,pe,ke){if(pe==null)throw Error(a(151));for(var Ye=null,Ot=null,Ve=se,yt=se=0,It=null,Mt=pe.next();Ve!==null&&!Mt.done;yt++,Mt=pe.next()){Ve.index>yt?(It=Ve,Ve=null):It=Ve.sibling;var zo=ge(le,Ve,Mt.value,ke);if(zo===null){Ve===null&&(Ve=It);break}l&&Ve&&zo.alternate===null&&h(le,Ve),se=_(zo,se,yt),Ot===null?Ye=zo:Ot.sibling=zo,Ot=zo,Ve=It}if(Mt.done)return f(le,Ve),Et&&Ni(le,yt),Ye;if(Ve===null){for(;!Mt.done;yt++,Mt=pe.next())Mt=Ne(le,Mt.value,ke),Mt!==null&&(se=_(Mt,se,yt),Ot===null?Ye=Mt:Ot.sibling=Mt,Ot=Mt);return Et&&Ni(le,yt),Ye}for(Ve=y(Ve);!Mt.done;yt++,Mt=pe.next())Mt=be(Ve,le,yt,Mt.value,ke),Mt!==null&&(l&&Mt.alternate!==null&&Ve.delete(Mt.key===null?yt:Mt.key),se=_(Mt,se,yt),Ot===null?Ye=Mt:Ot.sibling=Mt,Ot=Mt);return l&&Ve.forEach(function(NV){return h(le,NV)}),Et&&Ni(le,yt),Ye}function nn(le,se,pe,ke){if(typeof pe=="object"&&pe!==null&&pe.type===v&&pe.key===null&&(pe=pe.props.children),typeof pe=="object"&&pe!==null){switch(pe.$$typeof){case g:e:{for(var Ye=pe.key;se!==null;){if(se.key===Ye){if(Ye=pe.type,Ye===v){if(se.tag===7){f(le,se.sibling),ke=S(se,pe.props.children),ke.return=le,le=ke;break e}}else if(se.elementType===Ye||typeof Ye=="object"&&Ye!==null&&Ye.$$typeof===M&&Xl(Ye)===se.type){f(le,se.sibling),ke=S(se,pe.props),Gf(ke,pe),ke.return=le,le=ke;break e}f(le,se);break}else h(le,se);se=se.sibling}pe.type===v?(ke=Vl(pe.props.children,le.mode,ke,pe.key),ke.return=le,le=ke):(ke=Wy(pe.type,pe.key,pe.props,null,le.mode,ke),Gf(ke,pe),ke.return=le,le=ke)}return A(le);case b:e:{for(Ye=pe.key;se!==null;){if(se.key===Ye)if(se.tag===4&&se.stateNode.containerInfo===pe.containerInfo&&se.stateNode.implementation===pe.implementation){f(le,se.sibling),ke=S(se,pe.children||[]),ke.return=le,le=ke;break e}else{f(le,se);break}else h(le,se);se=se.sibling}ke=aw(pe,le.mode,ke),ke.return=le,le=ke}return A(le);case M:return pe=Xl(pe),nn(le,se,pe,ke)}if(ae(pe))return Pe(le,se,pe,ke);if(R(pe)){if(Ye=R(pe),typeof Ye!="function")throw Error(a(150));return pe=Ye.call(pe),Je(le,se,pe,ke)}if(typeof pe.then=="function")return nn(le,se,Yy(pe),ke);if(pe.$$typeof===N)return nn(le,se,Gy(le,pe),ke);Jy(le,pe)}return typeof pe=="string"&&pe!==""||typeof pe=="number"||typeof pe=="bigint"?(pe=""+pe,se!==null&&se.tag===6?(f(le,se.sibling),ke=S(se,pe),ke.return=le,le=ke):(f(le,se),ke=nw(pe,le.mode,ke),ke.return=le,le=ke),A(le)):f(le,se)}return function(le,se,pe,ke){try{Hf=0;var Ye=nn(le,se,pe,ke);return Kd=null,Ye}catch(Ve){if(Ve===qd||Ve===Ky)throw Ve;var Ot=zr(29,Ve,null,le.mode);return Ot.lanes=ke,Ot.return=le,Ot}}}var Jl=pE(!0),fE=pE(!1),xo=!1;function mw(l){l.updateQueue={baseState:l.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,lanes:0,hiddenCallbacks:null},callbacks:null}}function gw(l,h){l=l.updateQueue,h.updateQueue===l&&(h.updateQueue={baseState:l.baseState,firstBaseUpdate:l.firstBaseUpdate,lastBaseUpdate:l.lastBaseUpdate,shared:l.shared,callbacks:null})}function wo(l){return{lane:l,tag:0,payload:null,callback:null,next:null}}function So(l,h,f){var y=l.updateQueue;if(y===null)return null;if(y=y.shared,(zt&2)!==0){var S=y.pending;return S===null?h.next=h:(h.next=S.next,S.next=h),y.pending=h,h=jy(l),JT(l,null,f),h}return Uy(l,y,h,f),jy(l)}function qf(l,h,f){if(h=h.updateQueue,h!==null&&(h=h.shared,(f&4194048)!==0)){var y=h.lanes;y&=l.pendingLanes,f|=y,h.lanes=f,ht(l,f)}}function yw(l,h){var f=l.updateQueue,y=l.alternate;if(y!==null&&(y=y.updateQueue,f===y)){var S=null,_=null;if(f=f.firstBaseUpdate,f!==null){do{var A={lane:f.lane,tag:f.tag,payload:f.payload,callback:null,next:null};_===null?S=_=A:_=_.next=A,f=f.next}while(f!==null);_===null?S=_=h:_=_.next=h}else S=_=h;f={baseState:y.baseState,firstBaseUpdate:S,lastBaseUpdate:_,shared:y.shared,callbacks:y.callbacks},l.updateQueue=f;return}l=f.lastBaseUpdate,l===null?f.firstBaseUpdate=h:l.next=h,f.lastBaseUpdate=h}var bw=!1;function Kf(){if(bw){var l=Gd;if(l!==null)throw l}}function Xf(l,h,f,y){bw=!1;var S=l.updateQueue;xo=!1;var _=S.firstBaseUpdate,A=S.lastBaseUpdate,z=S.shared.pending;if(z!==null){S.shared.pending=null;var J=z,fe=J.next;J.next=null,A===null?_=fe:A.next=fe,A=J;var Se=l.alternate;Se!==null&&(Se=Se.updateQueue,z=Se.lastBaseUpdate,z!==A&&(z===null?Se.firstBaseUpdate=fe:z.next=fe,Se.lastBaseUpdate=J))}if(_!==null){var Ne=S.baseState;A=0,Se=fe=J=null,z=_;do{var ge=z.lane&-536870913,be=ge!==z.lane;if(be?(Nt&ge)===ge:(y&ge)===ge){ge!==0&&ge===Hd&&(bw=!0),Se!==null&&(Se=Se.next={lane:0,tag:z.tag,payload:z.payload,callback:null,next:null});e:{var Pe=l,Je=z;ge=h;var nn=f;switch(Je.tag){case 1:if(Pe=Je.payload,typeof Pe=="function"){Ne=Pe.call(nn,Ne,ge);break e}Ne=Pe;break e;case 3:Pe.flags=Pe.flags&-65537|128;case 0:if(Pe=Je.payload,ge=typeof Pe=="function"?Pe.call(nn,Ne,ge):Pe,ge==null)break e;Ne=p({},Ne,ge);break e;case 2:xo=!0}}ge=z.callback,ge!==null&&(l.flags|=64,be&&(l.flags|=8192),be=S.callbacks,be===null?S.callbacks=[ge]:be.push(ge))}else be={lane:ge,tag:z.tag,payload:z.payload,callback:z.callback,next:null},Se===null?(fe=Se=be,J=Ne):Se=Se.next=be,A|=ge;if(z=z.next,z===null){if(z=S.shared.pending,z===null)break;be=z,z=be.next,be.next=null,S.lastBaseUpdate=be,S.shared.pending=null}}while(!0);Se===null&&(J=Ne),S.baseState=J,S.firstBaseUpdate=fe,S.lastBaseUpdate=Se,_===null&&(S.shared.lanes=0),To|=A,l.lanes=A,l.memoizedState=Ne}}function mE(l,h){if(typeof l!="function")throw Error(a(191,l));l.call(h)}function gE(l,h){var f=l.callbacks;if(f!==null)for(l.callbacks=null,l=0;l<f.length;l++)mE(f[l],h)}var Xd=L(null),Zy=L(0);function yE(l,h){l=Fi,ie(Zy,l),ie(Xd,h),Fi=l|h.baseLanes}function vw(){ie(Zy,Fi),ie(Xd,Xd.current)}function xw(){Fi=Zy.current,ee(Xd),ee(Zy)}var Lr=L(null),cs=null;function ko(l){var h=l.alternate;ie(Fn,Fn.current&1),ie(Lr,l),cs===null&&(h===null||Xd.current!==null||h.memoizedState!==null)&&(cs=l)}function ww(l){ie(Fn,Fn.current),ie(Lr,l),cs===null&&(cs=l)}function bE(l){l.tag===22?(ie(Fn,Fn.current),ie(Lr,l),cs===null&&(cs=l)):_o()}function _o(){ie(Fn,Fn.current),ie(Lr,Lr.current)}function Br(l){ee(Lr),cs===l&&(cs=null),ee(Fn)}var Fn=L(0);function Qy(l){for(var h=l;h!==null;){if(h.tag===13){var f=h.memoizedState;if(f!==null&&(f=f.dehydrated,f===null||T1(f)||E1(f)))return h}else if(h.tag===19&&(h.memoizedProps.revealOrder==="forwards"||h.memoizedProps.revealOrder==="backwards"||h.memoizedProps.revealOrder==="unstable_legacy-backwards"||h.memoizedProps.revealOrder==="together")){if((h.flags&128)!==0)return h}else if(h.child!==null){h.child.return=h,h=h.child;continue}if(h===l)break;for(;h.sibling===null;){if(h.return===null||h.return===l)return null;h=h.return}h.sibling.return=h.return,h=h.sibling}return null}var Ei=0,gt=null,en=null,Kn=null,eb=!1,Yd=!1,Zl=!1,tb=0,Yf=0,Jd=null,mW=0;function Cn(){throw Error(a(321))}function Sw(l,h){if(h===null)return!1;for(var f=0;f<h.length&&f<l.length;f++)if(!Fr(l[f],h[f]))return!1;return!0}function kw(l,h,f,y,S,_){return Ei=_,gt=h,h.memoizedState=null,h.updateQueue=null,h.lanes=0,j.H=l===null||l.memoizedState===null?tC:Lw,Zl=!1,_=f(y,S),Zl=!1,Yd&&(_=xE(h,f,y,S)),vE(l),_}function vE(l){j.H=Qf;var h=en!==null&&en.next!==null;if(Ei=0,Kn=en=gt=null,eb=!1,Yf=0,Jd=null,h)throw Error(a(300));l===null||Xn||(l=l.dependencies,l!==null&&Hy(l)&&(Xn=!0))}function xE(l,h,f,y){gt=l;var S=0;do{if(Yd&&(Jd=null),Yf=0,Yd=!1,25<=S)throw Error(a(301));if(S+=1,Kn=en=null,l.updateQueue!=null){var _=l.updateQueue;_.lastEffect=null,_.events=null,_.stores=null,_.memoCache!=null&&(_.memoCache.index=0)}j.H=nC,_=h(f,y)}while(Yd);return _}function gW(){var l=j.H,h=l.useState()[0];return h=typeof h.then=="function"?Jf(h):h,l=l.useState()[0],(en!==null?en.memoizedState:null)!==l&&(gt.flags|=1024),h}function _w(){var l=tb!==0;return tb=0,l}function Nw(l,h,f){h.updateQueue=l.updateQueue,h.flags&=-2053,l.lanes&=~f}function Iw(l){if(eb){for(l=l.memoizedState;l!==null;){var h=l.queue;h!==null&&(h.pending=null),l=l.next}eb=!1}Ei=0,Kn=en=gt=null,Yd=!1,Yf=tb=0,Jd=null}function rr(){var l={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return Kn===null?gt.memoizedState=Kn=l:Kn=Kn.next=l,Kn}function zn(){if(en===null){var l=gt.alternate;l=l!==null?l.memoizedState:null}else l=en.next;var h=Kn===null?gt.memoizedState:Kn.next;if(h!==null)Kn=h,en=l;else{if(l===null)throw gt.alternate===null?Error(a(467)):Error(a(310));en=l,l={memoizedState:en.memoizedState,baseState:en.baseState,baseQueue:en.baseQueue,queue:en.queue,next:null},Kn===null?gt.memoizedState=Kn=l:Kn=Kn.next=l}return Kn}function nb(){return{lastEffect:null,events:null,stores:null,memoCache:null}}function Jf(l){var h=Yf;return Yf+=1,Jd===null&&(Jd=[]),l=cE(Jd,l,h),h=gt,(Kn===null?h.memoizedState:Kn.next)===null&&(h=h.alternate,j.H=h===null||h.memoizedState===null?tC:Lw),l}function ab(l){if(l!==null&&typeof l=="object"){if(typeof l.then=="function")return Jf(l);if(l.$$typeof===N)return $a(l)}throw Error(a(438,String(l)))}function Tw(l){var h=null,f=gt.updateQueue;if(f!==null&&(h=f.memoCache),h==null){var y=gt.alternate;y!==null&&(y=y.updateQueue,y!==null&&(y=y.memoCache,y!=null&&(h={data:y.data.map(function(S){return S.slice()}),index:0})))}if(h==null&&(h={data:[],index:0}),f===null&&(f=nb(),gt.updateQueue=f),f.memoCache=h,f=h.data[h.index],f===void 0)for(f=h.data[h.index]=Array(l),y=0;y<l;y++)f[y]=V;return h.index++,f}function Ci(l,h){return typeof h=="function"?h(l):h}function rb(l){var h=zn();return Ew(h,en,l)}function Ew(l,h,f){var y=l.queue;if(y===null)throw Error(a(311));y.lastRenderedReducer=f;var S=l.baseQueue,_=y.pending;if(_!==null){if(S!==null){var A=S.next;S.next=_.next,_.next=A}h.baseQueue=S=_,y.pending=null}if(_=l.baseState,S===null)l.memoizedState=_;else{h=S.next;var z=A=null,J=null,fe=h,Se=!1;do{var Ne=fe.lane&-536870913;if(Ne!==fe.lane?(Nt&Ne)===Ne:(Ei&Ne)===Ne){var ge=fe.revertLane;if(ge===0)J!==null&&(J=J.next={lane:0,revertLane:0,gesture:null,action:fe.action,hasEagerState:fe.hasEagerState,eagerState:fe.eagerState,next:null}),Ne===Hd&&(Se=!0);else if((Ei&ge)===ge){fe=fe.next,ge===Hd&&(Se=!0);continue}else Ne={lane:0,revertLane:fe.revertLane,gesture:null,action:fe.action,hasEagerState:fe.hasEagerState,eagerState:fe.eagerState,next:null},J===null?(z=J=Ne,A=_):J=J.next=Ne,gt.lanes|=ge,To|=ge;Ne=fe.action,Zl&&f(_,Ne),_=fe.hasEagerState?fe.eagerState:f(_,Ne)}else ge={lane:Ne,revertLane:fe.revertLane,gesture:fe.gesture,action:fe.action,hasEagerState:fe.hasEagerState,eagerState:fe.eagerState,next:null},J===null?(z=J=ge,A=_):J=J.next=ge,gt.lanes|=Ne,To|=Ne;fe=fe.next}while(fe!==null&&fe!==h);if(J===null?A=_:J.next=z,!Fr(_,l.memoizedState)&&(Xn=!0,Se&&(f=Gd,f!==null)))throw f;l.memoizedState=_,l.baseState=A,l.baseQueue=J,y.lastRenderedState=_}return S===null&&(y.lanes=0),[l.memoizedState,y.dispatch]}function Cw(l){var h=zn(),f=h.queue;if(f===null)throw Error(a(311));f.lastRenderedReducer=l;var y=f.dispatch,S=f.pending,_=h.memoizedState;if(S!==null){f.pending=null;var A=S=S.next;do _=l(_,A.action),A=A.next;while(A!==S);Fr(_,h.memoizedState)||(Xn=!0),h.memoizedState=_,h.baseQueue===null&&(h.baseState=_),f.lastRenderedState=_}return[_,y]}function wE(l,h,f){var y=gt,S=zn(),_=Et;if(_){if(f===void 0)throw Error(a(407));f=f()}else f=h();var A=!Fr((en||S).memoizedState,f);if(A&&(S.memoizedState=f,Xn=!0),S=S.queue,Rw(_E.bind(null,y,S,l),[l]),S.getSnapshot!==h||A||Kn!==null&&Kn.memoizedState.tag&1){if(y.flags|=2048,Zd(9,{destroy:void 0},kE.bind(null,y,S,f,h),null),on===null)throw Error(a(349));_||(Ei&127)!==0||SE(y,h,f)}return f}function SE(l,h,f){l.flags|=16384,l={getSnapshot:h,value:f},h=gt.updateQueue,h===null?(h=nb(),gt.updateQueue=h,h.stores=[l]):(f=h.stores,f===null?h.stores=[l]:f.push(l))}function kE(l,h,f,y){h.value=f,h.getSnapshot=y,NE(h)&&IE(l)}function _E(l,h,f){return f(function(){NE(h)&&IE(l)})}function NE(l){var h=l.getSnapshot;l=l.value;try{var f=h();return!Fr(l,f)}catch{return!0}}function IE(l){var h=Wl(l,2);h!==null&&Sr(h,l,2)}function Aw(l){var h=rr();if(typeof l=="function"){var f=l;if(l=f(),Zl){sn(!0);try{f()}finally{sn(!1)}}}return h.memoizedState=h.baseState=l,h.queue={pending:null,lanes:0,dispatch:null,lastRenderedReducer:Ci,lastRenderedState:l},h}function TE(l,h,f,y){return l.baseState=f,Ew(l,en,typeof y=="function"?y:Ci)}function yW(l,h,f,y,S){if(ob(l))throw Error(a(485));if(l=h.action,l!==null){var _={payload:S,action:l,next:null,isTransition:!0,status:"pending",value:null,reason:null,listeners:[],then:function(A){_.listeners.push(A)}};j.T!==null?f(!0):_.isTransition=!1,y(_),f=h.pending,f===null?(_.next=h.pending=_,EE(h,_)):(_.next=f.next,h.pending=f.next=_)}}function EE(l,h){var f=h.action,y=h.payload,S=l.state;if(h.isTransition){var _=j.T,A={};j.T=A;try{var z=f(S,y),J=j.S;J!==null&&J(A,z),CE(l,h,z)}catch(fe){$w(l,h,fe)}finally{_!==null&&A.types!==null&&(_.types=A.types),j.T=_}}else try{_=f(S,y),CE(l,h,_)}catch(fe){$w(l,h,fe)}}function CE(l,h,f){f!==null&&typeof f=="object"&&typeof f.then=="function"?f.then(function(y){AE(l,h,y)},function(y){return $w(l,h,y)}):AE(l,h,f)}function AE(l,h,f){h.status="fulfilled",h.value=f,$E(h),l.state=f,h=l.pending,h!==null&&(f=h.next,f===h?l.pending=null:(f=f.next,h.next=f,EE(l,f)))}function $w(l,h,f){var y=l.pending;if(l.pending=null,y!==null){y=y.next;do h.status="rejected",h.reason=f,$E(h),h=h.next;while(h!==y)}l.action=null}function $E(l){l=l.listeners;for(var h=0;h<l.length;h++)(0,l[h])()}function RE(l,h){return h}function DE(l,h){if(Et){var f=on.formState;if(f!==null){e:{var y=gt;if(Et){if(fn){t:{for(var S=fn,_=us;S.nodeType!==8;){if(!_){S=null;break t}if(S=ds(S.nextSibling),S===null){S=null;break t}}_=S.data,S=_==="F!"||_==="F"?S:null}if(S){fn=ds(S.nextSibling),y=S.data==="F!";break e}}bo(y)}y=!1}y&&(h=f[0])}}return f=rr(),f.memoizedState=f.baseState=h,y={pending:null,lanes:0,dispatch:null,lastRenderedReducer:RE,lastRenderedState:h},f.queue=y,f=ZE.bind(null,gt,y),y.dispatch=f,y=Aw(!1),_=zw.bind(null,gt,!1,y.queue),y=rr(),S={state:h,dispatch:null,action:l,pending:null},y.queue=S,f=yW.bind(null,gt,S,_,f),S.dispatch=f,y.memoizedState=l,[h,f,!1]}function OE(l){var h=zn();return ME(h,en,l)}function ME(l,h,f){if(h=Ew(l,h,RE)[0],l=rb(Ci)[0],typeof h=="object"&&h!==null&&typeof h.then=="function")try{var y=Jf(h)}catch(A){throw A===qd?Ky:A}else y=h;h=zn();var S=h.queue,_=S.dispatch;return f!==h.memoizedState&&(gt.flags|=2048,Zd(9,{destroy:void 0},bW.bind(null,S,f),null)),[y,_,l]}function bW(l,h){l.action=h}function FE(l){var h=zn(),f=en;if(f!==null)return ME(h,f,l);zn(),h=h.memoizedState,f=zn();var y=f.queue.dispatch;return f.memoizedState=l,[h,y,!1]}function Zd(l,h,f,y){return l={tag:l,create:f,deps:y,inst:h,next:null},h=gt.updateQueue,h===null&&(h=nb(),gt.updateQueue=h),f=h.lastEffect,f===null?h.lastEffect=l.next=l:(y=f.next,f.next=l,l.next=y,h.lastEffect=l),l}function zE(){return zn().memoizedState}function sb(l,h,f,y){var S=rr();gt.flags|=l,S.memoizedState=Zd(1|h,{destroy:void 0},f,y===void 0?null:y)}function ib(l,h,f,y){var S=zn();y=y===void 0?null:y;var _=S.memoizedState.inst;en!==null&&y!==null&&Sw(y,en.memoizedState.deps)?S.memoizedState=Zd(h,_,f,y):(gt.flags|=l,S.memoizedState=Zd(1|h,_,f,y))}function LE(l,h){sb(8390656,8,l,h)}function Rw(l,h){ib(2048,8,l,h)}function vW(l){gt.flags|=4;var h=gt.updateQueue;if(h===null)h=nb(),gt.updateQueue=h,h.events=[l];else{var f=h.events;f===null?h.events=[l]:f.push(l)}}function BE(l){var h=zn().memoizedState;return vW({ref:h,nextImpl:l}),function(){if((zt&2)!==0)throw Error(a(440));return h.impl.apply(void 0,arguments)}}function PE(l,h){return ib(4,2,l,h)}function UE(l,h){return ib(4,4,l,h)}function jE(l,h){if(typeof h=="function"){l=l();var f=h(l);return function(){typeof f=="function"?f():h(null)}}if(h!=null)return l=l(),h.current=l,function(){h.current=null}}function WE(l,h,f){f=f!=null?f.concat([l]):null,ib(4,4,jE.bind(null,h,l),f)}function Dw(){}function VE(l,h){var f=zn();h=h===void 0?null:h;var y=f.memoizedState;return h!==null&&Sw(h,y[1])?y[0]:(f.memoizedState=[l,h],l)}function HE(l,h){var f=zn();h=h===void 0?null:h;var y=f.memoizedState;if(h!==null&&Sw(h,y[1]))return y[0];if(y=l(),Zl){sn(!0);try{l()}finally{sn(!1)}}return f.memoizedState=[y,h],y}function Ow(l,h,f){return f===void 0||(Ei&1073741824)!==0&&(Nt&261930)===0?l.memoizedState=h:(l.memoizedState=f,l=GC(),gt.lanes|=l,To|=l,f)}function GE(l,h,f,y){return Fr(f,h)?f:Xd.current!==null?(l=Ow(l,f,y),Fr(l,h)||(Xn=!0),l):(Ei&42)===0||(Ei&1073741824)!==0&&(Nt&261930)===0?(Xn=!0,l.memoizedState=f):(l=GC(),gt.lanes|=l,To|=l,h)}function qE(l,h,f,y,S){var _=K.p;K.p=_!==0&&8>_?_:8;var A=j.T,z={};j.T=z,zw(l,!1,h,f);try{var J=S(),fe=j.S;if(fe!==null&&fe(z,J),J!==null&&typeof J=="object"&&typeof J.then=="function"){var Se=fW(J,y);Zf(l,h,Se,jr(l))}else Zf(l,h,y,jr(l))}catch(Ne){Zf(l,h,{then:function(){},status:"rejected",reason:Ne},jr())}finally{K.p=_,A!==null&&z.types!==null&&(A.types=z.types),j.T=A}}function xW(){}function Mw(l,h,f,y){if(l.tag!==5)throw Error(a(476));var S=KE(l).queue;qE(l,S,h,Q,f===null?xW:function(){return XE(l),f(y)})}function KE(l){var h=l.memoizedState;if(h!==null)return h;h={memoizedState:Q,baseState:Q,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:Ci,lastRenderedState:Q},next:null};var f={};return h.next={memoizedState:f,baseState:f,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:Ci,lastRenderedState:f},next:null},l.memoizedState=h,l=l.alternate,l!==null&&(l.memoizedState=h),h}function XE(l){var h=KE(l);h.next===null&&(h=l.alternate.memoizedState),Zf(l,h.next.queue,{},jr())}function Fw(){return $a(mm)}function YE(){return zn().memoizedState}function JE(){return zn().memoizedState}function wW(l){for(var h=l.return;h!==null;){switch(h.tag){case 24:case 3:var f=jr();l=wo(f);var y=So(h,l,f);y!==null&&(Sr(y,h,f),qf(y,h,f)),h={cache:dw()},l.payload=h;return}h=h.return}}function SW(l,h,f){var y=jr();f={lane:y,revertLane:0,gesture:null,action:f,hasEagerState:!1,eagerState:null,next:null},ob(l)?QE(h,f):(f=ew(l,h,f,y),f!==null&&(Sr(f,l,y),eC(f,h,y)))}function ZE(l,h,f){var y=jr();Zf(l,h,f,y)}function Zf(l,h,f,y){var S={lane:y,revertLane:0,gesture:null,action:f,hasEagerState:!1,eagerState:null,next:null};if(ob(l))QE(h,S);else{var _=l.alternate;if(l.lanes===0&&(_===null||_.lanes===0)&&(_=h.lastRenderedReducer,_!==null))try{var A=h.lastRenderedState,z=_(A,f);if(S.hasEagerState=!0,S.eagerState=z,Fr(z,A))return Uy(l,h,S,0),on===null&&Py(),!1}catch{}if(f=ew(l,h,S,y),f!==null)return Sr(f,l,y),eC(f,h,y),!0}return!1}function zw(l,h,f,y){if(y={lane:2,revertLane:m1(),gesture:null,action:y,hasEagerState:!1,eagerState:null,next:null},ob(l)){if(h)throw Error(a(479))}else h=ew(l,f,y,2),h!==null&&Sr(h,l,2)}function ob(l){var h=l.alternate;return l===gt||h!==null&&h===gt}function QE(l,h){Yd=eb=!0;var f=l.pending;f===null?h.next=h:(h.next=f.next,f.next=h),l.pending=h}function eC(l,h,f){if((f&4194048)!==0){var y=h.lanes;y&=l.pendingLanes,f|=y,h.lanes=f,ht(l,f)}}var Qf={readContext:$a,use:ab,useCallback:Cn,useContext:Cn,useEffect:Cn,useImperativeHandle:Cn,useLayoutEffect:Cn,useInsertionEffect:Cn,useMemo:Cn,useReducer:Cn,useRef:Cn,useState:Cn,useDebugValue:Cn,useDeferredValue:Cn,useTransition:Cn,useSyncExternalStore:Cn,useId:Cn,useHostTransitionStatus:Cn,useFormState:Cn,useActionState:Cn,useOptimistic:Cn,useMemoCache:Cn,useCacheRefresh:Cn};Qf.useEffectEvent=Cn;var tC={readContext:$a,use:ab,useCallback:function(l,h){return rr().memoizedState=[l,h===void 0?null:h],l},useContext:$a,useEffect:LE,useImperativeHandle:function(l,h,f){f=f!=null?f.concat([l]):null,sb(4194308,4,jE.bind(null,h,l),f)},useLayoutEffect:function(l,h){return sb(4194308,4,l,h)},useInsertionEffect:function(l,h){sb(4,2,l,h)},useMemo:function(l,h){var f=rr();h=h===void 0?null:h;var y=l();if(Zl){sn(!0);try{l()}finally{sn(!1)}}return f.memoizedState=[y,h],y},useReducer:function(l,h,f){var y=rr();if(f!==void 0){var S=f(h);if(Zl){sn(!0);try{f(h)}finally{sn(!1)}}}else S=h;return y.memoizedState=y.baseState=S,l={pending:null,lanes:0,dispatch:null,lastRenderedReducer:l,lastRenderedState:S},y.queue=l,l=l.dispatch=SW.bind(null,gt,l),[y.memoizedState,l]},useRef:function(l){var h=rr();return l={current:l},h.memoizedState=l},useState:function(l){l=Aw(l);var h=l.queue,f=ZE.bind(null,gt,h);return h.dispatch=f,[l.memoizedState,f]},useDebugValue:Dw,useDeferredValue:function(l,h){var f=rr();return Ow(f,l,h)},useTransition:function(){var l=Aw(!1);return l=qE.bind(null,gt,l.queue,!0,!1),rr().memoizedState=l,[!1,l]},useSyncExternalStore:function(l,h,f){var y=gt,S=rr();if(Et){if(f===void 0)throw Error(a(407));f=f()}else{if(f=h(),on===null)throw Error(a(349));(Nt&127)!==0||SE(y,h,f)}S.memoizedState=f;var _={value:f,getSnapshot:h};return S.queue=_,LE(_E.bind(null,y,_,l),[l]),y.flags|=2048,Zd(9,{destroy:void 0},kE.bind(null,y,_,f,h),null),f},useId:function(){var l=rr(),h=on.identifierPrefix;if(Et){var f=Ys,y=Xs;f=(y&~(1<<32-xa(y)-1)).toString(32)+f,h="_"+h+"R_"+f,f=tb++,0<f&&(h+="H"+f.toString(32)),h+="_"}else f=mW++,h="_"+h+"r_"+f.toString(32)+"_";return l.memoizedState=h},useHostTransitionStatus:Fw,useFormState:DE,useActionState:DE,useOptimistic:function(l){var h=rr();h.memoizedState=h.baseState=l;var f={pending:null,lanes:0,dispatch:null,lastRenderedReducer:null,lastRenderedState:null};return h.queue=f,h=zw.bind(null,gt,!0,f),f.dispatch=h,[l,h]},useMemoCache:Tw,useCacheRefresh:function(){return rr().memoizedState=wW.bind(null,gt)},useEffectEvent:function(l){var h=rr(),f={impl:l};return h.memoizedState=f,function(){if((zt&2)!==0)throw Error(a(440));return f.impl.apply(void 0,arguments)}}},Lw={readContext:$a,use:ab,useCallback:VE,useContext:$a,useEffect:Rw,useImperativeHandle:WE,useInsertionEffect:PE,useLayoutEffect:UE,useMemo:HE,useReducer:rb,useRef:zE,useState:function(){return rb(Ci)},useDebugValue:Dw,useDeferredValue:function(l,h){var f=zn();return GE(f,en.memoizedState,l,h)},useTransition:function(){var l=rb(Ci)[0],h=zn().memoizedState;return[typeof l=="boolean"?l:Jf(l),h]},useSyncExternalStore:wE,useId:YE,useHostTransitionStatus:Fw,useFormState:OE,useActionState:OE,useOptimistic:function(l,h){var f=zn();return TE(f,en,l,h)},useMemoCache:Tw,useCacheRefresh:JE};Lw.useEffectEvent=BE;var nC={readContext:$a,use:ab,useCallback:VE,useContext:$a,useEffect:Rw,useImperativeHandle:WE,useInsertionEffect:PE,useLayoutEffect:UE,useMemo:HE,useReducer:Cw,useRef:zE,useState:function(){return Cw(Ci)},useDebugValue:Dw,useDeferredValue:function(l,h){var f=zn();return en===null?Ow(f,l,h):GE(f,en.memoizedState,l,h)},useTransition:function(){var l=Cw(Ci)[0],h=zn().memoizedState;return[typeof l=="boolean"?l:Jf(l),h]},useSyncExternalStore:wE,useId:YE,useHostTransitionStatus:Fw,useFormState:FE,useActionState:FE,useOptimistic:function(l,h){var f=zn();return en!==null?TE(f,en,l,h):(f.baseState=l,[l,f.queue.dispatch])},useMemoCache:Tw,useCacheRefresh:JE};nC.useEffectEvent=BE;function Bw(l,h,f,y){h=l.memoizedState,f=f(y,h),f=f==null?h:p({},h,f),l.memoizedState=f,l.lanes===0&&(l.updateQueue.baseState=f)}var Pw={enqueueSetState:function(l,h,f){l=l._reactInternals;var y=jr(),S=wo(y);S.payload=h,f!=null&&(S.callback=f),h=So(l,S,y),h!==null&&(Sr(h,l,y),qf(h,l,y))},enqueueReplaceState:function(l,h,f){l=l._reactInternals;var y=jr(),S=wo(y);S.tag=1,S.payload=h,f!=null&&(S.callback=f),h=So(l,S,y),h!==null&&(Sr(h,l,y),qf(h,l,y))},enqueueForceUpdate:function(l,h){l=l._reactInternals;var f=jr(),y=wo(f);y.tag=2,h!=null&&(y.callback=h),h=So(l,y,f),h!==null&&(Sr(h,l,f),qf(h,l,f))}};function aC(l,h,f,y,S,_,A){return l=l.stateNode,typeof l.shouldComponentUpdate=="function"?l.shouldComponentUpdate(y,_,A):h.prototype&&h.prototype.isPureReactComponent?!Bf(f,y)||!Bf(S,_):!0}function rC(l,h,f,y){l=h.state,typeof h.componentWillReceiveProps=="function"&&h.componentWillReceiveProps(f,y),typeof h.UNSAFE_componentWillReceiveProps=="function"&&h.UNSAFE_componentWillReceiveProps(f,y),h.state!==l&&Pw.enqueueReplaceState(h,h.state,null)}function Ql(l,h){var f=h;if("ref"in h){f={};for(var y in h)y!=="ref"&&(f[y]=h[y])}if(l=l.defaultProps){f===h&&(f=p({},f));for(var S in l)f[S]===void 0&&(f[S]=l[S])}return f}function sC(l){By(l)}function iC(l){console.error(l)}function oC(l){By(l)}function lb(l,h){try{var f=l.onUncaughtError;f(h.value,{componentStack:h.stack})}catch(y){setTimeout(function(){throw y})}}function lC(l,h,f){try{var y=l.onCaughtError;y(f.value,{componentStack:f.stack,errorBoundary:h.tag===1?h.stateNode:null})}catch(S){setTimeout(function(){throw S})}}function Uw(l,h,f){return f=wo(f),f.tag=3,f.payload={element:null},f.callback=function(){lb(l,h)},f}function uC(l){return l=wo(l),l.tag=3,l}function cC(l,h,f,y){var S=f.type.getDerivedStateFromError;if(typeof S=="function"){var _=y.value;l.payload=function(){return S(_)},l.callback=function(){lC(h,f,y)}}var A=f.stateNode;A!==null&&typeof A.componentDidCatch=="function"&&(l.callback=function(){lC(h,f,y),typeof S!="function"&&(Eo===null?Eo=new Set([this]):Eo.add(this));var z=y.stack;this.componentDidCatch(y.value,{componentStack:z!==null?z:""})})}function kW(l,h,f,y,S){if(f.flags|=32768,y!==null&&typeof y=="object"&&typeof y.then=="function"){if(h=f.alternate,h!==null&&Vd(h,f,S,!0),f=Lr.current,f!==null){switch(f.tag){case 31:case 13:return cs===null?xb():f.alternate===null&&An===0&&(An=3),f.flags&=-257,f.flags|=65536,f.lanes=S,y===Xy?f.flags|=16384:(h=f.updateQueue,h===null?f.updateQueue=new Set([y]):h.add(y),h1(l,y,S)),!1;case 22:return f.flags|=65536,y===Xy?f.flags|=16384:(h=f.updateQueue,h===null?(h={transitions:null,markerInstances:null,retryQueue:new Set([y])},f.updateQueue=h):(f=h.retryQueue,f===null?h.retryQueue=new Set([y]):f.add(y)),h1(l,y,S)),!1}throw Error(a(435,f.tag))}return h1(l,y,S),xb(),!1}if(Et)return h=Lr.current,h!==null?((h.flags&65536)===0&&(h.flags|=256),h.flags|=65536,h.lanes=S,y!==iw&&(l=Error(a(422),{cause:y}),jf(is(l,f)))):(y!==iw&&(h=Error(a(423),{cause:y}),jf(is(h,f))),l=l.current.alternate,l.flags|=65536,S&=-S,l.lanes|=S,y=is(y,f),S=Uw(l.stateNode,y,S),yw(l,S),An!==4&&(An=2)),!1;var _=Error(a(520),{cause:y});if(_=is(_,f),om===null?om=[_]:om.push(_),An!==4&&(An=2),h===null)return!0;y=is(y,f),f=h;do{switch(f.tag){case 3:return f.flags|=65536,l=S&-S,f.lanes|=l,l=Uw(f.stateNode,y,l),yw(f,l),!1;case 1:if(h=f.type,_=f.stateNode,(f.flags&128)===0&&(typeof h.getDerivedStateFromError=="function"||_!==null&&typeof _.componentDidCatch=="function"&&(Eo===null||!Eo.has(_))))return f.flags|=65536,S&=-S,f.lanes|=S,S=uC(S),cC(S,l,f,y),yw(f,S),!1}f=f.return}while(f!==null);return!1}var jw=Error(a(461)),Xn=!1;function Ra(l,h,f,y){h.child=l===null?fE(h,null,f,y):Jl(h,l.child,f,y)}function dC(l,h,f,y,S){f=f.render;var _=h.ref;if("ref"in y){var A={};for(var z in y)z!=="ref"&&(A[z]=y[z])}else A=y;return ql(h),y=kw(l,h,f,A,_,S),z=_w(),l!==null&&!Xn?(Nw(l,h,S),Ai(l,h,S)):(Et&&z&&rw(h),h.flags|=1,Ra(l,h,y,S),h.child)}function hC(l,h,f,y,S){if(l===null){var _=f.type;return typeof _=="function"&&!tw(_)&&_.defaultProps===void 0&&f.compare===null?(h.tag=15,h.type=_,pC(l,h,_,y,S)):(l=Wy(f.type,null,y,h,h.mode,S),l.ref=h.ref,l.return=h,h.child=l)}if(_=l.child,!Yw(l,S)){var A=_.memoizedProps;if(f=f.compare,f=f!==null?f:Bf,f(A,y)&&l.ref===h.ref)return Ai(l,h,S)}return h.flags|=1,l=_i(_,y),l.ref=h.ref,l.return=h,h.child=l}function pC(l,h,f,y,S){if(l!==null){var _=l.memoizedProps;if(Bf(_,y)&&l.ref===h.ref)if(Xn=!1,h.pendingProps=y=_,Yw(l,S))(l.flags&131072)!==0&&(Xn=!0);else return h.lanes=l.lanes,Ai(l,h,S)}return Ww(l,h,f,y,S)}function fC(l,h,f,y){var S=y.children,_=l!==null?l.memoizedState:null;if(l===null&&h.stateNode===null&&(h.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null}),y.mode==="hidden"){if((h.flags&128)!==0){if(_=_!==null?_.baseLanes|f:f,l!==null){for(y=h.child=l.child,S=0;y!==null;)S=S|y.lanes|y.childLanes,y=y.sibling;y=S&~_}else y=0,h.child=null;return mC(l,h,_,f,y)}if((f&536870912)!==0)h.memoizedState={baseLanes:0,cachePool:null},l!==null&&qy(h,_!==null?_.cachePool:null),_!==null?yE(h,_):vw(),bE(h);else return y=h.lanes=536870912,mC(l,h,_!==null?_.baseLanes|f:f,f,y)}else _!==null?(qy(h,_.cachePool),yE(h,_),_o(),h.memoizedState=null):(l!==null&&qy(h,null),vw(),_o());return Ra(l,h,S,f),h.child}function em(l,h){return l!==null&&l.tag===22||h.stateNode!==null||(h.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null}),h.sibling}function mC(l,h,f,y,S){var _=pw();return _=_===null?null:{parent:qn._currentValue,pool:_},h.memoizedState={baseLanes:f,cachePool:_},l!==null&&qy(h,null),vw(),bE(h),l!==null&&Vd(l,h,y,!0),h.childLanes=S,null}function ub(l,h){return h=db({mode:h.mode,children:h.children},l.mode),h.ref=l.ref,l.child=h,h.return=l,h}function gC(l,h,f){return Jl(h,l.child,null,f),l=ub(h,h.pendingProps),l.flags|=2,Br(h),h.memoizedState=null,l}function _W(l,h,f){var y=h.pendingProps,S=(h.flags&128)!==0;if(h.flags&=-129,l===null){if(Et){if(y.mode==="hidden")return l=ub(h,y),h.lanes=536870912,em(null,l);if(ww(h),(l=fn)?(l=EA(l,us),l=l!==null&&l.data==="&"?l:null,l!==null&&(h.memoizedState={dehydrated:l,treeContext:go!==null?{id:Xs,overflow:Ys}:null,retryLane:536870912,hydrationErrors:null},f=QT(l),f.return=h,h.child=f,Aa=h,fn=null)):l=null,l===null)throw bo(h);return h.lanes=536870912,null}return ub(h,y)}var _=l.memoizedState;if(_!==null){var A=_.dehydrated;if(ww(h),S)if(h.flags&256)h.flags&=-257,h=gC(l,h,f);else if(h.memoizedState!==null)h.child=l.child,h.flags|=128,h=null;else throw Error(a(558));else if(Xn||Vd(l,h,f,!1),S=(f&l.childLanes)!==0,Xn||S){if(y=on,y!==null&&(A=st(y,f),A!==0&&A!==_.retryLane))throw _.retryLane=A,Wl(l,A),Sr(y,l,A),jw;xb(),h=gC(l,h,f)}else l=_.treeContext,fn=ds(A.nextSibling),Aa=h,Et=!0,yo=null,us=!1,l!==null&&nE(h,l),h=ub(h,y),h.flags|=4096;return h}return l=_i(l.child,{mode:y.mode,children:y.children}),l.ref=h.ref,h.child=l,l.return=h,l}function cb(l,h){var f=h.ref;if(f===null)l!==null&&l.ref!==null&&(h.flags|=4194816);else{if(typeof f!="function"&&typeof f!="object")throw Error(a(284));(l===null||l.ref!==f)&&(h.flags|=4194816)}}function Ww(l,h,f,y,S){return ql(h),f=kw(l,h,f,y,void 0,S),y=_w(),l!==null&&!Xn?(Nw(l,h,S),Ai(l,h,S)):(Et&&y&&rw(h),h.flags|=1,Ra(l,h,f,S),h.child)}function yC(l,h,f,y,S,_){return ql(h),h.updateQueue=null,f=xE(h,y,f,S),vE(l),y=_w(),l!==null&&!Xn?(Nw(l,h,_),Ai(l,h,_)):(Et&&y&&rw(h),h.flags|=1,Ra(l,h,f,_),h.child)}function bC(l,h,f,y,S){if(ql(h),h.stateNode===null){var _=Pd,A=f.contextType;typeof A=="object"&&A!==null&&(_=$a(A)),_=new f(y,_),h.memoizedState=_.state!==null&&_.state!==void 0?_.state:null,_.updater=Pw,h.stateNode=_,_._reactInternals=h,_=h.stateNode,_.props=y,_.state=h.memoizedState,_.refs={},mw(h),A=f.contextType,_.context=typeof A=="object"&&A!==null?$a(A):Pd,_.state=h.memoizedState,A=f.getDerivedStateFromProps,typeof A=="function"&&(Bw(h,f,A,y),_.state=h.memoizedState),typeof f.getDerivedStateFromProps=="function"||typeof _.getSnapshotBeforeUpdate=="function"||typeof _.UNSAFE_componentWillMount!="function"&&typeof _.componentWillMount!="function"||(A=_.state,typeof _.componentWillMount=="function"&&_.componentWillMount(),typeof _.UNSAFE_componentWillMount=="function"&&_.UNSAFE_componentWillMount(),A!==_.state&&Pw.enqueueReplaceState(_,_.state,null),Xf(h,y,_,S),Kf(),_.state=h.memoizedState),typeof _.componentDidMount=="function"&&(h.flags|=4194308),y=!0}else if(l===null){_=h.stateNode;var z=h.memoizedProps,J=Ql(f,z);_.props=J;var fe=_.context,Se=f.contextType;A=Pd,typeof Se=="object"&&Se!==null&&(A=$a(Se));var Ne=f.getDerivedStateFromProps;Se=typeof Ne=="function"||typeof _.getSnapshotBeforeUpdate=="function",z=h.pendingProps!==z,Se||typeof _.UNSAFE_componentWillReceiveProps!="function"&&typeof _.componentWillReceiveProps!="function"||(z||fe!==A)&&rC(h,_,y,A),xo=!1;var ge=h.memoizedState;_.state=ge,Xf(h,y,_,S),Kf(),fe=h.memoizedState,z||ge!==fe||xo?(typeof Ne=="function"&&(Bw(h,f,Ne,y),fe=h.memoizedState),(J=xo||aC(h,f,J,y,ge,fe,A))?(Se||typeof _.UNSAFE_componentWillMount!="function"&&typeof _.componentWillMount!="function"||(typeof _.componentWillMount=="function"&&_.componentWillMount(),typeof _.UNSAFE_componentWillMount=="function"&&_.UNSAFE_componentWillMount()),typeof _.componentDidMount=="function"&&(h.flags|=4194308)):(typeof _.componentDidMount=="function"&&(h.flags|=4194308),h.memoizedProps=y,h.memoizedState=fe),_.props=y,_.state=fe,_.context=A,y=J):(typeof _.componentDidMount=="function"&&(h.flags|=4194308),y=!1)}else{_=h.stateNode,gw(l,h),A=h.memoizedProps,Se=Ql(f,A),_.props=Se,Ne=h.pendingProps,ge=_.context,fe=f.contextType,J=Pd,typeof fe=="object"&&fe!==null&&(J=$a(fe)),z=f.getDerivedStateFromProps,(fe=typeof z=="function"||typeof _.getSnapshotBeforeUpdate=="function")||typeof _.UNSAFE_componentWillReceiveProps!="function"&&typeof _.componentWillReceiveProps!="function"||(A!==Ne||ge!==J)&&rC(h,_,y,J),xo=!1,ge=h.memoizedState,_.state=ge,Xf(h,y,_,S),Kf();var be=h.memoizedState;A!==Ne||ge!==be||xo||l!==null&&l.dependencies!==null&&Hy(l.dependencies)?(typeof z=="function"&&(Bw(h,f,z,y),be=h.memoizedState),(Se=xo||aC(h,f,Se,y,ge,be,J)||l!==null&&l.dependencies!==null&&Hy(l.dependencies))?(fe||typeof _.UNSAFE_componentWillUpdate!="function"&&typeof _.componentWillUpdate!="function"||(typeof _.componentWillUpdate=="function"&&_.componentWillUpdate(y,be,J),typeof _.UNSAFE_componentWillUpdate=="function"&&_.UNSAFE_componentWillUpdate(y,be,J)),typeof _.componentDidUpdate=="function"&&(h.flags|=4),typeof _.getSnapshotBeforeUpdate=="function"&&(h.flags|=1024)):(typeof _.componentDidUpdate!="function"||A===l.memoizedProps&&ge===l.memoizedState||(h.flags|=4),typeof _.getSnapshotBeforeUpdate!="function"||A===l.memoizedProps&&ge===l.memoizedState||(h.flags|=1024),h.memoizedProps=y,h.memoizedState=be),_.props=y,_.state=be,_.context=J,y=Se):(typeof _.componentDidUpdate!="function"||A===l.memoizedProps&&ge===l.memoizedState||(h.flags|=4),typeof _.getSnapshotBeforeUpdate!="function"||A===l.memoizedProps&&ge===l.memoizedState||(h.flags|=1024),y=!1)}return _=y,cb(l,h),y=(h.flags&128)!==0,_||y?(_=h.stateNode,f=y&&typeof f.getDerivedStateFromError!="function"?null:_.render(),h.flags|=1,l!==null&&y?(h.child=Jl(h,l.child,null,S),h.child=Jl(h,null,f,S)):Ra(l,h,f,S),h.memoizedState=_.state,l=h.child):l=Ai(l,h,S),l}function vC(l,h,f,y){return Hl(),h.flags|=256,Ra(l,h,f,y),h.child}var Vw={dehydrated:null,treeContext:null,retryLane:0,hydrationErrors:null};function Hw(l){return{baseLanes:l,cachePool:lE()}}function Gw(l,h,f){return l=l!==null?l.childLanes&~f:0,h&&(l|=Ur),l}function xC(l,h,f){var y=h.pendingProps,S=!1,_=(h.flags&128)!==0,A;if((A=_)||(A=l!==null&&l.memoizedState===null?!1:(Fn.current&2)!==0),A&&(S=!0,h.flags&=-129),A=(h.flags&32)!==0,h.flags&=-33,l===null){if(Et){if(S?ko(h):_o(),(l=fn)?(l=EA(l,us),l=l!==null&&l.data!=="&"?l:null,l!==null&&(h.memoizedState={dehydrated:l,treeContext:go!==null?{id:Xs,overflow:Ys}:null,retryLane:536870912,hydrationErrors:null},f=QT(l),f.return=h,h.child=f,Aa=h,fn=null)):l=null,l===null)throw bo(h);return E1(l)?h.lanes=32:h.lanes=536870912,null}var z=y.children;return y=y.fallback,S?(_o(),S=h.mode,z=db({mode:"hidden",children:z},S),y=Vl(y,S,f,null),z.return=h,y.return=h,z.sibling=y,h.child=z,y=h.child,y.memoizedState=Hw(f),y.childLanes=Gw(l,A,f),h.memoizedState=Vw,em(null,y)):(ko(h),qw(h,z))}var J=l.memoizedState;if(J!==null&&(z=J.dehydrated,z!==null)){if(_)h.flags&256?(ko(h),h.flags&=-257,h=Kw(l,h,f)):h.memoizedState!==null?(_o(),h.child=l.child,h.flags|=128,h=null):(_o(),z=y.fallback,S=h.mode,y=db({mode:"visible",children:y.children},S),z=Vl(z,S,f,null),z.flags|=2,y.return=h,z.return=h,y.sibling=z,h.child=y,Jl(h,l.child,null,f),y=h.child,y.memoizedState=Hw(f),y.childLanes=Gw(l,A,f),h.memoizedState=Vw,h=em(null,y));else if(ko(h),E1(z)){if(A=z.nextSibling&&z.nextSibling.dataset,A)var fe=A.dgst;A=fe,y=Error(a(419)),y.stack="",y.digest=A,jf({value:y,source:null,stack:null}),h=Kw(l,h,f)}else if(Xn||Vd(l,h,f,!1),A=(f&l.childLanes)!==0,Xn||A){if(A=on,A!==null&&(y=st(A,f),y!==0&&y!==J.retryLane))throw J.retryLane=y,Wl(l,y),Sr(A,l,y),jw;T1(z)||xb(),h=Kw(l,h,f)}else T1(z)?(h.flags|=192,h.child=l.child,h=null):(l=J.treeContext,fn=ds(z.nextSibling),Aa=h,Et=!0,yo=null,us=!1,l!==null&&nE(h,l),h=qw(h,y.children),h.flags|=4096);return h}return S?(_o(),z=y.fallback,S=h.mode,J=l.child,fe=J.sibling,y=_i(J,{mode:"hidden",children:y.children}),y.subtreeFlags=J.subtreeFlags&65011712,fe!==null?z=_i(fe,z):(z=Vl(z,S,f,null),z.flags|=2),z.return=h,y.return=h,y.sibling=z,h.child=y,em(null,y),y=h.child,z=l.child.memoizedState,z===null?z=Hw(f):(S=z.cachePool,S!==null?(J=qn._currentValue,S=S.parent!==J?{parent:J,pool:J}:S):S=lE(),z={baseLanes:z.baseLanes|f,cachePool:S}),y.memoizedState=z,y.childLanes=Gw(l,A,f),h.memoizedState=Vw,em(l.child,y)):(ko(h),f=l.child,l=f.sibling,f=_i(f,{mode:"visible",children:y.children}),f.return=h,f.sibling=null,l!==null&&(A=h.deletions,A===null?(h.deletions=[l],h.flags|=16):A.push(l)),h.child=f,h.memoizedState=null,f)}function qw(l,h){return h=db({mode:"visible",children:h},l.mode),h.return=l,l.child=h}function db(l,h){return l=zr(22,l,null,h),l.lanes=0,l}function Kw(l,h,f){return Jl(h,l.child,null,f),l=qw(h,h.pendingProps.children),l.flags|=2,h.memoizedState=null,l}function wC(l,h,f){l.lanes|=h;var y=l.alternate;y!==null&&(y.lanes|=h),uw(l.return,h,f)}function Xw(l,h,f,y,S,_){var A=l.memoizedState;A===null?l.memoizedState={isBackwards:h,rendering:null,renderingStartTime:0,last:y,tail:f,tailMode:S,treeForkCount:_}:(A.isBackwards=h,A.rendering=null,A.renderingStartTime=0,A.last=y,A.tail=f,A.tailMode=S,A.treeForkCount=_)}function SC(l,h,f){var y=h.pendingProps,S=y.revealOrder,_=y.tail;y=y.children;var A=Fn.current,z=(A&2)!==0;if(z?(A=A&1|2,h.flags|=128):A&=1,ie(Fn,A),Ra(l,h,y,f),y=Et?Uf:0,!z&&l!==null&&(l.flags&128)!==0)e:for(l=h.child;l!==null;){if(l.tag===13)l.memoizedState!==null&&wC(l,f,h);else if(l.tag===19)wC(l,f,h);else if(l.child!==null){l.child.return=l,l=l.child;continue}if(l===h)break e;for(;l.sibling===null;){if(l.return===null||l.return===h)break e;l=l.return}l.sibling.return=l.return,l=l.sibling}switch(S){case"forwards":for(f=h.child,S=null;f!==null;)l=f.alternate,l!==null&&Qy(l)===null&&(S=f),f=f.sibling;f=S,f===null?(S=h.child,h.child=null):(S=f.sibling,f.sibling=null),Xw(h,!1,S,f,_,y);break;case"backwards":case"unstable_legacy-backwards":for(f=null,S=h.child,h.child=null;S!==null;){if(l=S.alternate,l!==null&&Qy(l)===null){h.child=S;break}l=S.sibling,S.sibling=f,f=S,S=l}Xw(h,!0,f,null,_,y);break;case"together":Xw(h,!1,null,null,void 0,y);break;default:h.memoizedState=null}return h.child}function Ai(l,h,f){if(l!==null&&(h.dependencies=l.dependencies),To|=h.lanes,(f&h.childLanes)===0)if(l!==null){if(Vd(l,h,f,!1),(f&h.childLanes)===0)return null}else return null;if(l!==null&&h.child!==l.child)throw Error(a(153));if(h.child!==null){for(l=h.child,f=_i(l,l.pendingProps),h.child=f,f.return=h;l.sibling!==null;)l=l.sibling,f=f.sibling=_i(l,l.pendingProps),f.return=h;f.sibling=null}return h.child}function Yw(l,h){return(l.lanes&h)!==0?!0:(l=l.dependencies,!!(l!==null&&Hy(l)))}function NW(l,h,f){switch(h.tag){case 3:Ce(h,h.stateNode.containerInfo),vo(h,qn,l.memoizedState.cache),Hl();break;case 27:case 5:Ke(h);break;case 4:Ce(h,h.stateNode.containerInfo);break;case 10:vo(h,h.type,h.memoizedProps.value);break;case 31:if(h.memoizedState!==null)return h.flags|=128,ww(h),null;break;case 13:var y=h.memoizedState;if(y!==null)return y.dehydrated!==null?(ko(h),h.flags|=128,null):(f&h.child.childLanes)!==0?xC(l,h,f):(ko(h),l=Ai(l,h,f),l!==null?l.sibling:null);ko(h);break;case 19:var S=(l.flags&128)!==0;if(y=(f&h.childLanes)!==0,y||(Vd(l,h,f,!1),y=(f&h.childLanes)!==0),S){if(y)return SC(l,h,f);h.flags|=128}if(S=h.memoizedState,S!==null&&(S.rendering=null,S.tail=null,S.lastEffect=null),ie(Fn,Fn.current),y)break;return null;case 22:return h.lanes=0,fC(l,h,f,h.pendingProps);case 24:vo(h,qn,l.memoizedState.cache)}return Ai(l,h,f)}function kC(l,h,f){if(l!==null)if(l.memoizedProps!==h.pendingProps)Xn=!0;else{if(!Yw(l,f)&&(h.flags&128)===0)return Xn=!1,NW(l,h,f);Xn=(l.flags&131072)!==0}else Xn=!1,Et&&(h.flags&1048576)!==0&&tE(h,Uf,h.index);switch(h.lanes=0,h.tag){case 16:e:{var y=h.pendingProps;if(l=Xl(h.elementType),h.type=l,typeof l=="function")tw(l)?(y=Ql(l,y),h.tag=1,h=bC(null,h,l,y,f)):(h.tag=0,h=Ww(null,h,l,y,f));else{if(l!=null){var S=l.$$typeof;if(S===I){h.tag=11,h=dC(null,h,l,y,f);break e}else if(S===D){h.tag=14,h=hC(null,h,l,y,f);break e}}throw h=Z(l)||l,Error(a(306,h,""))}}return h;case 0:return Ww(l,h,h.type,h.pendingProps,f);case 1:return y=h.type,S=Ql(y,h.pendingProps),bC(l,h,y,S,f);case 3:e:{if(Ce(h,h.stateNode.containerInfo),l===null)throw Error(a(387));y=h.pendingProps;var _=h.memoizedState;S=_.element,gw(l,h),Xf(h,y,null,f);var A=h.memoizedState;if(y=A.cache,vo(h,qn,y),y!==_.cache&&cw(h,[qn],f,!0),Kf(),y=A.element,_.isDehydrated)if(_={element:y,isDehydrated:!1,cache:A.cache},h.updateQueue.baseState=_,h.memoizedState=_,h.flags&256){h=vC(l,h,y,f);break e}else if(y!==S){S=is(Error(a(424)),h),jf(S),h=vC(l,h,y,f);break e}else for(l=h.stateNode.containerInfo,l.nodeType===9?l=l.body:l=l.nodeName==="HTML"?l.ownerDocument.body:l,fn=ds(l.firstChild),Aa=h,Et=!0,yo=null,us=!0,f=fE(h,null,y,f),h.child=f;f;)f.flags=f.flags&-3|4096,f=f.sibling;else{if(Hl(),y===S){h=Ai(l,h,f);break e}Ra(l,h,y,f)}h=h.child}return h;case 26:return cb(l,h),l===null?(f=OA(h.type,null,h.pendingProps,null))?h.memoizedState=f:Et||(f=h.type,l=h.pendingProps,y=Tb(Ie.current).createElement(f),y[Tn]=h,y[Ft]=l,Da(y,f,l),Gn(y),h.stateNode=y):h.memoizedState=OA(h.type,l.memoizedProps,h.pendingProps,l.memoizedState),null;case 27:return Ke(h),l===null&&Et&&(y=h.stateNode=$A(h.type,h.pendingProps,Ie.current),Aa=h,us=!0,S=fn,Ro(h.type)?(C1=S,fn=ds(y.firstChild)):fn=S),Ra(l,h,h.pendingProps.children,f),cb(l,h),l===null&&(h.flags|=4194304),h.child;case 5:return l===null&&Et&&((S=y=fn)&&(y=tV(y,h.type,h.pendingProps,us),y!==null?(h.stateNode=y,Aa=h,fn=ds(y.firstChild),us=!1,S=!0):S=!1),S||bo(h)),Ke(h),S=h.type,_=h.pendingProps,A=l!==null?l.memoizedProps:null,y=_.children,_1(S,_)?y=null:A!==null&&_1(S,A)&&(h.flags|=32),h.memoizedState!==null&&(S=kw(l,h,gW,null,null,f),mm._currentValue=S),cb(l,h),Ra(l,h,y,f),h.child;case 6:return l===null&&Et&&((l=f=fn)&&(f=nV(f,h.pendingProps,us),f!==null?(h.stateNode=f,Aa=h,fn=null,l=!0):l=!1),l||bo(h)),null;case 13:return xC(l,h,f);case 4:return Ce(h,h.stateNode.containerInfo),y=h.pendingProps,l===null?h.child=Jl(h,null,y,f):Ra(l,h,y,f),h.child;case 11:return dC(l,h,h.type,h.pendingProps,f);case 7:return Ra(l,h,h.pendingProps,f),h.child;case 8:return Ra(l,h,h.pendingProps.children,f),h.child;case 12:return Ra(l,h,h.pendingProps.children,f),h.child;case 10:return y=h.pendingProps,vo(h,h.type,y.value),Ra(l,h,y.children,f),h.child;case 9:return S=h.type._context,y=h.pendingProps.children,ql(h),S=$a(S),y=y(S),h.flags|=1,Ra(l,h,y,f),h.child;case 14:return hC(l,h,h.type,h.pendingProps,f);case 15:return pC(l,h,h.type,h.pendingProps,f);case 19:return SC(l,h,f);case 31:return _W(l,h,f);case 22:return fC(l,h,f,h.pendingProps);case 24:return ql(h),y=$a(qn),l===null?(S=pw(),S===null&&(S=on,_=dw(),S.pooledCache=_,_.refCount++,_!==null&&(S.pooledCacheLanes|=f),S=_),h.memoizedState={parent:y,cache:S},mw(h),vo(h,qn,S)):((l.lanes&f)!==0&&(gw(l,h),Xf(h,null,null,f),Kf()),S=l.memoizedState,_=h.memoizedState,S.parent!==y?(S={parent:y,cache:y},h.memoizedState=S,h.lanes===0&&(h.memoizedState=h.updateQueue.baseState=S),vo(h,qn,y)):(y=_.cache,vo(h,qn,y),y!==S.cache&&cw(h,[qn],f,!0))),Ra(l,h,h.pendingProps.children,f),h.child;case 29:throw h.pendingProps}throw Error(a(156,h.tag))}function $i(l){l.flags|=4}function Jw(l,h,f,y,S){if((h=(l.mode&32)!==0)&&(h=!1),h){if(l.flags|=16777216,(S&335544128)===S)if(l.stateNode.complete)l.flags|=8192;else if(YC())l.flags|=8192;else throw Yl=Xy,fw}else l.flags&=-16777217}function _C(l,h){if(h.type!=="stylesheet"||(h.state.loading&4)!==0)l.flags&=-16777217;else if(l.flags|=16777216,!BA(h))if(YC())l.flags|=8192;else throw Yl=Xy,fw}function hb(l,h){h!==null&&(l.flags|=4),l.flags&16384&&(h=l.tag!==22?Ae():536870912,l.lanes|=h,nh|=h)}function tm(l,h){if(!Et)switch(l.tailMode){case"hidden":h=l.tail;for(var f=null;h!==null;)h.alternate!==null&&(f=h),h=h.sibling;f===null?l.tail=null:f.sibling=null;break;case"collapsed":f=l.tail;for(var y=null;f!==null;)f.alternate!==null&&(y=f),f=f.sibling;y===null?h||l.tail===null?l.tail=null:l.tail.sibling=null:y.sibling=null}}function mn(l){var h=l.alternate!==null&&l.alternate.child===l.child,f=0,y=0;if(h)for(var S=l.child;S!==null;)f|=S.lanes|S.childLanes,y|=S.subtreeFlags&65011712,y|=S.flags&65011712,S.return=l,S=S.sibling;else for(S=l.child;S!==null;)f|=S.lanes|S.childLanes,y|=S.subtreeFlags,y|=S.flags,S.return=l,S=S.sibling;return l.subtreeFlags|=y,l.childLanes=f,h}function IW(l,h,f){var y=h.pendingProps;switch(sw(h),h.tag){case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return mn(h),null;case 1:return mn(h),null;case 3:return f=h.stateNode,y=null,l!==null&&(y=l.memoizedState.cache),h.memoizedState.cache!==y&&(h.flags|=2048),Ti(qn),ze(),f.pendingContext&&(f.context=f.pendingContext,f.pendingContext=null),(l===null||l.child===null)&&(Wd(h)?$i(h):l===null||l.memoizedState.isDehydrated&&(h.flags&256)===0||(h.flags|=1024,ow())),mn(h),null;case 26:var S=h.type,_=h.memoizedState;return l===null?($i(h),_!==null?(mn(h),_C(h,_)):(mn(h),Jw(h,S,null,y,f))):_?_!==l.memoizedState?($i(h),mn(h),_C(h,_)):(mn(h),h.flags&=-16777217):(l=l.memoizedProps,l!==y&&$i(h),mn(h),Jw(h,S,l,y,f)),null;case 27:if(at(h),f=Ie.current,S=h.type,l!==null&&h.stateNode!=null)l.memoizedProps!==y&&$i(h);else{if(!y){if(h.stateNode===null)throw Error(a(166));return mn(h),null}l=de.current,Wd(h)?aE(h):(l=$A(S,y,f),h.stateNode=l,$i(h))}return mn(h),null;case 5:if(at(h),S=h.type,l!==null&&h.stateNode!=null)l.memoizedProps!==y&&$i(h);else{if(!y){if(h.stateNode===null)throw Error(a(166));return mn(h),null}if(_=de.current,Wd(h))aE(h);else{var A=Tb(Ie.current);switch(_){case 1:_=A.createElementNS("http://www.w3.org/2000/svg",S);break;case 2:_=A.createElementNS("http://www.w3.org/1998/Math/MathML",S);break;default:switch(S){case"svg":_=A.createElementNS("http://www.w3.org/2000/svg",S);break;case"math":_=A.createElementNS("http://www.w3.org/1998/Math/MathML",S);break;case"script":_=A.createElement("div"),_.innerHTML="<script><\/script>",_=_.removeChild(_.firstChild);break;case"select":_=typeof y.is=="string"?A.createElement("select",{is:y.is}):A.createElement("select"),y.multiple?_.multiple=!0:y.size&&(_.size=y.size);break;default:_=typeof y.is=="string"?A.createElement(S,{is:y.is}):A.createElement(S)}}_[Tn]=h,_[Ft]=y;e:for(A=h.child;A!==null;){if(A.tag===5||A.tag===6)_.appendChild(A.stateNode);else if(A.tag!==4&&A.tag!==27&&A.child!==null){A.child.return=A,A=A.child;continue}if(A===h)break e;for(;A.sibling===null;){if(A.return===null||A.return===h)break e;A=A.return}A.sibling.return=A.return,A=A.sibling}h.stateNode=_;e:switch(Da(_,S,y),S){case"button":case"input":case"select":case"textarea":y=!!y.autoFocus;break e;case"img":y=!0;break e;default:y=!1}y&&$i(h)}}return mn(h),Jw(h,h.type,l===null?null:l.memoizedProps,h.pendingProps,f),null;case 6:if(l&&h.stateNode!=null)l.memoizedProps!==y&&$i(h);else{if(typeof y!="string"&&h.stateNode===null)throw Error(a(166));if(l=Ie.current,Wd(h)){if(l=h.stateNode,f=h.memoizedProps,y=null,S=Aa,S!==null)switch(S.tag){case 27:case 5:y=S.memoizedProps}l[Tn]=h,l=!!(l.nodeValue===f||y!==null&&y.suppressHydrationWarning===!0||xA(l.nodeValue,f)),l||bo(h,!0)}else l=Tb(l).createTextNode(y),l[Tn]=h,h.stateNode=l}return mn(h),null;case 31:if(f=h.memoizedState,l===null||l.memoizedState!==null){if(y=Wd(h),f!==null){if(l===null){if(!y)throw Error(a(318));if(l=h.memoizedState,l=l!==null?l.dehydrated:null,!l)throw Error(a(557));l[Tn]=h}else Hl(),(h.flags&128)===0&&(h.memoizedState=null),h.flags|=4;mn(h),l=!1}else f=ow(),l!==null&&l.memoizedState!==null&&(l.memoizedState.hydrationErrors=f),l=!0;if(!l)return h.flags&256?(Br(h),h):(Br(h),null);if((h.flags&128)!==0)throw Error(a(558))}return mn(h),null;case 13:if(y=h.memoizedState,l===null||l.memoizedState!==null&&l.memoizedState.dehydrated!==null){if(S=Wd(h),y!==null&&y.dehydrated!==null){if(l===null){if(!S)throw Error(a(318));if(S=h.memoizedState,S=S!==null?S.dehydrated:null,!S)throw Error(a(317));S[Tn]=h}else Hl(),(h.flags&128)===0&&(h.memoizedState=null),h.flags|=4;mn(h),S=!1}else S=ow(),l!==null&&l.memoizedState!==null&&(l.memoizedState.hydrationErrors=S),S=!0;if(!S)return h.flags&256?(Br(h),h):(Br(h),null)}return Br(h),(h.flags&128)!==0?(h.lanes=f,h):(f=y!==null,l=l!==null&&l.memoizedState!==null,f&&(y=h.child,S=null,y.alternate!==null&&y.alternate.memoizedState!==null&&y.alternate.memoizedState.cachePool!==null&&(S=y.alternate.memoizedState.cachePool.pool),_=null,y.memoizedState!==null&&y.memoizedState.cachePool!==null&&(_=y.memoizedState.cachePool.pool),_!==S&&(y.flags|=2048)),f!==l&&f&&(h.child.flags|=8192),hb(h,h.updateQueue),mn(h),null);case 4:return ze(),l===null&&v1(h.stateNode.containerInfo),mn(h),null;case 10:return Ti(h.type),mn(h),null;case 19:if(ee(Fn),y=h.memoizedState,y===null)return mn(h),null;if(S=(h.flags&128)!==0,_=y.rendering,_===null)if(S)tm(y,!1);else{if(An!==0||l!==null&&(l.flags&128)!==0)for(l=h.child;l!==null;){if(_=Qy(l),_!==null){for(h.flags|=128,tm(y,!1),l=_.updateQueue,h.updateQueue=l,hb(h,l),h.subtreeFlags=0,l=f,f=h.child;f!==null;)ZT(f,l),f=f.sibling;return ie(Fn,Fn.current&1|2),Et&&Ni(h,y.treeForkCount),h.child}l=l.sibling}y.tail!==null&&dn()>yb&&(h.flags|=128,S=!0,tm(y,!1),h.lanes=4194304)}else{if(!S)if(l=Qy(_),l!==null){if(h.flags|=128,S=!0,l=l.updateQueue,h.updateQueue=l,hb(h,l),tm(y,!0),y.tail===null&&y.tailMode==="hidden"&&!_.alternate&&!Et)return mn(h),null}else 2*dn()-y.renderingStartTime>yb&&f!==536870912&&(h.flags|=128,S=!0,tm(y,!1),h.lanes=4194304);y.isBackwards?(_.sibling=h.child,h.child=_):(l=y.last,l!==null?l.sibling=_:h.child=_,y.last=_)}return y.tail!==null?(l=y.tail,y.rendering=l,y.tail=l.sibling,y.renderingStartTime=dn(),l.sibling=null,f=Fn.current,ie(Fn,S?f&1|2:f&1),Et&&Ni(h,y.treeForkCount),l):(mn(h),null);case 22:case 23:return Br(h),xw(),y=h.memoizedState!==null,l!==null?l.memoizedState!==null!==y&&(h.flags|=8192):y&&(h.flags|=8192),y?(f&536870912)!==0&&(h.flags&128)===0&&(mn(h),h.subtreeFlags&6&&(h.flags|=8192)):mn(h),f=h.updateQueue,f!==null&&hb(h,f.retryQueue),f=null,l!==null&&l.memoizedState!==null&&l.memoizedState.cachePool!==null&&(f=l.memoizedState.cachePool.pool),y=null,h.memoizedState!==null&&h.memoizedState.cachePool!==null&&(y=h.memoizedState.cachePool.pool),y!==f&&(h.flags|=2048),l!==null&&ee(Kl),null;case 24:return f=null,l!==null&&(f=l.memoizedState.cache),h.memoizedState.cache!==f&&(h.flags|=2048),Ti(qn),mn(h),null;case 25:return null;case 30:return null}throw Error(a(156,h.tag))}function TW(l,h){switch(sw(h),h.tag){case 1:return l=h.flags,l&65536?(h.flags=l&-65537|128,h):null;case 3:return Ti(qn),ze(),l=h.flags,(l&65536)!==0&&(l&128)===0?(h.flags=l&-65537|128,h):null;case 26:case 27:case 5:return at(h),null;case 31:if(h.memoizedState!==null){if(Br(h),h.alternate===null)throw Error(a(340));Hl()}return l=h.flags,l&65536?(h.flags=l&-65537|128,h):null;case 13:if(Br(h),l=h.memoizedState,l!==null&&l.dehydrated!==null){if(h.alternate===null)throw Error(a(340));Hl()}return l=h.flags,l&65536?(h.flags=l&-65537|128,h):null;case 19:return ee(Fn),null;case 4:return ze(),null;case 10:return Ti(h.type),null;case 22:case 23:return Br(h),xw(),l!==null&&ee(Kl),l=h.flags,l&65536?(h.flags=l&-65537|128,h):null;case 24:return Ti(qn),null;case 25:return null;default:return null}}function NC(l,h){switch(sw(h),h.tag){case 3:Ti(qn),ze();break;case 26:case 27:case 5:at(h);break;case 4:ze();break;case 31:h.memoizedState!==null&&Br(h);break;case 13:Br(h);break;case 19:ee(Fn);break;case 10:Ti(h.type);break;case 22:case 23:Br(h),xw(),l!==null&&ee(Kl);break;case 24:Ti(qn)}}function nm(l,h){try{var f=h.updateQueue,y=f!==null?f.lastEffect:null;if(y!==null){var S=y.next;f=S;do{if((f.tag&l)===l){y=void 0;var _=f.create,A=f.inst;y=_(),A.destroy=y}f=f.next}while(f!==S)}}catch(z){qt(h,h.return,z)}}function No(l,h,f){try{var y=h.updateQueue,S=y!==null?y.lastEffect:null;if(S!==null){var _=S.next;y=_;do{if((y.tag&l)===l){var A=y.inst,z=A.destroy;if(z!==void 0){A.destroy=void 0,S=h;var J=f,fe=z;try{fe()}catch(Se){qt(S,J,Se)}}}y=y.next}while(y!==_)}}catch(Se){qt(h,h.return,Se)}}function IC(l){var h=l.updateQueue;if(h!==null){var f=l.stateNode;try{gE(h,f)}catch(y){qt(l,l.return,y)}}}function TC(l,h,f){f.props=Ql(l.type,l.memoizedProps),f.state=l.memoizedState;try{f.componentWillUnmount()}catch(y){qt(l,h,y)}}function am(l,h){try{var f=l.ref;if(f!==null){switch(l.tag){case 26:case 27:case 5:var y=l.stateNode;break;case 30:y=l.stateNode;break;default:y=l.stateNode}typeof f=="function"?l.refCleanup=f(y):f.current=y}}catch(S){qt(l,h,S)}}function Js(l,h){var f=l.ref,y=l.refCleanup;if(f!==null)if(typeof y=="function")try{y()}catch(S){qt(l,h,S)}finally{l.refCleanup=null,l=l.alternate,l!=null&&(l.refCleanup=null)}else if(typeof f=="function")try{f(null)}catch(S){qt(l,h,S)}else f.current=null}function EC(l){var h=l.type,f=l.memoizedProps,y=l.stateNode;try{e:switch(h){case"button":case"input":case"select":case"textarea":f.autoFocus&&y.focus();break e;case"img":f.src?y.src=f.src:f.srcSet&&(y.srcset=f.srcSet)}}catch(S){qt(l,l.return,S)}}function Zw(l,h,f){try{var y=l.stateNode;XW(y,l.type,f,h),y[Ft]=h}catch(S){qt(l,l.return,S)}}function CC(l){return l.tag===5||l.tag===3||l.tag===26||l.tag===27&&Ro(l.type)||l.tag===4}function Qw(l){e:for(;;){for(;l.sibling===null;){if(l.return===null||CC(l.return))return null;l=l.return}for(l.sibling.return=l.return,l=l.sibling;l.tag!==5&&l.tag!==6&&l.tag!==18;){if(l.tag===27&&Ro(l.type)||l.flags&2||l.child===null||l.tag===4)continue e;l.child.return=l,l=l.child}if(!(l.flags&2))return l.stateNode}}function e1(l,h,f){var y=l.tag;if(y===5||y===6)l=l.stateNode,h?(f.nodeType===9?f.body:f.nodeName==="HTML"?f.ownerDocument.body:f).insertBefore(l,h):(h=f.nodeType===9?f.body:f.nodeName==="HTML"?f.ownerDocument.body:f,h.appendChild(l),f=f._reactRootContainer,f!=null||h.onclick!==null||(h.onclick=yr));else if(y!==4&&(y===27&&Ro(l.type)&&(f=l.stateNode,h=null),l=l.child,l!==null))for(e1(l,h,f),l=l.sibling;l!==null;)e1(l,h,f),l=l.sibling}function pb(l,h,f){var y=l.tag;if(y===5||y===6)l=l.stateNode,h?f.insertBefore(l,h):f.appendChild(l);else if(y!==4&&(y===27&&Ro(l.type)&&(f=l.stateNode),l=l.child,l!==null))for(pb(l,h,f),l=l.sibling;l!==null;)pb(l,h,f),l=l.sibling}function AC(l){var h=l.stateNode,f=l.memoizedProps;try{for(var y=l.type,S=h.attributes;S.length;)h.removeAttributeNode(S[0]);Da(h,y,f),h[Tn]=l,h[Ft]=f}catch(_){qt(l,l.return,_)}}var Ri=!1,Yn=!1,t1=!1,$C=typeof WeakSet=="function"?WeakSet:Set,Sa=null;function EW(l,h){if(l=l.containerInfo,S1=Ob,l=WT(l),Kx(l)){if("selectionStart"in l)var f={start:l.selectionStart,end:l.selectionEnd};else e:{f=(f=l.ownerDocument)&&f.defaultView||window;var y=f.getSelection&&f.getSelection();if(y&&y.rangeCount!==0){f=y.anchorNode;var S=y.anchorOffset,_=y.focusNode;y=y.focusOffset;try{f.nodeType,_.nodeType}catch{f=null;break e}var A=0,z=-1,J=-1,fe=0,Se=0,Ne=l,ge=null;t:for(;;){for(var be;Ne!==f||S!==0&&Ne.nodeType!==3||(z=A+S),Ne!==_||y!==0&&Ne.nodeType!==3||(J=A+y),Ne.nodeType===3&&(A+=Ne.nodeValue.length),(be=Ne.firstChild)!==null;)ge=Ne,Ne=be;for(;;){if(Ne===l)break t;if(ge===f&&++fe===S&&(z=A),ge===_&&++Se===y&&(J=A),(be=Ne.nextSibling)!==null)break;Ne=ge,ge=Ne.parentNode}Ne=be}f=z===-1||J===-1?null:{start:z,end:J}}else f=null}f=f||{start:0,end:0}}else f=null;for(k1={focusedElem:l,selectionRange:f},Ob=!1,Sa=h;Sa!==null;)if(h=Sa,l=h.child,(h.subtreeFlags&1028)!==0&&l!==null)l.return=h,Sa=l;else for(;Sa!==null;){switch(h=Sa,_=h.alternate,l=h.flags,h.tag){case 0:if((l&4)!==0&&(l=h.updateQueue,l=l!==null?l.events:null,l!==null))for(f=0;f<l.length;f++)S=l[f],S.ref.impl=S.nextImpl;break;case 11:case 15:break;case 1:if((l&1024)!==0&&_!==null){l=void 0,f=h,S=_.memoizedProps,_=_.memoizedState,y=f.stateNode;try{var Pe=Ql(f.type,S);l=y.getSnapshotBeforeUpdate(Pe,_),y.__reactInternalSnapshotBeforeUpdate=l}catch(Je){qt(f,f.return,Je)}}break;case 3:if((l&1024)!==0){if(l=h.stateNode.containerInfo,f=l.nodeType,f===9)I1(l);else if(f===1)switch(l.nodeName){case"HEAD":case"HTML":case"BODY":I1(l);break;default:l.textContent=""}}break;case 5:case 26:case 27:case 6:case 4:case 17:break;default:if((l&1024)!==0)throw Error(a(163))}if(l=h.sibling,l!==null){l.return=h.return,Sa=l;break}Sa=h.return}}function RC(l,h,f){var y=f.flags;switch(f.tag){case 0:case 11:case 15:Oi(l,f),y&4&&nm(5,f);break;case 1:if(Oi(l,f),y&4)if(l=f.stateNode,h===null)try{l.componentDidMount()}catch(A){qt(f,f.return,A)}else{var S=Ql(f.type,h.memoizedProps);h=h.memoizedState;try{l.componentDidUpdate(S,h,l.__reactInternalSnapshotBeforeUpdate)}catch(A){qt(f,f.return,A)}}y&64&&IC(f),y&512&&am(f,f.return);break;case 3:if(Oi(l,f),y&64&&(l=f.updateQueue,l!==null)){if(h=null,f.child!==null)switch(f.child.tag){case 27:case 5:h=f.child.stateNode;break;case 1:h=f.child.stateNode}try{gE(l,h)}catch(A){qt(f,f.return,A)}}break;case 27:h===null&&y&4&&AC(f);case 26:case 5:Oi(l,f),h===null&&y&4&&EC(f),y&512&&am(f,f.return);break;case 12:Oi(l,f);break;case 31:Oi(l,f),y&4&&MC(l,f);break;case 13:Oi(l,f),y&4&&FC(l,f),y&64&&(l=f.memoizedState,l!==null&&(l=l.dehydrated,l!==null&&(f=zW.bind(null,f),aV(l,f))));break;case 22:if(y=f.memoizedState!==null||Ri,!y){h=h!==null&&h.memoizedState!==null||Yn,S=Ri;var _=Yn;Ri=y,(Yn=h)&&!_?Mi(l,f,(f.subtreeFlags&8772)!==0):Oi(l,f),Ri=S,Yn=_}break;case 30:break;default:Oi(l,f)}}function DC(l){var h=l.alternate;h!==null&&(l.alternate=null,DC(h)),l.child=null,l.deletions=null,l.sibling=null,l.tag===5&&(h=l.stateNode,h!==null&&If(h)),l.stateNode=null,l.return=null,l.dependencies=null,l.memoizedProps=null,l.memoizedState=null,l.pendingProps=null,l.stateNode=null,l.updateQueue=null}var bn=null,br=!1;function Di(l,h,f){for(f=f.child;f!==null;)OC(l,h,f),f=f.sibling}function OC(l,h,f){if(In&&typeof In.onCommitFiberUnmount=="function")try{In.onCommitFiberUnmount(ja,f)}catch{}switch(f.tag){case 26:Yn||Js(f,h),Di(l,h,f),f.memoizedState?f.memoizedState.count--:f.stateNode&&(f=f.stateNode,f.parentNode.removeChild(f));break;case 27:Yn||Js(f,h);var y=bn,S=br;Ro(f.type)&&(bn=f.stateNode,br=!1),Di(l,h,f),hm(f.stateNode),bn=y,br=S;break;case 5:Yn||Js(f,h);case 6:if(y=bn,S=br,bn=null,Di(l,h,f),bn=y,br=S,bn!==null)if(br)try{(bn.nodeType===9?bn.body:bn.nodeName==="HTML"?bn.ownerDocument.body:bn).removeChild(f.stateNode)}catch(_){qt(f,h,_)}else try{bn.removeChild(f.stateNode)}catch(_){qt(f,h,_)}break;case 18:bn!==null&&(br?(l=bn,IA(l.nodeType===9?l.body:l.nodeName==="HTML"?l.ownerDocument.body:l,f.stateNode),ch(l)):IA(bn,f.stateNode));break;case 4:y=bn,S=br,bn=f.stateNode.containerInfo,br=!0,Di(l,h,f),bn=y,br=S;break;case 0:case 11:case 14:case 15:No(2,f,h),Yn||No(4,f,h),Di(l,h,f);break;case 1:Yn||(Js(f,h),y=f.stateNode,typeof y.componentWillUnmount=="function"&&TC(f,h,y)),Di(l,h,f);break;case 21:Di(l,h,f);break;case 22:Yn=(y=Yn)||f.memoizedState!==null,Di(l,h,f),Yn=y;break;default:Di(l,h,f)}}function MC(l,h){if(h.memoizedState===null&&(l=h.alternate,l!==null&&(l=l.memoizedState,l!==null))){l=l.dehydrated;try{ch(l)}catch(f){qt(h,h.return,f)}}}function FC(l,h){if(h.memoizedState===null&&(l=h.alternate,l!==null&&(l=l.memoizedState,l!==null&&(l=l.dehydrated,l!==null))))try{ch(l)}catch(f){qt(h,h.return,f)}}function CW(l){switch(l.tag){case 31:case 13:case 19:var h=l.stateNode;return h===null&&(h=l.stateNode=new $C),h;case 22:return l=l.stateNode,h=l._retryCache,h===null&&(h=l._retryCache=new $C),h;default:throw Error(a(435,l.tag))}}function fb(l,h){var f=CW(l);h.forEach(function(y){if(!f.has(y)){f.add(y);var S=LW.bind(null,l,y);y.then(S,S)}})}function vr(l,h){var f=h.deletions;if(f!==null)for(var y=0;y<f.length;y++){var S=f[y],_=l,A=h,z=A;e:for(;z!==null;){switch(z.tag){case 27:if(Ro(z.type)){bn=z.stateNode,br=!1;break e}break;case 5:bn=z.stateNode,br=!1;break e;case 3:case 4:bn=z.stateNode.containerInfo,br=!0;break e}z=z.return}if(bn===null)throw Error(a(160));OC(_,A,S),bn=null,br=!1,_=S.alternate,_!==null&&(_.return=null),S.return=null}if(h.subtreeFlags&13886)for(h=h.child;h!==null;)zC(h,l),h=h.sibling}var Ts=null;function zC(l,h){var f=l.alternate,y=l.flags;switch(l.tag){case 0:case 11:case 14:case 15:vr(h,l),xr(l),y&4&&(No(3,l,l.return),nm(3,l),No(5,l,l.return));break;case 1:vr(h,l),xr(l),y&512&&(Yn||f===null||Js(f,f.return)),y&64&&Ri&&(l=l.updateQueue,l!==null&&(y=l.callbacks,y!==null&&(f=l.shared.hiddenCallbacks,l.shared.hiddenCallbacks=f===null?y:f.concat(y))));break;case 26:var S=Ts;if(vr(h,l),xr(l),y&512&&(Yn||f===null||Js(f,f.return)),y&4){var _=f!==null?f.memoizedState:null;if(y=l.memoizedState,f===null)if(y===null)if(l.stateNode===null){e:{y=l.type,f=l.memoizedProps,S=S.ownerDocument||S;t:switch(y){case"title":_=S.getElementsByTagName("title")[0],(!_||_[Fl]||_[Tn]||_.namespaceURI==="http://www.w3.org/2000/svg"||_.hasAttribute("itemprop"))&&(_=S.createElement(y),S.head.insertBefore(_,S.querySelector("head > title"))),Da(_,y,f),_[Tn]=l,Gn(_),y=_;break e;case"link":var A=zA("link","href",S).get(y+(f.href||""));if(A){for(var z=0;z<A.length;z++)if(_=A[z],_.getAttribute("href")===(f.href==null||f.href===""?null:f.href)&&_.getAttribute("rel")===(f.rel==null?null:f.rel)&&_.getAttribute("title")===(f.title==null?null:f.title)&&_.getAttribute("crossorigin")===(f.crossOrigin==null?null:f.crossOrigin)){A.splice(z,1);break t}}_=S.createElement(y),Da(_,y,f),S.head.appendChild(_);break;case"meta":if(A=zA("meta","content",S).get(y+(f.content||""))){for(z=0;z<A.length;z++)if(_=A[z],_.getAttribute("content")===(f.content==null?null:""+f.content)&&_.getAttribute("name")===(f.name==null?null:f.name)&&_.getAttribute("property")===(f.property==null?null:f.property)&&_.getAttribute("http-equiv")===(f.httpEquiv==null?null:f.httpEquiv)&&_.getAttribute("charset")===(f.charSet==null?null:f.charSet)){A.splice(z,1);break t}}_=S.createElement(y),Da(_,y,f),S.head.appendChild(_);break;default:throw Error(a(468,y))}_[Tn]=l,Gn(_),y=_}l.stateNode=y}else LA(S,l.type,l.stateNode);else l.stateNode=FA(S,y,l.memoizedProps);else _!==y?(_===null?f.stateNode!==null&&(f=f.stateNode,f.parentNode.removeChild(f)):_.count--,y===null?LA(S,l.type,l.stateNode):FA(S,y,l.memoizedProps)):y===null&&l.stateNode!==null&&Zw(l,l.memoizedProps,f.memoizedProps)}break;case 27:vr(h,l),xr(l),y&512&&(Yn||f===null||Js(f,f.return)),f!==null&&y&4&&Zw(l,l.memoizedProps,f.memoizedProps);break;case 5:if(vr(h,l),xr(l),y&512&&(Yn||f===null||Js(f,f.return)),l.flags&32){S=l.stateNode;try{Ks(S,"")}catch(Pe){qt(l,l.return,Pe)}}y&4&&l.stateNode!=null&&(S=l.memoizedProps,Zw(l,S,f!==null?f.memoizedProps:S)),y&1024&&(t1=!0);break;case 6:if(vr(h,l),xr(l),y&4){if(l.stateNode===null)throw Error(a(162));y=l.memoizedProps,f=l.stateNode;try{f.nodeValue=y}catch(Pe){qt(l,l.return,Pe)}}break;case 3:if(Ab=null,S=Ts,Ts=Eb(h.containerInfo),vr(h,l),Ts=S,xr(l),y&4&&f!==null&&f.memoizedState.isDehydrated)try{ch(h.containerInfo)}catch(Pe){qt(l,l.return,Pe)}t1&&(t1=!1,LC(l));break;case 4:y=Ts,Ts=Eb(l.stateNode.containerInfo),vr(h,l),xr(l),Ts=y;break;case 12:vr(h,l),xr(l);break;case 31:vr(h,l),xr(l),y&4&&(y=l.updateQueue,y!==null&&(l.updateQueue=null,fb(l,y)));break;case 13:vr(h,l),xr(l),l.child.flags&8192&&l.memoizedState!==null!=(f!==null&&f.memoizedState!==null)&&(gb=dn()),y&4&&(y=l.updateQueue,y!==null&&(l.updateQueue=null,fb(l,y)));break;case 22:S=l.memoizedState!==null;var J=f!==null&&f.memoizedState!==null,fe=Ri,Se=Yn;if(Ri=fe||S,Yn=Se||J,vr(h,l),Yn=Se,Ri=fe,xr(l),y&8192)e:for(h=l.stateNode,h._visibility=S?h._visibility&-2:h._visibility|1,S&&(f===null||J||Ri||Yn||eu(l)),f=null,h=l;;){if(h.tag===5||h.tag===26){if(f===null){J=f=h;try{if(_=J.stateNode,S)A=_.style,typeof A.setProperty=="function"?A.setProperty("display","none","important"):A.display="none";else{z=J.stateNode;var Ne=J.memoizedProps.style,ge=Ne!=null&&Ne.hasOwnProperty("display")?Ne.display:null;z.style.display=ge==null||typeof ge=="boolean"?"":(""+ge).trim()}}catch(Pe){qt(J,J.return,Pe)}}}else if(h.tag===6){if(f===null){J=h;try{J.stateNode.nodeValue=S?"":J.memoizedProps}catch(Pe){qt(J,J.return,Pe)}}}else if(h.tag===18){if(f===null){J=h;try{var be=J.stateNode;S?TA(be,!0):TA(J.stateNode,!1)}catch(Pe){qt(J,J.return,Pe)}}}else if((h.tag!==22&&h.tag!==23||h.memoizedState===null||h===l)&&h.child!==null){h.child.return=h,h=h.child;continue}if(h===l)break e;for(;h.sibling===null;){if(h.return===null||h.return===l)break e;f===h&&(f=null),h=h.return}f===h&&(f=null),h.sibling.return=h.return,h=h.sibling}y&4&&(y=l.updateQueue,y!==null&&(f=y.retryQueue,f!==null&&(y.retryQueue=null,fb(l,f))));break;case 19:vr(h,l),xr(l),y&4&&(y=l.updateQueue,y!==null&&(l.updateQueue=null,fb(l,y)));break;case 30:break;case 21:break;default:vr(h,l),xr(l)}}function xr(l){var h=l.flags;if(h&2){try{for(var f,y=l.return;y!==null;){if(CC(y)){f=y;break}y=y.return}if(f==null)throw Error(a(160));switch(f.tag){case 27:var S=f.stateNode,_=Qw(l);pb(l,_,S);break;case 5:var A=f.stateNode;f.flags&32&&(Ks(A,""),f.flags&=-33);var z=Qw(l);pb(l,z,A);break;case 3:case 4:var J=f.stateNode.containerInfo,fe=Qw(l);e1(l,fe,J);break;default:throw Error(a(161))}}catch(Se){qt(l,l.return,Se)}l.flags&=-3}h&4096&&(l.flags&=-4097)}function LC(l){if(l.subtreeFlags&1024)for(l=l.child;l!==null;){var h=l;LC(h),h.tag===5&&h.flags&1024&&h.stateNode.reset(),l=l.sibling}}function Oi(l,h){if(h.subtreeFlags&8772)for(h=h.child;h!==null;)RC(l,h.alternate,h),h=h.sibling}function eu(l){for(l=l.child;l!==null;){var h=l;switch(h.tag){case 0:case 11:case 14:case 15:No(4,h,h.return),eu(h);break;case 1:Js(h,h.return);var f=h.stateNode;typeof f.componentWillUnmount=="function"&&TC(h,h.return,f),eu(h);break;case 27:hm(h.stateNode);case 26:case 5:Js(h,h.return),eu(h);break;case 22:h.memoizedState===null&&eu(h);break;case 30:eu(h);break;default:eu(h)}l=l.sibling}}function Mi(l,h,f){for(f=f&&(h.subtreeFlags&8772)!==0,h=h.child;h!==null;){var y=h.alternate,S=l,_=h,A=_.flags;switch(_.tag){case 0:case 11:case 15:Mi(S,_,f),nm(4,_);break;case 1:if(Mi(S,_,f),y=_,S=y.stateNode,typeof S.componentDidMount=="function")try{S.componentDidMount()}catch(fe){qt(y,y.return,fe)}if(y=_,S=y.updateQueue,S!==null){var z=y.stateNode;try{var J=S.shared.hiddenCallbacks;if(J!==null)for(S.shared.hiddenCallbacks=null,S=0;S<J.length;S++)mE(J[S],z)}catch(fe){qt(y,y.return,fe)}}f&&A&64&&IC(_),am(_,_.return);break;case 27:AC(_);case 26:case 5:Mi(S,_,f),f&&y===null&&A&4&&EC(_),am(_,_.return);break;case 12:Mi(S,_,f);break;case 31:Mi(S,_,f),f&&A&4&&MC(S,_);break;case 13:Mi(S,_,f),f&&A&4&&FC(S,_);break;case 22:_.memoizedState===null&&Mi(S,_,f),am(_,_.return);break;case 30:break;default:Mi(S,_,f)}h=h.sibling}}function n1(l,h){var f=null;l!==null&&l.memoizedState!==null&&l.memoizedState.cachePool!==null&&(f=l.memoizedState.cachePool.pool),l=null,h.memoizedState!==null&&h.memoizedState.cachePool!==null&&(l=h.memoizedState.cachePool.pool),l!==f&&(l!=null&&l.refCount++,f!=null&&Wf(f))}function a1(l,h){l=null,h.alternate!==null&&(l=h.alternate.memoizedState.cache),h=h.memoizedState.cache,h!==l&&(h.refCount++,l!=null&&Wf(l))}function Es(l,h,f,y){if(h.subtreeFlags&10256)for(h=h.child;h!==null;)BC(l,h,f,y),h=h.sibling}function BC(l,h,f,y){var S=h.flags;switch(h.tag){case 0:case 11:case 15:Es(l,h,f,y),S&2048&&nm(9,h);break;case 1:Es(l,h,f,y);break;case 3:Es(l,h,f,y),S&2048&&(l=null,h.alternate!==null&&(l=h.alternate.memoizedState.cache),h=h.memoizedState.cache,h!==l&&(h.refCount++,l!=null&&Wf(l)));break;case 12:if(S&2048){Es(l,h,f,y),l=h.stateNode;try{var _=h.memoizedProps,A=_.id,z=_.onPostCommit;typeof z=="function"&&z(A,h.alternate===null?"mount":"update",l.passiveEffectDuration,-0)}catch(J){qt(h,h.return,J)}}else Es(l,h,f,y);break;case 31:Es(l,h,f,y);break;case 13:Es(l,h,f,y);break;case 23:break;case 22:_=h.stateNode,A=h.alternate,h.memoizedState!==null?_._visibility&2?Es(l,h,f,y):rm(l,h):_._visibility&2?Es(l,h,f,y):(_._visibility|=2,Qd(l,h,f,y,(h.subtreeFlags&10256)!==0||!1)),S&2048&&n1(A,h);break;case 24:Es(l,h,f,y),S&2048&&a1(h.alternate,h);break;default:Es(l,h,f,y)}}function Qd(l,h,f,y,S){for(S=S&&((h.subtreeFlags&10256)!==0||!1),h=h.child;h!==null;){var _=l,A=h,z=f,J=y,fe=A.flags;switch(A.tag){case 0:case 11:case 15:Qd(_,A,z,J,S),nm(8,A);break;case 23:break;case 22:var Se=A.stateNode;A.memoizedState!==null?Se._visibility&2?Qd(_,A,z,J,S):rm(_,A):(Se._visibility|=2,Qd(_,A,z,J,S)),S&&fe&2048&&n1(A.alternate,A);break;case 24:Qd(_,A,z,J,S),S&&fe&2048&&a1(A.alternate,A);break;default:Qd(_,A,z,J,S)}h=h.sibling}}function rm(l,h){if(h.subtreeFlags&10256)for(h=h.child;h!==null;){var f=l,y=h,S=y.flags;switch(y.tag){case 22:rm(f,y),S&2048&&n1(y.alternate,y);break;case 24:rm(f,y),S&2048&&a1(y.alternate,y);break;default:rm(f,y)}h=h.sibling}}var sm=8192;function eh(l,h,f){if(l.subtreeFlags&sm)for(l=l.child;l!==null;)PC(l,h,f),l=l.sibling}function PC(l,h,f){switch(l.tag){case 26:eh(l,h,f),l.flags&sm&&l.memoizedState!==null&&mV(f,Ts,l.memoizedState,l.memoizedProps);break;case 5:eh(l,h,f);break;case 3:case 4:var y=Ts;Ts=Eb(l.stateNode.containerInfo),eh(l,h,f),Ts=y;break;case 22:l.memoizedState===null&&(y=l.alternate,y!==null&&y.memoizedState!==null?(y=sm,sm=16777216,eh(l,h,f),sm=y):eh(l,h,f));break;default:eh(l,h,f)}}function UC(l){var h=l.alternate;if(h!==null&&(l=h.child,l!==null)){h.child=null;do h=l.sibling,l.sibling=null,l=h;while(l!==null)}}function im(l){var h=l.deletions;if((l.flags&16)!==0){if(h!==null)for(var f=0;f<h.length;f++){var y=h[f];Sa=y,WC(y,l)}UC(l)}if(l.subtreeFlags&10256)for(l=l.child;l!==null;)jC(l),l=l.sibling}function jC(l){switch(l.tag){case 0:case 11:case 15:im(l),l.flags&2048&&No(9,l,l.return);break;case 3:im(l);break;case 12:im(l);break;case 22:var h=l.stateNode;l.memoizedState!==null&&h._visibility&2&&(l.return===null||l.return.tag!==13)?(h._visibility&=-3,mb(l)):im(l);break;default:im(l)}}function mb(l){var h=l.deletions;if((l.flags&16)!==0){if(h!==null)for(var f=0;f<h.length;f++){var y=h[f];Sa=y,WC(y,l)}UC(l)}for(l=l.child;l!==null;){switch(h=l,h.tag){case 0:case 11:case 15:No(8,h,h.return),mb(h);break;case 22:f=h.stateNode,f._visibility&2&&(f._visibility&=-3,mb(h));break;default:mb(h)}l=l.sibling}}function WC(l,h){for(;Sa!==null;){var f=Sa;switch(f.tag){case 0:case 11:case 15:No(8,f,h);break;case 23:case 22:if(f.memoizedState!==null&&f.memoizedState.cachePool!==null){var y=f.memoizedState.cachePool.pool;y!=null&&y.refCount++}break;case 24:Wf(f.memoizedState.cache)}if(y=f.child,y!==null)y.return=f,Sa=y;else e:for(f=l;Sa!==null;){y=Sa;var S=y.sibling,_=y.return;if(DC(y),y===f){Sa=null;break e}if(S!==null){S.return=_,Sa=S;break e}Sa=_}}}var AW={getCacheForType:function(l){var h=$a(qn),f=h.data.get(l);return f===void 0&&(f=l(),h.data.set(l,f)),f},cacheSignal:function(){return $a(qn).controller.signal}},$W=typeof WeakMap=="function"?WeakMap:Map,zt=0,on=null,St=null,Nt=0,Gt=0,Pr=null,Io=!1,th=!1,r1=!1,Fi=0,An=0,To=0,tu=0,s1=0,Ur=0,nh=0,om=null,wr=null,i1=!1,gb=0,VC=0,yb=1/0,bb=null,Eo=null,sa=0,Co=null,ah=null,zi=0,o1=0,l1=null,HC=null,lm=0,u1=null;function jr(){return(zt&2)!==0&&Nt!==0?Nt&-Nt:j.T!==null?m1():ns()}function GC(){if(Ur===0)if((Nt&536870912)===0||Et){var l=Ns;Ns<<=1,(Ns&3932160)===0&&(Ns=262144),Ur=l}else Ur=536870912;return l=Lr.current,l!==null&&(l.flags|=32),Ur}function Sr(l,h,f){(l===on&&(Gt===2||Gt===9)||l.cancelPendingCommit!==null)&&(rh(l,0),Ao(l,Nt,Ur,!1)),Re(l,f),((zt&2)===0||l!==on)&&(l===on&&((zt&2)===0&&(tu|=f),An===4&&Ao(l,Nt,Ur,!1)),Zs(l))}function qC(l,h,f){if((zt&6)!==0)throw Error(a(327));var y=!f&&(h&127)===0&&(h&l.expiredLanes)===0||qs(l,h),S=y?OW(l,h):d1(l,h,!0),_=y;do{if(S===0){th&&!y&&Ao(l,h,0,!1);break}else{if(f=l.current.alternate,_&&!RW(f)){S=d1(l,h,!1),_=!1;continue}if(S===2){if(_=h,l.errorRecoveryDisabledLanes&_)var A=0;else A=l.pendingLanes&-536870913,A=A!==0?A:A&536870912?536870912:0;if(A!==0){h=A;e:{var z=l;S=om;var J=z.current.memoizedState.isDehydrated;if(J&&(rh(z,A).flags|=256),A=d1(z,A,!1),A!==2){if(r1&&!J){z.errorRecoveryDisabledLanes|=_,tu|=_,S=4;break e}_=wr,wr=S,_!==null&&(wr===null?wr=_:wr.push.apply(wr,_))}S=A}if(_=!1,S!==2)continue}}if(S===1){rh(l,0),Ao(l,h,0,!0);break}e:{switch(y=l,_=S,_){case 0:case 1:throw Error(a(345));case 4:if((h&4194048)!==h)break;case 6:Ao(y,h,Ur,!Io);break e;case 2:wr=null;break;case 3:case 5:break;default:throw Error(a(329))}if((h&62914560)===h&&(S=gb+300-dn(),10<S)){if(Ao(y,h,Ur,!Io),ts(y,0,!0)!==0)break e;zi=h,y.timeoutHandle=_A(KC.bind(null,y,f,wr,bb,i1,h,Ur,tu,nh,Io,_,"Throttled",-0,0),S);break e}KC(y,f,wr,bb,i1,h,Ur,tu,nh,Io,_,null,-0,0)}}break}while(!0);Zs(l)}function KC(l,h,f,y,S,_,A,z,J,fe,Se,Ne,ge,be){if(l.timeoutHandle=-1,Ne=h.subtreeFlags,Ne&8192||(Ne&16785408)===16785408){Ne={stylesheets:null,count:0,imgCount:0,imgBytes:0,suspenseyImages:[],waitingForImages:!0,waitingForViewTransition:!1,unsuspend:yr},PC(h,_,Ne);var Pe=(_&62914560)===_?gb-dn():(_&4194048)===_?VC-dn():0;if(Pe=gV(Ne,Pe),Pe!==null){zi=_,l.cancelPendingCommit=Pe(nA.bind(null,l,h,_,f,y,S,A,z,J,Se,Ne,null,ge,be)),Ao(l,_,A,!fe);return}}nA(l,h,_,f,y,S,A,z,J)}function RW(l){for(var h=l;;){var f=h.tag;if((f===0||f===11||f===15)&&h.flags&16384&&(f=h.updateQueue,f!==null&&(f=f.stores,f!==null)))for(var y=0;y<f.length;y++){var S=f[y],_=S.getSnapshot;S=S.value;try{if(!Fr(_(),S))return!1}catch{return!1}}if(f=h.child,h.subtreeFlags&16384&&f!==null)f.return=h,h=f;else{if(h===l)break;for(;h.sibling===null;){if(h.return===null||h.return===l)return!0;h=h.return}h.sibling.return=h.return,h=h.sibling}}return!0}function Ao(l,h,f,y){h&=~s1,h&=~tu,l.suspendedLanes|=h,l.pingedLanes&=~h,y&&(l.warmLanes|=h),y=l.expirationTimes;for(var S=h;0<S;){var _=31-xa(S),A=1<<_;y[_]=-1,S&=~A}f!==0&&Qt(l,f,h)}function vb(){return(zt&6)===0?(um(0),!1):!0}function c1(){if(St!==null){if(Gt===0)var l=St.return;else l=St,Ii=Gl=null,Iw(l),Kd=null,Hf=0,l=St;for(;l!==null;)NC(l.alternate,l),l=l.return;St=null}}function rh(l,h){var f=l.timeoutHandle;f!==-1&&(l.timeoutHandle=-1,ZW(f)),f=l.cancelPendingCommit,f!==null&&(l.cancelPendingCommit=null,f()),zi=0,c1(),on=l,St=f=_i(l.current,null),Nt=h,Gt=0,Pr=null,Io=!1,th=qs(l,h),r1=!1,nh=Ur=s1=tu=To=An=0,wr=om=null,i1=!1,(h&8)!==0&&(h|=h&32);var y=l.entangledLanes;if(y!==0)for(l=l.entanglements,y&=h;0<y;){var S=31-xa(y),_=1<<S;h|=l[S],y&=~_}return Fi=h,Py(),f}function XC(l,h){gt=null,j.H=Qf,h===qd||h===Ky?(h=dE(),Gt=3):h===fw?(h=dE(),Gt=4):Gt=h===jw?8:h!==null&&typeof h=="object"&&typeof h.then=="function"?6:1,Pr=h,St===null&&(An=1,lb(l,is(h,l.current)))}function YC(){var l=Lr.current;return l===null?!0:(Nt&4194048)===Nt?cs===null:(Nt&62914560)===Nt||(Nt&536870912)!==0?l===cs:!1}function JC(){var l=j.H;return j.H=Qf,l===null?Qf:l}function ZC(){var l=j.A;return j.A=AW,l}function xb(){An=4,Io||(Nt&4194048)!==Nt&&Lr.current!==null||(th=!0),(To&134217727)===0&&(tu&134217727)===0||on===null||Ao(on,Nt,Ur,!1)}function d1(l,h,f){var y=zt;zt|=2;var S=JC(),_=ZC();(on!==l||Nt!==h)&&(bb=null,rh(l,h)),h=!1;var A=An;e:do try{if(Gt!==0&&St!==null){var z=St,J=Pr;switch(Gt){case 8:c1(),A=6;break e;case 3:case 2:case 9:case 6:Lr.current===null&&(h=!0);var fe=Gt;if(Gt=0,Pr=null,sh(l,z,J,fe),f&&th){A=0;break e}break;default:fe=Gt,Gt=0,Pr=null,sh(l,z,J,fe)}}DW(),A=An;break}catch(Se){XC(l,Se)}while(!0);return h&&l.shellSuspendCounter++,Ii=Gl=null,zt=y,j.H=S,j.A=_,St===null&&(on=null,Nt=0,Py()),A}function DW(){for(;St!==null;)QC(St)}function OW(l,h){var f=zt;zt|=2;var y=JC(),S=ZC();on!==l||Nt!==h?(bb=null,yb=dn()+500,rh(l,h)):th=qs(l,h);e:do try{if(Gt!==0&&St!==null){h=St;var _=Pr;t:switch(Gt){case 1:Gt=0,Pr=null,sh(l,h,_,1);break;case 2:case 9:if(uE(_)){Gt=0,Pr=null,eA(h);break}h=function(){Gt!==2&&Gt!==9||on!==l||(Gt=7),Zs(l)},_.then(h,h);break e;case 3:Gt=7;break e;case 4:Gt=5;break e;case 7:uE(_)?(Gt=0,Pr=null,eA(h)):(Gt=0,Pr=null,sh(l,h,_,7));break;case 5:var A=null;switch(St.tag){case 26:A=St.memoizedState;case 5:case 27:var z=St;if(A?BA(A):z.stateNode.complete){Gt=0,Pr=null;var J=z.sibling;if(J!==null)St=J;else{var fe=z.return;fe!==null?(St=fe,wb(fe)):St=null}break t}}Gt=0,Pr=null,sh(l,h,_,5);break;case 6:Gt=0,Pr=null,sh(l,h,_,6);break;case 8:c1(),An=6;break e;default:throw Error(a(462))}}MW();break}catch(Se){XC(l,Se)}while(!0);return Ii=Gl=null,j.H=y,j.A=S,zt=f,St!==null?0:(on=null,Nt=0,Py(),An)}function MW(){for(;St!==null&&!Hn();)QC(St)}function QC(l){var h=kC(l.alternate,l,Fi);l.memoizedProps=l.pendingProps,h===null?wb(l):St=h}function eA(l){var h=l,f=h.alternate;switch(h.tag){case 15:case 0:h=yC(f,h,h.pendingProps,h.type,void 0,Nt);break;case 11:h=yC(f,h,h.pendingProps,h.type.render,h.ref,Nt);break;case 5:Iw(h);default:NC(f,h),h=St=ZT(h,Fi),h=kC(f,h,Fi)}l.memoizedProps=l.pendingProps,h===null?wb(l):St=h}function sh(l,h,f,y){Ii=Gl=null,Iw(h),Kd=null,Hf=0;var S=h.return;try{if(kW(l,S,h,f,Nt)){An=1,lb(l,is(f,l.current)),St=null;return}}catch(_){if(S!==null)throw St=S,_;An=1,lb(l,is(f,l.current)),St=null;return}h.flags&32768?(Et||y===1?l=!0:th||(Nt&536870912)!==0?l=!1:(Io=l=!0,(y===2||y===9||y===3||y===6)&&(y=Lr.current,y!==null&&y.tag===13&&(y.flags|=16384))),tA(h,l)):wb(h)}function wb(l){var h=l;do{if((h.flags&32768)!==0){tA(h,Io);return}l=h.return;var f=IW(h.alternate,h,Fi);if(f!==null){St=f;return}if(h=h.sibling,h!==null){St=h;return}St=h=l}while(h!==null);An===0&&(An=5)}function tA(l,h){do{var f=TW(l.alternate,l);if(f!==null){f.flags&=32767,St=f;return}if(f=l.return,f!==null&&(f.flags|=32768,f.subtreeFlags=0,f.deletions=null),!h&&(l=l.sibling,l!==null)){St=l;return}St=l=f}while(l!==null);An=6,St=null}function nA(l,h,f,y,S,_,A,z,J){l.cancelPendingCommit=null;do Sb();while(sa!==0);if((zt&6)!==0)throw Error(a(327));if(h!==null){if(h===l.current)throw Error(a(177));if(_=h.lanes|h.childLanes,_|=Qx,Ht(l,f,_,A,z,J),l===on&&(St=on=null,Nt=0),ah=h,Co=l,zi=f,o1=_,l1=S,HC=y,(h.subtreeFlags&10256)!==0||(h.flags&10256)!==0?(l.callbackNode=null,l.callbackPriority=0,BW(va,function(){return oA(),null})):(l.callbackNode=null,l.callbackPriority=0),y=(h.flags&13878)!==0,(h.subtreeFlags&13878)!==0||y){y=j.T,j.T=null,S=K.p,K.p=2,A=zt,zt|=4;try{EW(l,h,f)}finally{zt=A,K.p=S,j.T=y}}sa=1,aA(),rA(),sA()}}function aA(){if(sa===1){sa=0;var l=Co,h=ah,f=(h.flags&13878)!==0;if((h.subtreeFlags&13878)!==0||f){f=j.T,j.T=null;var y=K.p;K.p=2;var S=zt;zt|=4;try{zC(h,l);var _=k1,A=WT(l.containerInfo),z=_.focusedElem,J=_.selectionRange;if(A!==z&&z&&z.ownerDocument&&jT(z.ownerDocument.documentElement,z)){if(J!==null&&Kx(z)){var fe=J.start,Se=J.end;if(Se===void 0&&(Se=fe),"selectionStart"in z)z.selectionStart=fe,z.selectionEnd=Math.min(Se,z.value.length);else{var Ne=z.ownerDocument||document,ge=Ne&&Ne.defaultView||window;if(ge.getSelection){var be=ge.getSelection(),Pe=z.textContent.length,Je=Math.min(J.start,Pe),nn=J.end===void 0?Je:Math.min(J.end,Pe);!be.extend&&Je>nn&&(A=nn,nn=Je,Je=A);var le=UT(z,Je),se=UT(z,nn);if(le&&se&&(be.rangeCount!==1||be.anchorNode!==le.node||be.anchorOffset!==le.offset||be.focusNode!==se.node||be.focusOffset!==se.offset)){var pe=Ne.createRange();pe.setStart(le.node,le.offset),be.removeAllRanges(),Je>nn?(be.addRange(pe),be.extend(se.node,se.offset)):(pe.setEnd(se.node,se.offset),be.addRange(pe))}}}}for(Ne=[],be=z;be=be.parentNode;)be.nodeType===1&&Ne.push({element:be,left:be.scrollLeft,top:be.scrollTop});for(typeof z.focus=="function"&&z.focus(),z=0;z<Ne.length;z++){var ke=Ne[z];ke.element.scrollLeft=ke.left,ke.element.scrollTop=ke.top}}Ob=!!S1,k1=S1=null}finally{zt=S,K.p=y,j.T=f}}l.current=h,sa=2}}function rA(){if(sa===2){sa=0;var l=Co,h=ah,f=(h.flags&8772)!==0;if((h.subtreeFlags&8772)!==0||f){f=j.T,j.T=null;var y=K.p;K.p=2;var S=zt;zt|=4;try{RC(l,h.alternate,h)}finally{zt=S,K.p=y,j.T=f}}sa=3}}function sA(){if(sa===4||sa===3){sa=0,Ta();var l=Co,h=ah,f=zi,y=HC;(h.subtreeFlags&10256)!==0||(h.flags&10256)!==0?sa=5:(sa=0,ah=Co=null,iA(l,l.pendingLanes));var S=l.pendingLanes;if(S===0&&(Eo=null),Ea(f),h=h.stateNode,In&&typeof In.onCommitFiberRoot=="function")try{In.onCommitFiberRoot(ja,h,void 0,(h.current.flags&128)===128)}catch{}if(y!==null){h=j.T,S=K.p,K.p=2,j.T=null;try{for(var _=l.onRecoverableError,A=0;A<y.length;A++){var z=y[A];_(z.value,{componentStack:z.stack})}}finally{j.T=h,K.p=S}}(zi&3)!==0&&Sb(),Zs(l),S=l.pendingLanes,(f&261930)!==0&&(S&42)!==0?l===u1?lm++:(lm=0,u1=l):lm=0,um(0)}}function iA(l,h){(l.pooledCacheLanes&=h)===0&&(h=l.pooledCache,h!=null&&(l.pooledCache=null,Wf(h)))}function Sb(){return aA(),rA(),sA(),oA()}function oA(){if(sa!==5)return!1;var l=Co,h=o1;o1=0;var f=Ea(zi),y=j.T,S=K.p;try{K.p=32>f?32:f,j.T=null,f=l1,l1=null;var _=Co,A=zi;if(sa=0,ah=Co=null,zi=0,(zt&6)!==0)throw Error(a(331));var z=zt;if(zt|=4,jC(_.current),BC(_,_.current,A,f),zt=z,um(0,!1),In&&typeof In.onPostCommitFiberRoot=="function")try{In.onPostCommitFiberRoot(ja,_)}catch{}return!0}finally{K.p=S,j.T=y,iA(l,h)}}function lA(l,h,f){h=is(f,h),h=Uw(l.stateNode,h,2),l=So(l,h,2),l!==null&&(Re(l,2),Zs(l))}function qt(l,h,f){if(l.tag===3)lA(l,l,f);else for(;h!==null;){if(h.tag===3){lA(h,l,f);break}else if(h.tag===1){var y=h.stateNode;if(typeof h.type.getDerivedStateFromError=="function"||typeof y.componentDidCatch=="function"&&(Eo===null||!Eo.has(y))){l=is(f,l),f=uC(2),y=So(h,f,2),y!==null&&(cC(f,y,h,l),Re(y,2),Zs(y));break}}h=h.return}}function h1(l,h,f){var y=l.pingCache;if(y===null){y=l.pingCache=new $W;var S=new Set;y.set(h,S)}else S=y.get(h),S===void 0&&(S=new Set,y.set(h,S));S.has(f)||(r1=!0,S.add(f),l=FW.bind(null,l,h,f),h.then(l,l))}function FW(l,h,f){var y=l.pingCache;y!==null&&y.delete(h),l.pingedLanes|=l.suspendedLanes&f,l.warmLanes&=~f,on===l&&(Nt&f)===f&&(An===4||An===3&&(Nt&62914560)===Nt&&300>dn()-gb?(zt&2)===0&&rh(l,0):s1|=f,nh===Nt&&(nh=0)),Zs(l)}function uA(l,h){h===0&&(h=Ae()),l=Wl(l,h),l!==null&&(Re(l,h),Zs(l))}function zW(l){var h=l.memoizedState,f=0;h!==null&&(f=h.retryLane),uA(l,f)}function LW(l,h){var f=0;switch(l.tag){case 31:case 13:var y=l.stateNode,S=l.memoizedState;S!==null&&(f=S.retryLane);break;case 19:y=l.stateNode;break;case 22:y=l.stateNode._retryCache;break;default:throw Error(a(314))}y!==null&&y.delete(h),uA(l,f)}function BW(l,h){return rn(l,h)}var kb=null,ih=null,p1=!1,_b=!1,f1=!1,$o=0;function Zs(l){l!==ih&&l.next===null&&(ih===null?kb=ih=l:ih=ih.next=l),_b=!0,p1||(p1=!0,UW())}function um(l,h){if(!f1&&_b){f1=!0;do for(var f=!1,y=kb;y!==null;){if(l!==0){var S=y.pendingLanes;if(S===0)var _=0;else{var A=y.suspendedLanes,z=y.pingedLanes;_=(1<<31-xa(42|l)+1)-1,_&=S&~(A&~z),_=_&201326741?_&201326741|1:_?_|2:0}_!==0&&(f=!0,pA(y,_))}else _=Nt,_=ts(y,y===on?_:0,y.cancelPendingCommit!==null||y.timeoutHandle!==-1),(_&3)===0||qs(y,_)||(f=!0,pA(y,_));y=y.next}while(f);f1=!1}}function PW(){cA()}function cA(){_b=p1=!1;var l=0;$o!==0&&JW()&&(l=$o);for(var h=dn(),f=null,y=kb;y!==null;){var S=y.next,_=dA(y,h);_===0?(y.next=null,f===null?kb=S:f.next=S,S===null&&(ih=f)):(f=y,(l!==0||(_&3)!==0)&&(_b=!0)),y=S}sa!==0&&sa!==5||um(l),$o!==0&&($o=0)}function dA(l,h){for(var f=l.suspendedLanes,y=l.pingedLanes,S=l.expirationTimes,_=l.pendingLanes&-62914561;0<_;){var A=31-xa(_),z=1<<A,J=S[A];J===-1?((z&f)===0||(z&y)!==0)&&(S[A]=xe(z,h)):J<=h&&(l.expiredLanes|=z),_&=~z}if(h=on,f=Nt,f=ts(l,l===h?f:0,l.cancelPendingCommit!==null||l.timeoutHandle!==-1),y=l.callbackNode,f===0||l===h&&(Gt===2||Gt===9)||l.cancelPendingCommit!==null)return y!==null&&y!==null&&ra(y),l.callbackNode=null,l.callbackPriority=0;if((f&3)===0||qs(l,f)){if(h=f&-f,h===l.callbackPriority)return h;switch(y!==null&&ra(y),Ea(f)){case 2:case 8:f=Mn;break;case 32:f=va;break;case 268435456:f=oo;break;default:f=va}return y=hA.bind(null,l),f=rn(f,y),l.callbackPriority=h,l.callbackNode=f,h}return y!==null&&y!==null&&ra(y),l.callbackPriority=2,l.callbackNode=null,2}function hA(l,h){if(sa!==0&&sa!==5)return l.callbackNode=null,l.callbackPriority=0,null;var f=l.callbackNode;if(Sb()&&l.callbackNode!==f)return null;var y=Nt;return y=ts(l,l===on?y:0,l.cancelPendingCommit!==null||l.timeoutHandle!==-1),y===0?null:(qC(l,y,h),dA(l,dn()),l.callbackNode!=null&&l.callbackNode===f?hA.bind(null,l):null)}function pA(l,h){if(Sb())return null;qC(l,h,!0)}function UW(){QW(function(){(zt&6)!==0?rn(ba,PW):cA()})}function m1(){if($o===0){var l=Hd;l===0&&(l=fr,fr<<=1,(fr&261888)===0&&(fr=256)),$o=l}return $o}function fA(l){return l==null||typeof l=="symbol"||typeof l=="boolean"?null:typeof l=="function"?l:Ll(""+l)}function mA(l,h){var f=h.ownerDocument.createElement("input");return f.name=h.name,f.value=h.value,l.id&&f.setAttribute("form",l.id),h.parentNode.insertBefore(f,h),l=new FormData(l),f.parentNode.removeChild(f),l}function jW(l,h,f,y,S){if(h==="submit"&&f&&f.stateNode===S){var _=fA((S[Ft]||null).action),A=y.submitter;A&&(h=(h=A[Ft]||null)?fA(h.formAction):A.getAttribute("formAction"),h!==null&&(_=h,A=null));var z=new Fy("action","action",null,y,S);l.push({event:z,listeners:[{instance:null,listener:function(){if(y.defaultPrevented){if($o!==0){var J=A?mA(S,A):new FormData(S);Mw(f,{pending:!0,data:J,method:S.method,action:_},null,J)}}else typeof _=="function"&&(z.preventDefault(),J=A?mA(S,A):new FormData(S),Mw(f,{pending:!0,data:J,method:S.method,action:_},_,J))},currentTarget:S}]})}}for(var g1=0;g1<Zx.length;g1++){var y1=Zx[g1],WW=y1.toLowerCase(),VW=y1[0].toUpperCase()+y1.slice(1);Is(WW,"on"+VW)}Is(GT,"onAnimationEnd"),Is(qT,"onAnimationIteration"),Is(KT,"onAnimationStart"),Is("dblclick","onDoubleClick"),Is("focusin","onFocus"),Is("focusout","onBlur"),Is(iW,"onTransitionRun"),Is(oW,"onTransitionStart"),Is(lW,"onTransitionCancel"),Is(XT,"onTransitionEnd"),co("onMouseEnter",["mouseout","mouseover"]),co("onMouseLeave",["mouseout","mouseover"]),co("onPointerEnter",["pointerout","pointerover"]),co("onPointerLeave",["pointerout","pointerover"]),wi("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),wi("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),wi("onBeforeInput",["compositionend","keypress","textInput","paste"]),wi("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),wi("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),wi("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var cm="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),HW=new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(cm));function gA(l,h){h=(h&4)!==0;for(var f=0;f<l.length;f++){var y=l[f],S=y.event;y=y.listeners;e:{var _=void 0;if(h)for(var A=y.length-1;0<=A;A--){var z=y[A],J=z.instance,fe=z.currentTarget;if(z=z.listener,J!==_&&S.isPropagationStopped())break e;_=z,S.currentTarget=fe;try{_(S)}catch(Se){By(Se)}S.currentTarget=null,_=J}else for(A=0;A<y.length;A++){if(z=y[A],J=z.instance,fe=z.currentTarget,z=z.listener,J!==_&&S.isPropagationStopped())break e;_=z,S.currentTarget=fe;try{_(S)}catch(Se){By(Se)}S.currentTarget=null,_=J}}}}function kt(l,h){var f=h[lo];f===void 0&&(f=h[lo]=new Set);var y=l+"__bubble";f.has(y)||(yA(h,l,2,!1),f.add(y))}function b1(l,h,f){var y=0;h&&(y|=4),yA(f,l,y,h)}var Nb="_reactListening"+Math.random().toString(36).slice(2);function v1(l){if(!l[Nb]){l[Nb]=!0,Nd.forEach(function(f){f!=="selectionchange"&&(HW.has(f)||b1(f,!1,l),b1(f,!0,l))});var h=l.nodeType===9?l:l.ownerDocument;h===null||h[Nb]||(h[Nb]=!0,b1("selectionchange",!1,h))}}function yA(l,h,f,y){switch(GA(h)){case 2:var S=vV;break;case 8:S=xV;break;default:S=O1}f=S.bind(null,h,f,l),S=void 0,!We||h!=="touchstart"&&h!=="touchmove"&&h!=="wheel"||(S=!0),y?S!==void 0?l.addEventListener(h,f,{capture:!0,passive:S}):l.addEventListener(h,f,!0):S!==void 0?l.addEventListener(h,f,{passive:S}):l.addEventListener(h,f,!1)}function x1(l,h,f,y,S){var _=y;if((h&1)===0&&(h&2)===0&&y!==null)e:for(;;){if(y===null)return;var A=y.tag;if(A===3||A===4){var z=y.stateNode.containerInfo;if(z===S)break;if(A===4)for(A=y.return;A!==null;){var J=A.tag;if((J===3||J===4)&&A.stateNode.containerInfo===S)return;A=A.return}for(;z!==null;){if(A=as(z),A===null)return;if(J=A.tag,J===5||J===6||J===26||J===27){y=_=A;continue e}z=z.parentNode}}y=y.return}rt(function(){var fe=_,Se=Df(f),Ne=[];e:{var ge=YT.get(l);if(ge!==void 0){var be=Fy,Pe=l;switch(l){case"keypress":if(Md(f)===0)break e;case"keydown":case"keyup":be=Lj;break;case"focusin":Pe="focus",be=Wx;break;case"focusout":Pe="blur",be=Wx;break;case"beforeblur":case"afterblur":be=Wx;break;case"click":if(f.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":be=NT;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":be=Ij;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":be=Uj;break;case GT:case qT:case KT:be=Cj;break;case XT:be=Wj;break;case"scroll":case"scrollend":be=_j;break;case"wheel":be=Hj;break;case"copy":case"cut":case"paste":be=$j;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":be=TT;break;case"toggle":case"beforetoggle":be=qj}var Je=(h&4)!==0,nn=!Je&&(l==="scroll"||l==="scrollend"),le=Je?ge!==null?ge+"Capture":null:ge;Je=[];for(var se=fe,pe;se!==null;){var ke=se;if(pe=ke.stateNode,ke=ke.tag,ke!==5&&ke!==26&&ke!==27||pe===null||le===null||(ke=nt(se,le),ke!=null&&Je.push(dm(se,ke,pe))),nn)break;se=se.return}0<Je.length&&(ge=new be(ge,Pe,null,f,Se),Ne.push({event:ge,listeners:Je}))}}if((h&7)===0){e:{if(ge=l==="mouseover"||l==="pointerover",be=l==="mouseout"||l==="pointerout",ge&&f!==mo&&(Pe=f.relatedTarget||f.fromElement)&&(as(Pe)||Pe[nr]))break e;if((be||ge)&&(ge=Se.window===Se?Se:(ge=Se.ownerDocument)?ge.defaultView||ge.parentWindow:window,be?(Pe=f.relatedTarget||f.toElement,be=fe,Pe=Pe?as(Pe):null,Pe!==null&&(nn=s(Pe),Je=Pe.tag,Pe!==nn||Je!==5&&Je!==27&&Je!==6)&&(Pe=null)):(be=null,Pe=fe),be!==Pe)){if(Je=NT,ke="onMouseLeave",le="onMouseEnter",se="mouse",(l==="pointerout"||l==="pointerover")&&(Je=TT,ke="onPointerLeave",le="onPointerEnter",se="pointer"),nn=be==null?ge:zl(be),pe=Pe==null?ge:zl(Pe),ge=new Je(ke,se+"leave",be,f,Se),ge.target=nn,ge.relatedTarget=pe,ke=null,as(Se)===fe&&(Je=new Je(le,se+"enter",Pe,f,Se),Je.target=pe,Je.relatedTarget=nn,ke=Je),nn=ke,be&&Pe)t:{for(Je=GW,le=be,se=Pe,pe=0,ke=le;ke;ke=Je(ke))pe++;ke=0;for(var Ye=se;Ye;Ye=Je(Ye))ke++;for(;0<pe-ke;)le=Je(le),pe--;for(;0<ke-pe;)se=Je(se),ke--;for(;pe--;){if(le===se||se!==null&&le===se.alternate){Je=le;break t}le=Je(le),se=Je(se)}Je=null}else Je=null;be!==null&&bA(Ne,ge,be,Je,!1),Pe!==null&&nn!==null&&bA(Ne,nn,Pe,Je,!0)}}e:{if(ge=fe?zl(fe):window,be=ge.nodeName&&ge.nodeName.toLowerCase(),be==="select"||be==="input"&&ge.type==="file")var Ot=MT;else if(DT(ge))if(FT)Ot=aW;else{Ot=tW;var Ve=eW}else be=ge.nodeName,!be||be.toLowerCase()!=="input"||ge.type!=="checkbox"&&ge.type!=="radio"?fe&&fo(fe.elementType)&&(Ot=MT):Ot=nW;if(Ot&&(Ot=Ot(l,fe))){OT(Ne,Ot,f,Se);break e}Ve&&Ve(l,ge,fe),l==="focusout"&&fe&&ge.type==="number"&&fe.memoizedProps.value!=null&&po(ge,"number",ge.value)}switch(Ve=fe?zl(fe):window,l){case"focusin":(DT(Ve)||Ve.contentEditable==="true")&&(zd=Ve,Xx=fe,Pf=null);break;case"focusout":Pf=Xx=zd=null;break;case"mousedown":Yx=!0;break;case"contextmenu":case"mouseup":case"dragend":Yx=!1,VT(Ne,f,Se);break;case"selectionchange":if(sW)break;case"keydown":case"keyup":VT(Ne,f,Se)}var yt;if(Hx)e:{switch(l){case"compositionstart":var It="onCompositionStart";break e;case"compositionend":It="onCompositionEnd";break e;case"compositionupdate":It="onCompositionUpdate";break e}It=void 0}else Fd?$T(l,f)&&(It="onCompositionEnd"):l==="keydown"&&f.keyCode===229&&(It="onCompositionStart");It&&(ET&&f.locale!=="ko"&&(Fd||It!=="onCompositionStart"?It==="onCompositionEnd"&&Fd&&(yt=Od()):(En=Se,Mr="value"in En?En.value:En.textContent,Fd=!0)),Ve=Ib(fe,It),0<Ve.length&&(It=new IT(It,l,null,f,Se),Ne.push({event:It,listeners:Ve}),yt?It.data=yt:(yt=RT(f),yt!==null&&(It.data=yt)))),(yt=Xj?Yj(l,f):Jj(l,f))&&(It=Ib(fe,"onBeforeInput"),0<It.length&&(Ve=new IT("onBeforeInput","beforeinput",null,f,Se),Ne.push({event:Ve,listeners:It}),Ve.data=yt)),jW(Ne,l,fe,f,Se)}gA(Ne,h)})}function dm(l,h,f){return{instance:l,listener:h,currentTarget:f}}function Ib(l,h){for(var f=h+"Capture",y=[];l!==null;){var S=l,_=S.stateNode;if(S=S.tag,S!==5&&S!==26&&S!==27||_===null||(S=nt(l,f),S!=null&&y.unshift(dm(l,S,_)),S=nt(l,h),S!=null&&y.push(dm(l,S,_))),l.tag===3)return y;l=l.return}return[]}function GW(l){if(l===null)return null;do l=l.return;while(l&&l.tag!==5&&l.tag!==27);return l||null}function bA(l,h,f,y,S){for(var _=h._reactName,A=[];f!==null&&f!==y;){var z=f,J=z.alternate,fe=z.stateNode;if(z=z.tag,J!==null&&J===y)break;z!==5&&z!==26&&z!==27||fe===null||(J=fe,S?(fe=nt(f,_),fe!=null&&A.unshift(dm(f,fe,J))):S||(fe=nt(f,_),fe!=null&&A.push(dm(f,fe,J)))),f=f.return}A.length!==0&&l.push({event:h,listeners:A})}var qW=/\r\n?/g,KW=/\u0000|\uFFFD/g;function vA(l){return(typeof l=="string"?l:""+l).replace(qW,`
`).replace(KW,"")}function xA(l,h){return h=vA(h),vA(l)===h}function tn(l,h,f,y,S,_){switch(f){case"children":typeof y=="string"?h==="body"||h==="textarea"&&y===""||Ks(l,y):(typeof y=="number"||typeof y=="bigint")&&h!=="body"&&Ks(l,""+y);break;case"className":Ed(l,"class",y);break;case"tabIndex":Ed(l,"tabindex",y);break;case"dir":case"role":case"viewBox":case"width":case"height":Ed(l,f,y);break;case"style":$d(l,y,_);break;case"data":if(h!=="object"){Ed(l,"data",y);break}case"src":case"href":if(y===""&&(h!=="a"||f!=="href")){l.removeAttribute(f);break}if(y==null||typeof y=="function"||typeof y=="symbol"||typeof y=="boolean"){l.removeAttribute(f);break}y=Ll(""+y),l.setAttribute(f,y);break;case"action":case"formAction":if(typeof y=="function"){l.setAttribute(f,"javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");break}else typeof _=="function"&&(f==="formAction"?(h!=="input"&&tn(l,h,"name",S.name,S,null),tn(l,h,"formEncType",S.formEncType,S,null),tn(l,h,"formMethod",S.formMethod,S,null),tn(l,h,"formTarget",S.formTarget,S,null)):(tn(l,h,"encType",S.encType,S,null),tn(l,h,"method",S.method,S,null),tn(l,h,"target",S.target,S,null)));if(y==null||typeof y=="symbol"||typeof y=="boolean"){l.removeAttribute(f);break}y=Ll(""+y),l.setAttribute(f,y);break;case"onClick":y!=null&&(l.onclick=yr);break;case"onScroll":y!=null&&kt("scroll",l);break;case"onScrollEnd":y!=null&&kt("scrollend",l);break;case"dangerouslySetInnerHTML":if(y!=null){if(typeof y!="object"||!("__html"in y))throw Error(a(61));if(f=y.__html,f!=null){if(S.children!=null)throw Error(a(60));l.innerHTML=f}}break;case"multiple":l.multiple=y&&typeof y!="function"&&typeof y!="symbol";break;case"muted":l.muted=y&&typeof y!="function"&&typeof y!="symbol";break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"defaultValue":case"defaultChecked":case"innerHTML":case"ref":break;case"autoFocus":break;case"xlinkHref":if(y==null||typeof y=="function"||typeof y=="boolean"||typeof y=="symbol"){l.removeAttribute("xlink:href");break}f=Ll(""+y),l.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href",f);break;case"contentEditable":case"spellCheck":case"draggable":case"value":case"autoReverse":case"externalResourcesRequired":case"focusable":case"preserveAlpha":y!=null&&typeof y!="function"&&typeof y!="symbol"?l.setAttribute(f,""+y):l.removeAttribute(f);break;case"inert":case"allowFullScreen":case"async":case"autoPlay":case"controls":case"default":case"defer":case"disabled":case"disablePictureInPicture":case"disableRemotePlayback":case"formNoValidate":case"hidden":case"loop":case"noModule":case"noValidate":case"open":case"playsInline":case"readOnly":case"required":case"reversed":case"scoped":case"seamless":case"itemScope":y&&typeof y!="function"&&typeof y!="symbol"?l.setAttribute(f,""):l.removeAttribute(f);break;case"capture":case"download":y===!0?l.setAttribute(f,""):y!==!1&&y!=null&&typeof y!="function"&&typeof y!="symbol"?l.setAttribute(f,y):l.removeAttribute(f);break;case"cols":case"rows":case"size":case"span":y!=null&&typeof y!="function"&&typeof y!="symbol"&&!isNaN(y)&&1<=y?l.setAttribute(f,y):l.removeAttribute(f);break;case"rowSpan":case"start":y==null||typeof y=="function"||typeof y=="symbol"||isNaN(y)?l.removeAttribute(f):l.setAttribute(f,y);break;case"popover":kt("beforetoggle",l),kt("toggle",l),Td(l,"popover",y);break;case"xlinkActuate":rs(l,"http://www.w3.org/1999/xlink","xlink:actuate",y);break;case"xlinkArcrole":rs(l,"http://www.w3.org/1999/xlink","xlink:arcrole",y);break;case"xlinkRole":rs(l,"http://www.w3.org/1999/xlink","xlink:role",y);break;case"xlinkShow":rs(l,"http://www.w3.org/1999/xlink","xlink:show",y);break;case"xlinkTitle":rs(l,"http://www.w3.org/1999/xlink","xlink:title",y);break;case"xlinkType":rs(l,"http://www.w3.org/1999/xlink","xlink:type",y);break;case"xmlBase":rs(l,"http://www.w3.org/XML/1998/namespace","xml:base",y);break;case"xmlLang":rs(l,"http://www.w3.org/XML/1998/namespace","xml:lang",y);break;case"xmlSpace":rs(l,"http://www.w3.org/XML/1998/namespace","xml:space",y);break;case"is":Td(l,"is",y);break;case"innerText":case"textContent":break;default:(!(2<f.length)||f[0]!=="o"&&f[0]!=="O"||f[1]!=="n"&&f[1]!=="N")&&(f=Rd.get(f)||f,Td(l,f,y))}}function w1(l,h,f,y,S,_){switch(f){case"style":$d(l,y,_);break;case"dangerouslySetInnerHTML":if(y!=null){if(typeof y!="object"||!("__html"in y))throw Error(a(61));if(f=y.__html,f!=null){if(S.children!=null)throw Error(a(60));l.innerHTML=f}}break;case"children":typeof y=="string"?Ks(l,y):(typeof y=="number"||typeof y=="bigint")&&Ks(l,""+y);break;case"onScroll":y!=null&&kt("scroll",l);break;case"onScrollEnd":y!=null&&kt("scrollend",l);break;case"onClick":y!=null&&(l.onclick=yr);break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"innerHTML":case"ref":break;case"innerText":case"textContent":break;default:if(!Ry.hasOwnProperty(f))e:{if(f[0]==="o"&&f[1]==="n"&&(S=f.endsWith("Capture"),h=f.slice(2,S?f.length-7:void 0),_=l[Ft]||null,_=_!=null?_[f]:null,typeof _=="function"&&l.removeEventListener(h,_,S),typeof y=="function")){typeof _!="function"&&_!==null&&(f in l?l[f]=null:l.hasAttribute(f)&&l.removeAttribute(f)),l.addEventListener(h,y,S);break e}f in l?l[f]=y:y===!0?l.setAttribute(f,""):Td(l,f,y)}}}function Da(l,h,f){switch(h){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"img":kt("error",l),kt("load",l);var y=!1,S=!1,_;for(_ in f)if(f.hasOwnProperty(_)){var A=f[_];if(A!=null)switch(_){case"src":y=!0;break;case"srcSet":S=!0;break;case"children":case"dangerouslySetInnerHTML":throw Error(a(137,h));default:tn(l,h,_,A,f,null)}}S&&tn(l,h,"srcSet",f.srcSet,f,null),y&&tn(l,h,"src",f.src,f,null);return;case"input":kt("invalid",l);var z=_=A=S=null,J=null,fe=null;for(y in f)if(f.hasOwnProperty(y)){var Se=f[y];if(Se!=null)switch(y){case"name":S=Se;break;case"type":A=Se;break;case"checked":J=Se;break;case"defaultChecked":fe=Se;break;case"value":_=Se;break;case"defaultValue":z=Se;break;case"children":case"dangerouslySetInnerHTML":if(Se!=null)throw Error(a(137,h));break;default:tn(l,h,y,Se,f,null)}}Cf(l,_,z,J,fe,A,S,!1);return;case"select":kt("invalid",l),y=A=_=null;for(S in f)if(f.hasOwnProperty(S)&&(z=f[S],z!=null))switch(S){case"value":_=z;break;case"defaultValue":A=z;break;case"multiple":y=z;default:tn(l,h,S,z,f,null)}h=_,f=A,l.multiple=!!y,h!=null?Si(l,!!y,h,!1):f!=null&&Si(l,!!y,f,!0);return;case"textarea":kt("invalid",l),_=S=y=null;for(A in f)if(f.hasOwnProperty(A)&&(z=f[A],z!=null))switch(A){case"value":y=z;break;case"defaultValue":S=z;break;case"children":_=z;break;case"dangerouslySetInnerHTML":if(z!=null)throw Error(a(91));break;default:tn(l,h,A,z,f,null)}$f(l,y,S,_);return;case"option":for(J in f)f.hasOwnProperty(J)&&(y=f[J],y!=null)&&(J==="selected"?l.selected=y&&typeof y!="function"&&typeof y!="symbol":tn(l,h,J,y,f,null));return;case"dialog":kt("beforetoggle",l),kt("toggle",l),kt("cancel",l),kt("close",l);break;case"iframe":case"object":kt("load",l);break;case"video":case"audio":for(y=0;y<cm.length;y++)kt(cm[y],l);break;case"image":kt("error",l),kt("load",l);break;case"details":kt("toggle",l);break;case"embed":case"source":case"link":kt("error",l),kt("load",l);case"area":case"base":case"br":case"col":case"hr":case"keygen":case"meta":case"param":case"track":case"wbr":case"menuitem":for(fe in f)if(f.hasOwnProperty(fe)&&(y=f[fe],y!=null))switch(fe){case"children":case"dangerouslySetInnerHTML":throw Error(a(137,h));default:tn(l,h,fe,y,f,null)}return;default:if(fo(h)){for(Se in f)f.hasOwnProperty(Se)&&(y=f[Se],y!==void 0&&w1(l,h,Se,y,f,void 0));return}}for(z in f)f.hasOwnProperty(z)&&(y=f[z],y!=null&&tn(l,h,z,y,f,null))}function XW(l,h,f,y){switch(h){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"input":var S=null,_=null,A=null,z=null,J=null,fe=null,Se=null;for(be in f){var Ne=f[be];if(f.hasOwnProperty(be)&&Ne!=null)switch(be){case"checked":break;case"value":break;case"defaultValue":J=Ne;default:y.hasOwnProperty(be)||tn(l,h,be,null,y,Ne)}}for(var ge in y){var be=y[ge];if(Ne=f[ge],y.hasOwnProperty(ge)&&(be!=null||Ne!=null))switch(ge){case"type":_=be;break;case"name":S=be;break;case"checked":fe=be;break;case"defaultChecked":Se=be;break;case"value":A=be;break;case"defaultValue":z=be;break;case"children":case"dangerouslySetInnerHTML":if(be!=null)throw Error(a(137,h));break;default:be!==Ne&&tn(l,h,ge,be,y,Ne)}}Ef(l,A,z,J,fe,Se,_,S);return;case"select":be=A=z=ge=null;for(_ in f)if(J=f[_],f.hasOwnProperty(_)&&J!=null)switch(_){case"value":break;case"multiple":be=J;default:y.hasOwnProperty(_)||tn(l,h,_,null,y,J)}for(S in y)if(_=y[S],J=f[S],y.hasOwnProperty(S)&&(_!=null||J!=null))switch(S){case"value":ge=_;break;case"defaultValue":z=_;break;case"multiple":A=_;default:_!==J&&tn(l,h,S,_,y,J)}h=z,f=A,y=be,ge!=null?Si(l,!!f,ge,!1):!!y!=!!f&&(h!=null?Si(l,!!f,h,!0):Si(l,!!f,f?[]:"",!1));return;case"textarea":be=ge=null;for(z in f)if(S=f[z],f.hasOwnProperty(z)&&S!=null&&!y.hasOwnProperty(z))switch(z){case"value":break;case"children":break;default:tn(l,h,z,null,y,S)}for(A in y)if(S=y[A],_=f[A],y.hasOwnProperty(A)&&(S!=null||_!=null))switch(A){case"value":ge=S;break;case"defaultValue":be=S;break;case"children":break;case"dangerouslySetInnerHTML":if(S!=null)throw Error(a(91));break;default:S!==_&&tn(l,h,A,S,y,_)}Af(l,ge,be);return;case"option":for(var Pe in f)ge=f[Pe],f.hasOwnProperty(Pe)&&ge!=null&&!y.hasOwnProperty(Pe)&&(Pe==="selected"?l.selected=!1:tn(l,h,Pe,null,y,ge));for(J in y)ge=y[J],be=f[J],y.hasOwnProperty(J)&&ge!==be&&(ge!=null||be!=null)&&(J==="selected"?l.selected=ge&&typeof ge!="function"&&typeof ge!="symbol":tn(l,h,J,ge,y,be));return;case"img":case"link":case"area":case"base":case"br":case"col":case"embed":case"hr":case"keygen":case"meta":case"param":case"source":case"track":case"wbr":case"menuitem":for(var Je in f)ge=f[Je],f.hasOwnProperty(Je)&&ge!=null&&!y.hasOwnProperty(Je)&&tn(l,h,Je,null,y,ge);for(fe in y)if(ge=y[fe],be=f[fe],y.hasOwnProperty(fe)&&ge!==be&&(ge!=null||be!=null))switch(fe){case"children":case"dangerouslySetInnerHTML":if(ge!=null)throw Error(a(137,h));break;default:tn(l,h,fe,ge,y,be)}return;default:if(fo(h)){for(var nn in f)ge=f[nn],f.hasOwnProperty(nn)&&ge!==void 0&&!y.hasOwnProperty(nn)&&w1(l,h,nn,void 0,y,ge);for(Se in y)ge=y[Se],be=f[Se],!y.hasOwnProperty(Se)||ge===be||ge===void 0&&be===void 0||w1(l,h,Se,ge,y,be);return}}for(var le in f)ge=f[le],f.hasOwnProperty(le)&&ge!=null&&!y.hasOwnProperty(le)&&tn(l,h,le,null,y,ge);for(Ne in y)ge=y[Ne],be=f[Ne],!y.hasOwnProperty(Ne)||ge===be||ge==null&&be==null||tn(l,h,Ne,ge,y,be)}function wA(l){switch(l){case"css":case"script":case"font":case"img":case"image":case"input":case"link":return!0;default:return!1}}function YW(){if(typeof performance.getEntriesByType=="function"){for(var l=0,h=0,f=performance.getEntriesByType("resource"),y=0;y<f.length;y++){var S=f[y],_=S.transferSize,A=S.initiatorType,z=S.duration;if(_&&z&&wA(A)){for(A=0,z=S.responseEnd,y+=1;y<f.length;y++){var J=f[y],fe=J.startTime;if(fe>z)break;var Se=J.transferSize,Ne=J.initiatorType;Se&&wA(Ne)&&(J=J.responseEnd,A+=Se*(J<z?1:(z-fe)/(J-fe)))}if(--y,h+=8*(_+A)/(S.duration/1e3),l++,10<l)break}}if(0<l)return h/l/1e6}return navigator.connection&&(l=navigator.connection.downlink,typeof l=="number")?l:5}var S1=null,k1=null;function Tb(l){return l.nodeType===9?l:l.ownerDocument}function SA(l){switch(l){case"http://www.w3.org/2000/svg":return 1;case"http://www.w3.org/1998/Math/MathML":return 2;default:return 0}}function kA(l,h){if(l===0)switch(h){case"svg":return 1;case"math":return 2;default:return 0}return l===1&&h==="foreignObject"?0:l}function _1(l,h){return l==="textarea"||l==="noscript"||typeof h.children=="string"||typeof h.children=="number"||typeof h.children=="bigint"||typeof h.dangerouslySetInnerHTML=="object"&&h.dangerouslySetInnerHTML!==null&&h.dangerouslySetInnerHTML.__html!=null}var N1=null;function JW(){var l=window.event;return l&&l.type==="popstate"?l===N1?!1:(N1=l,!0):(N1=null,!1)}var _A=typeof setTimeout=="function"?setTimeout:void 0,ZW=typeof clearTimeout=="function"?clearTimeout:void 0,NA=typeof Promise=="function"?Promise:void 0,QW=typeof queueMicrotask=="function"?queueMicrotask:typeof NA<"u"?function(l){return NA.resolve(null).then(l).catch(eV)}:_A;function eV(l){setTimeout(function(){throw l})}function Ro(l){return l==="head"}function IA(l,h){var f=h,y=0;do{var S=f.nextSibling;if(l.removeChild(f),S&&S.nodeType===8)if(f=S.data,f==="/$"||f==="/&"){if(y===0){l.removeChild(S),ch(h);return}y--}else if(f==="$"||f==="$?"||f==="$~"||f==="$!"||f==="&")y++;else if(f==="html")hm(l.ownerDocument.documentElement);else if(f==="head"){f=l.ownerDocument.head,hm(f);for(var _=f.firstChild;_;){var A=_.nextSibling,z=_.nodeName;_[Fl]||z==="SCRIPT"||z==="STYLE"||z==="LINK"&&_.rel.toLowerCase()==="stylesheet"||f.removeChild(_),_=A}}else f==="body"&&hm(l.ownerDocument.body);f=S}while(f);ch(h)}function TA(l,h){var f=l;l=0;do{var y=f.nextSibling;if(f.nodeType===1?h?(f._stashedDisplay=f.style.display,f.style.display="none"):(f.style.display=f._stashedDisplay||"",f.getAttribute("style")===""&&f.removeAttribute("style")):f.nodeType===3&&(h?(f._stashedText=f.nodeValue,f.nodeValue=""):f.nodeValue=f._stashedText||""),y&&y.nodeType===8)if(f=y.data,f==="/$"){if(l===0)break;l--}else f!=="$"&&f!=="$?"&&f!=="$~"&&f!=="$!"||l++;f=y}while(f)}function I1(l){var h=l.firstChild;for(h&&h.nodeType===10&&(h=h.nextSibling);h;){var f=h;switch(h=h.nextSibling,f.nodeName){case"HTML":case"HEAD":case"BODY":I1(f),If(f);continue;case"SCRIPT":case"STYLE":continue;case"LINK":if(f.rel.toLowerCase()==="stylesheet")continue}l.removeChild(f)}}function tV(l,h,f,y){for(;l.nodeType===1;){var S=f;if(l.nodeName.toLowerCase()!==h.toLowerCase()){if(!y&&(l.nodeName!=="INPUT"||l.type!=="hidden"))break}else if(y){if(!l[Fl])switch(h){case"meta":if(!l.hasAttribute("itemprop"))break;return l;case"link":if(_=l.getAttribute("rel"),_==="stylesheet"&&l.hasAttribute("data-precedence"))break;if(_!==S.rel||l.getAttribute("href")!==(S.href==null||S.href===""?null:S.href)||l.getAttribute("crossorigin")!==(S.crossOrigin==null?null:S.crossOrigin)||l.getAttribute("title")!==(S.title==null?null:S.title))break;return l;case"style":if(l.hasAttribute("data-precedence"))break;return l;case"script":if(_=l.getAttribute("src"),(_!==(S.src==null?null:S.src)||l.getAttribute("type")!==(S.type==null?null:S.type)||l.getAttribute("crossorigin")!==(S.crossOrigin==null?null:S.crossOrigin))&&_&&l.hasAttribute("async")&&!l.hasAttribute("itemprop"))break;return l;default:return l}}else if(h==="input"&&l.type==="hidden"){var _=S.name==null?null:""+S.name;if(S.type==="hidden"&&l.getAttribute("name")===_)return l}else return l;if(l=ds(l.nextSibling),l===null)break}return null}function nV(l,h,f){if(h==="")return null;for(;l.nodeType!==3;)if((l.nodeType!==1||l.nodeName!=="INPUT"||l.type!=="hidden")&&!f||(l=ds(l.nextSibling),l===null))return null;return l}function EA(l,h){for(;l.nodeType!==8;)if((l.nodeType!==1||l.nodeName!=="INPUT"||l.type!=="hidden")&&!h||(l=ds(l.nextSibling),l===null))return null;return l}function T1(l){return l.data==="$?"||l.data==="$~"}function E1(l){return l.data==="$!"||l.data==="$?"&&l.ownerDocument.readyState!=="loading"}function aV(l,h){var f=l.ownerDocument;if(l.data==="$~")l._reactRetry=h;else if(l.data!=="$?"||f.readyState!=="loading")h();else{var y=function(){h(),f.removeEventListener("DOMContentLoaded",y)};f.addEventListener("DOMContentLoaded",y),l._reactRetry=y}}function ds(l){for(;l!=null;l=l.nextSibling){var h=l.nodeType;if(h===1||h===3)break;if(h===8){if(h=l.data,h==="$"||h==="$!"||h==="$?"||h==="$~"||h==="&"||h==="F!"||h==="F")break;if(h==="/$"||h==="/&")return null}}return l}var C1=null;function CA(l){l=l.nextSibling;for(var h=0;l;){if(l.nodeType===8){var f=l.data;if(f==="/$"||f==="/&"){if(h===0)return ds(l.nextSibling);h--}else f!=="$"&&f!=="$!"&&f!=="$?"&&f!=="$~"&&f!=="&"||h++}l=l.nextSibling}return null}function AA(l){l=l.previousSibling;for(var h=0;l;){if(l.nodeType===8){var f=l.data;if(f==="$"||f==="$!"||f==="$?"||f==="$~"||f==="&"){if(h===0)return l;h--}else f!=="/$"&&f!=="/&"||h++}l=l.previousSibling}return null}function $A(l,h,f){switch(h=Tb(f),l){case"html":if(l=h.documentElement,!l)throw Error(a(452));return l;case"head":if(l=h.head,!l)throw Error(a(453));return l;case"body":if(l=h.body,!l)throw Error(a(454));return l;default:throw Error(a(451))}}function hm(l){for(var h=l.attributes;h.length;)l.removeAttributeNode(h[0]);If(l)}var hs=new Map,RA=new Set;function Eb(l){return typeof l.getRootNode=="function"?l.getRootNode():l.nodeType===9?l:l.ownerDocument}var Li=K.d;K.d={f:rV,r:sV,D:iV,C:oV,L:lV,m:uV,X:dV,S:cV,M:hV};function rV(){var l=Li.f(),h=vb();return l||h}function sV(l){var h=uo(l);h!==null&&h.tag===5&&h.type==="form"?XE(h):Li.r(l)}var oh=typeof document>"u"?null:document;function DA(l,h,f){var y=oh;if(y&&typeof h=="string"&&h){var S=gr(h);S='link[rel="'+l+'"][href="'+S+'"]',typeof f=="string"&&(S+='[crossorigin="'+f+'"]'),RA.has(S)||(RA.add(S),l={rel:l,crossOrigin:f,href:h},y.querySelector(S)===null&&(h=y.createElement("link"),Da(h,"link",l),Gn(h),y.head.appendChild(h)))}}function iV(l){Li.D(l),DA("dns-prefetch",l,null)}function oV(l,h){Li.C(l,h),DA("preconnect",l,h)}function lV(l,h,f){Li.L(l,h,f);var y=oh;if(y&&l&&h){var S='link[rel="preload"][as="'+gr(h)+'"]';h==="image"&&f&&f.imageSrcSet?(S+='[imagesrcset="'+gr(f.imageSrcSet)+'"]',typeof f.imageSizes=="string"&&(S+='[imagesizes="'+gr(f.imageSizes)+'"]')):S+='[href="'+gr(l)+'"]';var _=S;switch(h){case"style":_=lh(l);break;case"script":_=uh(l)}hs.has(_)||(l=p({rel:"preload",href:h==="image"&&f&&f.imageSrcSet?void 0:l,as:h},f),hs.set(_,l),y.querySelector(S)!==null||h==="style"&&y.querySelector(pm(_))||h==="script"&&y.querySelector(fm(_))||(h=y.createElement("link"),Da(h,"link",l),Gn(h),y.head.appendChild(h)))}}function uV(l,h){Li.m(l,h);var f=oh;if(f&&l){var y=h&&typeof h.as=="string"?h.as:"script",S='link[rel="modulepreload"][as="'+gr(y)+'"][href="'+gr(l)+'"]',_=S;switch(y){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":_=uh(l)}if(!hs.has(_)&&(l=p({rel:"modulepreload",href:l},h),hs.set(_,l),f.querySelector(S)===null)){switch(y){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":if(f.querySelector(fm(_)))return}y=f.createElement("link"),Da(y,"link",l),Gn(y),f.head.appendChild(y)}}}function cV(l,h,f){Li.S(l,h,f);var y=oh;if(y&&l){var S=xi(y).hoistableStyles,_=lh(l);h=h||"default";var A=S.get(_);if(!A){var z={loading:0,preload:null};if(A=y.querySelector(pm(_)))z.loading=5;else{l=p({rel:"stylesheet",href:l,"data-precedence":h},f),(f=hs.get(_))&&A1(l,f);var J=A=y.createElement("link");Gn(J),Da(J,"link",l),J._p=new Promise(function(fe,Se){J.onload=fe,J.onerror=Se}),J.addEventListener("load",function(){z.loading|=1}),J.addEventListener("error",function(){z.loading|=2}),z.loading|=4,Cb(A,h,y)}A={type:"stylesheet",instance:A,count:1,state:z},S.set(_,A)}}}function dV(l,h){Li.X(l,h);var f=oh;if(f&&l){var y=xi(f).hoistableScripts,S=uh(l),_=y.get(S);_||(_=f.querySelector(fm(S)),_||(l=p({src:l,async:!0},h),(h=hs.get(S))&&$1(l,h),_=f.createElement("script"),Gn(_),Da(_,"link",l),f.head.appendChild(_)),_={type:"script",instance:_,count:1,state:null},y.set(S,_))}}function hV(l,h){Li.M(l,h);var f=oh;if(f&&l){var y=xi(f).hoistableScripts,S=uh(l),_=y.get(S);_||(_=f.querySelector(fm(S)),_||(l=p({src:l,async:!0,type:"module"},h),(h=hs.get(S))&&$1(l,h),_=f.createElement("script"),Gn(_),Da(_,"link",l),f.head.appendChild(_)),_={type:"script",instance:_,count:1,state:null},y.set(S,_))}}function OA(l,h,f,y){var S=(S=Ie.current)?Eb(S):null;if(!S)throw Error(a(446));switch(l){case"meta":case"title":return null;case"style":return typeof f.precedence=="string"&&typeof f.href=="string"?(h=lh(f.href),f=xi(S).hoistableStyles,y=f.get(h),y||(y={type:"style",instance:null,count:0,state:null},f.set(h,y)),y):{type:"void",instance:null,count:0,state:null};case"link":if(f.rel==="stylesheet"&&typeof f.href=="string"&&typeof f.precedence=="string"){l=lh(f.href);var _=xi(S).hoistableStyles,A=_.get(l);if(A||(S=S.ownerDocument||S,A={type:"stylesheet",instance:null,count:0,state:{loading:0,preload:null}},_.set(l,A),(_=S.querySelector(pm(l)))&&!_._p&&(A.instance=_,A.state.loading=5),hs.has(l)||(f={rel:"preload",as:"style",href:f.href,crossOrigin:f.crossOrigin,integrity:f.integrity,media:f.media,hrefLang:f.hrefLang,referrerPolicy:f.referrerPolicy},hs.set(l,f),_||pV(S,l,f,A.state))),h&&y===null)throw Error(a(528,""));return A}if(h&&y!==null)throw Error(a(529,""));return null;case"script":return h=f.async,f=f.src,typeof f=="string"&&h&&typeof h!="function"&&typeof h!="symbol"?(h=uh(f),f=xi(S).hoistableScripts,y=f.get(h),y||(y={type:"script",instance:null,count:0,state:null},f.set(h,y)),y):{type:"void",instance:null,count:0,state:null};default:throw Error(a(444,l))}}function lh(l){return'href="'+gr(l)+'"'}function pm(l){return'link[rel="stylesheet"]['+l+"]"}function MA(l){return p({},l,{"data-precedence":l.precedence,precedence:null})}function pV(l,h,f,y){l.querySelector('link[rel="preload"][as="style"]['+h+"]")?y.loading=1:(h=l.createElement("link"),y.preload=h,h.addEventListener("load",function(){return y.loading|=1}),h.addEventListener("error",function(){return y.loading|=2}),Da(h,"link",f),Gn(h),l.head.appendChild(h))}function uh(l){return'[src="'+gr(l)+'"]'}function fm(l){return"script[async]"+l}function FA(l,h,f){if(h.count++,h.instance===null)switch(h.type){case"style":var y=l.querySelector('style[data-href~="'+gr(f.href)+'"]');if(y)return h.instance=y,Gn(y),y;var S=p({},f,{"data-href":f.href,"data-precedence":f.precedence,href:null,precedence:null});return y=(l.ownerDocument||l).createElement("style"),Gn(y),Da(y,"style",S),Cb(y,f.precedence,l),h.instance=y;case"stylesheet":S=lh(f.href);var _=l.querySelector(pm(S));if(_)return h.state.loading|=4,h.instance=_,Gn(_),_;y=MA(f),(S=hs.get(S))&&A1(y,S),_=(l.ownerDocument||l).createElement("link"),Gn(_);var A=_;return A._p=new Promise(function(z,J){A.onload=z,A.onerror=J}),Da(_,"link",y),h.state.loading|=4,Cb(_,f.precedence,l),h.instance=_;case"script":return _=uh(f.src),(S=l.querySelector(fm(_)))?(h.instance=S,Gn(S),S):(y=f,(S=hs.get(_))&&(y=p({},f),$1(y,S)),l=l.ownerDocument||l,S=l.createElement("script"),Gn(S),Da(S,"link",y),l.head.appendChild(S),h.instance=S);case"void":return null;default:throw Error(a(443,h.type))}else h.type==="stylesheet"&&(h.state.loading&4)===0&&(y=h.instance,h.state.loading|=4,Cb(y,f.precedence,l));return h.instance}function Cb(l,h,f){for(var y=f.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'),S=y.length?y[y.length-1]:null,_=S,A=0;A<y.length;A++){var z=y[A];if(z.dataset.precedence===h)_=z;else if(_!==S)break}_?_.parentNode.insertBefore(l,_.nextSibling):(h=f.nodeType===9?f.head:f,h.insertBefore(l,h.firstChild))}function A1(l,h){l.crossOrigin==null&&(l.crossOrigin=h.crossOrigin),l.referrerPolicy==null&&(l.referrerPolicy=h.referrerPolicy),l.title==null&&(l.title=h.title)}function $1(l,h){l.crossOrigin==null&&(l.crossOrigin=h.crossOrigin),l.referrerPolicy==null&&(l.referrerPolicy=h.referrerPolicy),l.integrity==null&&(l.integrity=h.integrity)}var Ab=null;function zA(l,h,f){if(Ab===null){var y=new Map,S=Ab=new Map;S.set(f,y)}else S=Ab,y=S.get(f),y||(y=new Map,S.set(f,y));if(y.has(l))return y;for(y.set(l,null),f=f.getElementsByTagName(l),S=0;S<f.length;S++){var _=f[S];if(!(_[Fl]||_[Tn]||l==="link"&&_.getAttribute("rel")==="stylesheet")&&_.namespaceURI!=="http://www.w3.org/2000/svg"){var A=_.getAttribute(h)||"";A=l+A;var z=y.get(A);z?z.push(_):y.set(A,[_])}}return y}function LA(l,h,f){l=l.ownerDocument||l,l.head.insertBefore(f,h==="title"?l.querySelector("head > title"):null)}function fV(l,h,f){if(f===1||h.itemProp!=null)return!1;switch(l){case"meta":case"title":return!0;case"style":if(typeof h.precedence!="string"||typeof h.href!="string"||h.href==="")break;return!0;case"link":if(typeof h.rel!="string"||typeof h.href!="string"||h.href===""||h.onLoad||h.onError)break;return h.rel==="stylesheet"?(l=h.disabled,typeof h.precedence=="string"&&l==null):!0;case"script":if(h.async&&typeof h.async!="function"&&typeof h.async!="symbol"&&!h.onLoad&&!h.onError&&h.src&&typeof h.src=="string")return!0}return!1}function BA(l){return!(l.type==="stylesheet"&&(l.state.loading&3)===0)}function mV(l,h,f,y){if(f.type==="stylesheet"&&(typeof y.media!="string"||matchMedia(y.media).matches!==!1)&&(f.state.loading&4)===0){if(f.instance===null){var S=lh(y.href),_=h.querySelector(pm(S));if(_){h=_._p,h!==null&&typeof h=="object"&&typeof h.then=="function"&&(l.count++,l=$b.bind(l),h.then(l,l)),f.state.loading|=4,f.instance=_,Gn(_);return}_=h.ownerDocument||h,y=MA(y),(S=hs.get(S))&&A1(y,S),_=_.createElement("link"),Gn(_);var A=_;A._p=new Promise(function(z,J){A.onload=z,A.onerror=J}),Da(_,"link",y),f.instance=_}l.stylesheets===null&&(l.stylesheets=new Map),l.stylesheets.set(f,h),(h=f.state.preload)&&(f.state.loading&3)===0&&(l.count++,f=$b.bind(l),h.addEventListener("load",f),h.addEventListener("error",f))}}var R1=0;function gV(l,h){return l.stylesheets&&l.count===0&&Db(l,l.stylesheets),0<l.count||0<l.imgCount?function(f){var y=setTimeout(function(){if(l.stylesheets&&Db(l,l.stylesheets),l.unsuspend){var _=l.unsuspend;l.unsuspend=null,_()}},6e4+h);0<l.imgBytes&&R1===0&&(R1=62500*YW());var S=setTimeout(function(){if(l.waitingForImages=!1,l.count===0&&(l.stylesheets&&Db(l,l.stylesheets),l.unsuspend)){var _=l.unsuspend;l.unsuspend=null,_()}},(l.imgBytes>R1?50:800)+h);return l.unsuspend=f,function(){l.unsuspend=null,clearTimeout(y),clearTimeout(S)}}:null}function $b(){if(this.count--,this.count===0&&(this.imgCount===0||!this.waitingForImages)){if(this.stylesheets)Db(this,this.stylesheets);else if(this.unsuspend){var l=this.unsuspend;this.unsuspend=null,l()}}}var Rb=null;function Db(l,h){l.stylesheets=null,l.unsuspend!==null&&(l.count++,Rb=new Map,h.forEach(yV,l),Rb=null,$b.call(l))}function yV(l,h){if(!(h.state.loading&4)){var f=Rb.get(l);if(f)var y=f.get(null);else{f=new Map,Rb.set(l,f);for(var S=l.querySelectorAll("link[data-precedence],style[data-precedence]"),_=0;_<S.length;_++){var A=S[_];(A.nodeName==="LINK"||A.getAttribute("media")!=="not all")&&(f.set(A.dataset.precedence,A),y=A)}y&&f.set(null,y)}S=h.instance,A=S.getAttribute("data-precedence"),_=f.get(A)||y,_===y&&f.set(null,S),f.set(A,S),this.count++,y=$b.bind(this),S.addEventListener("load",y),S.addEventListener("error",y),_?_.parentNode.insertBefore(S,_.nextSibling):(l=l.nodeType===9?l.head:l,l.insertBefore(S,l.firstChild)),h.state.loading|=4}}var mm={$$typeof:N,Provider:null,Consumer:null,_currentValue:Q,_currentValue2:Q,_threadCount:0};function bV(l,h,f,y,S,_,A,z,J){this.tag=1,this.containerInfo=l,this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.next=this.pendingContext=this.context=this.cancelPendingCommit=null,this.callbackPriority=0,this.expirationTimes=Ge(-1),this.entangledLanes=this.shellSuspendCounter=this.errorRecoveryDisabledLanes=this.expiredLanes=this.warmLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=Ge(0),this.hiddenUpdates=Ge(null),this.identifierPrefix=y,this.onUncaughtError=S,this.onCaughtError=_,this.onRecoverableError=A,this.pooledCache=null,this.pooledCacheLanes=0,this.formState=J,this.incompleteTransitions=new Map}function PA(l,h,f,y,S,_,A,z,J,fe,Se,Ne){return l=new bV(l,h,f,A,J,fe,Se,Ne,z),h=1,_===!0&&(h|=24),_=zr(3,null,null,h),l.current=_,_.stateNode=l,h=dw(),h.refCount++,l.pooledCache=h,h.refCount++,_.memoizedState={element:y,isDehydrated:f,cache:h},mw(_),l}function UA(l){return l?(l=Pd,l):Pd}function jA(l,h,f,y,S,_){S=UA(S),y.context===null?y.context=S:y.pendingContext=S,y=wo(h),y.payload={element:f},_=_===void 0?null:_,_!==null&&(y.callback=_),f=So(l,y,h),f!==null&&(Sr(f,l,h),qf(f,l,h))}function WA(l,h){if(l=l.memoizedState,l!==null&&l.dehydrated!==null){var f=l.retryLane;l.retryLane=f!==0&&f<h?f:h}}function D1(l,h){WA(l,h),(l=l.alternate)&&WA(l,h)}function VA(l){if(l.tag===13||l.tag===31){var h=Wl(l,67108864);h!==null&&Sr(h,l,67108864),D1(l,67108864)}}function HA(l){if(l.tag===13||l.tag===31){var h=jr();h=pn(h);var f=Wl(l,h);f!==null&&Sr(f,l,h),D1(l,h)}}var Ob=!0;function vV(l,h,f,y){var S=j.T;j.T=null;var _=K.p;try{K.p=2,O1(l,h,f,y)}finally{K.p=_,j.T=S}}function xV(l,h,f,y){var S=j.T;j.T=null;var _=K.p;try{K.p=8,O1(l,h,f,y)}finally{K.p=_,j.T=S}}function O1(l,h,f,y){if(Ob){var S=M1(y);if(S===null)x1(l,h,y,Mb,f),qA(l,y);else if(SV(S,l,h,f,y))y.stopPropagation();else if(qA(l,y),h&4&&-1<wV.indexOf(l)){for(;S!==null;){var _=uo(S);if(_!==null)switch(_.tag){case 3:if(_=_.stateNode,_.current.memoizedState.isDehydrated){var A=tr(_.pendingLanes);if(A!==0){var z=_;for(z.pendingLanes|=2,z.entangledLanes|=2;A;){var J=1<<31-xa(A);z.entanglements[1]|=J,A&=~J}Zs(_),(zt&6)===0&&(yb=dn()+500,um(0))}}break;case 31:case 13:z=Wl(_,2),z!==null&&Sr(z,_,2),vb(),D1(_,2)}if(_=M1(y),_===null&&x1(l,h,y,Mb,f),_===S)break;S=_}S!==null&&y.stopPropagation()}else x1(l,h,y,null,f)}}function M1(l){return l=Df(l),F1(l)}var Mb=null;function F1(l){if(Mb=null,l=as(l),l!==null){var h=s(l);if(h===null)l=null;else{var f=h.tag;if(f===13){if(l=i(h),l!==null)return l;l=null}else if(f===31){if(l=o(h),l!==null)return l;l=null}else if(f===3){if(h.stateNode.current.memoizedState.isDehydrated)return h.tag===3?h.stateNode.containerInfo:null;l=null}else h!==l&&(l=null)}}return Mb=l,null}function GA(l){switch(l){case"beforetoggle":case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"toggle":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 2;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 8;case"message":switch(Ua()){case ba:return 2;case Mn:return 8;case va:case Gs:return 32;case oo:return 268435456;default:return 32}default:return 32}}var z1=!1,Do=null,Oo=null,Mo=null,gm=new Map,ym=new Map,Fo=[],wV="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");function qA(l,h){switch(l){case"focusin":case"focusout":Do=null;break;case"dragenter":case"dragleave":Oo=null;break;case"mouseover":case"mouseout":Mo=null;break;case"pointerover":case"pointerout":gm.delete(h.pointerId);break;case"gotpointercapture":case"lostpointercapture":ym.delete(h.pointerId)}}function bm(l,h,f,y,S,_){return l===null||l.nativeEvent!==_?(l={blockedOn:h,domEventName:f,eventSystemFlags:y,nativeEvent:_,targetContainers:[S]},h!==null&&(h=uo(h),h!==null&&VA(h)),l):(l.eventSystemFlags|=y,h=l.targetContainers,S!==null&&h.indexOf(S)===-1&&h.push(S),l)}function SV(l,h,f,y,S){switch(h){case"focusin":return Do=bm(Do,l,h,f,y,S),!0;case"dragenter":return Oo=bm(Oo,l,h,f,y,S),!0;case"mouseover":return Mo=bm(Mo,l,h,f,y,S),!0;case"pointerover":var _=S.pointerId;return gm.set(_,bm(gm.get(_)||null,l,h,f,y,S)),!0;case"gotpointercapture":return _=S.pointerId,ym.set(_,bm(ym.get(_)||null,l,h,f,y,S)),!0}return!1}function KA(l){var h=as(l.target);if(h!==null){var f=s(h);if(f!==null){if(h=f.tag,h===13){if(h=i(f),h!==null){l.blockedOn=h,Ml(l.priority,function(){HA(f)});return}}else if(h===31){if(h=o(f),h!==null){l.blockedOn=h,Ml(l.priority,function(){HA(f)});return}}else if(h===3&&f.stateNode.current.memoizedState.isDehydrated){l.blockedOn=f.tag===3?f.stateNode.containerInfo:null;return}}}l.blockedOn=null}function Fb(l){if(l.blockedOn!==null)return!1;for(var h=l.targetContainers;0<h.length;){var f=M1(l.nativeEvent);if(f===null){f=l.nativeEvent;var y=new f.constructor(f.type,f);mo=y,f.target.dispatchEvent(y),mo=null}else return h=uo(f),h!==null&&VA(h),l.blockedOn=f,!1;h.shift()}return!0}function XA(l,h,f){Fb(l)&&f.delete(h)}function kV(){z1=!1,Do!==null&&Fb(Do)&&(Do=null),Oo!==null&&Fb(Oo)&&(Oo=null),Mo!==null&&Fb(Mo)&&(Mo=null),gm.forEach(XA),ym.forEach(XA)}function zb(l,h){l.blockedOn===h&&(l.blockedOn=null,z1||(z1=!0,e.unstable_scheduleCallback(e.unstable_NormalPriority,kV)))}var Lb=null;function YA(l){Lb!==l&&(Lb=l,e.unstable_scheduleCallback(e.unstable_NormalPriority,function(){Lb===l&&(Lb=null);for(var h=0;h<l.length;h+=3){var f=l[h],y=l[h+1],S=l[h+2];if(typeof y!="function"){if(F1(y||f)===null)continue;break}var _=uo(f);_!==null&&(l.splice(h,3),h-=3,Mw(_,{pending:!0,data:S,method:f.method,action:y},y,S))}}))}function ch(l){function h(J){return zb(J,l)}Do!==null&&zb(Do,l),Oo!==null&&zb(Oo,l),Mo!==null&&zb(Mo,l),gm.forEach(h),ym.forEach(h);for(var f=0;f<Fo.length;f++){var y=Fo[f];y.blockedOn===l&&(y.blockedOn=null)}for(;0<Fo.length&&(f=Fo[0],f.blockedOn===null);)KA(f),f.blockedOn===null&&Fo.shift();if(f=(l.ownerDocument||l).$$reactFormReplay,f!=null)for(y=0;y<f.length;y+=3){var S=f[y],_=f[y+1],A=S[Ft]||null;if(typeof _=="function")A||YA(f);else if(A){var z=null;if(_&&_.hasAttribute("formAction")){if(S=_,A=_[Ft]||null)z=A.formAction;else if(F1(S)!==null)continue}else z=A.action;typeof z=="function"?f[y+1]=z:(f.splice(y,3),y-=3),YA(f)}}}function JA(){function l(_){_.canIntercept&&_.info==="react-transition"&&_.intercept({handler:function(){return new Promise(function(A){return S=A})},focusReset:"manual",scroll:"manual"})}function h(){S!==null&&(S(),S=null),y||setTimeout(f,20)}function f(){if(!y&&!navigation.transition){var _=navigation.currentEntry;_&&_.url!=null&&navigation.navigate(_.url,{state:_.getState(),info:"react-transition",history:"replace"})}}if(typeof navigation=="object"){var y=!1,S=null;return navigation.addEventListener("navigate",l),navigation.addEventListener("navigatesuccess",h),navigation.addEventListener("navigateerror",h),setTimeout(f,100),function(){y=!0,navigation.removeEventListener("navigate",l),navigation.removeEventListener("navigatesuccess",h),navigation.removeEventListener("navigateerror",h),S!==null&&(S(),S=null)}}}function L1(l){this._internalRoot=l}Bb.prototype.render=L1.prototype.render=function(l){var h=this._internalRoot;if(h===null)throw Error(a(409));var f=h.current,y=jr();jA(f,y,l,h,null,null)},Bb.prototype.unmount=L1.prototype.unmount=function(){var l=this._internalRoot;if(l!==null){this._internalRoot=null;var h=l.containerInfo;jA(l.current,2,null,l,null,null),vb(),h[nr]=null}};function Bb(l){this._internalRoot=l}Bb.prototype.unstable_scheduleHydration=function(l){if(l){var h=ns();l={blockedOn:null,target:l,priority:h};for(var f=0;f<Fo.length&&h!==0&&h<Fo[f].priority;f++);Fo.splice(f,0,l),f===0&&KA(l)}};var ZA=t.version;if(ZA!=="19.2.3")throw Error(a(527,ZA,"19.2.3"));K.findDOMNode=function(l){var h=l._reactInternals;if(h===void 0)throw typeof l.render=="function"?Error(a(188)):(l=Object.keys(l).join(","),Error(a(268,l)));return l=d(h),l=l!==null?c(l):null,l=l===null?null:l.stateNode,l};var _V={bundleType:0,version:"19.2.3",rendererPackageName:"react-dom",currentDispatcherRef:j,reconcilerVersion:"19.2.3"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var Pb=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!Pb.isDisabled&&Pb.supportsFiber)try{ja=Pb.inject(_V),In=Pb}catch{}}return xm.createRoot=function(l,h){if(!r(l))throw Error(a(299));var f=!1,y="",S=sC,_=iC,A=oC;return h!=null&&(h.unstable_strictMode===!0&&(f=!0),h.identifierPrefix!==void 0&&(y=h.identifierPrefix),h.onUncaughtError!==void 0&&(S=h.onUncaughtError),h.onCaughtError!==void 0&&(_=h.onCaughtError),h.onRecoverableError!==void 0&&(A=h.onRecoverableError)),h=PA(l,1,!1,null,null,f,y,null,S,_,A,JA),l[nr]=h.current,v1(l),new L1(h)},xm.hydrateRoot=function(l,h,f){if(!r(l))throw Error(a(299));var y=!1,S="",_=sC,A=iC,z=oC,J=null;return f!=null&&(f.unstable_strictMode===!0&&(y=!0),f.identifierPrefix!==void 0&&(S=f.identifierPrefix),f.onUncaughtError!==void 0&&(_=f.onUncaughtError),f.onCaughtError!==void 0&&(A=f.onCaughtError),f.onRecoverableError!==void 0&&(z=f.onRecoverableError),f.formState!==void 0&&(J=f.formState)),h=PA(l,1,!0,h,f??null,y,S,J,_,A,z,JA),h.context=UA(null),f=h.current,y=jr(),y=pn(y),S=wo(y),S.callback=null,So(f,S,y),f=y,h.current.lanes=f,Re(h,f),Zs(h),l[nr]=h.current,v1(l),new Bb(h)},xm.version="19.2.3",xm}var l$;function OV(){if(l$)return U1.exports;l$=1;function e(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)}catch(t){console.error(t)}}return e(),U1.exports=DV(),U1.exports}var MV=OV();var u$="popstate";function FV(e={}){function t(a,r){let{pathname:s,search:i,hash:o}=a.location;return SS("",{pathname:s,search:i,hash:o},r.state&&r.state.usr||null,r.state&&r.state.key||"default")}function n(a,r){return typeof r=="string"?r:Km(r)}return LV(t,n,null,e)}function _n(e,t){if(e===!1||e===null||typeof e>"u")throw new Error(t)}function Bs(e,t){if(!e){typeof console<"u"&&console.warn(t);try{throw new Error(t)}catch{}}}function zV(){return Math.random().toString(36).substring(2,10)}function c$(e,t){return{usr:e.state,key:e.key,idx:t}}function SS(e,t,n=null,a){return{pathname:typeof e=="string"?e:e.pathname,search:"",hash:"",...typeof t=="string"?Zh(t):t,state:n,key:t&&t.key||a||zV()}}function Km({pathname:e="/",search:t="",hash:n=""}){return t&&t!=="?"&&(e+=t.charAt(0)==="?"?t:"?"+t),n&&n!=="#"&&(e+=n.charAt(0)==="#"?n:"#"+n),e}function Zh(e){let t={};if(e){let n=e.indexOf("#");n>=0&&(t.hash=e.substring(n),e=e.substring(0,n));let a=e.indexOf("?");a>=0&&(t.search=e.substring(a),e=e.substring(0,a)),e&&(t.pathname=e)}return t}function LV(e,t,n,a={}){let{window:r=document.defaultView,v5Compat:s=!1}=a,i=r.history,o="POP",u=null,d=c();d==null&&(d=0,i.replaceState({...i.state,idx:d},""));function c(){return(i.state||{idx:null}).idx}function p(){o="POP";let x=c(),w=x==null?null:x-d;d=x,u&&u({action:o,location:v.location,delta:w})}function m(x,w){o="PUSH";let k=SS(v.location,x,w);d=c()+1;let N=c$(k,d),I=v.createHref(k);try{i.pushState(N,"",I)}catch(T){if(T instanceof DOMException&&T.name==="DataCloneError")throw T;r.location.assign(I)}s&&u&&u({action:o,location:v.location,delta:1})}function g(x,w){o="REPLACE";let k=SS(v.location,x,w);d=c();let N=c$(k,d),I=v.createHref(k);i.replaceState(N,"",I),s&&u&&u({action:o,location:v.location,delta:0})}function b(x){return BV(x)}let v={get action(){return o},get location(){return e(r,i)},listen(x){if(u)throw new Error("A history only accepts one active listener");return r.addEventListener(u$,p),u=x,()=>{r.removeEventListener(u$,p),u=null}},createHref(x){return t(r,x)},createURL:b,encodeLocation(x){let w=b(x);return{pathname:w.pathname,search:w.search,hash:w.hash}},push:m,replace:g,go(x){return i.go(x)}};return v}function BV(e,t=!1){let n="http://localhost";typeof window<"u"&&(n=window.location.origin!=="null"?window.location.origin:window.location.href),_n(n,"No window.location.(origin|href) available to create URL");let a=typeof e=="string"?e:Km(e);return a=a.replace(/ $/,"%20"),!t&&a.startsWith("//")&&(a=n+a),new URL(a,n)}function CD(e,t,n="/"){return PV(e,t,n,!1)}function PV(e,t,n,a){let r=typeof t=="string"?Zh(t):t,s=Ki(r.pathname||"/",n);if(s==null)return null;let i=AD(e);UV(i);let o=null;for(let u=0;o==null&&u<i.length;++u){let d=ZV(s);o=YV(i[u],d,a)}return o}function AD(e,t=[],n=[],a="",r=!1){let s=(i,o,u=r,d)=>{let c={relativePath:d===void 0?i.path||"":d,caseSensitive:i.caseSensitive===!0,childrenIndex:o,route:i};if(c.relativePath.startsWith("/")){if(!c.relativePath.startsWith(a)&&u)return;_n(c.relativePath.startsWith(a),`Absolute route path "${c.relativePath}" nested under path "${a}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`),c.relativePath=c.relativePath.slice(a.length)}let p=Vi([a,c.relativePath]),m=n.concat(c);i.children&&i.children.length>0&&(_n(i.index!==!0,`Index routes must not have child routes. Please remove all child routes from route path "${p}".`),AD(i.children,t,m,p,u)),!(i.path==null&&!i.index)&&t.push({path:p,score:KV(p,i.index),routesMeta:m})};return e.forEach((i,o)=>{if(i.path===""||!i.path?.includes("?"))s(i,o);else for(let u of $D(i.path))s(i,o,!0,u)}),t}function $D(e){let t=e.split("/");if(t.length===0)return[];let[n,...a]=t,r=n.endsWith("?"),s=n.replace(/\?$/,"");if(a.length===0)return r?[s,""]:[s];let i=$D(a.join("/")),o=[];return o.push(...i.map(u=>u===""?s:[s,u].join("/"))),r&&o.push(...i),o.map(u=>e.startsWith("/")&&u===""?"/":u)}function UV(e){e.sort((t,n)=>t.score!==n.score?n.score-t.score:XV(t.routesMeta.map(a=>a.childrenIndex),n.routesMeta.map(a=>a.childrenIndex)))}var jV=/^:[\w-]+$/,WV=3,VV=2,HV=1,GV=10,qV=-2,d$=e=>e==="*";function KV(e,t){let n=e.split("/"),a=n.length;return n.some(d$)&&(a+=qV),t&&(a+=VV),n.filter(r=>!d$(r)).reduce((r,s)=>r+(jV.test(s)?WV:s===""?HV:GV),a)}function XV(e,t){return e.length===t.length&&e.slice(0,-1).every((a,r)=>a===t[r])?e[e.length-1]-t[t.length-1]:0}function YV(e,t,n=!1){let{routesMeta:a}=e,r={},s="/",i=[];for(let o=0;o<a.length;++o){let u=a[o],d=o===a.length-1,c=s==="/"?t:t.slice(s.length)||"/",p=xv({path:u.relativePath,caseSensitive:u.caseSensitive,end:d},c),m=u.route;if(!p&&d&&n&&!a[a.length-1].route.index&&(p=xv({path:u.relativePath,caseSensitive:u.caseSensitive,end:!1},c)),!p)return null;Object.assign(r,p.params),i.push({params:r,pathname:Vi([s,p.pathname]),pathnameBase:n6(Vi([s,p.pathnameBase])),route:m}),p.pathnameBase!=="/"&&(s=Vi([s,p.pathnameBase]))}return i}function xv(e,t){typeof e=="string"&&(e={path:e,caseSensitive:!1,end:!0});let[n,a]=JV(e.path,e.caseSensitive,e.end),r=t.match(n);if(!r)return null;let s=r[0],i=s.replace(/(.)\/+$/,"$1"),o=r.slice(1);return{params:a.reduce((d,{paramName:c,isOptional:p},m)=>{if(c==="*"){let b=o[m]||"";i=s.slice(0,s.length-b.length).replace(/(.)\/+$/,"$1")}const g=o[m];return p&&!g?d[c]=void 0:d[c]=(g||"").replace(/%2F/g,"/"),d},{}),pathname:s,pathnameBase:i,pattern:e}}function JV(e,t=!1,n=!0){Bs(e==="*"||!e.endsWith("*")||e.endsWith("/*"),`Route path "${e}" will be treated as if it were "${e.replace(/\*$/,"/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${e.replace(/\*$/,"/*")}".`);let a=[],r="^"+e.replace(/\/*\*?$/,"").replace(/^\/*/,"/").replace(/[\\.*+^${}|()[\]]/g,"\\$&").replace(/\/:([\w-]+)(\?)?/g,(i,o,u)=>(a.push({paramName:o,isOptional:u!=null}),u?"/?([^\\/]+)?":"/([^\\/]+)")).replace(/\/([\w-]+)\?(\/|$)/g,"(/$1)?$2");return e.endsWith("*")?(a.push({paramName:"*"}),r+=e==="*"||e==="/*"?"(.*)$":"(?:\\/(.+)|\\/*)$"):n?r+="\\/*$":e!==""&&e!=="/"&&(r+="(?:(?=\\/|$))"),[new RegExp(r,t?void 0:"i"),a]}function ZV(e){try{return e.split("/").map(t=>decodeURIComponent(t).replace(/\//g,"%2F")).join("/")}catch(t){return Bs(!1,`The URL path "${e}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${t}).`),e}}function Ki(e,t){if(t==="/")return e;if(!e.toLowerCase().startsWith(t.toLowerCase()))return null;let n=t.endsWith("/")?t.length-1:t.length,a=e.charAt(n);return a&&a!=="/"?null:e.slice(n)||"/"}var RD=/^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,QV=e=>RD.test(e);function e6(e,t="/"){let{pathname:n,search:a="",hash:r=""}=typeof e=="string"?Zh(e):e,s;if(n)if(QV(n))s=n;else{if(n.includes("//")){let i=n;n=n.replace(/\/\/+/g,"/"),Bs(!1,`Pathnames cannot have embedded double slashes - normalizing ${i} -> ${n}`)}n.startsWith("/")?s=h$(n.substring(1),"/"):s=h$(n,t)}else s=t;return{pathname:s,search:a6(a),hash:r6(r)}}function h$(e,t){let n=t.replace(/\/+$/,"").split("/");return e.split("/").forEach(r=>{r===".."?n.length>1&&n.pop():r!=="."&&n.push(r)}),n.length>1?n.join("/"):"/"}function H1(e,t,n,a){return`Cannot include a '${e}' character in a manually specified \`to.${t}\` field [${JSON.stringify(a)}].  Please separate it out to the \`to.${n}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`}function t6(e){return e.filter((t,n)=>n===0||t.route.path&&t.route.path.length>0)}function DD(e){let t=t6(e);return t.map((n,a)=>a===t.length-1?n.pathname:n.pathnameBase)}function OD(e,t,n,a=!1){let r;typeof e=="string"?r=Zh(e):(r={...e},_n(!r.pathname||!r.pathname.includes("?"),H1("?","pathname","search",r)),_n(!r.pathname||!r.pathname.includes("#"),H1("#","pathname","hash",r)),_n(!r.search||!r.search.includes("#"),H1("#","search","hash",r)));let s=e===""||r.pathname==="",i=s?"/":r.pathname,o;if(i==null)o=n;else{let p=t.length-1;if(!a&&i.startsWith("..")){let m=i.split("/");for(;m[0]==="..";)m.shift(),p-=1;r.pathname=m.join("/")}o=p>=0?t[p]:"/"}let u=e6(r,o),d=i&&i!=="/"&&i.endsWith("/"),c=(s||i===".")&&n.endsWith("/");return!u.pathname.endsWith("/")&&(d||c)&&(u.pathname+="/"),u}var Vi=e=>e.join("/").replace(/\/\/+/g,"/"),n6=e=>e.replace(/\/+$/,"").replace(/^\/*/,"/"),a6=e=>!e||e==="?"?"":e.startsWith("?")?e:"?"+e,r6=e=>!e||e==="#"?"":e.startsWith("#")?e:"#"+e,s6=class{constructor(e,t,n,a=!1){this.status=e,this.statusText=t||"",this.internal=a,n instanceof Error?(this.data=n.toString(),this.error=n):this.data=n}};function i6(e){return e!=null&&typeof e.status=="number"&&typeof e.statusText=="string"&&typeof e.internal=="boolean"&&"data"in e}function o6(e){return e.map(t=>t.route.path).filter(Boolean).join("/").replace(/\/\/*/g,"/")||"/"}var MD=typeof window<"u"&&typeof window.document<"u"&&typeof window.document.createElement<"u";function FD(e,t){let n=e;if(typeof n!="string"||!RD.test(n))return{absoluteURL:void 0,isExternal:!1,to:n};let a=n,r=!1;if(MD)try{let s=new URL(window.location.href),i=n.startsWith("//")?new URL(s.protocol+n):new URL(n),o=Ki(i.pathname,t);i.origin===s.origin&&o!=null?n=o+i.search+i.hash:r=!0}catch{Bs(!1,`<Link to="${n}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`)}return{absoluteURL:a,isExternal:r,to:n}}Object.getOwnPropertyNames(Object.prototype).sort().join("\0");var zD=["POST","PUT","PATCH","DELETE"];new Set(zD);var l6=["GET",...zD];new Set(l6);var Qh=he.createContext(null);Qh.displayName="DataRouter";var n0=he.createContext(null);n0.displayName="DataRouterState";var u6=he.createContext(!1),LD=he.createContext({isTransitioning:!1});LD.displayName="ViewTransition";var c6=he.createContext(new Map);c6.displayName="Fetchers";var d6=he.createContext(null);d6.displayName="Await";var xs=he.createContext(null);xs.displayName="Navigation";var wg=he.createContext(null);wg.displayName="Location";var Ji=he.createContext({outlet:null,matches:[],isDataRoute:!1});Ji.displayName="Route";var Gk=he.createContext(null);Gk.displayName="RouteError";var BD="REACT_ROUTER_ERROR",h6="REDIRECT",p6="ROUTE_ERROR_RESPONSE";function f6(e){if(e.startsWith(`${BD}:${h6}:{`))try{let t=JSON.parse(e.slice(28));if(typeof t=="object"&&t&&typeof t.status=="number"&&typeof t.statusText=="string"&&typeof t.location=="string"&&typeof t.reloadDocument=="boolean"&&typeof t.replace=="boolean")return t}catch{}}function m6(e){if(e.startsWith(`${BD}:${p6}:{`))try{let t=JSON.parse(e.slice(40));if(typeof t=="object"&&t&&typeof t.status=="number"&&typeof t.statusText=="string")return new s6(t.status,t.statusText,t.data)}catch{}}function g6(e,{relative:t}={}){_n(Sg(),"useHref() may be used only in the context of a <Router> component.");let{basename:n,navigator:a}=he.useContext(xs),{hash:r,pathname:s,search:i}=kg(e,{relative:t}),o=s;return n!=="/"&&(o=s==="/"?n:Vi([n,s])),a.createHref({pathname:o,search:i,hash:r})}function Sg(){return he.useContext(wg)!=null}function gl(){return _n(Sg(),"useLocation() may be used only in the context of a <Router> component."),he.useContext(wg).location}var PD="You should call navigate() in a React.useEffect(), not when your component is first rendered.";function UD(e){he.useContext(xs).static||he.useLayoutEffect(e)}function y6(){let{isDataRoute:e}=he.useContext(Ji);return e?A6():b6()}function b6(){_n(Sg(),"useNavigate() may be used only in the context of a <Router> component.");let e=he.useContext(Qh),{basename:t,navigator:n}=he.useContext(xs),{matches:a}=he.useContext(Ji),{pathname:r}=gl(),s=JSON.stringify(DD(a)),i=he.useRef(!1);return UD(()=>{i.current=!0}),he.useCallback((u,d={})=>{if(Bs(i.current,PD),!i.current)return;if(typeof u=="number"){n.go(u);return}let c=OD(u,JSON.parse(s),r,d.relative==="path");e==null&&t!=="/"&&(c.pathname=c.pathname==="/"?t:Vi([t,c.pathname])),(d.replace?n.replace:n.push)(c,d.state,d)},[t,n,s,r,e])}he.createContext(null);function kg(e,{relative:t}={}){let{matches:n}=he.useContext(Ji),{pathname:a}=gl(),r=JSON.stringify(DD(n));return he.useMemo(()=>OD(e,JSON.parse(r),a,t==="path"),[e,r,a,t])}function v6(e,t){return jD(e,t)}function jD(e,t,n,a,r){_n(Sg(),"useRoutes() may be used only in the context of a <Router> component.");let{navigator:s}=he.useContext(xs),{matches:i}=he.useContext(Ji),o=i[i.length-1],u=o?o.params:{},d=o?o.pathname:"/",c=o?o.pathnameBase:"/",p=o&&o.route;{let k=p&&p.path||"";VD(d,!p||k.endsWith("*")||k.endsWith("*?"),`You rendered descendant <Routes> (or called \`useRoutes()\`) at "${d}" (under <Route path="${k}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${k}"> to <Route path="${k==="/"?"*":`${k}/*`}">.`)}let m=gl(),g;if(t){let k=typeof t=="string"?Zh(t):t;_n(c==="/"||k.pathname?.startsWith(c),`When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${c}" but pathname "${k.pathname}" was given in the \`location\` prop.`),g=k}else g=m;let b=g.pathname||"/",v=b;if(c!=="/"){let k=c.replace(/^\//,"").split("/");v="/"+b.replace(/^\//,"").split("/").slice(k.length).join("/")}let x=CD(e,{pathname:v});Bs(p||x!=null,`No routes matched location "${g.pathname}${g.search}${g.hash}" `),Bs(x==null||x[x.length-1].route.element!==void 0||x[x.length-1].route.Component!==void 0||x[x.length-1].route.lazy!==void 0,`Matched leaf route at location "${g.pathname}${g.search}${g.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`);let w=_6(x&&x.map(k=>Object.assign({},k,{params:Object.assign({},u,k.params),pathname:Vi([c,s.encodeLocation?s.encodeLocation(k.pathname.replace(/\?/g,"%3F").replace(/#/g,"%23")).pathname:k.pathname]),pathnameBase:k.pathnameBase==="/"?c:Vi([c,s.encodeLocation?s.encodeLocation(k.pathnameBase.replace(/\?/g,"%3F").replace(/#/g,"%23")).pathname:k.pathnameBase])})),i,n,a,r);return t&&w?he.createElement(wg.Provider,{value:{location:{pathname:"/",search:"",hash:"",state:null,key:"default",...g},navigationType:"POP"}},w):w}function x6(){let e=C6(),t=i6(e)?`${e.status} ${e.statusText}`:e instanceof Error?e.message:JSON.stringify(e),n=e instanceof Error?e.stack:null,a="rgba(200,200,200, 0.5)",r={padding:"0.5rem",backgroundColor:a},s={padding:"2px 4px",backgroundColor:a},i=null;return console.error("Error handled by React Router default ErrorBoundary:",e),i=he.createElement(he.Fragment,null,he.createElement("p",null," Hey developer "),he.createElement("p",null,"You can provide a way better UX than this when your app throws errors by providing your own ",he.createElement("code",{style:s},"ErrorBoundary")," or"," ",he.createElement("code",{style:s},"errorElement")," prop on your route.")),he.createElement(he.Fragment,null,he.createElement("h2",null,"Unexpected Application Error!"),he.createElement("h3",{style:{fontStyle:"italic"}},t),n?he.createElement("pre",{style:r},n):null,i)}var w6=he.createElement(x6,null),WD=class extends he.Component{constructor(e){super(e),this.state={location:e.location,revalidation:e.revalidation,error:e.error}}static getDerivedStateFromError(e){return{error:e}}static getDerivedStateFromProps(e,t){return t.location!==e.location||t.revalidation!=="idle"&&e.revalidation==="idle"?{error:e.error,location:e.location,revalidation:e.revalidation}:{error:e.error!==void 0?e.error:t.error,location:t.location,revalidation:e.revalidation||t.revalidation}}componentDidCatch(e,t){this.props.onError?this.props.onError(e,t):console.error("React Router caught the following error during render",e)}render(){let e=this.state.error;if(this.context&&typeof e=="object"&&e&&"digest"in e&&typeof e.digest=="string"){const n=m6(e.digest);n&&(e=n)}let t=e!==void 0?he.createElement(Ji.Provider,{value:this.props.routeContext},he.createElement(Gk.Provider,{value:e,children:this.props.component})):this.props.children;return this.context?he.createElement(S6,{error:e},t):t}};WD.contextType=u6;var G1=new WeakMap;function S6({children:e,error:t}){let{basename:n}=he.useContext(xs);if(typeof t=="object"&&t&&"digest"in t&&typeof t.digest=="string"){let a=f6(t.digest);if(a){let r=G1.get(t);if(r)throw r;let s=FD(a.location,n);if(MD&&!G1.get(t))if(s.isExternal||a.reloadDocument)window.location.href=s.absoluteURL||s.to;else{const i=Promise.resolve().then(()=>window.__reactRouterDataRouter.navigate(s.to,{replace:a.replace}));throw G1.set(t,i),i}return he.createElement("meta",{httpEquiv:"refresh",content:`0;url=${s.absoluteURL||s.to}`})}}return e}function k6({routeContext:e,match:t,children:n}){let a=he.useContext(Qh);return a&&a.static&&a.staticContext&&(t.route.errorElement||t.route.ErrorBoundary)&&(a.staticContext._deepestRenderedBoundaryId=t.route.id),he.createElement(Ji.Provider,{value:e},n)}function _6(e,t=[],n=null,a=null,r=null){if(e==null){if(!n)return null;if(n.errors)e=n.matches;else if(t.length===0&&!n.initialized&&n.matches.length>0)e=n.matches;else return null}let s=e,i=n?.errors;if(i!=null){let c=s.findIndex(p=>p.route.id&&i?.[p.route.id]!==void 0);_n(c>=0,`Could not find a matching route for errors on route IDs: ${Object.keys(i).join(",")}`),s=s.slice(0,Math.min(s.length,c+1))}let o=!1,u=-1;if(n)for(let c=0;c<s.length;c++){let p=s[c];if((p.route.HydrateFallback||p.route.hydrateFallbackElement)&&(u=c),p.route.id){let{loaderData:m,errors:g}=n,b=p.route.loader&&!m.hasOwnProperty(p.route.id)&&(!g||g[p.route.id]===void 0);if(p.route.lazy||b){o=!0,u>=0?s=s.slice(0,u+1):s=[s[0]];break}}}let d=n&&a?(c,p)=>{a(c,{location:n.location,params:n.matches?.[0]?.params??{},unstable_pattern:o6(n.matches),errorInfo:p})}:void 0;return s.reduceRight((c,p,m)=>{let g,b=!1,v=null,x=null;n&&(g=i&&p.route.id?i[p.route.id]:void 0,v=p.route.errorElement||w6,o&&(u<0&&m===0?(VD("route-fallback",!1,"No `HydrateFallback` element provided to render during initial hydration"),b=!0,x=null):u===m&&(b=!0,x=p.route.hydrateFallbackElement||null)));let w=t.concat(s.slice(0,m+1)),k=()=>{let N;return g?N=v:b?N=x:p.route.Component?N=he.createElement(p.route.Component,null):p.route.element?N=p.route.element:N=c,he.createElement(k6,{match:p,routeContext:{outlet:c,matches:w,isDataRoute:n!=null},children:N})};return n&&(p.route.ErrorBoundary||p.route.errorElement||m===0)?he.createElement(WD,{location:n.location,revalidation:n.revalidation,component:v,error:g,children:k(),routeContext:{outlet:null,matches:w,isDataRoute:!0},onError:d}):k()},null)}function qk(e){return`${e} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`}function N6(e){let t=he.useContext(Qh);return _n(t,qk(e)),t}function I6(e){let t=he.useContext(n0);return _n(t,qk(e)),t}function T6(e){let t=he.useContext(Ji);return _n(t,qk(e)),t}function Kk(e){let t=T6(e),n=t.matches[t.matches.length-1];return _n(n.route.id,`${e} can only be used on routes that contain a unique "id"`),n.route.id}function E6(){return Kk("useRouteId")}function C6(){let e=he.useContext(Gk),t=I6("useRouteError"),n=Kk("useRouteError");return e!==void 0?e:t.errors?.[n]}function A6(){let{router:e}=N6("useNavigate"),t=Kk("useNavigate"),n=he.useRef(!1);return UD(()=>{n.current=!0}),he.useCallback(async(r,s={})=>{Bs(n.current,PD),n.current&&(typeof r=="number"?await e.navigate(r):await e.navigate(r,{fromRouteId:t,...s}))},[e,t])}var p$={};function VD(e,t,n){!t&&!p$[e]&&(p$[e]=!0,Bs(!1,n))}he.memo($6);function $6({routes:e,future:t,state:n,onError:a}){return jD(e,void 0,n,a,t)}function Tm(e){_n(!1,"A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.")}function R6({basename:e="/",children:t=null,location:n,navigationType:a="POP",navigator:r,static:s=!1,unstable_useTransitions:i}){_n(!Sg(),"You cannot render a <Router> inside another <Router>. You should never have more than one in your app.");let o=e.replace(/^\/*/,"/"),u=he.useMemo(()=>({basename:o,navigator:r,static:s,unstable_useTransitions:i,future:{}}),[o,r,s,i]);typeof n=="string"&&(n=Zh(n));let{pathname:d="/",search:c="",hash:p="",state:m=null,key:g="default"}=n,b=he.useMemo(()=>{let v=Ki(d,o);return v==null?null:{location:{pathname:v,search:c,hash:p,state:m,key:g},navigationType:a}},[o,d,c,p,m,g,a]);return Bs(b!=null,`<Router basename="${o}"> is not able to match the URL "${d}${c}${p}" because it does not start with the basename, so the <Router> won't render anything.`),b==null?null:he.createElement(xs.Provider,{value:u},he.createElement(wg.Provider,{children:t,value:b}))}function D6({children:e,location:t}){return v6(kS(e),t)}function kS(e,t=[]){let n=[];return he.Children.forEach(e,(a,r)=>{if(!he.isValidElement(a))return;let s=[...t,r];if(a.type===he.Fragment){n.push.apply(n,kS(a.props.children,s));return}_n(a.type===Tm,`[${typeof a.type=="string"?a.type:a.type.name}] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`),_n(!a.props.index||!a.props.children,"An index route cannot have child routes.");let i={id:a.props.id||s.join("-"),caseSensitive:a.props.caseSensitive,element:a.props.element,Component:a.props.Component,index:a.props.index,path:a.props.path,middleware:a.props.middleware,loader:a.props.loader,action:a.props.action,hydrateFallbackElement:a.props.hydrateFallbackElement,HydrateFallback:a.props.HydrateFallback,errorElement:a.props.errorElement,ErrorBoundary:a.props.ErrorBoundary,hasErrorBoundary:a.props.hasErrorBoundary===!0||a.props.ErrorBoundary!=null||a.props.errorElement!=null,shouldRevalidate:a.props.shouldRevalidate,handle:a.props.handle,lazy:a.props.lazy};a.props.children&&(i.children=kS(a.props.children,s)),n.push(i)}),n}var uv="get",cv="application/x-www-form-urlencoded";function a0(e){return typeof HTMLElement<"u"&&e instanceof HTMLElement}function O6(e){return a0(e)&&e.tagName.toLowerCase()==="button"}function M6(e){return a0(e)&&e.tagName.toLowerCase()==="form"}function F6(e){return a0(e)&&e.tagName.toLowerCase()==="input"}function z6(e){return!!(e.metaKey||e.altKey||e.ctrlKey||e.shiftKey)}function L6(e,t){return e.button===0&&(!t||t==="_self")&&!z6(e)}var Ub=null;function B6(){if(Ub===null)try{new FormData(document.createElement("form"),0),Ub=!1}catch{Ub=!0}return Ub}var P6=new Set(["application/x-www-form-urlencoded","multipart/form-data","text/plain"]);function q1(e){return e!=null&&!P6.has(e)?(Bs(!1,`"${e}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${cv}"`),null):e}function U6(e,t){let n,a,r,s,i;if(M6(e)){let o=e.getAttribute("action");a=o?Ki(o,t):null,n=e.getAttribute("method")||uv,r=q1(e.getAttribute("enctype"))||cv,s=new FormData(e)}else if(O6(e)||F6(e)&&(e.type==="submit"||e.type==="image")){let o=e.form;if(o==null)throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');let u=e.getAttribute("formaction")||o.getAttribute("action");if(a=u?Ki(u,t):null,n=e.getAttribute("formmethod")||o.getAttribute("method")||uv,r=q1(e.getAttribute("formenctype"))||q1(o.getAttribute("enctype"))||cv,s=new FormData(o,e),!B6()){let{name:d,type:c,value:p}=e;if(c==="image"){let m=d?`${d}.`:"";s.append(`${m}x`,"0"),s.append(`${m}y`,"0")}else d&&s.append(d,p)}}else{if(a0(e))throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');n=uv,a=null,r=cv,i=e}return s&&r==="text/plain"&&(i=s,s=void 0),{action:a,method:n.toLowerCase(),encType:r,formData:s,body:i}}Object.getOwnPropertyNames(Object.prototype).sort().join("\0");function Xk(e,t){if(e===!1||e===null||typeof e>"u")throw new Error(t)}function j6(e,t,n){let a=typeof e=="string"?new URL(e,typeof window>"u"?"server://singlefetch/":window.location.origin):e;return a.pathname==="/"?a.pathname=`_root.${n}`:t&&Ki(a.pathname,t)==="/"?a.pathname=`${t.replace(/\/$/,"")}/_root.${n}`:a.pathname=`${a.pathname.replace(/\/$/,"")}.${n}`,a}async function W6(e,t){if(e.id in t)return t[e.id];try{let n=await import(e.module);return t[e.id]=n,n}catch(n){return console.error(`Error loading route module \`${e.module}\`, reloading page...`),console.error(n),window.__reactRouterContext&&window.__reactRouterContext.isSpaMode,window.location.reload(),new Promise(()=>{})}}function V6(e){return e==null?!1:e.href==null?e.rel==="preload"&&typeof e.imageSrcSet=="string"&&typeof e.imageSizes=="string":typeof e.rel=="string"&&typeof e.href=="string"}async function H6(e,t,n){let a=await Promise.all(e.map(async r=>{let s=t.routes[r.route.id];if(s){let i=await W6(s,n);return i.links?i.links():[]}return[]}));return X6(a.flat(1).filter(V6).filter(r=>r.rel==="stylesheet"||r.rel==="preload").map(r=>r.rel==="stylesheet"?{...r,rel:"prefetch",as:"style"}:{...r,rel:"prefetch"}))}function f$(e,t,n,a,r,s){let i=(u,d)=>n[d]?u.route.id!==n[d].route.id:!0,o=(u,d)=>n[d].pathname!==u.pathname||n[d].route.path?.endsWith("*")&&n[d].params["*"]!==u.params["*"];return s==="assets"?t.filter((u,d)=>i(u,d)||o(u,d)):s==="data"?t.filter((u,d)=>{let c=a.routes[u.route.id];if(!c||!c.hasLoader)return!1;if(i(u,d)||o(u,d))return!0;if(u.route.shouldRevalidate){let p=u.route.shouldRevalidate({currentUrl:new URL(r.pathname+r.search+r.hash,window.origin),currentParams:n[0]?.params||{},nextUrl:new URL(e,window.origin),nextParams:u.params,defaultShouldRevalidate:!0});if(typeof p=="boolean")return p}return!0}):[]}function G6(e,t,{includeHydrateFallback:n}={}){return q6(e.map(a=>{let r=t.routes[a.route.id];if(!r)return[];let s=[r.module];return r.clientActionModule&&(s=s.concat(r.clientActionModule)),r.clientLoaderModule&&(s=s.concat(r.clientLoaderModule)),n&&r.hydrateFallbackModule&&(s=s.concat(r.hydrateFallbackModule)),r.imports&&(s=s.concat(r.imports)),s}).flat(1))}function q6(e){return[...new Set(e)]}function K6(e){let t={},n=Object.keys(e).sort();for(let a of n)t[a]=e[a];return t}function X6(e,t){let n=new Set;return new Set(t),e.reduce((a,r)=>{let s=JSON.stringify(K6(r));return n.has(s)||(n.add(s),a.push({key:s,link:r})),a},[])}function HD(){let e=he.useContext(Qh);return Xk(e,"You must render this element inside a <DataRouterContext.Provider> element"),e}function Y6(){let e=he.useContext(n0);return Xk(e,"You must render this element inside a <DataRouterStateContext.Provider> element"),e}var Yk=he.createContext(void 0);Yk.displayName="FrameworkContext";function GD(){let e=he.useContext(Yk);return Xk(e,"You must render this element inside a <HydratedRouter> element"),e}function J6(e,t){let n=he.useContext(Yk),[a,r]=he.useState(!1),[s,i]=he.useState(!1),{onFocus:o,onBlur:u,onMouseEnter:d,onMouseLeave:c,onTouchStart:p}=t,m=he.useRef(null);he.useEffect(()=>{if(e==="render"&&i(!0),e==="viewport"){let v=w=>{w.forEach(k=>{i(k.isIntersecting)})},x=new IntersectionObserver(v,{threshold:.5});return m.current&&x.observe(m.current),()=>{x.disconnect()}}},[e]),he.useEffect(()=>{if(a){let v=setTimeout(()=>{i(!0)},100);return()=>{clearTimeout(v)}}},[a]);let g=()=>{r(!0)},b=()=>{r(!1),i(!1)};return n?e!=="intent"?[s,m,{}]:[s,m,{onFocus:wm(o,g),onBlur:wm(u,b),onMouseEnter:wm(d,g),onMouseLeave:wm(c,b),onTouchStart:wm(p,g)}]:[!1,m,{}]}function wm(e,t){return n=>{e&&e(n),n.defaultPrevented||t(n)}}function Z6({page:e,...t}){let{router:n}=HD(),a=he.useMemo(()=>CD(n.routes,e,n.basename),[n.routes,e,n.basename]);return a?he.createElement(eH,{page:e,matches:a,...t}):null}function Q6(e){let{manifest:t,routeModules:n}=GD(),[a,r]=he.useState([]);return he.useEffect(()=>{let s=!1;return H6(e,t,n).then(i=>{s||r(i)}),()=>{s=!0}},[e,t,n]),a}function eH({page:e,matches:t,...n}){let a=gl(),{manifest:r,routeModules:s}=GD(),{basename:i}=HD(),{loaderData:o,matches:u}=Y6(),d=he.useMemo(()=>f$(e,t,u,r,a,"data"),[e,t,u,r,a]),c=he.useMemo(()=>f$(e,t,u,r,a,"assets"),[e,t,u,r,a]),p=he.useMemo(()=>{if(e===a.pathname+a.search+a.hash)return[];let b=new Set,v=!1;if(t.forEach(w=>{let k=r.routes[w.route.id];!k||!k.hasLoader||(!d.some(N=>N.route.id===w.route.id)&&w.route.id in o&&s[w.route.id]?.shouldRevalidate||k.hasClientLoader?v=!0:b.add(w.route.id))}),b.size===0)return[];let x=j6(e,i,"data");return v&&b.size>0&&x.searchParams.set("_routes",t.filter(w=>b.has(w.route.id)).map(w=>w.route.id).join(",")),[x.pathname+x.search]},[i,o,a,r,d,t,e,s]),m=he.useMemo(()=>G6(c,r),[c,r]),g=Q6(c);return he.createElement(he.Fragment,null,p.map(b=>he.createElement("link",{key:b,rel:"prefetch",as:"fetch",href:b,...n})),m.map(b=>he.createElement("link",{key:b,rel:"modulepreload",href:b,...n})),g.map(({key:b,link:v})=>he.createElement("link",{key:b,nonce:n.nonce,...v})))}function tH(...e){return t=>{e.forEach(n=>{typeof n=="function"?n(t):n!=null&&(n.current=t)})}}var nH=typeof window<"u"&&typeof window.document<"u"&&typeof window.document.createElement<"u";try{nH&&(window.__reactRouterVersion="7.11.0")}catch{}function aH({basename:e,children:t,unstable_useTransitions:n,window:a}){let r=he.useRef();r.current==null&&(r.current=FV({window:a,v5Compat:!0}));let s=r.current,[i,o]=he.useState({action:s.action,location:s.location}),u=he.useCallback(d=>{n===!1?o(d):he.startTransition(()=>o(d))},[n]);return he.useLayoutEffect(()=>s.listen(u),[s,u]),he.createElement(R6,{basename:e,children:t,location:i.location,navigationType:i.action,navigator:s,unstable_useTransitions:n})}var qD=/^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,Ih=he.forwardRef(function({onClick:t,discover:n="render",prefetch:a="none",relative:r,reloadDocument:s,replace:i,state:o,target:u,to:d,preventScrollReset:c,viewTransition:p,unstable_defaultShouldRevalidate:m,...g},b){let{basename:v,unstable_useTransitions:x}=he.useContext(xs),w=typeof d=="string"&&qD.test(d),k=FD(d,v);d=k.to;let N=g6(d,{relative:r}),[I,T,$]=J6(a,g),D=oH(d,{replace:i,state:o,target:u,preventScrollReset:c,relative:r,viewTransition:p,unstable_defaultShouldRevalidate:m,unstable_useTransitions:x});function M(V){t&&t(V),V.defaultPrevented||D(V)}let B=he.createElement("a",{...g,...$,href:k.absoluteURL||N,onClick:k.isExternal||s?t:M,ref:tH(b,T),target:u,"data-discover":!w&&n==="render"?"true":void 0});return I&&!w?he.createElement(he.Fragment,null,B,he.createElement(Z6,{page:N})):B});Ih.displayName="Link";var rH=he.forwardRef(function({"aria-current":t="page",caseSensitive:n=!1,className:a="",end:r=!1,style:s,to:i,viewTransition:o,children:u,...d},c){let p=kg(i,{relative:d.relative}),m=gl(),g=he.useContext(n0),{navigator:b,basename:v}=he.useContext(xs),x=g!=null&&hH(p)&&o===!0,w=b.encodeLocation?b.encodeLocation(p).pathname:p.pathname,k=m.pathname,N=g&&g.navigation&&g.navigation.location?g.navigation.location.pathname:null;n||(k=k.toLowerCase(),N=N?N.toLowerCase():null,w=w.toLowerCase()),N&&v&&(N=Ki(N,v)||N);const I=w!=="/"&&w.endsWith("/")?w.length-1:w.length;let T=k===w||!r&&k.startsWith(w)&&k.charAt(I)==="/",$=N!=null&&(N===w||!r&&N.startsWith(w)&&N.charAt(w.length)==="/"),D={isActive:T,isPending:$,isTransitioning:x},M=T?t:void 0,B;typeof a=="function"?B=a(D):B=[a,T?"active":null,$?"pending":null,x?"transitioning":null].filter(Boolean).join(" ");let V=typeof s=="function"?s(D):s;return he.createElement(Ih,{...d,"aria-current":M,className:B,ref:c,style:V,to:i,viewTransition:o},typeof u=="function"?u(D):u)});rH.displayName="NavLink";var sH=he.forwardRef(({discover:e="render",fetcherKey:t,navigate:n,reloadDocument:a,replace:r,state:s,method:i=uv,action:o,onSubmit:u,relative:d,preventScrollReset:c,viewTransition:p,unstable_defaultShouldRevalidate:m,...g},b)=>{let{unstable_useTransitions:v}=he.useContext(xs),x=cH(),w=dH(o,{relative:d}),k=i.toLowerCase()==="get"?"get":"post",N=typeof o=="string"&&qD.test(o),I=T=>{if(u&&u(T),T.defaultPrevented)return;T.preventDefault();let $=T.nativeEvent.submitter,D=$?.getAttribute("formmethod")||i,M=()=>x($||T.currentTarget,{fetcherKey:t,method:D,navigate:n,replace:r,state:s,relative:d,preventScrollReset:c,viewTransition:p,unstable_defaultShouldRevalidate:m});v&&n!==!1?he.startTransition(()=>M()):M()};return he.createElement("form",{ref:b,method:k,action:w,onSubmit:a?u:I,...g,"data-discover":!N&&e==="render"?"true":void 0})});sH.displayName="Form";function iH(e){return`${e} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`}function KD(e){let t=he.useContext(Qh);return _n(t,iH(e)),t}function oH(e,{target:t,replace:n,state:a,preventScrollReset:r,relative:s,viewTransition:i,unstable_defaultShouldRevalidate:o,unstable_useTransitions:u}={}){let d=y6(),c=gl(),p=kg(e,{relative:s});return he.useCallback(m=>{if(L6(m,t)){m.preventDefault();let g=n!==void 0?n:Km(c)===Km(p),b=()=>d(e,{replace:g,state:a,preventScrollReset:r,relative:s,viewTransition:i,unstable_defaultShouldRevalidate:o});u?he.startTransition(()=>b()):b()}},[c,d,p,n,a,t,e,r,s,i,o,u])}var lH=0,uH=()=>`__${String(++lH)}__`;function cH(){let{router:e}=KD("useSubmit"),{basename:t}=he.useContext(xs),n=E6(),a=e.fetch,r=e.navigate;return he.useCallback(async(s,i={})=>{let{action:o,method:u,encType:d,formData:c,body:p}=U6(s,t);if(i.navigate===!1){let m=i.fetcherKey||uH();await a(m,n,i.action||o,{unstable_defaultShouldRevalidate:i.unstable_defaultShouldRevalidate,preventScrollReset:i.preventScrollReset,formData:c,body:p,formMethod:i.method||u,formEncType:i.encType||d,flushSync:i.flushSync})}else await r(i.action||o,{unstable_defaultShouldRevalidate:i.unstable_defaultShouldRevalidate,preventScrollReset:i.preventScrollReset,formData:c,body:p,formMethod:i.method||u,formEncType:i.encType||d,replace:i.replace,state:i.state,fromRouteId:n,flushSync:i.flushSync,viewTransition:i.viewTransition})},[a,r,t,n])}function dH(e,{relative:t}={}){let{basename:n}=he.useContext(xs),a=he.useContext(Ji);_n(a,"useFormAction must be used inside a RouteContext");let[r]=a.matches.slice(-1),s={...kg(e||".",{relative:t})},i=gl();if(e==null){s.search=i.search;let o=new URLSearchParams(s.search),u=o.getAll("index");if(u.some(c=>c==="")){o.delete("index"),u.filter(p=>p).forEach(p=>o.append("index",p));let c=o.toString();s.search=c?`?${c}`:""}}return(!e||e===".")&&r.route.index&&(s.search=s.search?s.search.replace(/^\?/,"?index&"):"?index"),n!=="/"&&(s.pathname=s.pathname==="/"?n:Vi([n,s.pathname])),Km(s)}function hH(e,{relative:t}={}){let n=he.useContext(LD);_n(n!=null,"`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?");let{basename:a}=KD("useViewTransitionState"),r=kg(e,{relative:t});if(!n.isTransitioning)return!1;let s=Ki(n.currentLocation.pathname,a)||n.currentLocation.pathname,i=Ki(n.nextLocation.pathname,a)||n.nextLocation.pathname;return xv(r.pathname,i)!=null||xv(r.pathname,s)!=null}const pH=e=>e.replace(/([a-z0-9])([A-Z])/g,"$1-$2").toLowerCase(),fH=e=>e.replace(/^([A-Z])|[\s-_]+(\w)/g,(t,n,a)=>a?a.toUpperCase():n.toLowerCase()),m$=e=>{const t=fH(e);return t.charAt(0).toUpperCase()+t.slice(1)},XD=(...e)=>e.filter((t,n,a)=>!!t&&t.trim()!==""&&a.indexOf(t)===n).join(" ").trim(),mH=e=>{for(const t in e)if(t.startsWith("aria-")||t==="role"||t==="title")return!0};var gH={xmlns:"http://www.w3.org/2000/svg",width:24,height:24,viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:2,strokeLinecap:"round",strokeLinejoin:"round"};const yH=he.forwardRef(({color:e="currentColor",size:t=24,strokeWidth:n=2,absoluteStrokeWidth:a,className:r="",children:s,iconNode:i,...o},u)=>he.createElement("svg",{ref:u,...gH,width:t,height:t,stroke:e,strokeWidth:a?Number(n)*24/Number(t):n,className:XD("lucide",r),...!s&&!mH(o)&&{"aria-hidden":"true"},...o},[...i.map(([d,c])=>he.createElement(d,c)),...Array.isArray(s)?s:[s]]));const Rn=(e,t)=>{const n=he.forwardRef(({className:a,...r},s)=>he.createElement(yH,{ref:s,iconNode:t,className:XD(`lucide-${pH(m$(e))}`,`lucide-${e}`,a),...r}));return n.displayName=m$(e),n};const bH=[["path",{d:"M8 2v4",key:"1cmpym"}],["path",{d:"M16 2v4",key:"4m81vk"}],["rect",{width:"18",height:"18",x:"3",y:"4",rx:"2",key:"1hopcy"}],["path",{d:"M3 10h18",key:"8toen8"}]],vH=Rn("calendar",bH);const xH=[["path",{d:"M5 21v-6",key:"1hz6c0"}],["path",{d:"M12 21V9",key:"uvy0l4"}],["path",{d:"M19 21V3",key:"11j9sm"}]],wH=Rn("chart-no-axes-column-increasing",xH);const SH=[["circle",{cx:"12",cy:"12",r:"10",key:"1mglay"}],["path",{d:"m15 9-6 6",key:"1uzhvr"}],["path",{d:"m9 9 6 6",key:"z0biqf"}]],kH=Rn("circle-x",SH);const _H=[["path",{d:"M6 22a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h8a2.4 2.4 0 0 1 1.704.706l3.588 3.588A2.4 2.4 0 0 1 20 8v12a2 2 0 0 1-2 2z",key:"1oefj6"}],["path",{d:"M14 2v5a1 1 0 0 0 1 1h5",key:"wfsgrz"}],["path",{d:"M12 18v-6",key:"17g6i2"}],["path",{d:"m9 15 3 3 3-3",key:"1npd3o"}]],NH=Rn("file-down",_H);const IH=[["rect",{width:"7",height:"9",x:"3",y:"3",rx:"1",key:"10lvy0"}],["rect",{width:"7",height:"5",x:"14",y:"3",rx:"1",key:"16une8"}],["rect",{width:"7",height:"9",x:"14",y:"12",rx:"1",key:"1hutg5"}],["rect",{width:"7",height:"5",x:"3",y:"16",rx:"1",key:"ldoo1y"}]],TH=Rn("layout-dashboard",IH);const EH=[["path",{d:"M12 2v4",key:"3427ic"}],["path",{d:"m16.2 7.8 2.9-2.9",key:"r700ao"}],["path",{d:"M18 12h4",key:"wj9ykh"}],["path",{d:"m16.2 16.2 2.9 2.9",key:"1bxg5t"}],["path",{d:"M12 18v4",key:"jadmvz"}],["path",{d:"m4.9 19.1 2.9-2.9",key:"bwix9q"}],["path",{d:"M2 12h4",key:"j09sii"}],["path",{d:"m4.9 4.9 2.9 2.9",key:"giyufr"}]],wv=Rn("loader",EH);const CH=[["path",{d:"m22 7-8.991 5.727a2 2 0 0 1-2.009 0L2 7",key:"132q7q"}],["rect",{x:"2",y:"4",width:"20",height:"16",rx:"2",key:"izxlao"}]],AH=Rn("mail",CH);const $H=[["path",{d:"M13.832 16.568a1 1 0 0 0 1.213-.303l.355-.465A2 2 0 0 1 17 15h3a2 2 0 0 1 2 2v3a2 2 0 0 1-2 2A18 18 0 0 1 2 4a2 2 0 0 1 2-2h3a2 2 0 0 1 2 2v3a2 2 0 0 1-.8 1.6l-.468.351a1 1 0 0 0-.292 1.233 14 14 0 0 0 6.392 6.384",key:"9njp5v"}]],YD=Rn("phone",$H);const RH=[["path",{d:"M5 12h14",key:"1ays0h"}],["path",{d:"M12 5v14",key:"s699le"}]],DH=Rn("plus",RH);const OH=[["path",{d:"M15.2 3a2 2 0 0 1 1.4.6l3.8 3.8a2 2 0 0 1 .6 1.4V19a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2z",key:"1c8476"}],["path",{d:"M17 21v-7a1 1 0 0 0-1-1H8a1 1 0 0 0-1 1v7",key:"1ydtos"}],["path",{d:"M7 3v4a1 1 0 0 0 1 1h7",key:"t51u73"}]],JD=Rn("save",OH);const MH=[["path",{d:"M3 7V5a2 2 0 0 1 2-2h2",key:"aa7l1z"}],["path",{d:"M17 3h2a2 2 0 0 1 2 2v2",key:"4qcy5o"}],["path",{d:"M21 17v2a2 2 0 0 1-2 2h-2",key:"6vwrx8"}],["path",{d:"M7 21H5a2 2 0 0 1-2-2v-2",key:"ioqczr"}],["path",{d:"M8 14s1.5 2 4 2 4-2 4-2",key:"1y1vjs"}],["path",{d:"M9 9h.01",key:"1q5me6"}],["path",{d:"M15 9h.01",key:"x1ddxp"}]],g$=Rn("scan-face",MH);const FH=[["path",{d:"M3 7V5a2 2 0 0 1 2-2h2",key:"aa7l1z"}],["path",{d:"M17 3h2a2 2 0 0 1 2 2v2",key:"4qcy5o"}],["path",{d:"M21 17v2a2 2 0 0 1-2 2h-2",key:"6vwrx8"}],["path",{d:"M7 21H5a2 2 0 0 1-2-2v-2",key:"ioqczr"}],["path",{d:"M7 12h10",key:"b7w52i"}]],zH=Rn("scan-line",FH);const LH=[["path",{d:"m21 21-4.34-4.34",key:"14j7rj"}],["circle",{cx:"11",cy:"11",r:"8",key:"4ej97u"}]],ZD=Rn("search",LH);const BH=[["path",{d:"M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z",key:"oel41y"}],["path",{d:"m9 12 2 2 4-4",key:"dzmm74"}]],PH=Rn("shield-check",BH);const UH=[["path",{d:"M12 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7",key:"1m0v6g"}],["path",{d:"M18.375 2.625a1 1 0 0 1 3 3l-9.013 9.014a2 2 0 0 1-.853.505l-2.873.84a.5.5 0 0 1-.62-.62l.84-2.873a2 2 0 0 1 .506-.852z",key:"ohrbg2"}]],jH=Rn("square-pen",UH);const WH=[["path",{d:"M10 11v6",key:"nco0om"}],["path",{d:"M14 11v6",key:"outv1u"}],["path",{d:"M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6",key:"miytrc"}],["path",{d:"M3 6h18",key:"d0wm0j"}],["path",{d:"M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2",key:"e791ji"}]],VH=Rn("trash-2",WH);const HH=[["path",{d:"m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3",key:"wmoenq"}],["path",{d:"M12 9v4",key:"juzpu7"}],["path",{d:"M12 17h.01",key:"p32p05"}]],_S=Rn("triangle-alert",HH);const GH=[["path",{d:"m16 11 2 2 4-4",key:"9rsbq5"}],["path",{d:"M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2",key:"1yyitq"}],["circle",{cx:"9",cy:"7",r:"4",key:"nufk8"}]],Pm=Rn("user-check",GH);const qH=[["path",{d:"M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2",key:"1yyitq"}],["circle",{cx:"9",cy:"7",r:"4",key:"nufk8"}],["line",{x1:"19",x2:"19",y1:"8",y2:"14",key:"1bvyxn"}],["line",{x1:"22",x2:"16",y1:"11",y2:"11",key:"1shjgl"}]],KH=Rn("user-plus",qH);const XH=[["path",{d:"M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2",key:"1yyitq"}],["circle",{cx:"9",cy:"7",r:"4",key:"nufk8"}],["line",{x1:"17",x2:"22",y1:"8",y2:"13",key:"3nzzx3"}],["line",{x1:"22",x2:"17",y1:"8",y2:"13",key:"1swrse"}]],y$=Rn("user-x",XH);const YH=[["path",{d:"M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2",key:"1yyitq"}],["path",{d:"M16 3.128a4 4 0 0 1 0 7.744",key:"16gr8j"}],["path",{d:"M22 21v-2a4 4 0 0 0-3-3.87",key:"kshegd"}],["circle",{cx:"9",cy:"7",r:"4",key:"nufk8"}]],NS=Rn("users",YH);const JH=[["path",{d:"M18 6 6 18",key:"1bl5f8"}],["path",{d:"m6 6 12 12",key:"d8bk6v"}]],ZH=Rn("x",JH);var QH=Object.defineProperty,eG=(e=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(e,{get:(t,n)=>(typeof require<"u"?require:t)[n]}):e)(function(e){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+e+'" is not supported')}),Jk=(e,t)=>{for(var n in t)QH(e,n,{get:t[n],enumerable:!0})},IS={};Jk(IS,{Abs:()=>tp,Acos:()=>Gu,Acosh:()=>qu,AdadeltaOptimizer:()=>y2,AdagradOptimizer:()=>b2,AdamOptimizer:()=>v2,AdamaxOptimizer:()=>x2,Add:()=>bl,AddN:()=>Ku,All:()=>np,Any:()=>ap,ArgMax:()=>rp,ArgMin:()=>sp,Asin:()=>Xu,Asinh:()=>Yu,Atan:()=>Ju,Atan2:()=>Qu,Atanh:()=>Zu,AvgPool:()=>ec,AvgPool3D:()=>ip,AvgPool3DGrad:()=>Tg,AvgPoolGrad:()=>Ig,BackendWasm:()=>oU,BatchMatMul:()=>tc,BatchToSpaceND:()=>op,Bincount:()=>lp,BitwiseAnd:()=>up,BroadcastArgs:()=>Eg,BroadcastTo:()=>pO,Callback:()=>iz,CallbackList:()=>QF,Cast:()=>nc,Ceil:()=>ac,ClipByValue:()=>vl,Complex:()=>l0,ComplexAbs:()=>Cg,Concat:()=>cp,Conv2D:()=>rc,Conv2DBackpropFilter:()=>u0,Conv2DBackpropInput:()=>sc,Conv3D:()=>ic,Conv3DBackpropFilterV2:()=>dp,Conv3DBackpropInputV2:()=>hp,Cos:()=>oc,Cosh:()=>lc,CropAndResize:()=>fp,Cumprod:()=>pp,Cumsum:()=>uc,CustomCallback:()=>t3,DataStorage:()=>s0,DenseBincount:()=>Ag,DepthToSpace:()=>mp,DepthwiseConv2dNative:()=>cc,DepthwiseConv2dNativeBackpropFilter:()=>c0,DepthwiseConv2dNativeBackpropInput:()=>d0,Diag:()=>$g,Dilation2D:()=>dc,Dilation2DBackpropFilter:()=>Fh,Dilation2DBackpropInput:()=>Mh,Draw:()=>h0,ENV:()=>n_,EarlyStopping:()=>oz,Einsum:()=>p0,Elu:()=>pc,EluGrad:()=>gp,Environment:()=>dO,Equal:()=>yp,Erf:()=>fc,Exp:()=>mc,ExpandDims:()=>bp,Expm1:()=>gc,FFT:()=>f0,Fill:()=>Rg,FlipLeftRight:()=>vp,Floor:()=>yc,FloorDiv:()=>bc,FromPixels:()=>Nv,FusedBatchNorm:()=>vc,FusedConv2D:()=>Iu,FusedDepthwiseConv2D:()=>Tu,GPGPUContext:()=>bv,GatherNd:()=>wp,GatherV2:()=>xp,GraphModel:()=>iI,Greater:()=>Sp,GreaterEqual:()=>xc,History:()=>e3,IFFT:()=>m0,Identity:()=>wc,Imag:()=>g0,InputSpec:()=>Bn,IsFinite:()=>Sc,IsInf:()=>kc,IsNan:()=>_c,KernelBackend:()=>_g,LRN:()=>Ec,LRNGrad:()=>Cp,LayerVariable:()=>HF,LayersModel:()=>Gi,LeakyRelu:()=>Nc,Less:()=>kp,LessEqual:()=>_p,LinSpace:()=>Np,Log:()=>Ic,Log1p:()=>Tc,LogSoftmax:()=>mO,LogicalAnd:()=>Ip,LogicalNot:()=>Tp,LogicalOr:()=>Ep,LogicalXor:()=>fO,LowerBound:()=>HG,MathBackendCPU:()=>uI,MathBackendWebGL:()=>zI,MatrixBandPart:()=>GG,Max:()=>Cc,MaxPool:()=>$c,MaxPool3D:()=>Ap,MaxPool3DGrad:()=>Og,MaxPoolGrad:()=>Dg,MaxPoolWithArgmax:()=>Mg,Maximum:()=>Ac,Mean:()=>Rc,Min:()=>Dc,Minimum:()=>Oc,MirrorPad:()=>Mc,Mod:()=>Fc,MomentumOptimizer:()=>w2,Multinomial:()=>$p,Multiply:()=>zc,Neg:()=>Rp,NonMaxSuppressionV3:()=>Op,NonMaxSuppressionV4:()=>Mp,NonMaxSuppressionV5:()=>Fp,NotEqual:()=>Dp,OP_SCOPE_SUFFIX:()=>o_,OneHot:()=>Lc,OnesLike:()=>zp,Optimizer:()=>ao,OptimizerConstructors:()=>_F,Pack:()=>Lp,PadV2:()=>Bc,Pool:()=>qG,Pow:()=>Pc,Prelu:()=>Uc,Prod:()=>jc,RMSPropOptimizer:()=>S2,RNN:()=>ro,RaggedGather:()=>y0,RaggedRange:()=>b0,RaggedTensorToTensor:()=>v0,Range:()=>Fg,Rank:()=>CS,Real:()=>x0,RealDiv:()=>hc,Reciprocal:()=>Wc,Reduction:()=>Ha,Relu:()=>Vc,Relu6:()=>qc,Reshape:()=>Bp,ResizeBilinear:()=>Gc,ResizeBilinearGrad:()=>Up,ResizeNearestNeighbor:()=>Hc,ResizeNearestNeighborGrad:()=>Pp,Reverse:()=>Kc,RotateWithOffset:()=>nf,Round:()=>Xc,Rsqrt:()=>Yc,SGDOptimizer:()=>nx,ScatterNd:()=>jp,SearchSorted:()=>Vp,Select:()=>Hp,Selu:()=>Jc,Sequential:()=>mx,Sigmoid:()=>td,Sign:()=>ed,Sin:()=>Zc,Sinh:()=>Qc,Slice:()=>Gp,Softmax:()=>sd,Softplus:()=>nd,SpaceToBatchND:()=>qp,SparseFillEmptyRows:()=>zg,SparseReshape:()=>Xp,SparseSegmentMean:()=>Lg,SparseSegmentSum:()=>Bg,SparseToDense:()=>Yp,SplitV:()=>Kp,Sqrt:()=>ad,Square:()=>Pg,SquaredDifference:()=>id,StaticRegexReplace:()=>Ug,Step:()=>wl,StridedSlice:()=>Jp,StringNGrams:()=>jg,StringSplit:()=>Wg,StringToHashBucketFast:()=>Vg,Sub:()=>od,Sum:()=>rd,SymbolicTensor:()=>js,Tan:()=>ld,Tanh:()=>ud,Tensor:()=>dt,TensorBuffer:()=>Pn,TensorScatterUpdate:()=>Wp,Tile:()=>xl,TopK:()=>Zp,Transform:()=>Qp,Transpose:()=>Hi,Unique:()=>Hg,Unpack:()=>ef,UnsortedSegmentSum:()=>Gg,UpperBound:()=>KG,Variable:()=>Eu,ZerosLike:()=>tf,_FusedMatMul:()=>Nu,abs:()=>Ln,acos:()=>h_,acosh:()=>p_,add:()=>ye,addN:()=>WO,all:()=>N0,any:()=>eg,argMax:()=>Ru,argMin:()=>f_,asin:()=>m_,asinh:()=>g_,atan:()=>y_,atan2:()=>b_,atanh:()=>v_,avgPool:()=>eo,avgPool3d:()=>w_,backend:()=>l_,backend_util:()=>O,basicLSTMCell:()=>qO,batchNorm:()=>cd,batchNorm2d:()=>S_,batchNorm3d:()=>k_,batchNorm4d:()=>__,batchToSpaceND:()=>Qg,bincount:()=>N_,bitwiseAnd:()=>KO,booleanMaskAsync:()=>zM,broadcastArgs:()=>XO,broadcastTo:()=>xu,broadcast_util:()=>af,browser:()=>hy,buffer:()=>mt,callbacks:()=>Wae,cast:()=>Te,ceil:()=>I_,clipByValue:()=>za,clone:()=>li,complex:()=>Xi,concat:()=>Yt,concat1d:()=>T_,concat2d:()=>E_,concat3d:()=>C_,concat4d:()=>A_,constraints:()=>XF,conv1d:()=>I0,conv2d:()=>Ka,conv2dTranspose:()=>T0,conv3d:()=>R_,conv3dTranspose:()=>D_,copyRegisteredKernels:()=>ZG,cos:()=>ey,cosh:()=>E0,cosineWindow:()=>J0,cumprod:()=>ag,cumsum:()=>C0,customGrad:()=>pi,data:()=>$z,denseBincount:()=>Ev,deprecationWarn:()=>CO,depthToSpace:()=>O_,depthwiseConv2d:()=>dd,deregisterOp:()=>Gae,device_util:()=>Yg,diag:()=>JO,dilation2d:()=>M_,disableDeprecationWarnings:()=>E5,dispose:()=>it,disposeVariables:()=>C5,div:()=>Le,divNoNan:()=>F_,dot:()=>z_,dropout:()=>h2,einsum:()=>du,elu:()=>rf,enableDebugMode:()=>T5,enableProdMode:()=>I5,enclosingPowerOfTwo:()=>p2,engine:()=>ms,ensureShape:()=>QO,env:()=>oe,equal:()=>Ar,erf:()=>A0,euclideanNorm:()=>P_,exp:()=>La,expandDims:()=>da,expm1:()=>U_,eye:()=>$0,fft:()=>cy,fill:()=>Cr,findBackend:()=>M5,findBackendFactory:()=>F5,floor:()=>of,floorDiv:()=>_0,forceHalfFloat:()=>t4,fused:()=>Vh,gather:()=>lf,gatherND:()=>UM,gather_util:()=>N2,getBackend:()=>AO,getGradient:()=>TS,getKernel:()=>Jm,getKernelsForBackend:()=>Iv,getThreadsCount:()=>YIe,gpgpu_util:()=>RB,grad:()=>fK,grads:()=>mK,greater:()=>Qa,greaterEqual:()=>to,ifft:()=>Wh,imag:()=>ty,image:()=>Gr,inTopKAsync:()=>jM,initializers:()=>YF,input:()=>m3,io:()=>Na,irfft:()=>V0,isFinite:()=>j_,isInf:()=>W_,isNaN:()=>V_,keep:()=>Zn,kernel_impls:()=>yi,layers:()=>JF,leakyRelu:()=>ny,less:()=>Bh,lessEqual:()=>kl,linalg:()=>g2,linspace:()=>rM,loadGraphModel:()=>Zre,loadGraphModelSync:()=>Qre,loadLayersModel:()=>Lte,localResponseNormalization:()=>H_,log:()=>$r,log1p:()=>ay,logSigmoid:()=>G_,logSoftmax:()=>D0,logSumExp:()=>ry,logicalAnd:()=>bs,logicalNot:()=>sy,logicalOr:()=>O0,logicalXor:()=>q_,losses:()=>eF,lowerBound:()=>iM,matMul:()=>pt,math:()=>dF,max:()=>Yr,maxPool:()=>la,maxPool3d:()=>K_,maxPoolWithArgmax:()=>oM,maximum:()=>gi,mean:()=>vn,memory:()=>FS,meshgrid:()=>lM,metrics:()=>az,min:()=>Lh,minimum:()=>ol,mirrorPad:()=>X_,mod:()=>Y_,model:()=>Ute,models:()=>rz,moments:()=>iy,movingAverage:()=>LM,mul:()=>Y,multiRNNCell:()=>uM,multinomial:()=>cM,neg:()=>un,nextFrame:()=>I2,norm:()=>sf,notEqual:()=>Mu,oneHot:()=>Ph,ones:()=>or,onesLike:()=>Rr,op:()=>X,outerProduct:()=>dM,pad:()=>Vs,pad1d:()=>hM,pad2d:()=>pM,pad3d:()=>fM,pad4d:()=>mM,pool:()=>J_,pow:()=>hi,prelu:()=>ly,print:()=>d_,prod:()=>Z_,profile:()=>A5,raggedGather:()=>gM,raggedRange:()=>yM,raggedTensorToTensor:()=>bM,rand:()=>vM,randomGamma:()=>kM,randomNormal:()=>F0,randomStandardNormal:()=>_M,randomUniform:()=>_l,randomUniformInt:()=>NM,range:()=>Fu,ready:()=>D5,real:()=>Uh,reciprocal:()=>a2,registerBackend:()=>k0,registerCallbackConstructor:()=>Wte,registerGradient:()=>gO,registerKernel:()=>qg,registerOp:()=>Hae,regularizers:()=>sz,relu:()=>jt,relu6:()=>z0,removeBackend:()=>O5,reshape:()=>te,reverse:()=>Qr,reverse1d:()=>IM,reverse2d:()=>TM,reverse3d:()=>EM,reverse4d:()=>CM,rfft:()=>dy,round:()=>L0,rsqrt:()=>B0,scalar:()=>He,scatterND:()=>BM,scatter_util:()=>q0,searchSorted:()=>M0,selu:()=>P0,separableConv2d:()=>uf,sequential:()=>jte,serialization:()=>_e,setBackend:()=>R5,setPlatform:()=>z5,setThreadsCount:()=>XIe,setWasmPath:()=>qIe,setWasmPaths:()=>KIe,setWebGLContext:()=>nB,setdiff1dAsync:()=>AM,shared:()=>cI,sigmoid:()=>ys,sign:()=>r2,signal:()=>QM,sin:()=>U0,sinh:()=>j0,slice:()=>wt,slice1d:()=>uy,slice2d:()=>W0,slice3d:()=>cf,slice4d:()=>jh,slice_util:()=>ea,softmax:()=>Nl,softplus:()=>hd,spaceToBatchND:()=>oy,sparse:()=>tF,sparseToDense:()=>PM,spectral:()=>ZM,split:()=>lr,sqrt:()=>fa,square:()=>Xt,squaredDifference:()=>H0,squeeze:()=>Il,stack:()=>Un,step:()=>pd,stridedSlice:()=>s2,string:()=>nF,sub:()=>Fe,sum:()=>Be,sumOutType:()=>S0,tan:()=>i2,tanh:()=>il,tensor:()=>qa,tensor1d:()=>Lt,tensor2d:()=>ui,tensor3d:()=>G0,tensor4d:()=>ll,tensor5d:()=>$M,tensor6d:()=>RM,tensorScatterUpdate:()=>OM,tensor_util:()=>Fs,test_util:()=>xM,tidy:()=>ne,tile:()=>Er,time:()=>$5,topk:()=>l2,train:()=>ou,transpose:()=>ft,truncatedNormal:()=>X0,unique:()=>u2,unregisterGradient:()=>JG,unregisterKernel:()=>YG,unsortedSegmentSum:()=>Y0,unstack:()=>Nn,upcastType:()=>Jr,upperBound:()=>MM,util:()=>E,valueAndGrad:()=>gK,valueAndGrads:()=>yK,variable:()=>c2,variableGrads:()=>sM,version:()=>aTe,version_converter:()=>tse,version_core:()=>UY,version_cpu:()=>noe,version_layers:()=>X2,version_wasm:()=>JIe,version_webgl:()=>Hfe,webgl:()=>Gfe,webgl_util:()=>tB,where:()=>pa,whereAsync:()=>d2,zeros:()=>xn,zerosLike:()=>_t});var tG=Object.create,Zk=Object.defineProperty,nG=Object.getOwnPropertyDescriptor,aG=Object.getOwnPropertyNames,rG=Object.getPrototypeOf,sG=Object.prototype.hasOwnProperty,Wn=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),ot=(e,t)=>{for(var n in t)Zk(e,n,{get:t[n],enumerable:!0})},iG=(e,t,n,a)=>{if(t&&typeof t=="object"||typeof t=="function")for(let r of aG(t))!sG.call(e,r)&&r!==n&&Zk(e,r,{get:()=>t[r],enumerable:!(a=nG(t,r))||a.enumerable});return e},yl=(e,t,n)=>(n=e!=null?tG(rG(e)):{},iG(!e||!e.__esModule?Zk(n,"default",{value:e,enumerable:!0}):n,e)),oG=Wn((e,t)=>{t.exports=a;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function a(R,H,Z){this.low=R|0,this.high=H|0,this.unsigned=!!Z}a.prototype.__isLong__,Object.defineProperty(a.prototype,"__isLong__",{value:!0});function r(R){return(R&&R.__isLong__)===!0}a.isLong=r;var s={},i={};function o(R,H){var Z,ae,j;return H?(R>>>=0,(j=0<=R&&R<256)&&(ae=i[R],ae)?ae:(Z=d(R,(R|0)<0?-1:0,!0),j&&(i[R]=Z),Z)):(R|=0,(j=-128<=R&&R<128)&&(ae=s[R],ae)?ae:(Z=d(R,R<0?-1:0,!1),j&&(s[R]=Z),Z))}a.fromInt=o;function u(R,H){if(isNaN(R))return H?I:N;if(H){if(R<0)return I;if(R>=x)return B}else{if(R<=-w)return V;if(R+1>=w)return M}return R<0?u(-R,H).neg():d(R%v|0,R/v|0,H)}a.fromNumber=u;function d(R,H,Z){return new a(R,H,Z)}a.fromBits=d;var c=Math.pow;function p(R,H,Z){if(R.length===0)throw Error("empty string");if(R==="NaN"||R==="Infinity"||R==="+Infinity"||R==="-Infinity")return N;if(typeof H=="number"?(Z=H,H=!1):H=!!H,Z=Z||10,Z<2||36<Z)throw RangeError("radix");var ae;if((ae=R.indexOf("-"))>0)throw Error("interior hyphen");if(ae===0)return p(R.substring(1),H,Z).neg();for(var j=u(c(Z,8)),K=N,Q=0;Q<R.length;Q+=8){var ce=Math.min(8,R.length-Q),me=parseInt(R.substring(Q,Q+ce),Z);if(ce<8){var L=u(c(Z,ce));K=K.mul(L).add(u(me))}else K=K.mul(j),K=K.add(u(me))}return K.unsigned=H,K}a.fromString=p;function m(R,H){return typeof R=="number"?u(R,H):typeof R=="string"?p(R,H):d(R.low,R.high,typeof H=="boolean"?H:R.unsigned)}a.fromValue=m;var g=65536,b=1<<24,v=g*g,x=v*v,w=x/2,k=o(b),N=o(0);a.ZERO=N;var I=o(0,!0);a.UZERO=I;var T=o(1);a.ONE=T;var $=o(1,!0);a.UONE=$;var D=o(-1);a.NEG_ONE=D;var M=d(-1,2147483647,!1);a.MAX_VALUE=M;var B=d(-1,-1,!0);a.MAX_UNSIGNED_VALUE=B;var V=d(0,-2147483648,!1);a.MIN_VALUE=V;var W=a.prototype;W.toInt=function(){return this.unsigned?this.low>>>0:this.low},W.toNumber=function(){return this.unsigned?(this.high>>>0)*v+(this.low>>>0):this.high*v+(this.low>>>0)},W.toString=function(R){if(R=R||10,R<2||36<R)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(V)){var H=u(R),Z=this.div(H),ae=Z.mul(H).sub(this);return Z.toString(R)+ae.toInt().toString(R)}else return"-"+this.neg().toString(R);for(var j=u(c(R,6),this.unsigned),K=this,Q="";;){var ce=K.div(j),me=K.sub(ce.mul(j)).toInt()>>>0,L=me.toString(R);if(K=ce,K.isZero())return L+Q;for(;L.length<6;)L="0"+L;Q=""+L+Q}},W.getHighBits=function(){return this.high},W.getHighBitsUnsigned=function(){return this.high>>>0},W.getLowBits=function(){return this.low},W.getLowBitsUnsigned=function(){return this.low>>>0},W.getNumBitsAbs=function(){if(this.isNegative())return this.eq(V)?64:this.neg().getNumBitsAbs();for(var R=this.high!=0?this.high:this.low,H=31;H>0&&!(R&1<<H);H--);return this.high!=0?H+33:H+1},W.isZero=function(){return this.high===0&&this.low===0},W.eqz=W.isZero,W.isNegative=function(){return!this.unsigned&&this.high<0},W.isPositive=function(){return this.unsigned||this.high>=0},W.isOdd=function(){return(this.low&1)===1},W.isEven=function(){return(this.low&1)===0},W.equals=function(R){return r(R)||(R=m(R)),this.unsigned!==R.unsigned&&this.high>>>31===1&&R.high>>>31===1?!1:this.high===R.high&&this.low===R.low},W.eq=W.equals,W.notEquals=function(R){return!this.eq(R)},W.neq=W.notEquals,W.ne=W.notEquals,W.lessThan=function(R){return this.comp(R)<0},W.lt=W.lessThan,W.lessThanOrEqual=function(R){return this.comp(R)<=0},W.lte=W.lessThanOrEqual,W.le=W.lessThanOrEqual,W.greaterThan=function(R){return this.comp(R)>0},W.gt=W.greaterThan,W.greaterThanOrEqual=function(R){return this.comp(R)>=0},W.gte=W.greaterThanOrEqual,W.ge=W.greaterThanOrEqual,W.compare=function(R){if(r(R)||(R=m(R)),this.eq(R))return 0;var H=this.isNegative(),Z=R.isNegative();return H&&!Z?-1:!H&&Z?1:this.unsigned?R.high>>>0>this.high>>>0||R.high===this.high&&R.low>>>0>this.low>>>0?-1:1:this.sub(R).isNegative()?-1:1},W.comp=W.compare,W.negate=function(){return!this.unsigned&&this.eq(V)?V:this.not().add(T)},W.neg=W.negate,W.add=function(R){r(R)||(R=m(R));var H=this.high>>>16,Z=this.high&65535,ae=this.low>>>16,j=this.low&65535,K=R.high>>>16,Q=R.high&65535,ce=R.low>>>16,me=R.low&65535,L=0,ee=0,ie=0,de=0;return de+=j+me,ie+=de>>>16,de&=65535,ie+=ae+ce,ee+=ie>>>16,ie&=65535,ee+=Z+Q,L+=ee>>>16,ee&=65535,L+=H+K,L&=65535,d(ie<<16|de,L<<16|ee,this.unsigned)},W.subtract=function(R){return r(R)||(R=m(R)),this.add(R.neg())},W.sub=W.subtract,W.multiply=function(R){if(this.isZero())return N;if(r(R)||(R=m(R)),n){var H=n.mul(this.low,this.high,R.low,R.high);return d(H,n.get_high(),this.unsigned)}if(R.isZero())return N;if(this.eq(V))return R.isOdd()?V:N;if(R.eq(V))return this.isOdd()?V:N;if(this.isNegative())return R.isNegative()?this.neg().mul(R.neg()):this.neg().mul(R).neg();if(R.isNegative())return this.mul(R.neg()).neg();if(this.lt(k)&&R.lt(k))return u(this.toNumber()*R.toNumber(),this.unsigned);var Z=this.high>>>16,ae=this.high&65535,j=this.low>>>16,K=this.low&65535,Q=R.high>>>16,ce=R.high&65535,me=R.low>>>16,L=R.low&65535,ee=0,ie=0,de=0,we=0;return we+=K*L,de+=we>>>16,we&=65535,de+=j*L,ie+=de>>>16,de&=65535,de+=K*me,ie+=de>>>16,de&=65535,ie+=ae*L,ee+=ie>>>16,ie&=65535,ie+=j*me,ee+=ie>>>16,ie&=65535,ie+=K*ce,ee+=ie>>>16,ie&=65535,ee+=Z*L+ae*me+j*ce+K*Q,ee&=65535,d(de<<16|we,ee<<16|ie,this.unsigned)},W.mul=W.multiply,W.divide=function(R){if(r(R)||(R=m(R)),R.isZero())throw Error("division by zero");if(n){if(!this.unsigned&&this.high===-2147483648&&R.low===-1&&R.high===-1)return this;var H=(this.unsigned?n.div_u:n.div_s)(this.low,this.high,R.low,R.high);return d(H,n.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?I:N;var Z,ae,j;if(this.unsigned){if(R.unsigned||(R=R.toUnsigned()),R.gt(this))return I;if(R.gt(this.shru(1)))return $;j=I}else{if(this.eq(V)){if(R.eq(T)||R.eq(D))return V;if(R.eq(V))return T;var K=this.shr(1);return Z=K.div(R).shl(1),Z.eq(N)?R.isNegative()?T:D:(ae=this.sub(R.mul(Z)),j=Z.add(ae.div(R)),j)}else if(R.eq(V))return this.unsigned?I:N;if(this.isNegative())return R.isNegative()?this.neg().div(R.neg()):this.neg().div(R).neg();if(R.isNegative())return this.div(R.neg()).neg();j=N}for(ae=this;ae.gte(R);){Z=Math.max(1,Math.floor(ae.toNumber()/R.toNumber()));for(var Q=Math.ceil(Math.log(Z)/Math.LN2),ce=Q<=48?1:c(2,Q-48),me=u(Z),L=me.mul(R);L.isNegative()||L.gt(ae);)Z-=ce,me=u(Z,this.unsigned),L=me.mul(R);me.isZero()&&(me=T),j=j.add(me),ae=ae.sub(L)}return j},W.div=W.divide,W.modulo=function(R){if(r(R)||(R=m(R)),n){var H=(this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,R.low,R.high);return d(H,n.get_high(),this.unsigned)}return this.sub(this.div(R).mul(R))},W.mod=W.modulo,W.rem=W.modulo,W.not=function(){return d(~this.low,~this.high,this.unsigned)},W.and=function(R){return r(R)||(R=m(R)),d(this.low&R.low,this.high&R.high,this.unsigned)},W.or=function(R){return r(R)||(R=m(R)),d(this.low|R.low,this.high|R.high,this.unsigned)},W.xor=function(R){return r(R)||(R=m(R)),d(this.low^R.low,this.high^R.high,this.unsigned)},W.shiftLeft=function(R){return r(R)&&(R=R.toInt()),(R&=63)===0?this:R<32?d(this.low<<R,this.high<<R|this.low>>>32-R,this.unsigned):d(0,this.low<<R-32,this.unsigned)},W.shl=W.shiftLeft,W.shiftRight=function(R){return r(R)&&(R=R.toInt()),(R&=63)===0?this:R<32?d(this.low>>>R|this.high<<32-R,this.high>>R,this.unsigned):d(this.high>>R-32,this.high>=0?0:-1,this.unsigned)},W.shr=W.shiftRight,W.shiftRightUnsigned=function(R){if(r(R)&&(R=R.toInt()),R&=63,R===0)return this;var H=this.high;if(R<32){var Z=this.low;return d(Z>>>R|H<<32-R,H>>>R,this.unsigned)}else return R===32?d(H,0,this.unsigned):d(H>>>R-32,0,this.unsigned)},W.shru=W.shiftRightUnsigned,W.shr_u=W.shiftRightUnsigned,W.toSigned=function(){return this.unsigned?d(this.low,this.high,!1):this},W.toUnsigned=function(){return this.unsigned?this:d(this.low,this.high,!0)},W.toBytes=function(R){return R?this.toBytesLE():this.toBytesBE()},W.toBytesLE=function(){var R=this.high,H=this.low;return[H&255,H>>>8&255,H>>>16&255,H>>>24,R&255,R>>>8&255,R>>>16&255,R>>>24]},W.toBytesBE=function(){var R=this.high,H=this.low;return[R>>>24,R>>>16&255,R>>>8&255,R&255,H>>>24,H>>>16&255,H>>>8&255,H&255]},a.fromBytes=function(R,H,Z){return Z?a.fromBytesLE(R,H):a.fromBytesBE(R,H)},a.fromBytesLE=function(R,H){return new a(R[0]|R[1]<<8|R[2]<<16|R[3]<<24,R[4]|R[5]<<8|R[6]<<16|R[7]<<24,H)},a.fromBytesBE=function(R,H){return new a(R[4]<<24|R[5]<<16|R[6]<<8|R[7],R[0]<<24|R[1]<<16|R[2]<<8|R[3],H)}}),lG=Wn(()=>{}),uG=Wn(()=>{}),cG=Wn((e,t)=>{(function(n,a,r){function s(d){var c=this,p=u();c.next=function(){var m=2091639*c.s0+c.c*23283064365386963e-26;return c.s0=c.s1,c.s1=c.s2,c.s2=m-(c.c=m|0)},c.c=1,c.s0=p(" "),c.s1=p(" "),c.s2=p(" "),c.s0-=p(d),c.s0<0&&(c.s0+=1),c.s1-=p(d),c.s1<0&&(c.s1+=1),c.s2-=p(d),c.s2<0&&(c.s2+=1),p=null}function i(d,c){return c.c=d.c,c.s0=d.s0,c.s1=d.s1,c.s2=d.s2,c}function o(d,c){var p=new s(d),m=c&&c.state,g=p.next;return g.int32=function(){return p.next()*4294967296|0},g.double=function(){return g()+(g()*2097152|0)*11102230246251565e-32},g.quick=g,m&&(typeof m=="object"&&i(m,p),g.state=function(){return i(p,{})}),g}function u(){var d=4022871197,c=function(p){p=String(p);for(var m=0;m<p.length;m++){d+=p.charCodeAt(m);var g=.02519603282416938*d;d=g>>>0,g-=d,g*=d,d=g>>>0,g-=d,d+=g*4294967296}return(d>>>0)*23283064365386963e-26};return c}a&&a.exports?a.exports=o:r&&r.amd?r(function(){return o}):this.alea=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),dG=Wn((e,t)=>{(function(n,a,r){function s(u){var d=this,c="";d.x=0,d.y=0,d.z=0,d.w=0,d.next=function(){var m=d.x^d.x<<11;return d.x=d.y,d.y=d.z,d.z=d.w,d.w^=d.w>>>19^m^m>>>8},u===(u|0)?d.x=u:c+=u;for(var p=0;p<c.length+64;p++)d.x^=c.charCodeAt(p)|0,d.next()}function i(u,d){return d.x=u.x,d.y=u.y,d.z=u.z,d.w=u.w,d}function o(u,d){var c=new s(u),p=d&&d.state,m=function(){return(c.next()>>>0)/4294967296};return m.double=function(){do var g=c.next()>>>11,b=(c.next()>>>0)/4294967296,v=(g+b)/(1<<21);while(v===0);return v},m.int32=c.next,m.quick=m,p&&(typeof p=="object"&&i(p,c),m.state=function(){return i(c,{})}),m}a&&a.exports?a.exports=o:r&&r.amd?r(function(){return o}):this.xor128=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),hG=Wn((e,t)=>{(function(n,a,r){function s(u){var d=this,c="";d.next=function(){var m=d.x^d.x>>>2;return d.x=d.y,d.y=d.z,d.z=d.w,d.w=d.v,(d.d=d.d+362437|0)+(d.v=d.v^d.v<<4^(m^m<<1))|0},d.x=0,d.y=0,d.z=0,d.w=0,d.v=0,u===(u|0)?d.x=u:c+=u;for(var p=0;p<c.length+64;p++)d.x^=c.charCodeAt(p)|0,p==c.length&&(d.d=d.x<<10^d.x>>>4),d.next()}function i(u,d){return d.x=u.x,d.y=u.y,d.z=u.z,d.w=u.w,d.v=u.v,d.d=u.d,d}function o(u,d){var c=new s(u),p=d&&d.state,m=function(){return(c.next()>>>0)/4294967296};return m.double=function(){do var g=c.next()>>>11,b=(c.next()>>>0)/4294967296,v=(g+b)/(1<<21);while(v===0);return v},m.int32=c.next,m.quick=m,p&&(typeof p=="object"&&i(p,c),m.state=function(){return i(c,{})}),m}a&&a.exports?a.exports=o:r&&r.amd?r(function(){return o}):this.xorwow=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),pG=Wn((e,t)=>{(function(n,a,r){function s(u){var d=this;d.next=function(){var p=d.x,m=d.i,g,b;return g=p[m],g^=g>>>7,b=g^g<<24,g=p[m+1&7],b^=g^g>>>10,g=p[m+3&7],b^=g^g>>>3,g=p[m+4&7],b^=g^g<<7,g=p[m+7&7],g=g^g<<13,b^=g^g<<9,p[m]=b,d.i=m+1&7,b};function c(p,m){var g,b=[];if(m===(m|0))b[0]=m;else for(m=""+m,g=0;g<m.length;++g)b[g&7]=b[g&7]<<15^m.charCodeAt(g)+b[g+1&7]<<13;for(;b.length<8;)b.push(0);for(g=0;g<8&&b[g]===0;++g);for(g==8?b[7]=-1:b[g],p.x=b,p.i=0,g=256;g>0;--g)p.next()}c(d,u)}function i(u,d){return d.x=u.x.slice(),d.i=u.i,d}function o(u,d){u==null&&(u=+new Date);var c=new s(u),p=d&&d.state,m=function(){return(c.next()>>>0)/4294967296};return m.double=function(){do var g=c.next()>>>11,b=(c.next()>>>0)/4294967296,v=(g+b)/(1<<21);while(v===0);return v},m.int32=c.next,m.quick=m,p&&(p.x&&i(p,c),m.state=function(){return i(c,{})}),m}a&&a.exports?a.exports=o:r&&r.amd?r(function(){return o}):this.xorshift7=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),fG=Wn((e,t)=>{(function(n,a,r){function s(u){var d=this;d.next=function(){var p=d.w,m=d.X,g=d.i,b,v;return d.w=p=p+1640531527|0,v=m[g+34&127],b=m[g=g+1&127],v^=v<<13,b^=b<<17,v^=v>>>15,b^=b>>>12,v=m[g]=v^b,d.i=g,v+(p^p>>>16)|0};function c(p,m){var g,b,v,x,w,k=[],N=128;for(m===(m|0)?(b=m,m=null):(m=m+"\0",b=0,N=Math.max(N,m.length)),v=0,x=-32;x<N;++x)m&&(b^=m.charCodeAt((x+32)%m.length)),x===0&&(w=b),b^=b<<10,b^=b>>>15,b^=b<<4,b^=b>>>13,x>=0&&(w=w+1640531527|0,g=k[x&127]^=b+w,v=g==0?v+1:0);for(v>=128&&(k[(m&&m.length||0)&127]=-1),v=127,x=512;x>0;--x)b=k[v+34&127],g=k[v=v+1&127],b^=b<<13,g^=g<<17,b^=b>>>15,g^=g>>>12,k[v]=b^g;p.w=w,p.X=k,p.i=v}c(d,u)}function i(u,d){return d.i=u.i,d.w=u.w,d.X=u.X.slice(),d}function o(u,d){u==null&&(u=+new Date);var c=new s(u),p=d&&d.state,m=function(){return(c.next()>>>0)/4294967296};return m.double=function(){do var g=c.next()>>>11,b=(c.next()>>>0)/4294967296,v=(g+b)/(1<<21);while(v===0);return v},m.int32=c.next,m.quick=m,p&&(p.X&&i(p,c),m.state=function(){return i(c,{})}),m}a&&a.exports?a.exports=o:r&&r.amd?r(function(){return o}):this.xor4096=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),mG=Wn((e,t)=>{(function(n,a,r){function s(u){var d=this,c="";d.next=function(){var m=d.b,g=d.c,b=d.d,v=d.a;return m=m<<25^m>>>7^g,g=g-b|0,b=b<<24^b>>>8^v,v=v-m|0,d.b=m=m<<20^m>>>12^g,d.c=g=g-b|0,d.d=b<<16^g>>>16^v,d.a=v-m|0},d.a=0,d.b=0,d.c=-1640531527,d.d=1367130551,u===Math.floor(u)?(d.a=u/4294967296|0,d.b=u|0):c+=u;for(var p=0;p<c.length+20;p++)d.b^=c.charCodeAt(p)|0,d.next()}function i(u,d){return d.a=u.a,d.b=u.b,d.c=u.c,d.d=u.d,d}function o(u,d){var c=new s(u),p=d&&d.state,m=function(){return(c.next()>>>0)/4294967296};return m.double=function(){do var g=c.next()>>>11,b=(c.next()>>>0)/4294967296,v=(g+b)/(1<<21);while(v===0);return v},m.int32=c.next,m.quick=m,p&&(typeof p=="object"&&i(p,c),m.state=function(){return i(c,{})}),m}a&&a.exports?a.exports=o:r&&r.amd?r(function(){return o}):this.tychei=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),gG=Wn(()=>{}),yG=Wn((e,t)=>{(function(n,a,r){var s=256,i=6,o=52,u="random",d=r.pow(s,i),c=r.pow(2,o),p=c*2,m=s-1,g;function b(T,$,D){var M=[];$=$==!0?{entropy:!0}:$||{};var B=k(w($.entropy?[T,I(a)]:T??N(),3),M),V=new v(M),W=function(){for(var R=V.g(i),H=d,Z=0;R<c;)R=(R+Z)*s,H*=s,Z=V.g(1);for(;R>=p;)R/=2,H/=2,Z>>>=1;return(R+Z)/H};return W.int32=function(){return V.g(4)|0},W.quick=function(){return V.g(4)/4294967296},W.double=W,k(I(V.S),a),($.pass||D||function(R,H,Z,ae){return ae&&(ae.S&&x(ae,V),R.state=function(){return x(V,{})}),Z?(r[u]=R,H):R})(W,B,"global"in $?$.global:this==r,$.state)}function v(T){var $,D=T.length,M=this,B=0,V=M.i=M.j=0,W=M.S=[];for(D||(T=[D++]);B<s;)W[B]=B++;for(B=0;B<s;B++)W[B]=W[V=m&V+T[B%D]+($=W[B])],W[V]=$;(M.g=function(R){for(var H,Z=0,ae=M.i,j=M.j,K=M.S;R--;)H=K[ae=m&ae+1],Z=Z*s+K[m&(K[ae]=K[j=m&j+H])+(K[j]=H)];return M.i=ae,M.j=j,Z})(s)}function x(T,$){return $.i=T.i,$.j=T.j,$.S=T.S.slice(),$}function w(T,$){var D=[],M=typeof T,B;if($&&M=="object")for(B in T)try{D.push(w(T[B],$-1))}catch{}return D.length?D:M=="string"?T:T+"\0"}function k(T,$){for(var D=T+"",M,B=0;B<D.length;)$[m&B]=m&(M^=$[m&B]*19)+D.charCodeAt(B++);return I($)}function N(){try{var T;return g&&(T=g.randomBytes)?T=T(s):(T=new Uint8Array(s),(n.crypto||n.msCrypto).getRandomValues(T)),I(T)}catch{var $=n.navigator,D=$&&$.plugins;return[+new Date,n,D,n.screen,I(a)]}}function I(T){return String.fromCharCode.apply(0,T)}if(k(r.random(),a),typeof t=="object"&&t.exports){t.exports=b;try{g=gG()}catch{}}else typeof define=="function"&&define.amd?define(function(){return b}):r["seed"+u]=b})(typeof self<"u"?self:e,[],Math)}),r0=Wn((e,t)=>{var n=cG(),a=dG(),r=hG(),s=pG(),i=fG(),o=mG(),u=yG();u.alea=n,u.xor128=a,u.xorwow=r,u.xorshift7=s,u.xor4096=i,u.tychei=o,t.exports=u}),QD=Wn(()=>{}),Qk=Wn(()=>{}),eO=Wn(()=>{}),bG=Wn(()=>{}),vG=Wn(()=>{}),xG=Wn(()=>{}),wG=Wn((e,t)=>{var n=(()=>{var a=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(a=a||__filename),function(r){r=r||{};function s(){return Q.buffer!=Ce&&ut(Q.buffer),ze}function i(){return Q.buffer!=Ce&&ut(Q.buffer),Ke}function o(){return Q.buffer!=Ce&&ut(Q.buffer),at}function u(){return Q.buffer!=Ce&&ut(Q.buffer),lt}function d(){return Q.buffer!=Ce&&ut(Q.buffer),Dt}var c=typeof r<"u"?r:{},p,m;c.ready=new Promise(function(G,ue){p=G,m=ue});var g;typeof process<"u"&&process.listeners&&(g={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var b=Object.assign({},c),v=(G,ue)=>{throw ue},x=typeof window=="object",w=typeof importScripts=="function",k=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",N=c.ENVIRONMENT_IS_PTHREAD||!1,I="";function T(G){return c.locateFile?c.locateFile(G,I):I+G}var $,D,M;function B(G){G instanceof fr||ae("exiting due to exception: "+G)}if(k){var V=Qk(),W=eO();w?I=W.dirname(I)+"/":I=__dirname+"/",$=(ue,$e)=>(ue=In(ue)?new URL(ue):W.normalize(ue),V.readFileSync(ue,$e?void 0:"utf8")),M=ue=>{var $e=$(ue,!0);return $e.buffer||($e=new Uint8Array($e)),$e},D=(ue,$e,Xe)=>{ue=In(ue)?new URL(ue):W.normalize(ue),V.readFile(ue,function(rt,nt){rt?Xe(rt):$e(nt.buffer)})},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),process.argv.slice(2),process.on("uncaughtException",function(ue){if(!(ue instanceof fr))throw ue}),process.on("unhandledRejection",function(ue){throw ue}),v=(ue,$e)=>{if(rn())throw process.exitCode=ue,$e;B($e),process.exit(ue)},c.inspect=function(){return"[Emscripten Module object]"};let G;try{G=bG()}catch(ue){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),ue}global.Worker=G.Worker}else(x||w)&&(w?I=self.location.href:typeof document<"u"&&document.currentScript&&(I=document.currentScript.src),typeof a<"u"&&a&&(I=a),I.indexOf("blob:")!==0?I=I.substr(0,I.replace(/[?#].*/,"").lastIndexOf("/")+1):I="",k||($=G=>{var ue=new XMLHttpRequest;return ue.open("GET",G,!1),ue.send(null),ue.responseText},w&&(M=G=>{var ue=new XMLHttpRequest;return ue.open("GET",G,!1),ue.responseType="arraybuffer",ue.send(null),new Uint8Array(ue.response)}),D=(G,ue,$e)=>{var Xe=new XMLHttpRequest;Xe.open("GET",G,!0),Xe.responseType="arraybuffer",Xe.onload=()=>{if(Xe.status==200||Xe.status==0&&Xe.response){ue(Xe.response);return}$e()},Xe.onerror=$e,Xe.send(null)}));k&&typeof performance>"u"&&(global.performance=vG().performance);var R=console.log.bind(console),H=console.warn.bind(console);k&&(R=G=>V.writeSync(1,G+`
`),H=G=>V.writeSync(2,G+`
`));var Z=c.print||R,ae=c.printErr||H;Object.assign(c,b),b=null,c.arguments&&c.arguments,c.thisProgram&&c.thisProgram,c.quit&&(v=c.quit);var j;c.wasmBinary&&(j=c.wasmBinary);var K=c.noExitRuntime||!0;typeof WebAssembly!="object"&&_s("no native wasm support detected");var Q,ce,me=!1,L;function ee(G,ue){G||_s(ue)}var ie=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function de(G,ue,$e){ue>>>=0;for(var Xe=ue+$e,rt=ue;G[rt]&&!(rt>=Xe);)++rt;if(rt-ue>16&&G.buffer&&ie)return ie.decode(G.buffer instanceof SharedArrayBuffer?G.slice(ue,rt):G.subarray(ue,rt));for(var nt="";ue<rt;){var De=G[ue++];if(!(De&128)){nt+=String.fromCharCode(De);continue}var We=G[ue++]&63;if((De&224)==192){nt+=String.fromCharCode((De&31)<<6|We);continue}var Pt=G[ue++]&63;if((De&240)==224?De=(De&15)<<12|We<<6|Pt:De=(De&7)<<18|We<<12|Pt<<6|G[ue++]&63,De<65536)nt+=String.fromCharCode(De);else{var En=De-65536;nt+=String.fromCharCode(55296|En>>10,56320|En&1023)}}return nt}function we(G,ue){return G>>>=0,G?de(i(),G,ue):""}function Ie(G,ue,$e,Xe){if($e>>>=0,!(Xe>0))return 0;for(var rt=$e,nt=$e+Xe-1,De=0;De<G.length;++De){var We=G.charCodeAt(De);if(We>=55296&&We<=57343){var Pt=G.charCodeAt(++De);We=65536+((We&1023)<<10)|Pt&1023}if(We<=127){if($e>=nt)break;ue[$e++>>>0]=We}else if(We<=2047){if($e+1>=nt)break;ue[$e++>>>0]=192|We>>6,ue[$e++>>>0]=128|We&63}else if(We<=65535){if($e+2>=nt)break;ue[$e++>>>0]=224|We>>12,ue[$e++>>>0]=128|We>>6&63,ue[$e++>>>0]=128|We&63}else{if($e+3>=nt)break;ue[$e++>>>0]=240|We>>18,ue[$e++>>>0]=128|We>>12&63,ue[$e++>>>0]=128|We>>6&63,ue[$e++>>>0]=128|We&63}}return ue[$e>>>0]=0,$e-rt}function Ee(G,ue,$e){return Ie(G,i(),ue,$e)}var Ce,ze,Ke,at,lt,Dt;N&&(Ce=c.buffer);function ut(G){Ce=G,c.HEAP8=ze=new Int8Array(G),c.HEAP16=new Int16Array(G),c.HEAP32=at=new Int32Array(G),c.HEAPU8=Ke=new Uint8Array(G),c.HEAPU16=new Uint16Array(G),c.HEAPU32=lt=new Uint32Array(G),c.HEAPF32=new Float32Array(G),c.HEAPF64=Dt=new Float64Array(G)}var xt=c.INITIAL_MEMORY||16777216;if(N)Q=c.wasmMemory,Ce=c.buffer;else if(c.wasmMemory)Q=c.wasmMemory;else if(Q=new WebAssembly.Memory({initial:xt/65536,maximum:65536,shared:!0}),!(Q.buffer instanceof SharedArrayBuffer))throw ae("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),k&&ae("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");Q&&(Ce=Q.buffer),xt=Ce.byteLength,ut(Ce);var tt,At=[],Bt=[],ya=[];function rn(){return K}function ra(){if(c.preRun)for(typeof c.preRun=="function"&&(c.preRun=[c.preRun]);c.preRun.length;)dn(c.preRun.shift());Ht(At)}function Hn(){!N&&Ht(Bt)}function Ta(){if(!N){if(c.postRun)for(typeof c.postRun=="function"&&(c.postRun=[c.postRun]);c.postRun.length;)ba(c.postRun.shift());Ht(ya)}}function dn(G){At.unshift(G)}function Ua(G){Bt.unshift(G)}function ba(G){ya.unshift(G)}var Mn=0,va=null;function Gs(G){Mn++,c.monitorRunDependencies&&c.monitorRunDependencies(Mn)}function oo(G){if(Mn--,c.monitorRunDependencies&&c.monitorRunDependencies(Mn),Mn==0&&va){var ue=va;va=null,ue()}}function _s(G){c.onAbort&&c.onAbort(G),G="Aborted("+G+")",ae(G),me=!0,L=1,G+=". Build with -sASSERTIONS for more info.";var ue=new WebAssembly.RuntimeError(G);throw m(ue),ue}var Ol="data:application/octet-stream;base64,";function ja(G){return G.startsWith(Ol)}function In(G){return G.startsWith("file://")}var sn;sn="tfjs-backend-wasm-threaded-simd.wasm",ja(sn)||(sn=T(sn));function xa(G){try{if(G==sn&&j)return new Uint8Array(j);if(M)return M(G);throw"both async and sync fetching of the wasm failed"}catch(ue){_s(ue)}}function Sd(){if(!j&&(x||w)){if(typeof fetch=="function"&&!In(sn))return fetch(sn,{credentials:"same-origin"}).then(function(G){if(!G.ok)throw"failed to load wasm binary file at '"+sn+"'";return G.arrayBuffer()}).catch(function(){return xa(sn)});if(D)return new Promise(function(G,ue){D(sn,function($e){G(new Uint8Array($e))},ue)})}return Promise.resolve().then(function(){return xa(sn)})}function kd(){var G={env:Cf,wasi_snapshot_preview1:Cf};function ue(De,We){var Pt=De.exports;if(c.asm=Pt,ns(c.asm._emscripten_tls_init),tt=c.asm.__indirect_function_table,Ua(c.asm.__wasm_call_ctors),ce=We,!N){var En=Re.unusedWorkers.length;Re.unusedWorkers.forEach(function(Mr){Re.loadWasmModuleToWorker(Mr,function(){--En||oo()})})}}N||Gs();function $e(De){ue(De.instance,De.module)}function Xe(De){return Sd().then(function(We){return WebAssembly.instantiate(We,G)}).then(function(We){return We}).then(De,function(We){ae("failed to asynchronously prepare wasm: "+We),_s(We)})}function rt(){return!j&&typeof WebAssembly.instantiateStreaming=="function"&&!ja(sn)&&!In(sn)&&!k&&typeof fetch=="function"?fetch(sn,{credentials:"same-origin"}).then(function(De){var We=WebAssembly.instantiateStreaming(De,G);return We.then($e,function(Pt){return ae("wasm streaming compile failed: "+Pt),ae("falling back to ArrayBuffer instantiation"),Xe($e)})}):Xe($e)}if(c.instantiateWasm)try{var nt=c.instantiateWasm(G,ue);return nt}catch(De){ae("Module.instantiateWasm callback failed with error: "+De),m(De)}return rt().catch(m),{}}var _d={};function fr(G){this.name="ExitStatus",this.message="Program terminated with exit("+G+")",this.status=G}function Ns(G){var ue=Re.pthreads[G];delete Re.pthreads[G],ue.terminate(),Ks(G),Re.runningWorkers.splice(Re.runningWorkers.indexOf(ue),1),ue.pthread_ptr=0}function vi(G){var ue=Re.pthreads[G];ue.postMessage({cmd:"cancel"})}function tr(G){var ue=Re.pthreads[G];ee(ue),Re.returnWorkerToPool(ue)}function ts(G){var ue=Re.getNewWorker();if(!ue)return 6;Re.runningWorkers.push(ue),Re.pthreads[G.pthread_ptr]=ue,ue.pthread_ptr=G.pthread_ptr;var $e={cmd:"run",start_routine:G.startRoutine,arg:G.arg,pthread_ptr:G.pthread_ptr};return ue.runPthread=()=>{k&&ue.ref(),ue.postMessage($e,G.transferList),delete ue.runPthread},ue.loaded&&ue.runPthread(),0}function qs(G){if(N)return ho(1,1,G);L=G,rn()||(Re.terminateAllThreads(),c.onExit&&c.onExit(G),me=!0),v(G,new fr(G))}function xe(G,ue){if(L=G,!ue&&N)throw ht(G),"unwind";qs(G)}var Ae=xe;function Ge(G){if(G instanceof fr||G=="unwind")return L;v(1,G)}var Re={unusedWorkers:[],runningWorkers:[],tlsInitFunctions:[],pthreads:{},init:function(){N?Re.initWorker():Re.initMainThread()},initMainThread:function(){for(var G=8;G--;)Re.allocateUnusedWorker()},initWorker:function(){K=!1},setExitStatus:function(G){L=G},terminateAllThreads:function(){for(var G of Object.values(Re.pthreads))Re.returnWorkerToPool(G);for(var G of Re.unusedWorkers)G.terminate();Re.unusedWorkers=[]},returnWorkerToPool:function(G){var ue=G.pthread_ptr;delete Re.pthreads[ue],Re.unusedWorkers.push(G),Re.runningWorkers.splice(Re.runningWorkers.indexOf(G),1),G.pthread_ptr=0,k&&G.unref(),Ks(ue)},receiveObjectTransfer:function(G){},threadInitTLS:function(){Re.tlsInitFunctions.forEach(G=>G())},loadWasmModuleToWorker:function(G,ue){G.onmessage=nt=>{var De=nt.data,We=De.cmd;if(G.pthread_ptr&&(Re.currentProxiedOperationCallerThread=G.pthread_ptr),De.targetThread&&De.targetThread!=po()){var Pt=Re.pthreads[De.targetThread];Pt?Pt.postMessage(De,De.transferList):ae('Internal error! Worker sent a message "'+We+'" to target pthread '+De.targetThread+", but that thread no longer exists!"),Re.currentProxiedOperationCallerThread=void 0;return}We==="processProxyingQueue"?Nf(De.queue):We==="spawnThread"?ts(De):We==="cleanupThread"?tr(De.thread):We==="killThread"?Ns(De.thread):We==="cancelThread"?vi(De.thread):We==="loaded"?(G.loaded=!0,k&&G.unref(),ue&&ue(G),G.runPthread&&G.runPthread()):We==="print"?Z("Thread "+De.threadId+": "+De.text):We==="printErr"?ae("Thread "+De.threadId+": "+De.text):We==="alert"?alert("Thread "+De.threadId+": "+De.text):De.target==="setimmediate"?G.postMessage(De):We==="callHandler"?c[De.handler](...De.args):We&&ae("worker sent an unknown command "+We),Re.currentProxiedOperationCallerThread=void 0},G.onerror=nt=>{var De="worker sent an error!";throw ae(De+" "+nt.filename+":"+nt.lineno+": "+nt.message),nt},k&&(G.on("message",function(nt){G.onmessage({data:nt})}),G.on("error",function(nt){G.onerror(nt)}),G.on("detachedExit",function(){}));var $e=[],Xe=["onExit","onAbort","print","printErr"];for(var rt of Xe)c.hasOwnProperty(rt)&&$e.push(rt);G.postMessage({cmd:"load",handlers:$e,urlOrBlob:c.mainScriptUrlOrBlob||a,wasmMemory:Q,wasmModule:ce})},allocateUnusedWorker:function(){var G,ue=T("tfjs-backend-wasm-threaded-simd.worker.js");G=new Worker(ue),Re.unusedWorkers.push(G)},getNewWorker:function(){return Re.unusedWorkers.length==0&&(Re.allocateUnusedWorker(),Re.loadWasmModuleToWorker(Re.unusedWorkers[0])),Re.unusedWorkers.pop()}};c.PThread=Re;function Ht(G){for(;G.length>0;)G.shift()(c)}function Qt(){var G=po(),ue=o()[G+52>>>2],$e=o()[G+56>>>2],Xe=ue-$e;Rf(ue,Xe),fo(ue)}c.establishStackSpace=Qt;function ht(G){if(N)return ho(2,0,G);try{Ae(G)}catch(ue){Ge(ue)}}var st=[];function pn(G){var ue=st[G];return ue||(G>=st.length&&(st.length=G+1),st[G]=ue=tt.get(G)),ue}function Ea(G,ue){var $e=pn(G)(ue);rn()?Re.setExitStatus($e):My($e)}c.invokeEntryPoint=Ea;function ns(G){Re.tlsInitFunctions.push(G)}function Ml(G){Si(G,!w,1,!x),Re.threadInitTLS()}function mr(G){N?postMessage({cmd:"cleanupThread",thread:G}):tr(G)}function Tn(G,ue,$e,Xe){return N?ho(3,1,G,ue,$e,Xe):Ft(G,ue,$e,Xe)}function Ft(G,ue,$e,Xe){if(typeof SharedArrayBuffer>"u")return ae("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var rt=[],nt=0;if(N&&(rt.length===0||nt))return Tn(G,ue,$e,Xe);var De={startRoutine:$e,pthread_ptr:G,arg:Xe,transferList:rt};return N?(De.cmd="spawnThread",postMessage(De,rt),0):ts(De)}function nr(){return 65536}var lo=!0;function zx(){return lo}function Nf(G){Atomics.store(o(),G>>2,1),po()&&$f(G),Atomics.compareExchange(o(),G>>2,1,0)}c.executeNotifiedProxyingQueue=Nf;function $y(G,ue,$e,Xe){if(G==ue)setTimeout(()=>Nf(Xe));else if(N)postMessage({targetThread:G,cmd:"processProxyingQueue",queue:Xe});else{var rt=Re.pthreads[G];if(!rt)return;rt.postMessage({cmd:"processProxyingQueue",queue:Xe})}return 1}function Fl(G,ue,$e){return-1}function If(){_s("")}function as(G){as.shown||(as.shown={}),as.shown[G]||(as.shown[G]=1,k&&(G="warning: "+G),ae(G))}function uo(){k||w||as("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread")}function zl(){return Date.now()}function xi(){return 4294901760}function Gn(){return xi()}var Nd;k?Nd=()=>{var G=process.hrtime();return G[0]*1e3+G[1]/1e6}:Nd=()=>performance.timeOrigin+performance.now();function Ry(G,ue,$e){i().copyWithin(G>>>0,ue>>>0,ue+$e>>>0)}function wi(){return k?xG().cpus().length:navigator.hardwareConcurrency}function co(G){var ue=$d(),$e=G();return fo(ue),$e}function ho(G,ue){var $e=arguments.length-2,Xe=arguments;return co(()=>{for(var rt=$e,nt=Rd(rt*8),De=nt>>3,We=0;We<$e;We++){var Pt=Xe[2+We];d()[De+We>>>0]=Pt}return Af(G,rt,nt,ue)})}var Id=[];function Dy(G,ue,$e){Id.length=ue;for(var Xe=$e>>3,rt=0;rt<ue;rt++)Id[rt]=d()[Xe+rt>>>0];var nt=G<0,De=nt?_d[-G-1]:Ef[G];return De.apply(null,Id)}function Lx(G){try{return Q.grow(G-Ce.byteLength+65535>>>16),ut(Q.buffer),1}catch{}}function Td(G){var ue=i().length;if(G=G>>>0,G<=ue)return!1;var $e=xi();if(G>$e)return!1;let Xe=(Pt,En)=>Pt+(En-Pt%En)%En;for(var rt=1;rt<=4;rt*=2){var nt=ue*(1+.2/rt);nt=Math.min(nt,G+100663296);var De=Math.min($e,Xe(Math.max(G,nt),65536)),We=Lx(De);if(We)return!0}return!1}function Ed(){throw"unwind"}function rs(G){return N?ho(4,1,G):52}function ar(G,ue,$e,Xe,rt){return N?ho(5,1,G,ue,$e,Xe,rt):70}var Oy=[null,[],[]];function Bx(G,ue){var $e=Oy[G];ue===0||ue===10?((G===1?Z:ae)(de($e,0)),$e.length=0):$e.push(ue)}function Cd(G,ue,$e,Xe){if(N)return ho(6,1,G,ue,$e,Xe);for(var rt=0,nt=0;nt<$e;nt++){var De=u()[ue>>>2],We=u()[ue+4>>>2];ue+=8;for(var Pt=0;Pt<We;Pt++)Bx(G,i()[De+Pt>>>0]);rt+=We}return u()[Xe>>>2]=rt,0}function Tf(G){var ue=c["_"+G];return ue}function Ad(G,ue){s().set(G,ue>>>0)}function Px(G,ue,$e,Xe,rt){var nt={string:wa=>{var ki=0;if(wa!=null&&wa!==0){var Ca=(wa.length<<2)+1;ki=Rd(Ca),Ee(wa,ki,Ca)}return ki},array:wa=>{var ki=Rd(wa.length);return Ad(wa,ki),ki}};function De(wa){return ue==="string"?we(wa):ue==="boolean"?!!wa:wa}var We=Tf(G),Pt=[],En=0;if(Xe)for(var Mr=0;Mr<Xe.length;Mr++){var Bl=nt[$e[Mr]];Bl?(En===0&&(En=$d()),Pt[Mr]=Bl(Xe[Mr])):Pt[Mr]=Xe[Mr]}var Od=We.apply(null,Pt);function Md(wa){return En!==0&&fo(En),De(wa)}return Od=Md(Od),Od}function gr(G,ue,$e,Xe){$e=$e||[];var rt=$e.every(De=>De==="number"||De==="boolean"),nt=ue!=="string";return nt&&rt&&!Xe?Tf(G):function(){return Px(G,ue,$e,arguments)}}Re.init();var Ef=[null,qs,ht,Tn,rs,ar,Cd],Cf={__emscripten_init_main_thread_js:Ml,__emscripten_thread_cleanup:mr,__pthread_create_js:Ft,_emscripten_default_pthread_stack_size:nr,_emscripten_get_now_is_monotonic:zx,_emscripten_notify_task_queue:$y,_emscripten_set_offscreencanvas_size:Fl,abort:If,emscripten_check_blocking_allowed:uo,emscripten_date_now:zl,emscripten_get_heap_max:Gn,emscripten_get_now:Nd,emscripten_memcpy_big:Ry,emscripten_num_logical_cores:wi,emscripten_receive_on_main_thread_js:Dy,emscripten_resize_heap:Td,emscripten_unwind_to_js_event_loop:Ed,exit:Ae,fd_close:rs,fd_seek:ar,fd_write:Cd,memory:Q||c.wasmMemory};kd(),c.___wasm_call_ctors=function(){return(c.___wasm_call_ctors=c.asm.__wasm_call_ctors).apply(null,arguments)},c._init=function(){return(c._init=c.asm.init).apply(null,arguments)},c._init_with_threads_count=function(){return(c._init_with_threads_count=c.asm.init_with_threads_count).apply(null,arguments)},c._get_threads_count=function(){return(c._get_threads_count=c.asm.get_threads_count).apply(null,arguments)},c._register_tensor=function(){return(c._register_tensor=c.asm.register_tensor).apply(null,arguments)},c._dispose_data=function(){return(c._dispose_data=c.asm.dispose_data).apply(null,arguments)},c._dispose=function(){return(c._dispose=c.asm.dispose).apply(null,arguments)},c._Abs=function(){return(c._Abs=c.asm.Abs).apply(null,arguments)},c._Acos=function(){return(c._Acos=c.asm.Acos).apply(null,arguments)},c._Acosh=function(){return(c._Acosh=c.asm.Acosh).apply(null,arguments)},c._Add=function(){return(c._Add=c.asm.Add).apply(null,arguments)},c._AddN=function(){return(c._AddN=c.asm.AddN).apply(null,arguments)},c._All=function(){return(c._All=c.asm.All).apply(null,arguments)},c._Any=function(){return(c._Any=c.asm.Any).apply(null,arguments)},c._ArgMax=function(){return(c._ArgMax=c.asm.ArgMax).apply(null,arguments)},c._ArgMin=function(){return(c._ArgMin=c.asm.ArgMin).apply(null,arguments)},c._Asin=function(){return(c._Asin=c.asm.Asin).apply(null,arguments)},c._Asinh=function(){return(c._Asinh=c.asm.Asinh).apply(null,arguments)},c._Atan=function(){return(c._Atan=c.asm.Atan).apply(null,arguments)},c._Atan2=function(){return(c._Atan2=c.asm.Atan2).apply(null,arguments)},c._Atanh=function(){return(c._Atanh=c.asm.Atanh).apply(null,arguments)},c._AvgPool=function(){return(c._AvgPool=c.asm.AvgPool).apply(null,arguments)},c._AvgPool3D=function(){return(c._AvgPool3D=c.asm.AvgPool3D).apply(null,arguments)},c._AvgPool3DGrad=function(){return(c._AvgPool3DGrad=c.asm.AvgPool3DGrad).apply(null,arguments)},c._AvgPoolGrad=function(){return(c._AvgPoolGrad=c.asm.AvgPoolGrad).apply(null,arguments)},c._BatchMatMul=function(){return(c._BatchMatMul=c.asm.BatchMatMul).apply(null,arguments)},c._Bincount=function(){return(c._Bincount=c.asm.Bincount).apply(null,arguments)},c._BitwiseAnd=function(){return(c._BitwiseAnd=c.asm.BitwiseAnd).apply(null,arguments)},c._Ceil=function(){return(c._Ceil=c.asm.Ceil).apply(null,arguments)},c._ClipByValue=function(){return(c._ClipByValue=c.asm.ClipByValue).apply(null,arguments)},c._Conv2D=function(){return(c._Conv2D=c.asm.Conv2D).apply(null,arguments)},c._Conv2DBackpropInput=function(){return(c._Conv2DBackpropInput=c.asm.Conv2DBackpropInput).apply(null,arguments)},c._Conv3D=function(){return(c._Conv3D=c.asm.Conv3D).apply(null,arguments)},c._Conv3DBackpropFilterV2=function(){return(c._Conv3DBackpropFilterV2=c.asm.Conv3DBackpropFilterV2).apply(null,arguments)},c._Conv3DBackpropInputV2=function(){return(c._Conv3DBackpropInputV2=c.asm.Conv3DBackpropInputV2).apply(null,arguments)},c._Cos=function(){return(c._Cos=c.asm.Cos).apply(null,arguments)},c._Cosh=function(){return(c._Cosh=c.asm.Cosh).apply(null,arguments)},c._CropAndResize=function(){return(c._CropAndResize=c.asm.CropAndResize).apply(null,arguments)},c._Cumprod=function(){return(c._Cumprod=c.asm.Cumprod).apply(null,arguments)},c._Cumsum=function(){return(c._Cumsum=c.asm.Cumsum).apply(null,arguments)},c._DenseBincount=function(){return(c._DenseBincount=c.asm.DenseBincount).apply(null,arguments)},c._DepthToSpace=function(){return(c._DepthToSpace=c.asm.DepthToSpace).apply(null,arguments)},c._DepthwiseConv2dNative=function(){return(c._DepthwiseConv2dNative=c.asm.DepthwiseConv2dNative).apply(null,arguments)},c._Diag=function(){return(c._Diag=c.asm.Diag).apply(null,arguments)},c._Dilation2D=function(){return(c._Dilation2D=c.asm.Dilation2D).apply(null,arguments)},c._Dilation2DBackpropFilter=function(){return(c._Dilation2DBackpropFilter=c.asm.Dilation2DBackpropFilter).apply(null,arguments)},c._Dilation2DBackpropInput=function(){return(c._Dilation2DBackpropInput=c.asm.Dilation2DBackpropInput).apply(null,arguments)},c._Elu=function(){return(c._Elu=c.asm.Elu).apply(null,arguments)},c._EluGrad=function(){return(c._EluGrad=c.asm.EluGrad).apply(null,arguments)},c._Equal=function(){return(c._Equal=c.asm.Equal).apply(null,arguments)},c._Erf=function(){return(c._Erf=c.asm.Erf).apply(null,arguments)},c._Exp=function(){return(c._Exp=c.asm.Exp).apply(null,arguments)},c._Expm1=function(){return(c._Expm1=c.asm.Expm1).apply(null,arguments)},c._FlipLeftRight=function(){return(c._FlipLeftRight=c.asm.FlipLeftRight).apply(null,arguments)},c._Floor=function(){return(c._Floor=c.asm.Floor).apply(null,arguments)},c._FloorDiv=function(){return(c._FloorDiv=c.asm.FloorDiv).apply(null,arguments)},c._FusedBatchNorm=function(){return(c._FusedBatchNorm=c.asm.FusedBatchNorm).apply(null,arguments)},c._FusedConv2D=function(){return(c._FusedConv2D=c.asm.FusedConv2D).apply(null,arguments)},c._FusedDepthwiseConv2D=function(){return(c._FusedDepthwiseConv2D=c.asm.FusedDepthwiseConv2D).apply(null,arguments)},c._Gather=function(){return(c._Gather=c.asm.Gather).apply(null,arguments)},c._GatherNd=function(){return(c._GatherNd=c.asm.GatherNd).apply(null,arguments)},c._Greater=function(){return(c._Greater=c.asm.Greater).apply(null,arguments)},c._GreaterEqual=function(){return(c._GreaterEqual=c.asm.GreaterEqual).apply(null,arguments)},c._IsFinite=function(){return(c._IsFinite=c.asm.IsFinite).apply(null,arguments)},c._IsInf=function(){return(c._IsInf=c.asm.IsInf).apply(null,arguments)},c._IsNan=function(){return(c._IsNan=c.asm.IsNan).apply(null,arguments)},c._LRN=function(){return(c._LRN=c.asm.LRN).apply(null,arguments)},c._LRNGrad=function(){return(c._LRNGrad=c.asm.LRNGrad).apply(null,arguments)},c._LeakyRelu=function(){return(c._LeakyRelu=c.asm.LeakyRelu).apply(null,arguments)},c._Less=function(){return(c._Less=c.asm.Less).apply(null,arguments)},c._LessEqual=function(){return(c._LessEqual=c.asm.LessEqual).apply(null,arguments)},c._LinSpace=function(){return(c._LinSpace=c.asm.LinSpace).apply(null,arguments)},c._Log=function(){return(c._Log=c.asm.Log).apply(null,arguments)},c._Log1p=function(){return(c._Log1p=c.asm.Log1p).apply(null,arguments)},c._LogicalAnd=function(){return(c._LogicalAnd=c.asm.LogicalAnd).apply(null,arguments)},c._LogicalNot=function(){return(c._LogicalNot=c.asm.LogicalNot).apply(null,arguments)},c._LogicalOr=function(){return(c._LogicalOr=c.asm.LogicalOr).apply(null,arguments)},c._LogicalXor=function(){return(c._LogicalXor=c.asm.LogicalXor).apply(null,arguments)},c._Max=function(){return(c._Max=c.asm.Max).apply(null,arguments)},c._MaxPool=function(){return(c._MaxPool=c.asm.MaxPool).apply(null,arguments)},c._MaxPool3D=function(){return(c._MaxPool3D=c.asm.MaxPool3D).apply(null,arguments)},c._MaxPool3DGrad=function(){return(c._MaxPool3DGrad=c.asm.MaxPool3DGrad).apply(null,arguments)},c._MaxPoolGrad=function(){return(c._MaxPoolGrad=c.asm.MaxPoolGrad).apply(null,arguments)},c._MaxPoolWithArgmax=function(){return(c._MaxPoolWithArgmax=c.asm.MaxPoolWithArgmax).apply(null,arguments)},c._Maximum=function(){return(c._Maximum=c.asm.Maximum).apply(null,arguments)},c._Mean=function(){return(c._Mean=c.asm.Mean).apply(null,arguments)},c._Min=function(){return(c._Min=c.asm.Min).apply(null,arguments)},c._Minimum=function(){return(c._Minimum=c.asm.Minimum).apply(null,arguments)},c._MirrorPad=function(){return(c._MirrorPad=c.asm.MirrorPad).apply(null,arguments)},c._Mod=function(){return(c._Mod=c.asm.Mod).apply(null,arguments)},c._Multinomial=function(){return(c._Multinomial=c.asm.Multinomial).apply(null,arguments)},c._Multiply=function(){return(c._Multiply=c.asm.Multiply).apply(null,arguments)},c._Neg=function(){return(c._Neg=c.asm.Neg).apply(null,arguments)},c._NonMaxSuppressionV3=function(){return(c._NonMaxSuppressionV3=c.asm.NonMaxSuppressionV3).apply(null,arguments)},c._NonMaxSuppressionV4=function(){return(c._NonMaxSuppressionV4=c.asm.NonMaxSuppressionV4).apply(null,arguments)},c._NonMaxSuppressionV5=function(){return(c._NonMaxSuppressionV5=c.asm.NonMaxSuppressionV5).apply(null,arguments)},c._NotEqual=function(){return(c._NotEqual=c.asm.NotEqual).apply(null,arguments)},c._OneHot=function(){return(c._OneHot=c.asm.OneHot).apply(null,arguments)},c._PadV2=function(){return(c._PadV2=c.asm.PadV2).apply(null,arguments)},c._Pow=function(){return(c._Pow=c.asm.Pow).apply(null,arguments)},c._Prelu=function(){return(c._Prelu=c.asm.Prelu).apply(null,arguments)},c._Prod=function(){return(c._Prod=c.asm.Prod).apply(null,arguments)},c._RealDiv=function(){return(c._RealDiv=c.asm.RealDiv).apply(null,arguments)},c._Reciprocal=function(){return(c._Reciprocal=c.asm.Reciprocal).apply(null,arguments)},c._Relu=function(){return(c._Relu=c.asm.Relu).apply(null,arguments)},c._Relu6=function(){return(c._Relu6=c.asm.Relu6).apply(null,arguments)},c._ResizeBilinear=function(){return(c._ResizeBilinear=c.asm.ResizeBilinear).apply(null,arguments)},c._ResizeBilinearGrad=function(){return(c._ResizeBilinearGrad=c.asm.ResizeBilinearGrad).apply(null,arguments)},c._ResizeNearestNeighbor=function(){return(c._ResizeNearestNeighbor=c.asm.ResizeNearestNeighbor).apply(null,arguments)},c._ResizeNearestNeighborGrad=function(){return(c._ResizeNearestNeighborGrad=c.asm.ResizeNearestNeighborGrad).apply(null,arguments)},c._Reverse=function(){return(c._Reverse=c.asm.Reverse).apply(null,arguments)},c._RotateWithOffset=function(){return(c._RotateWithOffset=c.asm.RotateWithOffset).apply(null,arguments)},c._Round=function(){return(c._Round=c.asm.Round).apply(null,arguments)},c._Rsqrt=function(){return(c._Rsqrt=c.asm.Rsqrt).apply(null,arguments)},c._ScatterNd=function(){return(c._ScatterNd=c.asm.ScatterNd).apply(null,arguments)},c._SearchSorted=function(){return(c._SearchSorted=c.asm.SearchSorted).apply(null,arguments)},c._SelectV2=function(){return(c._SelectV2=c.asm.SelectV2).apply(null,arguments)},c._Selu=function(){return(c._Selu=c.asm.Selu).apply(null,arguments)},c._Sigmoid=function(){return(c._Sigmoid=c.asm.Sigmoid).apply(null,arguments)},c._Sign=function(){return(c._Sign=c.asm.Sign).apply(null,arguments)},c._Sin=function(){return(c._Sin=c.asm.Sin).apply(null,arguments)},c._Sinh=function(){return(c._Sinh=c.asm.Sinh).apply(null,arguments)},c._Softmax=function(){return(c._Softmax=c.asm.Softmax).apply(null,arguments)},c._Softplus=function(){return(c._Softplus=c.asm.Softplus).apply(null,arguments)},c._SparseFillEmptyRows=function(){return(c._SparseFillEmptyRows=c.asm.SparseFillEmptyRows).apply(null,arguments)},c._SparseReshape=function(){return(c._SparseReshape=c.asm.SparseReshape).apply(null,arguments)},c._SparseSegmentReduction=function(){return(c._SparseSegmentReduction=c.asm.SparseSegmentReduction).apply(null,arguments)},c._SparseToDense=function(){return(c._SparseToDense=c.asm.SparseToDense).apply(null,arguments)},c._Sqrt=function(){return(c._Sqrt=c.asm.Sqrt).apply(null,arguments)},c._Square=function(){return(c._Square=c.asm.Square).apply(null,arguments)},c._SquaredDifference=function(){return(c._SquaredDifference=c.asm.SquaredDifference).apply(null,arguments)},c._Step=function(){return(c._Step=c.asm.Step).apply(null,arguments)},c._StridedSlice=function(){return(c._StridedSlice=c.asm.StridedSlice).apply(null,arguments)},c._Sub=function(){return(c._Sub=c.asm.Sub).apply(null,arguments)},c._Sum=function(){return(c._Sum=c.asm.Sum).apply(null,arguments)},c._Tan=function(){return(c._Tan=c.asm.Tan).apply(null,arguments)},c._Tanh=function(){return(c._Tanh=c.asm.Tanh).apply(null,arguments)},c._TensorScatterUpdate=function(){return(c._TensorScatterUpdate=c.asm.TensorScatterUpdate).apply(null,arguments)},c._Tile=function(){return(c._Tile=c.asm.Tile).apply(null,arguments)},c._TopK=function(){return(c._TopK=c.asm.TopK).apply(null,arguments)},c._Transform=function(){return(c._Transform=c.asm.Transform).apply(null,arguments)},c._Transpose=function(){return(c._Transpose=c.asm.Transpose).apply(null,arguments)},c.__FusedMatMul=function(){return(c.__FusedMatMul=c.asm._FusedMatMul).apply(null,arguments)},c._malloc=function(){return(c._malloc=c.asm.malloc).apply(null,arguments)},c._free=function(){return(c._free=c.asm.free).apply(null,arguments)},c.__emscripten_tls_init=function(){return(c.__emscripten_tls_init=c.asm._emscripten_tls_init).apply(null,arguments)};var po=c._pthread_self=function(){return(po=c._pthread_self=c.asm.pthread_self).apply(null,arguments)};c.___errno_location=function(){return(c.___errno_location=c.asm.__errno_location).apply(null,arguments)};var Si=c.__emscripten_thread_init=function(){return(Si=c.__emscripten_thread_init=c.asm._emscripten_thread_init).apply(null,arguments)};c.__emscripten_thread_crashed=function(){return(c.__emscripten_thread_crashed=c.asm._emscripten_thread_crashed).apply(null,arguments)},c._emscripten_main_thread_process_queued_calls=function(){return(c._emscripten_main_thread_process_queued_calls=c.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},c._emscripten_main_browser_thread_id=function(){return(c._emscripten_main_browser_thread_id=c.asm.emscripten_main_browser_thread_id).apply(null,arguments)};var Af=c._emscripten_run_in_main_runtime_thread_js=function(){return(Af=c._emscripten_run_in_main_runtime_thread_js=c.asm.emscripten_run_in_main_runtime_thread_js).apply(null,arguments)};c._emscripten_dispatch_to_thread_=function(){return(c._emscripten_dispatch_to_thread_=c.asm.emscripten_dispatch_to_thread_).apply(null,arguments)};var $f=c.__emscripten_proxy_execute_task_queue=function(){return($f=c.__emscripten_proxy_execute_task_queue=c.asm._emscripten_proxy_execute_task_queue).apply(null,arguments)},Ks=c.__emscripten_thread_free_data=function(){return(Ks=c.__emscripten_thread_free_data=c.asm._emscripten_thread_free_data).apply(null,arguments)},My=c.__emscripten_thread_exit=function(){return(My=c.__emscripten_thread_exit=c.asm._emscripten_thread_exit).apply(null,arguments)},Rf=c._emscripten_stack_set_limits=function(){return(Rf=c._emscripten_stack_set_limits=c.asm.emscripten_stack_set_limits).apply(null,arguments)},$d=c.stackSave=function(){return($d=c.stackSave=c.asm.stackSave).apply(null,arguments)},fo=c.stackRestore=function(){return(fo=c.stackRestore=c.asm.stackRestore).apply(null,arguments)},Rd=c.stackAlloc=function(){return(Rd=c.stackAlloc=c.asm.stackAlloc).apply(null,arguments)};c.dynCall_iijjiiii=function(){return(c.dynCall_iijjiiii=c.asm.dynCall_iijjiiii).apply(null,arguments)},c.dynCall_jiji=function(){return(c.dynCall_jiji=c.asm.dynCall_jiji).apply(null,arguments)},c.keepRuntimeAlive=rn,c.wasmMemory=Q,c.cwrap=gr,c.ExitStatus=fr,c.PThread=Re;var Dd;va=function G(){Dd||Ll(),Dd||(va=G)};function Ll(G){if(Mn>0)return;if(N){p(c),Hn(),startWorker(c);return}if(ra(),Mn>0)return;function ue(){Dd||(Dd=!0,c.calledRun=!0,!me&&(Hn(),p(c),c.onRuntimeInitialized&&c.onRuntimeInitialized(),Ta()))}c.setStatus?(c.setStatus("Running..."),setTimeout(function(){setTimeout(function(){c.setStatus("")},1),ue()},1)):ue()}if(c.preInit)for(typeof c.preInit=="function"&&(c.preInit=[c.preInit]);c.preInit.length>0;)c.preInit.pop()();Ll();var yr;g&&(yr={uncaughtException:process.listeners("uncaughtException").filter(function(G){return!g.uncaughtException.indexOf(G)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(G){return!g.unhandledRejection.indexOf(G)>-1})});var mo;if(typeof WasmBackendModule<"u")mo=WasmBackendModule;else if(typeof r<"u")mo=r;else throw new Error("Could not find wasm module in post.js");if(yr){var Df=mo._dispose;mo._dispose=function(){Df(),yr.uncaughtException.forEach(function(G){process.removeListener("uncaughtException",G)}),yr.unhandledRejection.forEach(function(G){process.removeListener("unhandledRejection",G)})}}return r.ready}})();typeof e=="object"&&typeof t=="object"?t.exports=n:typeof define=="function"&&define.amd?define([],function(){return n}):typeof e=="object"&&(e.WasmBackendModuleThreadedSimd=n)}),SG=Wn((e,t)=>{t.exports.wasmWorkerContents=`"use strict";var Module={};var ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads");var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",data=>onmessage({data:data}));var fs=require("fs");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:function(f){(0,eval)(fs.readFileSync(f,"utf8")+"//# sourceURL="+f)},postMessage:function(msg){parentPort.postMessage(msg)},performance:global.performance||{now:function(){return Date.now()}}})}var initializedJS=false;var pendingNotifiedProxyingQueues=[];function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+"
");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;self.alert=threadAlert;Module["instantiateWasm"]=(info,receiveInstance)=>{var instance=new WebAssembly.Instance(Module["wasmModule"],info);receiveInstance(instance);Module["wasmModule"]=null;return instance.exports};self.onunhandledrejection=e=>{throw e.reason??e};self.startWorker=instance=>{Module=instance;postMessage({"cmd":"loaded"})};self.onmessage=e=>{try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;for(const handler of e.data.handlers){Module[handler]=function(){postMessage({cmd:"callHandler",handler:handler,args:[...arguments]})}}Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob=="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module)}else if(e.data.cmd==="run"){Module["__emscripten_thread_init"](e.data.pthread_ptr,0,0,1);Module["establishStackSpace"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].threadInitTLS();if(!initializedJS){pendingNotifiedProxyingQueues.forEach(queue=>{Module["executeNotifiedProxyingQueue"](queue)});pendingNotifiedProxyingQueues=[];initializedJS=true}try{Module["invokeEntryPoint"](e.data.start_routine,e.data.arg)}catch(ex){if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["keepRuntimeAlive"]()){}else{Module["__emscripten_thread_exit"](ex.status)}}else{throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["__emscripten_thread_exit"](-1)}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processProxyingQueue"){if(initializedJS){Module["executeNotifiedProxyingQueue"](e.data.queue)}else{pendingNotifiedProxyingQueues.push(e.data.queue)}}else if(e.data.cmd){err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){if(Module["__emscripten_thread_crashed"]){Module["__emscripten_thread_crashed"]()}throw ex}};`}),kG=Wn((e,t)=>{var n=(()=>{var a=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(a=a||__filename),function(r){r=r||{};var s=typeof r<"u"?r:{},i,o;s.ready=new Promise(function(xe,Ae){i=xe,o=Ae});var u;typeof process<"u"&&process.listeners&&(u={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var d=Object.assign({},s),c=typeof window=="object",p=typeof importScripts=="function",m=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",g="";function b(xe){return s.locateFile?s.locateFile(xe,g):g+xe}var v,x,w;if(m){var k=Qk(),N=eO();p?g=N.dirname(g)+"/":g=__dirname+"/",v=(xe,Ae)=>(xe=xt(xe)?new URL(xe):N.normalize(xe),k.readFileSync(xe,Ae?void 0:"utf8")),w=xe=>{var Ae=v(xe,!0);return Ae.buffer||(Ae=new Uint8Array(Ae)),Ae},x=(xe,Ae,Ge)=>{xe=xt(xe)?new URL(xe):N.normalize(xe),k.readFile(xe,function(Re,Ht){Re?Ge(Re):Ae(Ht.buffer)})},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),process.argv.slice(2),process.on("uncaughtException",function(xe){if(!(xe instanceof rn))throw xe}),process.on("unhandledRejection",function(xe){throw xe}),s.inspect=function(){return"[Emscripten Module object]"}}else(c||p)&&(p?g=self.location.href:typeof document<"u"&&document.currentScript&&(g=document.currentScript.src),a&&(g=a),g.indexOf("blob:")!==0?g=g.substr(0,g.replace(/[?#].*/,"").lastIndexOf("/")+1):g="",v=xe=>{var Ae=new XMLHttpRequest;return Ae.open("GET",xe,!1),Ae.send(null),Ae.responseText},p&&(w=xe=>{var Ae=new XMLHttpRequest;return Ae.open("GET",xe,!1),Ae.responseType="arraybuffer",Ae.send(null),new Uint8Array(Ae.response)}),x=(xe,Ae,Ge)=>{var Re=new XMLHttpRequest;Re.open("GET",xe,!0),Re.responseType="arraybuffer",Re.onload=()=>{if(Re.status==200||Re.status==0&&Re.response){Ae(Re.response);return}Ge()},Re.onerror=Ge,Re.send(null)});var I=s.print||console.log.bind(console),T=s.printErr||console.warn.bind(console);Object.assign(s,d),d=null,s.arguments&&s.arguments,s.thisProgram&&s.thisProgram,s.quit&&s.quit;var $;s.wasmBinary&&($=s.wasmBinary),s.noExitRuntime,typeof WebAssembly!="object"&&lt("no native wasm support detected");var D,M=!1,B=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function V(xe,Ae,Ge){Ae>>>=0;for(var Re=Ae+Ge,Ht=Ae;xe[Ht]&&!(Ht>=Re);)++Ht;if(Ht-Ae>16&&xe.buffer&&B)return B.decode(xe.subarray(Ae,Ht));for(var Qt="";Ae<Ht;){var ht=xe[Ae++];if(!(ht&128)){Qt+=String.fromCharCode(ht);continue}var st=xe[Ae++]&63;if((ht&224)==192){Qt+=String.fromCharCode((ht&31)<<6|st);continue}var pn=xe[Ae++]&63;if((ht&240)==224?ht=(ht&15)<<12|st<<6|pn:ht=(ht&7)<<18|st<<12|pn<<6|xe[Ae++]&63,ht<65536)Qt+=String.fromCharCode(ht);else{var Ea=ht-65536;Qt+=String.fromCharCode(55296|Ea>>10,56320|Ea&1023)}}return Qt}function W(xe,Ae){return xe>>>=0,xe?V(j,xe,Ae):""}function R(xe,Ae,Ge,Re){if(Ge>>>=0,!(Re>0))return 0;for(var Ht=Ge,Qt=Ge+Re-1,ht=0;ht<xe.length;++ht){var st=xe.charCodeAt(ht);if(st>=55296&&st<=57343){var pn=xe.charCodeAt(++ht);st=65536+((st&1023)<<10)|pn&1023}if(st<=127){if(Ge>=Qt)break;Ae[Ge++>>>0]=st}else if(st<=2047){if(Ge+1>=Qt)break;Ae[Ge++>>>0]=192|st>>6,Ae[Ge++>>>0]=128|st&63}else if(st<=65535){if(Ge+2>=Qt)break;Ae[Ge++>>>0]=224|st>>12,Ae[Ge++>>>0]=128|st>>6&63,Ae[Ge++>>>0]=128|st&63}else{if(Ge+3>=Qt)break;Ae[Ge++>>>0]=240|st>>18,Ae[Ge++>>>0]=128|st>>12&63,Ae[Ge++>>>0]=128|st>>6&63,Ae[Ge++>>>0]=128|st&63}}return Ae[Ge>>>0]=0,Ge-Ht}function H(xe,Ae,Ge){return R(xe,j,Ae,Ge)}var Z,ae,j,K;function Q(xe){Z=xe,s.HEAP8=ae=new Int8Array(xe),s.HEAP16=new Int16Array(xe),s.HEAP32=new Int32Array(xe),s.HEAPU8=j=new Uint8Array(xe),s.HEAPU16=new Uint16Array(xe),s.HEAPU32=K=new Uint32Array(xe),s.HEAPF32=new Float32Array(xe),s.HEAPF64=new Float64Array(xe)}s.INITIAL_MEMORY;var ce=[],me=[],L=[];function ee(){if(s.preRun)for(typeof s.preRun=="function"&&(s.preRun=[s.preRun]);s.preRun.length;)we(s.preRun.shift());ra(ce)}function ie(){ra(me)}function de(){if(s.postRun)for(typeof s.postRun=="function"&&(s.postRun=[s.postRun]);s.postRun.length;)Ee(s.postRun.shift());ra(L)}function we(xe){ce.unshift(xe)}function Ie(xe){me.unshift(xe)}function Ee(xe){L.unshift(xe)}var Ce=0,ze=null;function Ke(xe){Ce++,s.monitorRunDependencies&&s.monitorRunDependencies(Ce)}function at(xe){if(Ce--,s.monitorRunDependencies&&s.monitorRunDependencies(Ce),Ce==0&&ze){var Ae=ze;ze=null,Ae()}}function lt(xe){s.onAbort&&s.onAbort(xe),xe="Aborted("+xe+")",T(xe),M=!0,xe+=". Build with -sASSERTIONS for more info.";var Ae=new WebAssembly.RuntimeError(xe);throw o(Ae),Ae}var Dt="data:application/octet-stream;base64,";function ut(xe){return xe.startsWith(Dt)}function xt(xe){return xe.startsWith("file://")}var tt;tt="tfjs-backend-wasm.wasm",ut(tt)||(tt=b(tt));function At(xe){try{if(xe==tt&&$)return new Uint8Array($);if(w)return w(xe);throw"both async and sync fetching of the wasm failed"}catch(Ae){lt(Ae)}}function Bt(){if(!$&&(c||p)){if(typeof fetch=="function"&&!xt(tt))return fetch(tt,{credentials:"same-origin"}).then(function(xe){if(!xe.ok)throw"failed to load wasm binary file at '"+tt+"'";return xe.arrayBuffer()}).catch(function(){return At(tt)});if(x)return new Promise(function(xe,Ae){x(tt,function(Ge){xe(new Uint8Array(Ge))},Ae)})}return Promise.resolve().then(function(){return At(tt)})}function ya(){var xe={env:Sd,wasi_snapshot_preview1:Sd};function Ae(ht,st){var pn=ht.exports;s.asm=pn,D=s.asm.memory,Q(D.buffer),s.asm.__indirect_function_table,Ie(s.asm.__wasm_call_ctors),at()}Ke();function Ge(ht){Ae(ht.instance)}function Re(ht){return Bt().then(function(st){return WebAssembly.instantiate(st,xe)}).then(function(st){return st}).then(ht,function(st){T("failed to asynchronously prepare wasm: "+st),lt(st)})}function Ht(){return!$&&typeof WebAssembly.instantiateStreaming=="function"&&!ut(tt)&&!xt(tt)&&!m&&typeof fetch=="function"?fetch(tt,{credentials:"same-origin"}).then(function(ht){var st=WebAssembly.instantiateStreaming(ht,xe);return st.then(Ge,function(pn){return T("wasm streaming compile failed: "+pn),T("falling back to ArrayBuffer instantiation"),Re(Ge)})}):Re(Ge)}if(s.instantiateWasm)try{var Qt=s.instantiateWasm(xe,Ae);return Qt}catch(ht){T("Module.instantiateWasm callback failed with error: "+ht),o(ht)}return Ht().catch(o),{}}function rn(xe){this.name="ExitStatus",this.message="Program terminated with exit("+xe+")",this.status=xe}function ra(xe){for(;xe.length>0;)xe.shift()(s)}function Hn(){lt("")}function Ta(){return 4294901760}function dn(){return Ta()}function Ua(xe,Ae,Ge){j.copyWithin(xe>>>0,Ae>>>0,Ae+Ge>>>0)}function ba(xe){try{return D.grow(xe-Z.byteLength+65535>>>16),Q(D.buffer),1}catch{}}function Mn(xe){var Ae=j.length;xe=xe>>>0;var Ge=Ta();if(xe>Ge)return!1;let Re=(pn,Ea)=>pn+(Ea-pn%Ea)%Ea;for(var Ht=1;Ht<=4;Ht*=2){var Qt=Ae*(1+.2/Ht);Qt=Math.min(Qt,xe+100663296);var ht=Math.min(Ge,Re(Math.max(xe,Qt),65536)),st=ba(ht);if(st)return!0}return!1}function va(xe){return 52}function Gs(xe,Ae,Ge,Re,Ht){return 70}var oo=[null,[],[]];function _s(xe,Ae){var Ge=oo[xe];Ae===0||Ae===10?((xe===1?I:T)(V(Ge,0)),Ge.length=0):Ge.push(Ae)}function Ol(xe,Ae,Ge,Re){for(var Ht=0,Qt=0;Qt<Ge;Qt++){var ht=K[Ae>>>2],st=K[Ae+4>>>2];Ae+=8;for(var pn=0;pn<st;pn++)_s(xe,j[ht+pn>>>0]);Ht+=st}return K[Re>>>2]=Ht,0}function ja(xe){var Ae=s["_"+xe];return Ae}function In(xe,Ae){ae.set(xe,Ae>>>0)}function sn(xe,Ae,Ge,Re,Ht){var Qt={string:Ft=>{var nr=0;if(Ft!=null&&Ft!==0){var lo=(Ft.length<<2)+1;nr=fr(lo),H(Ft,nr,lo)}return nr},array:Ft=>{var nr=fr(Ft.length);return In(Ft,nr),nr}};function ht(Ft){return Ae==="string"?W(Ft):Ae==="boolean"?!!Ft:Ft}var st=ja(xe),pn=[],Ea=0;if(Re)for(var ns=0;ns<Re.length;ns++){var Ml=Qt[Ge[ns]];Ml?(Ea===0&&(Ea=kd()),pn[ns]=Ml(Re[ns])):pn[ns]=Re[ns]}var mr=st.apply(null,pn);function Tn(Ft){return Ea!==0&&_d(Ea),ht(Ft)}return mr=Tn(mr),mr}function xa(xe,Ae,Ge,Re){Ge=Ge||[];var Ht=Ge.every(ht=>ht==="number"||ht==="boolean"),Qt=Ae!=="string";return Qt&&Ht&&!Re?ja(xe):function(){return sn(xe,Ae,Ge,arguments)}}var Sd={abort:Hn,emscripten_get_heap_max:dn,emscripten_memcpy_big:Ua,emscripten_resize_heap:Mn,fd_close:va,fd_seek:Gs,fd_write:Ol};ya(),s.___wasm_call_ctors=function(){return(s.___wasm_call_ctors=s.asm.__wasm_call_ctors).apply(null,arguments)},s._init=function(){return(s._init=s.asm.init).apply(null,arguments)},s._init_with_threads_count=function(){return(s._init_with_threads_count=s.asm.init_with_threads_count).apply(null,arguments)},s._get_threads_count=function(){return(s._get_threads_count=s.asm.get_threads_count).apply(null,arguments)},s._register_tensor=function(){return(s._register_tensor=s.asm.register_tensor).apply(null,arguments)},s._dispose_data=function(){return(s._dispose_data=s.asm.dispose_data).apply(null,arguments)},s._dispose=function(){return(s._dispose=s.asm.dispose).apply(null,arguments)},s._Abs=function(){return(s._Abs=s.asm.Abs).apply(null,arguments)},s._Acos=function(){return(s._Acos=s.asm.Acos).apply(null,arguments)},s._Acosh=function(){return(s._Acosh=s.asm.Acosh).apply(null,arguments)},s._Add=function(){return(s._Add=s.asm.Add).apply(null,arguments)},s._AddN=function(){return(s._AddN=s.asm.AddN).apply(null,arguments)},s._All=function(){return(s._All=s.asm.All).apply(null,arguments)},s._Any=function(){return(s._Any=s.asm.Any).apply(null,arguments)},s._ArgMax=function(){return(s._ArgMax=s.asm.ArgMax).apply(null,arguments)},s._ArgMin=function(){return(s._ArgMin=s.asm.ArgMin).apply(null,arguments)},s._Asin=function(){return(s._Asin=s.asm.Asin).apply(null,arguments)},s._Asinh=function(){return(s._Asinh=s.asm.Asinh).apply(null,arguments)},s._Atan=function(){return(s._Atan=s.asm.Atan).apply(null,arguments)},s._Atan2=function(){return(s._Atan2=s.asm.Atan2).apply(null,arguments)},s._Atanh=function(){return(s._Atanh=s.asm.Atanh).apply(null,arguments)},s._AvgPool=function(){return(s._AvgPool=s.asm.AvgPool).apply(null,arguments)},s._AvgPool3D=function(){return(s._AvgPool3D=s.asm.AvgPool3D).apply(null,arguments)},s._AvgPool3DGrad=function(){return(s._AvgPool3DGrad=s.asm.AvgPool3DGrad).apply(null,arguments)},s._AvgPoolGrad=function(){return(s._AvgPoolGrad=s.asm.AvgPoolGrad).apply(null,arguments)},s._BatchMatMul=function(){return(s._BatchMatMul=s.asm.BatchMatMul).apply(null,arguments)},s._Bincount=function(){return(s._Bincount=s.asm.Bincount).apply(null,arguments)},s._BitwiseAnd=function(){return(s._BitwiseAnd=s.asm.BitwiseAnd).apply(null,arguments)},s._Ceil=function(){return(s._Ceil=s.asm.Ceil).apply(null,arguments)},s._ClipByValue=function(){return(s._ClipByValue=s.asm.ClipByValue).apply(null,arguments)},s._Conv2D=function(){return(s._Conv2D=s.asm.Conv2D).apply(null,arguments)},s._Conv2DBackpropInput=function(){return(s._Conv2DBackpropInput=s.asm.Conv2DBackpropInput).apply(null,arguments)},s._Conv3D=function(){return(s._Conv3D=s.asm.Conv3D).apply(null,arguments)},s._Conv3DBackpropFilterV2=function(){return(s._Conv3DBackpropFilterV2=s.asm.Conv3DBackpropFilterV2).apply(null,arguments)},s._Conv3DBackpropInputV2=function(){return(s._Conv3DBackpropInputV2=s.asm.Conv3DBackpropInputV2).apply(null,arguments)},s._Cos=function(){return(s._Cos=s.asm.Cos).apply(null,arguments)},s._Cosh=function(){return(s._Cosh=s.asm.Cosh).apply(null,arguments)},s._CropAndResize=function(){return(s._CropAndResize=s.asm.CropAndResize).apply(null,arguments)},s._Cumprod=function(){return(s._Cumprod=s.asm.Cumprod).apply(null,arguments)},s._Cumsum=function(){return(s._Cumsum=s.asm.Cumsum).apply(null,arguments)},s._DenseBincount=function(){return(s._DenseBincount=s.asm.DenseBincount).apply(null,arguments)},s._DepthToSpace=function(){return(s._DepthToSpace=s.asm.DepthToSpace).apply(null,arguments)},s._DepthwiseConv2dNative=function(){return(s._DepthwiseConv2dNative=s.asm.DepthwiseConv2dNative).apply(null,arguments)},s._Diag=function(){return(s._Diag=s.asm.Diag).apply(null,arguments)},s._Dilation2D=function(){return(s._Dilation2D=s.asm.Dilation2D).apply(null,arguments)},s._Dilation2DBackpropFilter=function(){return(s._Dilation2DBackpropFilter=s.asm.Dilation2DBackpropFilter).apply(null,arguments)},s._Dilation2DBackpropInput=function(){return(s._Dilation2DBackpropInput=s.asm.Dilation2DBackpropInput).apply(null,arguments)},s._Elu=function(){return(s._Elu=s.asm.Elu).apply(null,arguments)},s._EluGrad=function(){return(s._EluGrad=s.asm.EluGrad).apply(null,arguments)},s._Equal=function(){return(s._Equal=s.asm.Equal).apply(null,arguments)},s._Erf=function(){return(s._Erf=s.asm.Erf).apply(null,arguments)},s._Exp=function(){return(s._Exp=s.asm.Exp).apply(null,arguments)},s._Expm1=function(){return(s._Expm1=s.asm.Expm1).apply(null,arguments)},s._FlipLeftRight=function(){return(s._FlipLeftRight=s.asm.FlipLeftRight).apply(null,arguments)},s._Floor=function(){return(s._Floor=s.asm.Floor).apply(null,arguments)},s._FloorDiv=function(){return(s._FloorDiv=s.asm.FloorDiv).apply(null,arguments)},s._FusedBatchNorm=function(){return(s._FusedBatchNorm=s.asm.FusedBatchNorm).apply(null,arguments)},s._FusedConv2D=function(){return(s._FusedConv2D=s.asm.FusedConv2D).apply(null,arguments)},s._FusedDepthwiseConv2D=function(){return(s._FusedDepthwiseConv2D=s.asm.FusedDepthwiseConv2D).apply(null,arguments)},s._Gather=function(){return(s._Gather=s.asm.Gather).apply(null,arguments)},s._GatherNd=function(){return(s._GatherNd=s.asm.GatherNd).apply(null,arguments)},s._Greater=function(){return(s._Greater=s.asm.Greater).apply(null,arguments)},s._GreaterEqual=function(){return(s._GreaterEqual=s.asm.GreaterEqual).apply(null,arguments)},s._IsFinite=function(){return(s._IsFinite=s.asm.IsFinite).apply(null,arguments)},s._IsInf=function(){return(s._IsInf=s.asm.IsInf).apply(null,arguments)},s._IsNan=function(){return(s._IsNan=s.asm.IsNan).apply(null,arguments)},s._LRN=function(){return(s._LRN=s.asm.LRN).apply(null,arguments)},s._LRNGrad=function(){return(s._LRNGrad=s.asm.LRNGrad).apply(null,arguments)},s._LeakyRelu=function(){return(s._LeakyRelu=s.asm.LeakyRelu).apply(null,arguments)},s._Less=function(){return(s._Less=s.asm.Less).apply(null,arguments)},s._LessEqual=function(){return(s._LessEqual=s.asm.LessEqual).apply(null,arguments)},s._LinSpace=function(){return(s._LinSpace=s.asm.LinSpace).apply(null,arguments)},s._Log=function(){return(s._Log=s.asm.Log).apply(null,arguments)},s._Log1p=function(){return(s._Log1p=s.asm.Log1p).apply(null,arguments)},s._LogicalAnd=function(){return(s._LogicalAnd=s.asm.LogicalAnd).apply(null,arguments)},s._LogicalNot=function(){return(s._LogicalNot=s.asm.LogicalNot).apply(null,arguments)},s._LogicalOr=function(){return(s._LogicalOr=s.asm.LogicalOr).apply(null,arguments)},s._LogicalXor=function(){return(s._LogicalXor=s.asm.LogicalXor).apply(null,arguments)},s._Max=function(){return(s._Max=s.asm.Max).apply(null,arguments)},s._MaxPool=function(){return(s._MaxPool=s.asm.MaxPool).apply(null,arguments)},s._MaxPool3D=function(){return(s._MaxPool3D=s.asm.MaxPool3D).apply(null,arguments)},s._MaxPool3DGrad=function(){return(s._MaxPool3DGrad=s.asm.MaxPool3DGrad).apply(null,arguments)},s._MaxPoolGrad=function(){return(s._MaxPoolGrad=s.asm.MaxPoolGrad).apply(null,arguments)},s._MaxPoolWithArgmax=function(){return(s._MaxPoolWithArgmax=s.asm.MaxPoolWithArgmax).apply(null,arguments)},s._Maximum=function(){return(s._Maximum=s.asm.Maximum).apply(null,arguments)},s._Mean=function(){return(s._Mean=s.asm.Mean).apply(null,arguments)},s._Min=function(){return(s._Min=s.asm.Min).apply(null,arguments)},s._Minimum=function(){return(s._Minimum=s.asm.Minimum).apply(null,arguments)},s._MirrorPad=function(){return(s._MirrorPad=s.asm.MirrorPad).apply(null,arguments)},s._Mod=function(){return(s._Mod=s.asm.Mod).apply(null,arguments)},s._Multinomial=function(){return(s._Multinomial=s.asm.Multinomial).apply(null,arguments)},s._Multiply=function(){return(s._Multiply=s.asm.Multiply).apply(null,arguments)},s._Neg=function(){return(s._Neg=s.asm.Neg).apply(null,arguments)},s._NonMaxSuppressionV3=function(){return(s._NonMaxSuppressionV3=s.asm.NonMaxSuppressionV3).apply(null,arguments)},s._NonMaxSuppressionV4=function(){return(s._NonMaxSuppressionV4=s.asm.NonMaxSuppressionV4).apply(null,arguments)},s._NonMaxSuppressionV5=function(){return(s._NonMaxSuppressionV5=s.asm.NonMaxSuppressionV5).apply(null,arguments)},s._NotEqual=function(){return(s._NotEqual=s.asm.NotEqual).apply(null,arguments)},s._OneHot=function(){return(s._OneHot=s.asm.OneHot).apply(null,arguments)},s._PadV2=function(){return(s._PadV2=s.asm.PadV2).apply(null,arguments)},s._Pow=function(){return(s._Pow=s.asm.Pow).apply(null,arguments)},s._Prelu=function(){return(s._Prelu=s.asm.Prelu).apply(null,arguments)},s._Prod=function(){return(s._Prod=s.asm.Prod).apply(null,arguments)},s._RealDiv=function(){return(s._RealDiv=s.asm.RealDiv).apply(null,arguments)},s._Reciprocal=function(){return(s._Reciprocal=s.asm.Reciprocal).apply(null,arguments)},s._Relu=function(){return(s._Relu=s.asm.Relu).apply(null,arguments)},s._Relu6=function(){return(s._Relu6=s.asm.Relu6).apply(null,arguments)},s._ResizeBilinear=function(){return(s._ResizeBilinear=s.asm.ResizeBilinear).apply(null,arguments)},s._ResizeBilinearGrad=function(){return(s._ResizeBilinearGrad=s.asm.ResizeBilinearGrad).apply(null,arguments)},s._ResizeNearestNeighbor=function(){return(s._ResizeNearestNeighbor=s.asm.ResizeNearestNeighbor).apply(null,arguments)},s._ResizeNearestNeighborGrad=function(){return(s._ResizeNearestNeighborGrad=s.asm.ResizeNearestNeighborGrad).apply(null,arguments)},s._Reverse=function(){return(s._Reverse=s.asm.Reverse).apply(null,arguments)},s._RotateWithOffset=function(){return(s._RotateWithOffset=s.asm.RotateWithOffset).apply(null,arguments)},s._Round=function(){return(s._Round=s.asm.Round).apply(null,arguments)},s._Rsqrt=function(){return(s._Rsqrt=s.asm.Rsqrt).apply(null,arguments)},s._ScatterNd=function(){return(s._ScatterNd=s.asm.ScatterNd).apply(null,arguments)},s._SearchSorted=function(){return(s._SearchSorted=s.asm.SearchSorted).apply(null,arguments)},s._SelectV2=function(){return(s._SelectV2=s.asm.SelectV2).apply(null,arguments)},s._Selu=function(){return(s._Selu=s.asm.Selu).apply(null,arguments)},s._Sigmoid=function(){return(s._Sigmoid=s.asm.Sigmoid).apply(null,arguments)},s._Sign=function(){return(s._Sign=s.asm.Sign).apply(null,arguments)},s._Sin=function(){return(s._Sin=s.asm.Sin).apply(null,arguments)},s._Sinh=function(){return(s._Sinh=s.asm.Sinh).apply(null,arguments)},s._Softmax=function(){return(s._Softmax=s.asm.Softmax).apply(null,arguments)},s._Softplus=function(){return(s._Softplus=s.asm.Softplus).apply(null,arguments)},s._SparseFillEmptyRows=function(){return(s._SparseFillEmptyRows=s.asm.SparseFillEmptyRows).apply(null,arguments)},s._SparseReshape=function(){return(s._SparseReshape=s.asm.SparseReshape).apply(null,arguments)},s._SparseSegmentReduction=function(){return(s._SparseSegmentReduction=s.asm.SparseSegmentReduction).apply(null,arguments)},s._SparseToDense=function(){return(s._SparseToDense=s.asm.SparseToDense).apply(null,arguments)},s._Sqrt=function(){return(s._Sqrt=s.asm.Sqrt).apply(null,arguments)},s._Square=function(){return(s._Square=s.asm.Square).apply(null,arguments)},s._SquaredDifference=function(){return(s._SquaredDifference=s.asm.SquaredDifference).apply(null,arguments)},s._Step=function(){return(s._Step=s.asm.Step).apply(null,arguments)},s._StridedSlice=function(){return(s._StridedSlice=s.asm.StridedSlice).apply(null,arguments)},s._Sub=function(){return(s._Sub=s.asm.Sub).apply(null,arguments)},s._Sum=function(){return(s._Sum=s.asm.Sum).apply(null,arguments)},s._Tan=function(){return(s._Tan=s.asm.Tan).apply(null,arguments)},s._Tanh=function(){return(s._Tanh=s.asm.Tanh).apply(null,arguments)},s._TensorScatterUpdate=function(){return(s._TensorScatterUpdate=s.asm.TensorScatterUpdate).apply(null,arguments)},s._Tile=function(){return(s._Tile=s.asm.Tile).apply(null,arguments)},s._TopK=function(){return(s._TopK=s.asm.TopK).apply(null,arguments)},s._Transform=function(){return(s._Transform=s.asm.Transform).apply(null,arguments)},s._Transpose=function(){return(s._Transpose=s.asm.Transpose).apply(null,arguments)},s.__FusedMatMul=function(){return(s.__FusedMatMul=s.asm._FusedMatMul).apply(null,arguments)},s._malloc=function(){return(s._malloc=s.asm.malloc).apply(null,arguments)},s._free=function(){return(s._free=s.asm.free).apply(null,arguments)},s.___errno_location=function(){return(s.___errno_location=s.asm.__errno_location).apply(null,arguments)};var kd=s.stackSave=function(){return(kd=s.stackSave=s.asm.stackSave).apply(null,arguments)},_d=s.stackRestore=function(){return(_d=s.stackRestore=s.asm.stackRestore).apply(null,arguments)},fr=s.stackAlloc=function(){return(fr=s.stackAlloc=s.asm.stackAlloc).apply(null,arguments)};s.dynCall_iijjiiii=function(){return(s.dynCall_iijjiiii=s.asm.dynCall_iijjiiii).apply(null,arguments)},s.dynCall_jiji=function(){return(s.dynCall_jiji=s.asm.dynCall_jiji).apply(null,arguments)},s.cwrap=xa;var Ns;ze=function xe(){Ns||vi(),Ns||(ze=xe)};function vi(xe){if(Ce>0||(ee(),Ce>0))return;function Ae(){Ns||(Ns=!0,s.calledRun=!0,!M&&(ie(),i(s),s.onRuntimeInitialized&&s.onRuntimeInitialized(),de()))}s.setStatus?(s.setStatus("Running..."),setTimeout(function(){setTimeout(function(){s.setStatus("")},1),Ae()},1)):Ae()}if(s.preInit)for(typeof s.preInit=="function"&&(s.preInit=[s.preInit]);s.preInit.length>0;)s.preInit.pop()();vi();var tr;u&&(tr={uncaughtException:process.listeners("uncaughtException").filter(function(xe){return!u.uncaughtException.indexOf(xe)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(xe){return!u.unhandledRejection.indexOf(xe)>-1})});var ts;if(typeof r<"u")ts=r;else if(typeof WasmBackendModuleThreadedSimd<"u")ts=WasmBackendModuleThreadedSimd;else throw new Error("Could not find wasm module in post.js");if(tr){var qs=ts._dispose;ts._dispose=function(){qs(),tr.uncaughtException.forEach(function(xe){process.removeListener("uncaughtException",xe)}),tr.unhandledRejection.forEach(function(xe){process.removeListener("unhandledRejection",xe)})}}return r.ready}})();typeof e=="object"&&typeof t=="object"?t.exports=n:typeof define=="function"&&define.amd?define([],function(){return n}):typeof e=="object"&&(e.WasmBackendModule=n)}),s0=class{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}},_g=class{refCount(e){return kr("refCount")}incRef(e){return kr("incRef")}timerAvailable(){return!0}time(e){return kr("time")}read(e){return kr("read")}readSync(e){return kr("readSync")}readToGPU(e,t){return kr("readToGPU")}numDataIds(){return kr("numDataIds")}disposeData(e,t){return kr("disposeData")}write(e,t,n){return kr("write")}move(e,t,n,a,r){return kr("move")}createTensorFromGPUData(e,t,n){return kr("createTensorFromGPUData")}memory(){return kr("memory")}floatPrecision(){return kr("floatPrecision")}epsilon(){return this.floatPrecision()===32?1e-7:1e-4}dispose(){return kr("dispose")}};function kr(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function tO(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,Sv(e,t,n)}function _G(e,t){if(e.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);let n=e.length,a=0;for(;n>0;)a=Math.random()*n|0,n--,Sv(e,n,a),Sv(t,n,a)}function Xm(e,t,n){return Math.max(e,Math.min(t,n))}function NG(e){return e%2===0?e:e+1}function Sv(e,t,n){let a=e[t];e[t]=e[n],e[n]=a}function IG(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function TG(e,t){let n=Math.random();return t*n+(1-n)*e}function EG(e,t){let n=0;for(let a=0;a<e.length;a++){let r=Number(e[a])-Number(t[a]);n+=r*r}return n}function U(e,t){if(!e)throw new Error(typeof t=="string"?t:t())}function Ja(e,t,n=""){U(Zi(e,t),()=>n+` Shapes ${e} and ${t} must match`)}function Hu(e){U(e!=null,()=>"The input to the tensor constructor must be a non-null value.")}function Wt(e){if(e.length===0)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function CG(e){return e.length===0}function nO(e,t){if(e===t)return!0;if(e==null||t==null||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==null&&t[n]!==null&&e[n]!==t[n])return!1;return!0}function Zi(e,t){if(e===t)return!0;if(e==null||t==null||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function Oh(e){return e%1===0}function AG(e){if(Math.tanh!=null)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;{let t=Math.exp(2*e);return(t-1)/(t+1)}}function $G(e){let t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function RG(e){let t=new Uint32Array(e);for(let n=0;n<e;++n)t[n]=n;return tO(t),t}function Um(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function DG(e,t=r=>0,n,a){return new Promise((r,s)=>{let i=0,o=()=>{if(e()){r();return}i++;let u=t(i);if(n!=null&&i>=n){s();return}a!=null?a(o,u):setTimeout(o,u)};o()})}function OG(e,t){let n=1,a=-1;for(let s=0;s<e.length;++s)if(e[s]>=0)n*=e[s];else if(e[s]===-1){if(a!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${a} and dim ${s}`);a=s}else if(e[s]<0)throw Error(`Shapes can not be < 0. Found ${e[s]} at dim ${s}`);if(a===-1){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(n===0)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);let r=e.slice();return r[a]=t/n,r}function ws(e,t){let n=t.length;return e=e==null?t.map((a,r)=>r):[].concat(e),U(e.every(a=>a>=-n&&a<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`),U(e.every(a=>Oh(a)),()=>`All values in axis param must be integers but got axis ${e}`),e.map(a=>a<0?n+a:a)}function aO(e,t){let n=[],a=[],r=t!=null&&Array.isArray(t)&&t.length===0,s=t==null||r?null:ws(t,e).sort(),i=0;for(let o=0;o<e.length;++o){if(s!=null){if(s[i]===o&&e[o]!==1)throw new Error(`Can't squeeze axis ${o} since its dim '${e[o]}' is not 1`);(s[i]==null||s[i]>o)&&e[o]===1&&(n.push(e[o]),a.push(o)),s[i]<=o&&i++}e[o]!==1&&(n.push(e[o]),a.push(o))}return{newShape:n,keptDims:a}}function rO(e,t){return e_(e,t)}function e_(e,t){let n=null;if(e==null||e==="float32")n=new Float32Array(t);else if(e==="int32")n=new Int32Array(t);else if(e==="bool")n=new Uint8Array(t);else if(e==="string")n=new Array(t);else throw new Error(`Unknown data type ${e}`);return n}function sO(e,t){for(let n=0;n<e.length;n++){let a=e[n];if(isNaN(a)||!isFinite(a))throw Error(`A tensor of type ${t} being uploaded contains ${a}.`)}}function iO(e){return e==="bool"||e==="complex64"||e==="float32"||e==="int32"||e==="string"}function MG(e,t){return!(t==="complex64"||t==="float32"&&e!=="complex64"||t==="int32"&&e!=="float32"&&e!=="complex64"||t==="bool"&&e==="bool")}function kv(e){if(e==="float32"||e==="int32")return 4;if(e==="complex64")return 8;if(e==="bool")return 1;throw new Error(`Unknown dtype ${e}`)}function oO(e){if(e==null)return 0;let t=0;return e.forEach(n=>t+=n.length),t}function Ko(e){return typeof e=="string"||e instanceof String}function lO(e){return typeof e=="boolean"}function uO(e){return typeof e=="number"}function Ng(e){return Array.isArray(e)?Ng(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":uO(e)?"float32":Ko(e)?"string":lO(e)?"bool":"float32"}function tl(e){return!!(e&&e.constructor&&e.call&&e.apply)}function _v(e,t){for(let n=t;n<e;++n)if(e%n===0)return n;return e}function ep(e){let t=e.length;if(t<2)return[];let n=new Array(t-1);n[t-2]=e[t-1];for(let a=t-3;a>=0;--a)n[a]=n[a+1]*e[a+1];return n}function cO(e,t,n,a=!1){let r=new Array;if(t.length===1){let s=t[0]*(a?2:1);for(let i=0;i<s;i++)r[i]=n[e+i]}else{let s=t[0],i=t.slice(1),o=i.reduce((u,d)=>u*d)*(a?2:1);for(let u=0;u<s;u++)r[u]=cO(e+u*o,i,n,a)}return r}function Ch(e,t,n=!1){if(e.length===0)return t[0];let a=e.reduce((r,s)=>r*s)*(n?2:1);if(a===0)return[];if(a!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return cO(0,e,t,n)}function FG(e,t){if(Array.isArray(e))return e;if(t==="float32")return e instanceof Float32Array?e:new Float32Array(e);if(t==="int32")return e instanceof Int32Array?e:new Int32Array(e);if(t==="bool"||t==="string")return Uint8Array.from(new Int32Array(e));throw new Error(`Unknown dtype ${t}`)}function t_(e,t){let n=i0(e,t);for(let a=0;a<n.length;a++)n[a]=1;return n}function i0(e,t){if(t==null||t==="float32"||t==="complex64")return new Float32Array(e);if(t==="int32")return new Int32Array(e);if(t==="bool")return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function zG(e,t){let n=e.reduce((a,r)=>a*r,1);if(t==null||t==="float32")return Ch(e,new Float32Array(n));if(t==="int32")return Ch(e,new Int32Array(n));if(t==="bool")return Ch(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function Or(e){e.forEach(t=>{U(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`)})}function LG(e,t,n){if(t===0)return 0;if(t===1)return e[0];let a=e[e.length-1];for(let r=0;r<e.length-1;++r)a+=n[r]*e[r];return a}function BG(e,t,n){if(t===0)return[];if(t===1)return[e];let a=new Array(t);for(let r=0;r<a.length-1;++r)a[r]=Math.floor(e/n[r]),e-=a[r]*n[r];return a[a.length-1]=e,a}function o0(e){return e&&e.then&&typeof e.then=="function"}var b$="tfjsflags",dO=class{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=PG,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(oe().getBool("IS_TEST")||oe().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},this.urlFlags[e]!=null){let a=this.urlFlags[e];oe().getBool("IS_TEST")||oe().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${a}.`),this.set(e,a)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];let t=this.evaluateFlag(e);if(o0(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;let e=this.getQueryParams(this.global.location.search);b$ in e&&e[b$].split(",").forEach(t=>{let[n,a]=t.split(":");this.urlFlags[n]=jG(n,a)})}};function PG(e){let t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(n,...a)=>(UG(t,a[0],a[1]),a.join("="))),t}function UG(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}function jG(e,t){let n=t.toLowerCase();return n==="true"||n==="false"?n==="true":`${+n}`===n?+n:t}function oe(){return n_}var n_=null;function WG(e){n_=e}var K1;function hO(){if(K1==null){let e;if(typeof window<"u")e=window;else if(typeof global<"u")e=global;else if(typeof process<"u")e=process;else if(typeof self<"u")e=self;else throw new Error("Could not find a global object");K1=e}return K1}function VG(){let e=hO();return e._tfGlobals==null&&(e._tfGlobals=new Map),e._tfGlobals}function a_(e,t){let n=VG();if(n.has(e))return n.get(e);{let a=t();return n.set(e,a),n.get(e)}}var tp="Abs",Gu="Acos",qu="Acosh",bl="Add",Ku="AddN",np="All",ap="Any",rp="ArgMax",sp="ArgMin",Xu="Asin",Yu="Asinh",Ju="Atan",Zu="Atanh",Qu="Atan2",ec="AvgPool",Ig="AvgPoolGrad",ip="AvgPool3D",Tg="AvgPool3DGrad",tc="BatchMatMul",op="BatchToSpaceND",lp="Bincount",up="BitwiseAnd",pO="BroadcastTo",Eg="BroadcastArgs",nc="Cast",ac="Ceil",vl="ClipByValue",l0="Complex",Cg="ComplexAbs",cp="Concat",rc="Conv2D",u0="Conv2DBackpropFilter",sc="Conv2DBackpropInput",ic="Conv3D",dp="Conv3DBackpropFilterV2",hp="Conv3DBackpropInputV2",oc="Cos",lc="Cosh",pp="Cumprod",uc="Cumsum",fp="CropAndResize",Ag="DenseBincount",mp="DepthToSpace",cc="DepthwiseConv2dNative",c0="DepthwiseConv2dNativeBackpropFilter",d0="DepthwiseConv2dNativeBackpropInput",$g="Diag",dc="Dilation2D",Mh="Dilation2DBackpropInput",Fh="Dilation2DBackpropFilter",h0="Draw",hc="RealDiv",p0="Einsum",pc="Elu",gp="EluGrad",fc="Erf",yp="Equal",mc="Exp",bp="ExpandDims",gc="Expm1",f0="FFT",Rg="Fill",vp="FlipLeftRight",yc="Floor",bc="FloorDiv",vc="FusedBatchNorm",xp="GatherV2",wp="GatherNd",Sp="Greater",xc="GreaterEqual",wc="Identity",m0="IFFT",g0="Imag",Sc="IsFinite",kc="IsInf",_c="IsNan",Nc="LeakyRelu",kp="Less",_p="LessEqual",Np="LinSpace",Ic="Log",Tc="Log1p",Ip="LogicalAnd",Tp="LogicalNot",Ep="LogicalOr",fO="LogicalXor",mO="LogSoftmax",HG="LowerBound",Ec="LRN",Cp="LRNGrad",GG="MatrixBandPart",Cc="Max",Ac="Maximum",$c="MaxPool",Dg="MaxPoolGrad",Ap="MaxPool3D",Og="MaxPool3DGrad",Mg="MaxPoolWithArgmax",Rc="Mean",Dc="Min",Oc="Minimum",Mc="MirrorPad",Fc="Mod",$p="Multinomial",zc="Multiply",Rp="Neg",Dp="NotEqual",Op="NonMaxSuppressionV3",Mp="NonMaxSuppressionV4",Fp="NonMaxSuppressionV5",zp="OnesLike",Lc="OneHot",Lp="Pack",Bc="PadV2",qG="Pool",Pc="Pow",Uc="Prelu",jc="Prod",y0="RaggedGather",b0="RaggedRange",v0="RaggedTensorToTensor",Fg="Range",x0="Real",Wc="Reciprocal",Vc="Relu",Bp="Reshape",Hc="ResizeNearestNeighbor",Pp="ResizeNearestNeighborGrad",Gc="ResizeBilinear",Up="ResizeBilinearGrad",qc="Relu6",Kc="Reverse",Xc="Round",Yc="Rsqrt",jp="ScatterNd",Wp="TensorScatterUpdate",Vp="SearchSorted",Hp="Select",Jc="Selu",Gp="Slice",Zc="Sin",Qc="Sinh",ed="Sign",td="Sigmoid",nd="Softplus",ad="Sqrt",rd="Sum",qp="SpaceToBatchND",Kp="SplitV",sd="Softmax",zg="SparseFillEmptyRows",Xp="SparseReshape",Lg="SparseSegmentMean",Bg="SparseSegmentSum",Yp="SparseToDense",id="SquaredDifference",Pg="Square",Ug="StaticRegexReplace",Jp="StridedSlice",jg="StringNGrams",Wg="StringSplit",Vg="StringToHashBucketFast",od="Sub",ld="Tan",ud="Tanh",xl="Tile",Zp="TopK",Qp="Transform",Hi="Transpose",Hg="Unique",ef="Unpack",Gg="UnsortedSegmentSum",KG="UpperBound",tf="ZerosLike",wl="Step",Nv="FromPixels",nf="RotateWithOffset",Nu="_FusedMatMul",Iu="FusedConv2D",Tu="FusedDepthwiseConv2D";function Go(...e){oe().getBool("IS_TEST")||oe().getBool("PROD")||console.warn(...e)}function XG(...e){oe().getBool("IS_TEST")||oe().getBool("PROD")||console.log(...e)}var zh=a_("kernelRegistry",()=>new Map),Ym=a_("gradRegistry",()=>new Map);function Jm(e,t){let n=r_(e,t);return zh.get(n)}function TS(e){return Ym.get(e)}function Iv(e){let t=zh.entries(),n=[];for(;;){let{done:a,value:r}=t.next();if(a)break;let[s,i]=r,[o]=s.split("_");o===e&&n.push(i)}return n}function qg(e){let{kernelName:t,backendName:n}=e,a=r_(t,n);zh.has(a)&&Go(`The kernel '${t}' for backend '${n}' is already registered`),zh.set(a,e)}function gO(e){let{kernelName:t}=e;Ym.has(t)&&oe().getBool("DEBUG")&&Go(`Overriding the gradient for '${t}'`),Ym.set(t,e)}function YG(e,t){let n=r_(e,t);if(!zh.has(n))throw new Error(`The kernel '${e}' for backend '${t}' is not registered`);zh.delete(n)}function JG(e){if(!Ym.has(e))throw new Error(`The gradient '${e}' for backend is not registered`);Ym.delete(e)}function ZG(e,t){Iv(e).forEach(n=>{let a=Object.assign({},n,{backendName:t});qg(a)})}function r_(e,t){return`${t}_${e}`}var E={};ot(E,{arraysEqual:()=>Zi,arraysEqualWithNull:()=>nO,assert:()=>U,assertNonNegativeIntegerDimensions:()=>Or,assertNonNull:()=>Hu,assertShapesMatch:()=>Ja,bytesFromStringArray:()=>oO,bytesPerElement:()=>kv,checkConversionForErrors:()=>sO,clamp:()=>Xm,computeStrides:()=>ep,convertBackendValuesAndArrayBuffer:()=>FG,createScalarValue:()=>r5,createShuffledIndices:()=>RG,decodeString:()=>Tv,distSquared:()=>EG,encodeString:()=>Xg,fetch:()=>i5,fingerPrint64:()=>a5,flatten:()=>nl,getArrayFromDType:()=>e_,getTypedArrayFromDType:()=>rO,hasEncodingLoss:()=>MG,hexToLong:()=>Kg,indexToLoc:()=>BG,inferDtype:()=>Ng,inferFromImplicitShape:()=>OG,isBoolean:()=>lO,isFunction:()=>tl,isInt:()=>Oh,isNumber:()=>uO,isPromise:()=>o0,isScalarShape:()=>CG,isString:()=>Ko,isTypedArray:()=>ca,isValidDtype:()=>iO,locToIndex:()=>LG,makeOnesTypedArray:()=>t_,makeZerosNestedTypedArray:()=>zG,makeZerosTypedArray:()=>i0,nearestDivisor:()=>_v,nearestLargerEven:()=>NG,now:()=>Zm,parseAxisParam:()=>ws,randUniform:()=>TG,repeatedTry:()=>DG,rightPad:()=>Um,shuffle:()=>tO,shuffleCombo:()=>_G,sizeFromShape:()=>Wt,sizeToSquarishShape:()=>$G,squeezeShape:()=>aO,sum:()=>IG,swap:()=>Sv,tanh:()=>AG,toNestedArray:()=>Ch,toTypedArray:()=>w0});function yO(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}var v$=yl(oG()),cu=v$.default||v$;function Kg(e){return cu.fromString(e,!0,16)}var bO=Kg("c3a5c85c97cb3127"),iu=Kg("b492b66fbe98f273"),Va=Kg("9ae16a3b2f90404f");function ES(e){return e.xor(e.shru(47))}function vO(e,t,n){let a=e.slice(t,t+n);return cu.fromBytes(Array.from(a),!0,!0)}function ln(e,t){return vO(e,t,8)}function x$(e,t){return vO(e,t,4)}function ua(e,t){return t===0?e:e.shru(t).or(e.shl(64-t))}function Zo(e,t,n=Kg("9ddfea08eb382d69")){let a=e.xor(t).mul(n);a=a.xor(a.shru(47));let r=t.xor(a).mul(n);return r=r.xor(r.shru(47)),r=r.mul(n),r}function QG(e,t,n,a,r,s){r=r.add(e),s=ua(s.add(r).add(a),21);let i=r;return r=r.add(t),r=r.add(n),s=s.add(ua(r,44)),[r.add(a),s.add(i)]}function jb(e,t,n,a){return QG(ln(e,t),ln(e,t+8),ln(e,t+16),ln(e,t+24),n,a)}function e5(e,t=e.length){if(t>=8){let n=Va.add(t*2),a=ln(e,0).add(Va),r=ln(e,t-8),s=ua(r,37).mul(n).add(a),i=ua(a,25).add(r).mul(n);return Zo(s,i,n)}if(t>=4){let n=Va.add(t*2),a=x$(e,0);return Zo(a.shl(3).add(t),x$(e,t-4),n)}if(t>0){let n=e[0],a=e[t>>1],r=e[t-1],s=n+(a<<8),i=t+(r<<2);return ES(Va.mul(s).xor(bO.mul(i))).mul(Va)}return Va}function t5(e,t=e.length){let n=Va.add(t*2),a=ln(e,0).mul(iu),r=ln(e,8),s=ln(e,t-8).mul(n),i=ln(e,t-16).mul(Va);return Zo(ua(a.add(r),43).add(ua(s,30)).add(i),a.add(ua(r.add(Va),18)).add(s),n)}function n5(e,t=e.length){let n=Va.add(t*2),a=ln(e,0).mul(Va),r=ln(e,8),s=ln(e,t-8).mul(n),i=ln(e,t-16).mul(Va),o=ua(a.add(r),43).add(ua(s,30)).add(i),u=Zo(o,a.add(ua(r.add(Va),18)).add(s),n),d=ln(e,16).mul(n),c=ln(e,24),p=o.add(ln(e,t-32)).mul(n),m=u.add(ln(e,t-24)).mul(n);return Zo(ua(d.add(c),43).add(ua(p,30)).add(m),d.add(ua(c.add(a),18)).add(p),n)}function a5(e,t=e.length){let n=cu.fromNumber(81,!0);if(t<=32)return t<=16?e5(e,t):t5(e,t);if(t<=64)return n5(e,t);let a=n,r=n.mul(iu).add(113),s=ES(r.mul(Va).add(113)).mul(Va),i=[cu.UZERO,cu.UZERO],o=[cu.UZERO,cu.UZERO];a=a.mul(Va).add(ln(e,0));let u=0,d=(t-1>>6)*64,c=d+(t-1&63)-63;do a=ua(a.add(r).add(i[0]).add(ln(e,u+8)),37).mul(iu),r=ua(r.add(i[1]).add(ln(e,u+48)),42).mul(iu),a=a.xor(o[1]),r=r.add(i[0]).add(ln(e,u+40)),s=ua(s.add(o[0]),33).mul(iu),i=jb(e,u,i[1].mul(iu),a.add(o[0])),o=jb(e,u+32,s.add(o[1]),r.add(ln(e,u+16))),[s,a]=[a,s],u+=64;while(u!==d);let p=iu.add(s.and(255).shl(1));return u=c,o[0]=o[0].add(t-1&63),i[0]=i[0].add(o[0]),o[0]=o[0].add(i[0]),a=ua(a.add(r).add(i[0]).add(ln(e,u+8)),37).mul(p),r=ua(r.add(i[1]).add(ln(e,u+48)),42).mul(p),a=a.xor(o[1].mul(9)),r=r.add(i[0].mul(9).add(ln(e,u+40))),s=ua(s.add(o[0]),33).mul(p),i=jb(e,u,i[1].mul(p),a.add(o[0])),o=jb(e,u+32,s.add(o[1]),r.add(ln(e,u+16))),[s,a]=[a,s],Zo(Zo(i[0],o[0],p).add(ES(r).mul(bO)).add(s),Zo(i[1],o[1],p).add(a),p)}function r5(e,t){return t==="string"?Xg(e):w0([e],t)}function s5(e,t){return e instanceof Float32Array&&t==="float32"||e instanceof Int32Array&&t==="int32"||e instanceof Uint8Array&&t==="bool"}function w0(e,t){if(t==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=nl(e)),oe().getBool("DEBUG")&&sO(e,t),s5(e,t))return e;if(t==null||t==="float32"||t==="complex64")return new Float32Array(e);if(t==="int32")return new Int32Array(e);if(t==="bool"){let n=new Uint8Array(e.length);for(let a=0;a<n.length;++a)Math.round(e[a])!==0&&(n[a]=1);return n}else throw new Error(`Unknown data type ${t}`)}function Zm(){return oe().platform.now()}function i5(e,t){return oe().platform.fetch(e,t)}function Xg(e,t="utf-8"){return t=t||"utf-8",oe().platform.encode(e,t)}function Tv(e,t="utf-8"){return t=t||"utf-8",oe().platform.decode(e,t)}function ca(e){return oe().platform.isTypedArray!=null?oe().platform.isTypedArray(e):yO(e)}function nl(e,t=[],n=!1){if(t==null&&(t=[]),typeof e=="boolean"||typeof e=="number"||typeof e=="string"||o0(e)||e==null||ca(e)&&n)t.push(e);else if(Array.isArray(e)||ca(e))for(let a=0;a<e.length;++a)nl(e[a],t,n);else{let a=-1;for(let r of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(r)&&(a=Math.max(a,Number(r)));for(let r=0;r<=a;r++)nl(e[r],t,n)}return t}var o5=class{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new u5)}profileKernel(e,t,n){let a,r=()=>{a=n()},s,i=Zm();if(this.backendTimer.timerAvailable())s=this.backendTimer.time(r);else{r();for(let o of a)o.dataSync();s=Promise.resolve({kernelMs:Zm()-i})}if(oe().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let o=0;o<a.length;o++){let u=a[o];u.data().then(d=>{l5(d,u.dtype,e)})}return{kernelName:e,outputs:a,inputs:t,timeMs:s.then(o=>o.kernelMs),extraInfo:s.then(o=>o.getExtraProfileInfo!=null?o.getExtraProfileInfo():"")}}logKernelProfile(e){let{kernelName:t,outputs:n,timeMs:a,inputs:r,extraInfo:s}=e;n.forEach(i=>{Promise.all([i.data(),a,s]).then(o=>{this.logger.logKernelProfile(t,i,o[0],o[1],r,o[2])})})}};function l5(e,t,n){if(t!=="float32")return!1;for(let a=0;a<e.length;a++){let r=e[a];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${n}'`),!0}return!1}var u5=class{logKernelProfile(e,t,n,a,r,s){let i=typeof a=="number"?Um(`${a}ms`,9):a.error,o=Um(e,25),u=t.rank,d=t.size,c=Um(t.shape.toString(),14),p="";for(let m in r){let g=r[m];if(g!=null){let b=g.shape||t.shape,v=b.length;p+=`${m}: ${v}D ${v>0?b:""} `}}console.log(`%c${o}	%c${i}	%c${u}D ${c}	%c${d}	%c${p}	%c${s}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};function c5(e,t,n){let a={},r={};for(let u=0;u<t.length;u++)a[t[u].id]=!0;for(let u=0;u<e.length;u++){let d=e[u],c=d.inputs;for(let p in c){let m=c[p],g=!1;for(let b=0;b<t.length;b++)if(a[m.id]){d.outputs.forEach(v=>a[v.id]=!0),g=!0,r[d.id]=!0;break}if(g)break}}let s={};s[n.id]=!0;let i={};for(let u=e.length-1;u>=0;u--){let d=e[u],c=d.inputs;for(let p=0;p<d.outputs.length;p++)if(s[d.outputs[p].id]){for(let m in c)s[c[m].id]=!0,i[d.id]=!0;break}}let o=[];for(let u=0;u<e.length;u++){let d=e[u];if(r[d.id]&&i[d.id]){let c={};for(let m in d.inputs){let g=d.inputs[m];a[g.id]&&(c[m]=g)}let p=Object.assign({},d);p.inputs=c,p.outputs=d.outputs,o.push(p)}}return o}function d5(e,t,n,a){for(let r=t.length-1;r>=0;r--){let s=t[r],i=[];if(s.outputs.forEach(u=>{let d=e[u.id];d!=null?i.push(d):i.push(null)}),s.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);let o=s.gradient(i);for(let u in s.inputs){if(!(u in o))throw new Error(`Cannot backprop through input ${u}. Available gradients found: ${Object.keys(o)}.`);let d=n(()=>o[u]());if(d.dtype!=="float32")throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${u} must have 'float32' dtype, but has '${d.dtype}'`);let c=s.inputs[u];if(!Zi(d.shape,c.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${u}' has shape '${d.shape}', which does not match the shape of the input '${c.shape}'`);if(e[c.id]==null)e[c.id]=d;else{let p=e[c.id];e[c.id]=a(p,d),p.dispose()}}}}var w$=20,Sm=3,X1=7;function h5(e,t,n,a){let r=ep(t),s=p5(e,t,n,r),i=t.length,o=dv(e,t,n,r,s),u=["Tensor"];return a&&(u.push(`  dtype: ${n}`),u.push(`  rank: ${i}`),u.push(`  shape: [${t}]`),u.push("  values:")),u.push(o.map(d=>"    "+d).join(`
`)),u.join(`
`)}function p5(e,t,n,a){let r=Wt(t),s=a[a.length-1],i=new Array(s).fill(0),o=t.length,u=n==="complex64"?Cm(e):e;if(o>1)for(let d=0;d<r/s;d++){let c=d*s;for(let p=0;p<s;p++)i[p]=Math.max(i[p],Em(u[c+p],0,n).length)}return i}function Em(e,t,n){let a;return Array.isArray(e)?a=`${parseFloat(e[0].toFixed(X1))} + ${parseFloat(e[1].toFixed(X1))}j`:Ko(e)?a=`'${e}'`:n==="bool"?a=xO(e):a=parseFloat(e.toFixed(X1)).toString(),Um(a,t)}function xO(e){return e===0?"false":"true"}function dv(e,t,n,a,r,s=!0){let i=n==="complex64"?2:1,o=t[0],u=t.length;if(u===0){if(n==="complex64"){let v=Cm(e);return[Em(v[0],0,n)]}return n==="bool"?[xO(e[0])]:[e[0].toString()]}if(u===1){if(o>w$){let v=Sm*i,x=Array.from(e.slice(0,v)),w=Array.from(e.slice((o-Sm)*i,o*i));return n==="complex64"&&(x=Cm(x),w=Cm(w)),["["+x.map((k,N)=>Em(k,r[N],n)).join(", ")+", ..., "+w.map((k,N)=>Em(k,r[o-Sm+N],n)).join(", ")+"]"]}return["["+(n==="complex64"?Cm(e):Array.from(e)).map((v,x)=>Em(v,r[x],n)).join(", ")+"]"]}let d=t.slice(1),c=a.slice(1),p=a[0]*i,m=[];if(o>w$){for(let v=0;v<Sm;v++){let x=v*p,w=x+p;m.push(...dv(e.slice(x,w),d,n,c,r,!1))}m.push("...");for(let v=o-Sm;v<o;v++){let x=v*p,w=x+p;m.push(...dv(e.slice(x,w),d,n,c,r,v===o-1))}}else for(let v=0;v<o;v++){let x=v*p,w=x+p;m.push(...dv(e.slice(x,w),d,n,c,r,v===o-1))}let g=u===2?",":"";m[0]="["+(o>0?m[0]+g:"");for(let v=1;v<m.length-1;v++)m[v]=" "+m[v]+g;let b=`,
`;for(let v=2;v<u;v++)b+=`
`;return m[m.length-1]=" "+m[m.length-1]+"]"+(s?"":b),m}function Cm(e){let t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}var Pn=class{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=Wt(e),n!=null){let a=n.length;U(a===this.size,()=>`Length of values '${a}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||e_(t,this.size),this.strides=ep(e)}set(e,...t){t.length===0&&(t=[0]),U(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);let n=this.locToIndex(t);this.values[n]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(let a of e){if(a<0||a>=this.shape[t]){let r=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(r)}t++}let n=e[e.length-1];for(let a=0;a<e.length-1;++a)n+=this.strides[a]*e[a];return this.values[n]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];let t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return Ms().makeTensor(this.values,this.shape,this.dtype)}},Ms=null,xh=null;function f5(e){Ms=e}function m5(e){xh=e}var dt=class{constructor(e,t,n,a){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=Wt(e),this.strides=ep(e),this.dataId=n,this.id=a,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){let e=await this.data();return xh.buffer(this.shape,this.dtype,e)}bufferSync(){return xh.buffer(this.shape,this.dtype,this.dataSync())}async array(){let e=await this.data();return Ch(this.shape,e,this.dtype==="complex64")}arraySync(){return Ch(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();let e=Ms().read(this.dataId);if(this.dtype==="string"){let t=await e;try{return t.map(n=>Tv(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),Ms().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();let e=Ms().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>Tv(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();let e=await Ms().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),Ms().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return xh.print(this,e)}clone(){return this.throwIfDisposed(),xh.clone(this)}toString(e=!1){let t=this.dataSync();return h5(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),xh.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),Ms().makeVariable(this,e,t,n)}};Object.defineProperty(dt,Symbol.hasInstance,{value:e=>!!e&&e.data!=null&&e.dataSync!=null&&e.throwIfDisposed!=null});function ve(){return a_("Tensor",()=>dt)}ve();var Eu=class extends dt{constructor(e,t,n,a){super(e.shape,e.dtype,e.dataId,a),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!Zi(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Ms().disposeTensor(this),this.dataId=e.dataId,Ms().incRef(this,null)}dispose(){Ms().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(Eu,Symbol.hasInstance,{value:e=>e instanceof dt&&e.assign!=null&&e.assign instanceof Function});var Fs={};ot(Fs,{assertTypesMatch:()=>kO,getTensorsInContainer:()=>s_,isTensorInList:()=>y5,makeTypesMatch:()=>Sn});var CS;(function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"})(CS||(CS={}));var AS;(function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"})(AS||(AS={}));var $S;(function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"})($S||($S={}));var RS;(function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"})(RS||(RS={}));var DS;(function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"})(DS||(DS={}));var g5={float32:RS,int32:AS,bool:$S,complex64:DS};function Jr(e,t){if(e==="string"||t==="string"){if(e==="string"&&t==="string")return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return g5[e][t]}function S0(e){return Jr(e,"int32")}function wO(e){return e!=null&&typeof e=="object"&&"texture"in e&&e.texture instanceof WebGLTexture}function SO(e){return typeof GPUBuffer<"u"&&e!=null&&typeof e=="object"&&"buffer"in e&&e.buffer instanceof GPUBuffer}function Sn(e,t){if(e.dtype===t.dtype)return[e,t];let n=Jr(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function kO(e,t){U(e.dtype===t.dtype,()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`)}function y5(e,t){return t.some(n=>n.id===e.id)}function s_(e){let t=[];return _O(e,t,new Set),t}function _O(e,t,n){if(e==null)return;if(e instanceof dt){t.push(e);return}if(!b5(e))return;let a=e;for(let r in a){let s=a[r];n.has(s)||(n.add(s),_O(s,t,n))}}function b5(e){return Array.isArray(e)||typeof e=="object"}function Y1(e){return e.kernelName!=null}var S$=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(let e in this.registeredVariables)this.registeredVariables[e].dispose()}},i_=class OS{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new S$}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;let t=this.getSortedBackends();for(let n=0;n<t.length;n++){let a=t[n];if(await this.initializeBackend(a).success){await this.setBackend(a);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){let{name:t,asyncInit:n}=this.initializeBackendsAndReturnBest();if(n)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry))if(t in this.registryFactory){let{asyncInit:n}=this.initializeBackend(t);if(n)return null}else return null;return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,n,a=1){return t in this.registryFactory?(Go(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:n,priority:a},!0)}async setBackend(t){if(this.registryFactory[t]==null)throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,this.registry[t]==null){this.backendInstance=null;let{success:n,asyncInit:a}=this.initializeBackend(t);if(!(a?await n:n))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new o5(this.backendInstance),!0}setupRegisteredKernels(){Iv(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){Iv(t).forEach(n=>{n.disposeFunc!=null&&n.disposeFunc(this.registry[t])})}initializeBackend(t){let n=this.registryFactory[t];if(n==null)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{let a=n.factory();if(a&&!(a instanceof _g)&&typeof a.then=="function"){let r=++this.pendingBackendInitId,s=a.then(i=>r<this.pendingBackendInitId?!1:(this.registry[t]=i,this.pendingBackendInit=null,!0)).catch(i=>(r<this.pendingBackendInitId||(this.pendingBackendInit=null,Go(`Initialization of backend ${t} failed`),Go(i.stack||i.message)),!1));return this.pendingBackendInit=s,{success:s,asyncInit:!0}}else return this.registry[t]=a,{success:!0,asyncInit:!1}}catch(a){return Go(`Initialization of backend ${t} failed`),Go(a.stack||a.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,n)=>this.registryFactory[n].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){let t=this.getSortedBackends();for(let n=0;n<t.length;n++){let a=t[n],{success:r,asyncInit:s}=this.initializeBackend(a);if(s||r)return{name:a,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,n){let a=this.state.tensorInfo.get(n),r=a.backend,s=this.readSync(n),i=r.refCount(n);r.disposeData(n,!0),a.backend=t,t.move(n,s,a.shape,a.dtype,i),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,n){let a=null;if(n==null){if(typeof t!="function")throw new Error("Please provide a function to tidy()");n=t}else{if(typeof t!="string"&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof n!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");a=t}let r;return this.scopedRun(()=>this.startScope(a),()=>this.endScope(r),()=>(r=n(),r instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),r))}scopedRun(t,n,a){t();try{let r=a();return n(),r}catch(r){throw n(),r}}nextTensorId(){return OS.nextTensorId++}nextVariableId(){return OS.nextVariableId++}clone(t){let n=q.runKernel(wc,{x:t}),a={x:t},r=i=>({x:()=>{let o="float32",u={x:i},d={dtype:o};return q.runKernel(nc,u,d)}}),s=[];return this.addTapeNode(this.state.activeScope.name,a,[n],r,s,{}),n}runKernel(t,n,a){if(this.backendName==null&&this.backend,Jm(t,this.backendName)==null)throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:n,attrs:a})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,n,a){let r=this.backend.numDataIds(),s=0;a.forEach(u=>{s+=u.dtype==="complex64"?3:1});let i=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=r-n-s-i;if(o>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${o} data ids) after running '${t}'`)}runKernelFunc(t){let n,a=[],r=this.isTapeOn(),s=this.state.numBytes,i=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let o;this.backendName==null&&this.backend;let u,d=Y1(t)?t.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(Y1(t)){let{kernelName:b,inputs:v,attrs:x}=t;this.backendName==null&&this.backend;let w=Jm(b,this.backendName);U(w!=null,()=>`Cannot find registered kernel '${b}' for backend '${this.backendName}'`),o=()=>{let k=this.backend.numDataIds();u=w.kernelFunc({inputs:v,attrs:x,backend:this.backend});let N=Array.isArray(u)?u:[u];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(b,k,N);let I=N.map(T=>T.rank!=null?T:this.makeTensorFromTensorInfo(T));if(r){let T=this.getTensorsForGradient(b,v,I);a=this.saveTensorsForBackwardMode(T)}return I}}else{let{forwardFunc:b}=t,v=x=>{r&&(a=x.map(w=>this.keep(this.clone(w))))};o=()=>{let x=this.backend.numDataIds();u=this.tidy(()=>b(this.backend,v));let w=Array.isArray(u)?u:[u];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(d,x,w),w}}let{inputs:c,attrs:p}=t,m=Y1(t)?null:t.backwardsFunc,g;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?n=o():(g=this.profiler.profileKernel(d,c,()=>o()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(g),n=g.outputs)}),r&&this.addTapeNode(d,c,n,m,a,p),this.state.profiling&&this.state.activeProfile.kernels.push({name:d,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map(b=>c[b]!=null?c[b].shape:null),outputShapes:n.map(b=>b.shape),kernelTimeMs:g.timeMs,extraInfo:g.extraInfo}),Array.isArray(u)?n:n[0]}saveTensorsForBackwardMode(t){return t.map(n=>this.keep(this.clone(n)))}getTensorsForGradient(t,n,a){let r=TS(t);if(r!=null){let s=r.inputsToSave||[],i=r.outputsToSave||[],o;r.saveAllInputs?(U(Array.isArray(n),()=>"saveAllInputs is true, expected inputs to be an array."),o=Object.keys(n).map(d=>n[d])):o=s.map(d=>n[d]);let u=a.filter((d,c)=>i[c]);return o.concat(u)}return[]}makeTensor(t,n,a,r){if(t==null)throw new Error("Values passed to engine.makeTensor() are null");a=a||"float32",r=r||this.backend;let s=t;a==="string"&&Ko(t[0])&&(s=t.map(u=>Xg(u)));let i=r.write(s,n,a),o=new dt(n,a,i,this.nextTensorId());if(this.trackTensor(o,r),a==="string"){let u=this.state.tensorInfo.get(i),d=oO(s);this.state.numBytes+=d-u.bytes,u.bytes=d}return o}makeTensorFromDataId(t,n,a,r){a=a||"float32";let s={dataId:t,shape:n,dtype:a};return this.makeTensorFromTensorInfo(s,r)}makeTensorFromTensorInfo(t,n){let{dataId:a,shape:r,dtype:s}=t,i=new dt(r,s,a,this.nextTensorId());return this.trackTensor(i,n),i}makeVariable(t,n=!0,a,r){a=a||this.nextVariableId().toString(),r!=null&&r!==t.dtype&&(t=t.cast(r));let s=new Eu(t,n,a,this.nextTensorId());if(this.state.registeredVariables[s.name]!=null)throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(t,n){this.state.numTensors++,t.dtype==="string"&&this.state.numStringTensors++;let a=0;t.dtype!=="complex64"&&t.dtype!=="string"&&(a=t.size*kv(t.dtype)),this.state.numBytes+=a,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:n||this.backend,dtype:t.dtype,shape:t.shape,bytes:a})),t instanceof Eu||this.track(t)}incRef(t,n){this.trackTensor(t,n),this.backend.incRef(t.dataId)}removeDataId(t,n){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===n&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;let n=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,t.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=n.bytes),t.dtype!=="complex64"&&t.dtype!=="string"){let a=t.size*kv(t.dtype);this.state.numBytes-=a}n.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,n.backend)}disposeVariables(){for(let t in this.state.registeredVariables){let n=this.state.registeredVariables[t];this.disposeVariable(n)}}disposeVariable(t){this.disposeTensor(t),this.state.registeredVariables[t.name]!=null&&delete this.state.registeredVariables[t.name]}memory(){let t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,t.reasons==null&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;let n=this.state.numBytes,a=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(r=>r.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-n,this.state.activeProfile.newTensors=this.state.numTensors-a;for(let r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(t,n,a,r,s,i){let o={id:this.state.nextTapeNodeId++,kernelName:t,inputs:n,outputs:a,saved:s},u=TS(t);u!=null&&(r=u.gradFunc),r!=null&&(o.gradient=d=>(d=d.map((c,p)=>{if(c==null){let m=a[p],g=i0(m.size,m.dtype);return this.makeTensor(g,m.shape,m.dtype)}return c}),r(d.length>1?d:d[0],s,i))),this.state.activeTape.push(o)}keep(t){return t.kept=!0,t}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){let n={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(n.name=t),this.state.scopeStack.push(n),this.state.activeScope=n}endScope(t){let n=s_(t),a=new Set(n.map(s=>s.id));for(let s=0;s<this.state.activeScope.track.length;s++){let i=this.state.activeScope.track[s];!i.kept&&!a.has(i.id)&&i.dispose()}let r=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],n.forEach(s=>{!s.kept&&s.scopeId===r.id&&this.track(s)})}gradients(t,n,a,r=!1){if(U(n.length>0,()=>"gradients() received an empty list of xs."),a!=null&&a.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${a.dtype}'`);let s=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));U(s instanceof dt,()=>"The result y returned by f() must be a tensor.");let i=c5(this.state.activeTape,n,s);if(!r&&i.length===0&&n.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{let o={};o[s.id]=a??v5(s.shape),d5(o,i,d=>this.tidy(d),x5);let u=n.map(d=>o[d.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(d=>{for(let c of d.saved)c.dispose()}),this.state.activeTape=null),{value:s,grads:u}})}customGrad(t){return U(tl(t),()=>"The f passed in customGrad(f) must be a function."),(...n)=>{U(n.every(o=>o instanceof dt),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let a,r={};n.forEach((o,u)=>{r[u]=o});let s=(o,u)=>(a=t(...n,u),U(a.value instanceof dt,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),U(tl(a.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),a.value),i=(o,u)=>{let d=a.gradFunc(o,u),c=Array.isArray(d)?d:[d];U(c.length===n.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),U(c.every(m=>m instanceof dt),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");let p={};return c.forEach((m,g)=>{p[g]=()=>m}),p};return this.runKernelFunc({forwardFunc:s,backwardsFunc:i,inputs:r})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,n){return this.state.tensorInfo.get(t).backend.readToGPU(t,n)}async time(t){let n=Zm(),a=await this.backend.time(t);return a.wallMs=Zm()-n,a}track(t){return this.state.activeScope!=null&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new S$;for(let t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}};i_.nextTensorId=0;i_.nextVariableId=0;function v5(e){let t=t_(Wt(e),"float32");return q.makeTensor(t,e,"float32")}function NO(){let e=hO();if(e._tfengine==null){let t=new dO(e);e._tfengine=new i_(t)}return WG(e._tfengine.ENV),f5(()=>e._tfengine),e._tfengine}var q=NO();function x5(e,t){let n={a:e,b:t};return q.runKernel(bl,n)}var Yg={};ot(Yg,{isBrowser:()=>IO,isMobile:()=>k5,mockIsMobile:()=>S5});function w5(){return typeof navigator<"u"&&navigator!=null}var MS;function S5(e){MS=e}function k5(e){if(MS!==void 0)return MS;if(e||w5()){if(e||(e=navigator),e.product==="ReactNative")return!0;let t=e.userAgent||e.vendor||(typeof window<"u"?window.opera:"");if(!t){let n=e;return n.userAgentData&&n.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function IO(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}var cr=oe();cr.registerFlag("DEBUG",()=>!1,e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});cr.registerFlag("IS_BROWSER",()=>IO());cr.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");cr.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));cr.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));cr.registerFlag("PROD",()=>!1);cr.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>cr.getBool("DEBUG"));cr.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);cr.registerFlag("IS_TEST",()=>!1);cr.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>cr.getBool("DEBUG"));cr.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);cr.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);cr.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);function di(e,t){let n=e;if(ca(e))return t==="string"?[]:[e.length];if(wO(e)){let r=e.channels||"RGBA";return[e.height,e.width*r.length]}else if(SO(e))return[e.buffer.size/(t==null?4:kv(t))];if(!Array.isArray(e))return[];let a=[];for(;Array.isArray(n)||ca(n)&&t!=="string";)a.push(n.length),n=n[0];return Array.isArray(e)&&oe().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&TO(e,a,[]),a}function TO(e,t,n){if(n=n||[],!Array.isArray(e)&&!ca(e)){U(t.length===0,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}U(t.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`),U(e.length===t[0],()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`);let a=t.slice(1);for(let r=0;r<e.length;++r)TO(e[r],a,n.concat(r))}function k$(e,t,n,a){if(e!=="string_or_numeric"){if(e==null)throw new Error("Expected dtype cannot be null.");if(e!=="numeric"&&e!==t||e==="numeric"&&t==="string")throw new Error(`Argument '${n}' passed to '${a}' must be ${e} tensor, but got ${t} tensor`)}}function F(e,t,n,a="numeric"){if(e instanceof ve())return k$(a,e.dtype,t,n),e;let r=Ng(e);if(r!=="string"&&["bool","int32","float32"].indexOf(a)>=0&&(r=a),k$(a,r,t,n),e==null||!ca(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string"){let o=e==null?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${o}'`)}let s=di(e,r);!ca(e)&&!Array.isArray(e)&&(e=[e]);let i=r!=="string"?w0(e,r):nl(e,[],!0);return q.makeTensor(i,s,r)}function Qm(e,t,n,a="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map((r,s)=>F(r,`${t}[${s}]`,n,a))}var o_="__op";function X(e){let t=Object.keys(e);if(t.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0],a=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n=n+o_;let r=(...s)=>{q.startScope(n);try{let i=a(...s);return o0(i)&&console.error("Cannot return a Promise inside of tidy."),q.endScope(i),i}catch(i){throw q.endScope(null),i}};return Object.defineProperty(r,"name",{value:n,configurable:!0}),r}function _5(e,t){let n=F(e,"real","complex"),a=F(t,"imag","complex");Ja(n.shape,a.shape,`real and imag shapes, ${n.shape} and ${a.shape}, must match in call to tf.complex().`);let r={real:n,imag:a};return q.runKernel(l0,r)}var Xi=X({complex_:_5});function Sl(e,t,n,a){if(a==null)a=Ng(e);else if(a==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(SO(e)||wO(e)){if(a!=="float32"&&a!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${a}.`);return q.backend.createTensorFromGPUData(e,t||n,a)}if(!ca(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(t!=null){Or(t);let r=Wt(t),s=Wt(n);U(r===s,()=>`Based on the provided shape, [${t}], the tensor should have ${r} values but has ${s}`);for(let i=0;i<n.length;++i){let o=n[i],u=i===n.length-1?o!==Wt(t.slice(i)):!0;U(n[i]===t[i]||!u,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `)}}return!ca(e)&&!Array.isArray(e)&&(e=[e]),t=t||n,e=a!=="string"?w0(e,a):nl(e,[],!0),q.makeTensor(e,t,a)}function qa(e,t,n){let a=di(e,n);return Sl(e,t,a,n)}var Cu={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8},Qi=class EO{static join(t){return new EO(t).slice()}constructor(t){if(this.shards=[],this.previousShardIndex=0,t==null||(t instanceof Array||(t=[t]),t=t.map(a=>ca(a)?a.buffer:a),t.length===0))return;this.bufferUniformSize=t[0].byteLength;let n=0;for(let a=0;a<t.length;a++){let r=t[a];a!==t.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);let s=n+r.byteLength;this.shards.push({buffer:r,start:n,end:s}),n=s}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(t=0,n=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(t=isNaN(Number(t))?0:t,n=isNaN(Number(n))?0:n,t=Math.max(0,t),n=Math.min(this.byteLength,n),n<=t)return new ArrayBuffer(0);let a=this.findShardForByte(t);if(a===-1)throw new Error(`Could not find start shard for byte ${t}`);let r=n-t,s=new ArrayBuffer(r),i=new Uint8Array(s),o=0;for(let u=a;u<this.shards.length;u++){let d=this.shards[u],c=t+o-d.start,p=o,m=Math.min(n,d.end)-d.start,g=new Uint8Array(d.buffer,c,m-c);if(i.set(g,p),o+=g.length,n<d.end)break}return s}findShardForByte(t){if(this.shards.length===0||t<0||t>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(t/this.bufferUniformSize),this.previousShardIndex;function n(r){return t<r.start?-1:t>=r.end?1:0}if(n(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;let a=N5(this.shards,n);return a===-1?-1:(this.previousShardIndex=a,this.previousShardIndex)}};function N5(e,t){let n=0,a=e.length;for(;n<=a;){let r=Math.floor((a-n)/2)+n,s=t(e[r]);if(s===0)return r;s<0?a=r:n=r+1}return-1}function I5(){oe().set("PROD",!0)}function T5(){oe().set("DEBUG",!0)}function E5(){oe().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function CO(e){oe().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function C5(){q.disposeVariables()}function ms(){return q}function FS(){return q.memory()}function A5(e){return q.profile(e)}function ne(e,t){return q.tidy(e,t)}function it(e){s_(e).forEach(t=>t.dispose())}function Zn(e){return q.keep(e)}function $5(e){return q.time(e)}function R5(e){return q.setBackend(e)}function D5(){return q.ready()}function AO(){return q.backendName}function O5(e){q.removeBackend(e)}function M5(e){return q.findBackend(e)}function F5(e){return q.findBackendFactory(e)}function k0(e,t,n=1){return q.registerBackend(e,t,n)}function l_(){return q.backend}function z5(e,t){oe().setPlatform(e,t)}var al=4;async function L5(e,t){let n=[],a=[],r=Array.isArray(e)?e.map(i=>i.name):Object.keys(e);for(let i=0;i<r.length;++i){let o=r[i],u=Array.isArray(e)?e[i].tensor:e[o];if(u.dtype!=="float32"&&u.dtype!=="int32"&&u.dtype!=="bool"&&u.dtype!=="string"&&u.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${o}': ${u.dtype}`);let d={name:o,shape:u.shape,dtype:u.dtype};if(u.dtype==="string"){let c=new Promise(async p=>{let m=await u.bytes(),g=m.reduce((x,w)=>x+w.length,0)+al*m.length,b=new Uint8Array(g),v=0;for(let x=0;x<m.length;x++){let w=m[x],k=new Uint8Array(new Uint32Array([w.length]).buffer);b.set(k,v),v+=al,b.set(w,v),v+=w.length}p(b)});a.push(c)}else a.push(u.data());t!=null&&(d.group=t),n.push(d)}let s=await Promise.all(a);return{data:U5(s),specs:n}}function $O(e,t){let n=new Qi(e),a={},r=0;for(let s of t){let i=B5(s,(o,u)=>n.slice(r+o,r+u));a[s.name]=RO(s,n.slice(r,r+i)),r+=i}return a}function B5(e,t){let n=Wt(e.shape),a;if("quantization"in e){let r=e.quantization;a=Cu[r.dtype]}else if(e.dtype==="string"){let r=0;for(let s=0;s<n;s++)r+=al+new Uint32Array(t(r,r+al))[0];return r}else a=Cu[e.dtype];return n*a}async function P5(e,t){let n=Wt(e.shape),a;if("quantization"in e){let r=e.quantization;a=Cu[r.dtype]}else if(e.dtype==="string"){let r=0;for(let s=0;s<n;s++)r+=al+new Uint32Array(await t(r,r+al))[0];return r}else a=Cu[e.dtype];return n*a}function RO(e,t){let n=e.name,a=e.dtype,r=e.shape,s=Wt(r),i,o=0;if("quantization"in e){let u=e.quantization;if(u.dtype==="uint8"||u.dtype==="uint16"){if(!("min"in u&&"scale"in u))throw new Error(`Weight ${e.name} with quantization ${u.dtype} doesn't have corresponding metadata min and scale.`)}else if(u.dtype==="float16"){if(a!=="float32")throw new Error(`Weight ${e.name} is quantized with ${u.dtype} which only supports weights of type float32 not ${a}.`)}else throw new Error(`Weight ${e.name} has unknown quantization dtype ${u.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);let d=Cu[u.dtype],c=u.dtype==="uint8"?new Uint8Array(t):new Uint16Array(t);if(a==="float32")if(u.dtype==="uint8"||u.dtype==="uint16"){i=new Float32Array(c.length);for(let p=0;p<c.length;p++){let m=c[p];i[p]=m*u.scale+u.min}}else if(u.dtype==="float16")i=K5()(c);else throw new Error(`Unsupported quantization type ${u.dtype} for weight type float32.`);else if(a==="int32"){if(u.dtype!=="uint8"&&u.dtype!=="uint16")throw new Error(`Unsupported quantization type ${u.dtype} for weight type int32.`);i=new Int32Array(c.length);for(let p=0;p<c.length;p++){let m=c[p];i[p]=Math.round(m*u.scale+u.min)}}else throw new Error(`Unsupported dtype in weight '${n}': ${a}`);o+=s*d}else if(a==="string"){let u=Wt(e.shape);i=[];for(let d=0;d<u;d++){let c=new Uint32Array(t.slice(o,o+al))[0];o+=al;let p=new Uint8Array(t.slice(o,o+c));i.push(p),o+=c}}else{let u=Cu[a];if(a==="float32")i=new Float32Array(t);else if(a==="int32")i=new Int32Array(t);else if(a==="bool")i=new Uint8Array(t);else if(a==="complex64"){i=new Float32Array(t);let d=new Float32Array(i.length/2),c=new Float32Array(i.length/2);for(let b=0;b<d.length;b++)d[b]=i[b*2],c[b]=i[b*2+1];let p=qa(d,r,"float32"),m=qa(c,r,"float32"),g=Xi(p,m);return p.dispose(),m.dispose(),g}else throw new Error(`Unsupported dtype in weight '${n}': ${a}`);o+=s*u}return qa(i,r,a)}async function _$(e,t,n){let a=new Uint8Array(t);for(;a.byteLength<n;){let{done:r,value:s}=await e.read();if(r&&s==null){let o=n-a.byteLength;throw new Error(`Reader is done but ${o} bytes are still expected`)}let i=new Uint8Array(a.length+s.byteLength);i.set(a,0),i.set(new Uint8Array(s),a.length),a=i}return a.buffer}async function DO(e,t){let n={},a=e.getReader(),r=new ArrayBuffer(0);for(let s of t){let i=await P5(s,async(d,c)=>(r=await _$(a,r,c),r.slice(d,c)));r=await _$(a,r,i);let o=r.slice(0,i);r=r.slice(i);let u=RO(s,o);if(n[s.name]=u,AO()==="webgpu"){let d=l_();"uploadToGPU"in d&&Wt(u.shape)>=oe().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&d.uploadToGPU(u.dataId)}}return n}function U5(e){if(e===null)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0,n=[];e.forEach(s=>{if(t+=s.byteLength,n.push(s.byteLength===s.buffer.byteLength?s:new s.constructor(s)),!(s instanceof Float32Array||s instanceof Int32Array||s instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${s.constructor.name}`)});let a=new Uint8Array(t),r=0;return n.forEach(s=>{a.set(new Uint8Array(s.buffer),r),r+=s.byteLength}),a.buffer}var u_=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function N$(e){return u_?Buffer.byteLength(e,"utf8"):new Blob([e]).size}function j5(e){if(u_)return Buffer.from(e).toString("base64");let t=new Uint8Array(e),n="";for(let a=0,r=t.length;a<r;a++)n+=String.fromCharCode(t[a]);return btoa(n)}function W5(e){if(u_){let a=Buffer.from(e,"base64");return a.buffer.slice(a.byteOffset,a.byteOffset+a.byteLength)}let t=atob(e),n=new Uint8Array(t.length);for(let a=0;a<t.length;++a)n.set([t.charCodeAt(a)],a);return n.buffer}function V5(e){return Qi.join(e)}function I$(e){let t="/";for(e=e.trim();e.endsWith(t);)e=e.slice(0,e.length-1);let n=e.split(t);return n[n.length-1]}function OO(e,t){let n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return e.signature!=null&&(n.signature=e.signature),e.userDefinedMetadata!=null&&(n.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(n.modelInitializer=e.modelInitializer),e.initializerSignature!=null&&(n.initializerSignature=e.initializerSignature),e.trainingConfig!=null&&(n.trainingConfig=e.trainingConfig),n}function MO(e,t,n){let a={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(e.trainingConfig!=null&&(a.trainingConfig=e.trainingConfig),e.weightsManifest!=null){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");a.weightSpecs=t,a.weightData=n}return e.signature!=null&&(a.signature=e.signature),e.userDefinedMetadata!=null&&(a.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(a.modelInitializer=e.modelInitializer),e.initializerSignature!=null&&(a.initializerSignature=e.initializerSignature),a}async function c_(e,t){let n,a;return e.weightsManifest!=null&&([n,a]=await t(e.weightsManifest)),MO(e,n,a)}function Jg(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:e.modelTopology==null?0:N$(JSON.stringify(e.modelTopology)),weightSpecsBytes:e.weightSpecs==null?0:N$(JSON.stringify(e.weightSpecs)),weightDataBytes:e.weightData==null?0:new Qi(e.weightData).byteLength}}function zS(e){let t=[];for(let n of e)t.push(...n.weights);return t}function H5(){let e=n=>{let a=n<<13,r=0;for(;!(a&8388608);)r-=8388608,a<<=1;return a&=-8388609,r+=947912704,a|r},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}function G5(){let e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}function q5(){let e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}function K5(){let e=H5(),t=G5(),n=q5();return a=>{let r=new ArrayBuffer(4*a.length),s=new Uint32Array(r);for(let i=0;i<a.length;i++){let o=a[i],u=e[n[o>>10]+(o&1023)]+t[o>>10];s[i]=u}return new Float32Array(r)}}var Zr=class As{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return As.instance==null&&(As.instance=new As),As.instance}static registerSaveRouter(t){As.getInstance().saveRouters.push(t)}static registerLoadRouter(t){As.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return As.getHandlers(t,"save")}static getLoadHandlers(t,n){return As.getHandlers(t,"load",n)}static getHandlers(t,n,a){let r=[];return(n==="load"?As.getInstance().loadRouters:As.getInstance().saveRouters).forEach(s=>{let i=s(t,a);i!==null&&r.push(i)}),r}},X5=e=>Zr.registerSaveRouter(e),Y5=e=>Zr.registerLoadRouter(e),J5=e=>Zr.getSaveHandlers(e),Z5=(e,t)=>Zr.getLoadHandlers(e,t),LS="tensorflowjs",BS=1,yu="models_store",Xo="model_info_store";function FO(){if(!oe().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let e=typeof window>"u"?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(t==null)throw new Error("The current browser does not appear to support IndexedDB.");return t}function PS(e){let t=e.result;t.createObjectStore(yu,{keyPath:"modelPath"}),t.createObjectStore(Xo,{keyPath:"modelPath"})}var Au=class{constructor(e){if(this.indexedDB=FO(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((n,a)=>{let r=this.indexedDB.open(LS,BS);r.onupgradeneeded=()=>PS(r),r.onsuccess=()=>{let s=r.result;if(t==null){let i=s.transaction(yu,"readonly"),o=i.objectStore(yu).get(this.modelPath);o.onsuccess=()=>{if(o.result==null)return s.close(),a(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));n(o.result.modelArtifacts)},o.onerror=u=>(s.close(),a(o.error)),i.oncomplete=()=>s.close()}else{t.weightData=Qi.join(t.weightData);let i=Jg(t),o=s.transaction(Xo,"readwrite"),u=o.objectStore(Xo),d;try{d=u.put({modelPath:this.modelPath,modelArtifactsInfo:i})}catch(p){return a(p)}let c;d.onsuccess=()=>{c=s.transaction(yu,"readwrite");let p=c.objectStore(yu),m;try{m=p.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:i})}catch(g){return a(g)}m.onsuccess=()=>n({modelArtifactsInfo:i}),m.onerror=g=>{u=o.objectStore(Xo);let b=u.delete(this.modelPath);b.onsuccess=()=>(s.close(),a(m.error)),b.onerror=v=>(s.close(),a(m.error))}},d.onerror=p=>(s.close(),a(d.error)),o.oncomplete=()=>{c==null?s.close():c.oncomplete=()=>s.close()}}},r.onerror=s=>a(r.error)})}};Au.URL_SCHEME="indexeddb://";var zO=e=>oe().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Au.URL_SCHEME)?Q5(e.slice(Au.URL_SCHEME.length)):null;Zr.registerSaveRouter(zO);Zr.registerLoadRouter(zO);function Q5(e){return new Au(e)}function eq(e){return e.startsWith(Au.URL_SCHEME)?e.slice(Au.URL_SCHEME.length):e}var tq=class{constructor(){this.indexedDB=FO()}async listModels(){return new Promise((e,t)=>{let n=this.indexedDB.open(LS,BS);n.onupgradeneeded=()=>PS(n),n.onsuccess=()=>{let a=n.result,r=a.transaction(Xo,"readonly"),s=r.objectStore(Xo).getAll();s.onsuccess=()=>{let i={};for(let o of s.result)i[o.modelPath]=o.modelArtifactsInfo;e(i)},s.onerror=i=>(a.close(),t(s.error)),r.oncomplete=()=>a.close()},n.onerror=a=>t(n.error)})}async removeModel(e){return e=eq(e),new Promise((t,n)=>{let a=this.indexedDB.open(LS,BS);a.onupgradeneeded=()=>PS(a),a.onsuccess=()=>{let r=a.result,s=r.transaction(Xo,"readwrite"),i=s.objectStore(Xo),o=i.get(e),u;o.onsuccess=()=>{if(o.result==null)return r.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{let d=i.delete(e),c=()=>{u=r.transaction(yu,"readwrite");let p=u.objectStore(yu).delete(e);p.onsuccess=()=>t(o.result.modelArtifactsInfo),p.onerror=m=>n(o.error)};d.onsuccess=c,d.onerror=p=>(c(),r.close(),n(o.error))}},o.onerror=d=>(r.close(),n(o.error)),s.oncomplete=()=>{u==null?r.close():u.oncomplete=()=>r.close()}},a.onerror=r=>n(a.error)})}},Wi="/",wh="tensorflowjs_models",LO="info",nq="model_topology",aq="weight_specs",rq="weight_data",sq="model_metadata";function BO(e){return{info:[wh,e,LO].join(Wi),topology:[wh,e,nq].join(Wi),weightSpecs:[wh,e,aq].join(Wi),weightData:[wh,e,rq].join(Wi),modelMetadata:[wh,e,sq].join(Wi)}}function PO(e){for(let t of Object.values(e))window.localStorage.removeItem(t)}function iq(e){let t=e.split(Wi);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(Wi)}function oq(e){return e.startsWith($u.URL_SCHEME)?e.slice($u.URL_SCHEME.length):e}var $u=class{constructor(e){if(!oe().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=BO(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let t=JSON.stringify(e.modelTopology),n=JSON.stringify(e.weightSpecs),a=Jg(e),r=Qi.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(a)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,j5(r));let s={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(s)),{modelArtifactsInfo:a}}catch{throw PO(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${a.modelTopologyBytes}, weightSpecsBytes=${a.weightSpecsBytes}, weightDataBytes=${a.weightDataBytes}.`)}}}async load(){let e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(n==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;let a=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(a==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=a;let r=this.LS.getItem(this.keys.modelMetadata);if(r!=null){let i=JSON.parse(r);t.format=i.format,t.generatedBy=i.generatedBy,t.convertedBy=i.convertedBy,i.signature!=null&&(t.signature=i.signature),i.userDefinedMetadata!=null&&(t.userDefinedMetadata=i.userDefinedMetadata),i.modelInitializer!=null&&(t.modelInitializer=i.modelInitializer),i.initializerSignature!=null&&(t.initializerSignature=i.initializerSignature),i.trainingConfig!=null&&(t.trainingConfig=i.trainingConfig)}let s=this.LS.getItem(this.keys.weightData);if(s==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=W5(s),t}};$u.URL_SCHEME="localstorage://";var UO=e=>oe().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith($u.URL_SCHEME)?lq(e.slice($u.URL_SCHEME.length)):null;Zr.registerSaveRouter(UO);Zr.registerLoadRouter(UO);function lq(e){return new $u(e)}var uq=class{constructor(){U(oe().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),U(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){let e={},t=wh+Wi,n=Wi+LO;for(let a=0;a<this.LS.length;++a){let r=this.LS.key(a);if(r.startsWith(t)&&r.endsWith(n)){let s=iq(r);e[s]=JSON.parse(this.LS.getItem(r))}}return e}async removeModel(e){e=oq(e);let t=BO(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);let n=JSON.parse(this.LS.getItem(t.info));return PO(t),n}},Ah="://",rl=class Po{constructor(){this.managers={}}static getInstance(){return Po.instance==null&&(Po.instance=new Po),Po.instance}static registerManager(t,n){U(t!=null,()=>"scheme must not be undefined or null."),t.endsWith(Ah)&&(t=t.slice(0,t.indexOf(Ah))),U(t.length>0,()=>"scheme must not be an empty string.");let a=Po.getInstance();U(a.managers[t]==null,()=>`A model store manager is already registered for scheme '${t}'.`),a.managers[t]=n}static getManager(t){let n=Po.getInstance().managers[t];if(n==null)throw new Error(`Cannot find model manager for scheme '${t}'`);return n}static getSchemes(){return Object.keys(Po.getInstance().managers)}};function hv(e){if(e.indexOf(Ah)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${rl.getSchemes().join(",")}`);return{scheme:e.split(Ah)[0],path:e.split(Ah)[1]}}async function jO(e,t,n=!1){U(e!==t,()=>`Old path and new path are the same: '${e}'`);let a=Zr.getLoadHandlers(e);U(a.length>0,()=>`Copying failed because no load handler is found for source URL ${e}.`),U(a.length<2,()=>`Copying failed because more than one (${a.length}) load handlers for source URL ${e}.`);let r=a[0],s=Zr.getSaveHandlers(t);U(s.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),U(s.length<2,()=>`Copying failed because more than one (${a.length}) save handlers for destination URL ${t}.`);let i=s[0],o=hv(e).scheme,u=hv(e).path,d=o===hv(e).scheme,c=await r.load();n&&d&&await rl.getManager(o).removeModel(u);let p=await i.save(c);return n&&!d&&await rl.getManager(o).removeModel(u),p.modelArtifactsInfo}async function cq(){let e=rl.getSchemes(),t={};for(let n of e){let a=await rl.getManager(n).listModels();for(let r in a){let s=n+Ah+r;t[s]=a[r]}}return t}async function dq(e){let t=hv(e);return rl.getManager(t.scheme).removeModel(t.path)}async function hq(e,t){return jO(e,t,!1)}async function pq(e,t){return jO(e,t,!0)}var fq=class{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(typeof window>"u"||!oe().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",n=>{if(n.source===window&&n.data.name===this.messageName){n.stopPropagation();let a=this.functionRefs[n.data.index];a(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return yO(e)}};if(oe().get("IS_BROWSER")){oe().setPlatform("browser",new fq);try{rl.registerManager($u.URL_SCHEME,new uq)}catch{}try{rl.registerManager(Au.URL_SCHEME,new tq)}catch{}}var mq={importFetch:()=>lG()},J1,gq=class{constructor(){this.util=uG(),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return oe().global.fetch!=null?oe().global.fetch(e,t):(J1==null&&(J1=mq.importFetch()),J1(e,t))}now(){let e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}};oe().get("IS_NODE")&&!oe().get("IS_BROWSER")&&oe().setPlatform("node",new gq);function mt(e,t="float32",n){return t=t||"float32",Or(e),new Pn(e,t,n)}function yq(e,t){let n=F(e,"x","cast");if(!iO(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if(t==="string"&&n.dtype!=="string"||t!=="string"&&n.dtype==="string")throw new Error("Only strings can be casted to strings");let a={x:n},r={dtype:t};return q.runKernel(nc,a,r)}var Te=X({cast_:yq});function bq(e){let t={x:F(e,"x","clone","string_or_numeric")};return q.runKernel(wc,t)}var li=X({clone_:bq});function d_(e,t=!1){console.log(e.toString(t))}NO();var vq={buffer:mt,cast:Te,clone:li,print:d_};m5(vq);function xq(e,t){let n=F(e,"a","add"),a=F(t,"b","add");[n,a]=Sn(n,a);let r={a:n,b:a};return q.runKernel(bl,r)}var ye=X({add_:xq});function wq(e,t){let n=F(e,"a","floorDiv"),a=F(t,"b","floorDiv");[n,a]=Sn(n,a);let r={a:n,b:a};return q.runKernel(bc,r)}var _0=X({floorDiv_:wq});function Sq(e,t){let n=F(e,"a","div"),a=F(t,"b","div");if([n,a]=Sn(n,a),n.dtype==="int32"&&a.dtype==="int32")return _0(n,a);let r={a:n,b:a},s={};return q.runKernel(hc,r,s)}var Le=X({div_:Sq});function kq(e,t){let n=F(e,"a","mul"),a=F(t,"b","mul");[n,a]=Sn(n,a);let r={a:n,b:a};return q.runKernel(zc,r)}var Y=X({mul_:kq});function _q(e){let t=F(e,"x","abs");if(t.dtype==="complex64"){let n={x:t};return q.runKernel(Cg,n)}else{let n={x:t};return q.runKernel(tp,n)}}var Ln=X({abs_:_q});function Nq(e){let t={x:F(e,"x","acos")};return q.runKernel(Gu,t)}var h_=X({acos_:Nq});function Iq(e){let t={x:F(e,"x","acosh")};return q.runKernel(qu,t)}var p_=X({acosh_:Iq});function Tq(e){U(Array.isArray(e),()=>"The argument passed to tf.addN() must be a list of tensors"),U(e.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`);let t=e.map((r,s)=>F(r,`tensors${s}`,"addN")),n=t[0];t.forEach(r=>{if(r.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(r=>{if(!Zi(r.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});let a=t;return q.runKernel(Ku,a)}var WO=X({addN_:Tq});function Eq(e,t=null,n=!1){let a={x:F(e,"x","all","bool")},r={axis:t,keepDims:n};return q.runKernel(np,a,r)}var N0=X({all_:Eq});function Cq(e,t=null,n=!1){let a={x:F(e,"x","any","bool")},r={axis:t,keepDims:n};return q.runKernel(ap,a,r)}var eg=X({any_:Cq});function Aq(e,t=0){let n={x:F(e,"x","argMax")},a={axis:t};return q.runKernel(rp,n,a)}var Ru=X({argMax_:Aq});function $q(e,t=0){let n={x:F(e,"x","argMin")},a={axis:t};return q.runKernel(sp,n,a)}var f_=X({argMin_:$q});function Rq(e){let t={x:F(e,"x","asin")};return q.runKernel(Xu,t)}var m_=X({asin_:Rq});function Dq(e){let t={x:F(e,"x","asinh")};return q.runKernel(Yu,t)}var g_=X({asinh_:Dq});function Oq(e){let t={x:F(e,"x","atan")};return q.runKernel(Ju,t)}var y_=X({atan_:Oq});function Mq(e,t){let n=F(e,"a","atan2"),a=F(t,"b","atan2");[n,a]=Sn(n,a);let r={a:n,b:a};return q.runKernel(Qu,r)}var b_=X({atan2_:Mq});function Fq(e){let t={x:F(e,"x","atanh")};return q.runKernel(Zu,t)}var v_=X({atanh_:Fq});function zq(e,t,n,a,r="NHWC",s){let i=e[3],o=[...t,i],u=GO(r);return Zg(e,o,n,s,a,null,null,u)}function VO(e,t,n,a,r,s,i="channelsLast"){let[o,u]=tg(t),d;if(i==="channelsLast")d=[o,u,e[3],e[3]];else if(i==="channelsFirst")d=[o,u,e[1],e[1]];else throw new Error(`Unknown dataFormat ${i}`);return Zg(e,d,n,a,r,s,!1,i)}function Lq(e,t,n,a,r,s,i="NDHWC"){let[o,u,d]=US(t),c,p;if(i==="NDHWC")p="channelsLast",c=[o,u,d,e[4],e[4]];else if(i==="NCDHW")p="channelsFirst",c=[o,u,d,e[1],e[1]];else throw new Error(`Unknown dataFormat ${i}`);return HO(e,c,n,a,r,!1,p,s)}function Zg(e,t,n,a,r,s,i=!1,o="channelsLast"){let[u,d,c,p]=[-1,-1,-1,-1];if(o==="channelsLast")[u,d,c,p]=e;else if(o==="channelsFirst")[u,p,d,c]=e;else throw new Error(`Unknown dataFormat ${o}`);let[m,g,,b]=t,[v,x]=tg(n),[w,k]=tg(a),N=$h(m,w),I=$h(g,k),{padInfo:T,outHeight:$,outWidth:D}=Uq(r,d,c,v,x,N,I,s,o),M=i?b*p:b,B;return o==="channelsFirst"?B=[u,M,$,D]:o==="channelsLast"&&(B=[u,$,D,M]),{batchSize:u,dataFormat:o,inHeight:d,inWidth:c,inChannels:p,outHeight:$,outWidth:D,outChannels:M,padInfo:T,strideHeight:v,strideWidth:x,filterHeight:m,filterWidth:g,effectiveFilterHeight:N,effectiveFilterWidth:I,dilationHeight:w,dilationWidth:k,inShape:e,outShape:B,filterShape:t}}function HO(e,t,n,a,r,s=!1,i="channelsLast",o){let[u,d,c,p,m]=[-1,-1,-1,-1,-1];if(i==="channelsLast")[u,d,c,p,m]=e;else if(i==="channelsFirst")[u,m,d,c,p]=e;else throw new Error(`Unknown dataFormat ${i}`);let[g,b,v,,x]=t,[w,k,N]=US(n),[I,T,$]=US(a),D=$h(g,I),M=$h(b,T),B=$h(v,$),{padInfo:V,outDepth:W,outHeight:R,outWidth:H}=jq(r,d,c,p,w,k,N,D,M,B,o),Z=s?x*m:x,ae;return i==="channelsFirst"?ae=[u,Z,W,R,H]:i==="channelsLast"&&(ae=[u,W,R,H,Z]),{batchSize:u,dataFormat:i,inDepth:d,inHeight:c,inWidth:p,inChannels:m,outDepth:W,outHeight:R,outWidth:H,outChannels:Z,padInfo:V,strideDepth:w,strideHeight:k,strideWidth:N,filterDepth:g,filterHeight:b,filterWidth:v,effectiveFilterDepth:D,effectiveFilterHeight:M,effectiveFilterWidth:B,dilationDepth:I,dilationHeight:T,dilationWidth:$,inShape:e,outShape:ae,filterShape:t}}function Bq(e,t,n,a,r){a==null&&(a=x_(e,t,n));let s=e[0],i=e[1],o=ng((s-t+2*a)/n+1,r),u=ng((i-t+2*a)/n+1,r);return[o,u]}function Pq(e,t,n,a,r,s){r==null&&(r=x_(e,t[0],a[0]));let i=[0,0,0,n];for(let o=0;o<3;o++)e[o]+2*r>=t[o]&&(i[o]=ng((e[o]-t[o]+2*r)/a[o]+1,s));return i}function x_(e,t,n,a=1){let r=$h(t,a);return Math.floor((e[0]*(n-1)-n+r)/2)}function tg(e){return typeof e=="number"?[e,e,e]:e.length===2?[e[0],e[1],1]:e}function US(e){return typeof e=="number"?[e,e,e]:e}function $h(e,t){return t<=1?e:e+(e-1)*(t-1)}function Uq(e,t,n,a,r,s,i,o,u){let d,c,p;if(typeof e=="number"){d={top:e,bottom:e,left:e,right:e,type:e===0?"VALID":"NUMBER"};let m=Bq([t,n],s,a,e,o);c=m[0],p=m[1]}else if(e==="same"){c=Math.ceil(t/a),p=Math.ceil(n/r);let m=Math.max(0,(c-1)*a+s-t),g=Math.max(0,(p-1)*r+i-n),b=Math.floor(m/2),v=m-b,x=Math.floor(g/2),w=g-x;d={top:b,bottom:v,left:x,right:w,type:"SAME"}}else if(e==="valid")d={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((t-s+1)/a),p=Math.ceil((n-i+1)/r);else if(typeof e=="object"){let m=u==="channelsLast"?e[1][0]:e[2][0],g=u==="channelsLast"?e[1][1]:e[2][1],b=u==="channelsLast"?e[2][0]:e[3][0],v=u==="channelsLast"?e[2][1]:e[3][1];d={top:m,bottom:g,left:b,right:v,type:m===0&&g===0&&b===0&&v===0?"VALID":"EXPLICIT"},c=ng((t-s+m+g)/a+1,o),p=ng((n-i+b+v)/r+1,o)}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:d,outHeight:c,outWidth:p}}function jq(e,t,n,a,r,s,i,o,u,d,c){let p,m,g,b;if(e==="valid"&&(e=0),typeof e=="number"){p={top:e,bottom:e,left:e,right:e,front:e,back:e,type:e===0?"VALID":"NUMBER"};let v=Pq([t,n,a,1],[o,u,d],1,[r,s,i],e,c);m=v[0],g=v[1],b=v[2]}else if(e==="same"){m=Math.ceil(t/r),g=Math.ceil(n/s),b=Math.ceil(a/i);let v=(m-1)*r+o-t,x=(g-1)*s+u-n,w=(b-1)*i+d-a,k=Math.floor(v/2),N=v-k,I=Math.floor(x/2),T=x-I,$=Math.floor(w/2),D=w-$;p={top:I,bottom:T,left:$,right:D,front:k,back:N,type:"SAME"}}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:p,outDepth:m,outHeight:g,outWidth:b}}function ng(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function sl(e){let[t,n,a]=tg(e);return t===1&&n===1&&a===1}function mi(e,t){return sl(e)||sl(t)}function Du(e){return tg(e).every(t=>t>0)}function GO(e){if(e==="NHWC")return"channelsLast";if(e==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function Za(e,t,n){if(n!=null){if(typeof t=="string")throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if(typeof t=="number")U(Oh(t),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);else if(typeof t=="object")t.forEach(a=>{a.forEach(r=>{U(Oh(r),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${r}.`)})});else throw Error(`Error in ${e}: Unknown padding parameter: ${t}`)}}function Wq(e,t){let n={x:F(e,"x","reshape","string_or_numeric")},a={shape:t};return q.runKernel(Bp,n,a)}var te=X({reshape_:Wq});function Vq(e,t,n,a,r){let s=F(e,"x","avgPool","float32"),i=1;U(mi(n,i),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`);let o=s,u=!1;s.rank===3&&(u=!0,o=te(s,[1,s.shape[0],s.shape[1],s.shape[2]])),U(o.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${o.rank}.`),Za("avgPool",a,r);let d={x:o},c={filterSize:t,strides:n,pad:a,dimRoundingMode:r},p=q.runKernel(ec,d,c);return p=Te(p,s.dtype),u?te(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var eo=X({avgPool_:Vq});function Hq(e,t,n,a,r,s="NDHWC"){let i=F(e,"x","avgPool3d","float32"),o=i,u=!1;i.rank===4&&(u=!0,o=te(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),U(o.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`),U(s==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),U(typeof n=="number"&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`),Za("avgPool3d",a,r);let d={x:o},c={filterSize:t,strides:n,pad:a,dimRoundingMode:r,dataFormat:s},p=q.runKernel(ip,d,c);return p=Te(p,o.dtype),u?te(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}var w_=X({avgPool3d_:Hq});function Gq(e,t=0){U(e.length>=1,()=>"Pass at least one tensor to concat");let n=Qm(e,"tensors","concat","string_or_numeric");if(n[0].dtype==="complex64"&&n.forEach(s=>{if(s.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${s.dtype}. `)}),n.length===1)return li(n[0]);let a=n,r={axis:t};return q.runKernel(cp,a,r)}var Yt=X({concat_:Gq});function qq(e,t,n=!1,a=!1){let r=F(e,"a","matMul"),s=F(t,"b","matMul");[r,s]=Sn(r,s);let i={a:r,b:s},o={transposeA:n,transposeB:a};return q.runKernel(tc,i,o)}var pt=X({matMul_:qq});function Kq(e){let t={x:F(e,"x","sigmoid","float32")};return q.runKernel(td,t)}var ys=X({sigmoid_:Kq});function Xq(e,t,n){let a=F(e,"x","slice","string_or_numeric");if(a.rank===0)throw new Error("Slicing scalar is not possible");let r={x:a},s={begin:t,size:n};return q.runKernel(Gp,r,s)}var wt=X({slice_:Xq});function Yq(e){let t={x:F(e,"x","tanh","float32")};return q.runKernel(ud,t)}var il=X({tanh_:Yq});function Jq(e,t,n,a,r,s){let i=F(e,"forgetBias","basicLSTMCell"),o=F(t,"lstmKernel","basicLSTMCell"),u=F(n,"lstmBias","basicLSTMCell"),d=F(a,"data","basicLSTMCell"),c=F(r,"c","basicLSTMCell"),p=F(s,"h","basicLSTMCell"),m=Yt([d,p],1),g=pt(m,o),b=ye(g,u),v=b.shape[0],x=b.shape[1]/4,w=[v,x],k=wt(b,[0,0],w),N=wt(b,[0,x],w),I=wt(b,[0,x*2],w),T=wt(b,[0,x*3],w),$=ye(Y(ys(k),il(N)),Y(c,ys(ye(i,I)))),D=Y(il($),ys(T));return[$,D]}var qO=X({basicLSTMCell_:Jq});function Zq(e,t,n){let a=F(e,"x","batchToSpaceND"),r=t.reduce((o,u)=>o*u);U(a.rank>=1+t.length,()=>`input rank is ${a.rank} but should be > than blockShape.length ${t.length}`),U(n.length===t.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`),U(a.shape[0]%r===0,()=>`input tensor batch is ${a.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${r}`);let s={x:a},i={blockShape:t,crops:n};return q.runKernel(op,s,i)}var Qg=X({batchToSpaceND_:Zq});function Qq(e){let t;return e.rank===0||e.rank===1?t=te(e,[1,1,1,e.size]):e.rank===2?t=te(e,[1,1,e.shape[0],e.shape[1]]):e.rank===3?t=te(e,[1,e.shape[0],e.shape[1],e.shape[2]]):t=e,t}function e8(e,t,n,a,r,s){s==null&&(s=.001);let i=F(e,"x","batchNorm"),o=F(t,"mean","batchNorm"),u=F(n,"variance","batchNorm"),d;r!=null&&(d=F(r,"scale","batchNorm"));let c;a!=null&&(c=F(a,"offset","batchNorm")),U(o.rank===u.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),U(c==null||o.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),U(d==null||o.rank===d.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let p={x:Qq(i),scale:d,offset:c,mean:o,variance:u},m={varianceEpsilon:s},g=q.runKernel(vc,p,m);return te(g,i.shape)}var cd=X({batchNorm_:e8});function t8(e,t,n,a,r,s){let i=F(e,"x","batchNorm"),o=F(t,"mean","batchNorm"),u=F(n,"variance","batchNorm"),d;r!=null&&(d=F(r,"scale","batchNorm"));let c;return a!=null&&(c=F(a,"offset","batchNorm")),U(i.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),U(o.rank===2||o.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`),U(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${u.rank}.`),d!=null&&U(d.rank===2||d.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${d.rank}.`),c!=null&&U(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),cd(i,o,u,c,d,s)}var S_=X({batchNorm2d_:t8});function n8(e,t,n,a,r,s){let i=F(e,"x","batchNorm"),o=F(t,"mean","batchNorm"),u=F(n,"variance","batchNorm"),d;r!=null&&(d=F(r,"scale","batchNorm"));let c;return a!=null&&(c=F(a,"offset","batchNorm")),U(i.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),U(o.rank===3||o.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`),U(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${u.rank}.`),d!=null&&U(d.rank===3||d.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${d.rank}.`),c!=null&&U(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),cd(i,o,u,c,d,s)}var k_=X({batchNorm3d_:n8});function a8(e,t,n,a,r,s){let i=F(e,"x","batchNorm"),o=F(t,"mean","batchNorm"),u=F(n,"variance","batchNorm"),d;r!=null&&(d=F(r,"scale","batchNorm"));let c;return a!=null&&(c=F(a,"offset","batchNorm")),U(i.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),U(o.rank===4||o.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`),U(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${u.rank}.`),d!=null&&U(d.rank===4||d.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${d.rank}.`),c!=null&&U(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),cd(i,o,u,c,d,s)}var __=X({batchNorm4d_:a8});function r8(e,t,n){let a=F(e,"x","bincount"),r=F(t,"weights","bincount");U(a.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${a.dtype}`),U(n>=0,()=>`size must be non-negative, but got ${n}.`),U(r.size===a.size||r.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${a.shape}, weights shape: ${r.shape}.`);let s={x:a,weights:r},i={size:n};return q.runKernel(lp,s,i)}var N_=X({bincount_:r8});function s8(e,t){let n=F(e,"x","bitwiseAnd"),a=F(t,"y","bitwiseAnd");if(!Zi(n.shape,a.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${n.shape}, y: ${a.shape}`);if(n.dtype!=="int32"||a.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${n.dtype} and type of y: ${a.dtype}`);let r={a:n,b:a};return q.runKernel(up,r)}var KO=X({bitwiseAnd_:s8});function i8(e,t){let n=F(e,"s0","broadcastArgs","int32"),a=F(t,"s1","broadcastArgs","int32");if(n.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(a.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${a.rank}`);let r={s0:n,s1:a};return q.runKernel(Eg,r)}var XO=X({broadcastArgs_:i8});function o8(e,t){let n=F(e,"broadcastTo","x"),a=n.shape;if(Or(t),t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){let u=n.shape.slice();for(;u.length<t.length;)u.unshift(1);n=te(n,u)}let r=n.shape,s=Array.from(t);for(let u=t.length-1;u>=0;u--)if(r[u]===t[u])s[u]=1;else if(n.shape[u]!==1)throw new Error(`broadcastTo(): [${a}] cannot be broadcast to [${t}].`);if(s.map((u,d)=>u>1?d:-1).filter(u=>u>=0).length===0)return li(n);let i={x:n},o={reps:s};return q.runKernel(xl,i,o)}var xu=X({broadcastTo_:o8});function l8(e){let t={x:F(e,"x","ceil","float32")};return q.runKernel(ac,t)}var I_=X({ceil_:l8});function Cr(e,t,n){Or(e),n=n||Ng(t);let a={shape:e,value:t,dtype:n};return q.runKernel(Rg,{},a)}function u8(e,t,n){let a=F(e,"x","clipByValue");if(U(t<=n,()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`),t===n)return Cr(a.shape,t,a.dtype);let r={x:a},s={clipValueMin:t,clipValueMax:n};return q.runKernel(vl,r,s)}var za=X({clipByValue_:u8});function c8(e){return Yt(e,0)}var T_=X({concat1d_:c8});function d8(e,t){return Yt(e,t)}var E_=X({concat2d_:d8});function h8(e,t){return Yt(e,t)}var C_=X({concat3d_:h8});function p8(e,t){return Yt(e,t)}var A_=X({concat4d_:p8});function f8(e,t,n,a,r="NHWC",s=[1,1],i){let o=F(e,"x","conv2d","float32"),u=F(t,"filter","conv2d","float32"),d=o,c=!1;o.rank===3&&(c=!0,d=te(o,[1,o.shape[0],o.shape[1],o.shape[2]])),U(d.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${d.rank}.`),U(u.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`),Za("conv2d",a,i);let p=r==="NHWC"?d.shape[3]:d.shape[1];U(p===u.shape[2],()=>`Error in conv2d: depth of input (${p}) must match input depth for filter ${u.shape[2]}.`),U(mi(n,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`),U(Du(s),()=>"Error in conv2D: Dilated rates should be larger than 0."),U(Du(n),()=>"Error in conv2D: Strides should be larger than 0.");let m={x:d,filter:u},g={strides:n,pad:a,dataFormat:r,dilations:s,dimRoundingMode:i},b=q.runKernel(rc,m,g);return c?te(b,[b.shape[1],b.shape[2],b.shape[3]]):b}var Ka=X({conv2d_:f8});function m8(e,t,n,a,r="NWC",s=1,i){let o=F(e,"x","conv1d"),u=F(t,"filter","conv1d"),d=o,c=!1;o.rank===2&&(c=!0,d=te(o,[1,o.shape[0],o.shape[1]])),U(d.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${d.rank}.`),U(u.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`),Za("conv1d",a,i),U(d.shape[2]===u.shape[1],()=>`Error in conv1d: depth of input (${d.shape[2]}) must match input depth for filter ${u.shape[1]}.`),U(mi(n,s),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${s}'`),U(Du(s),()=>"Error in conv1D: Dilated rates should be larger than 0."),U(Du(n),()=>"Error in conv1D: Stride should be larger than 0."),U(r==="NWC",()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`);let p=te(u,[1,u.shape[0],u.shape[1],u.shape[2]]),m=te(d,[d.shape[0],1,d.shape[1],d.shape[2]]),g=Ka(m,p,[1,n],a,"NHWC",[1,s],i);return c?te(g,[g.shape[2],g.shape[3]]):te(g,[g.shape[0],g.shape[2],g.shape[3]])}var I0=X({conv1d_:m8});function g8(e,t,n,a,r,s="NHWC",i){U(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let o=e,u=t,d=!1;t.rank===3&&(d=!0,u=te(t,[1,t.shape[0],t.shape[1],t.shape[2]]),o=[1,e[0],e[1],e[2]]),U(o.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`),U(u.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${u.rank}`),U(n.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);let c=s==="NHWC"?o[3]:o[1],p=s==="NHWC"?u.shape[3]:u.shape[1];U(c===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`),U(p===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${p}) must match output depth for filter ${n.shape[3]}.`),Za("conv2dDerInput",r,i);let m={dy:u,filter:n},g={strides:a,pad:r,dataFormat:s,dimRoundingMode:i,inputShape:o},b=q.runKernel(sc,m,g);return d?te(b,[b.shape[1],b.shape[2],b.shape[3]]):b}var $_=X({conv2DBackpropInput_:g8});function y8(e,t,n,a,r,s){let i=F(e,"x","conv2dTranspose"),o=F(t,"filter","conv2dTranspose");return $_(n,i,o,a,r,"NHWC",s)}var T0=X({conv2dTranspose_:y8});function b8(e,t,n,a,r="NDHWC",s=[1,1,1]){let i=F(e,"x","conv3d"),o=F(t,"filter","conv3d"),u=i,d=!1;i.rank===4&&(d=!0,u=te(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),U(u.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${u.rank}.`),U(o.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`),U(u.shape[4]===o.shape[3],()=>`Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${o.shape[3]}.`),U(mi(n,s),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`),U(r==="NDHWC",()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`),U(Du(s),()=>"Error in conv3D: Dilated rates should be larger than 0."),U(Du(n),()=>"Error in conv3D: Strides should be larger than 0.");let c={x:u,filter:o},p={strides:n,pad:a,dataFormat:r,dilations:s},m=q.runKernel(ic,c,p);return d?te(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}var R_=X({conv3d_:b8});function v8(e,t,n,a,r){U(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let s=e,i=t,o=!1;t.rank===4&&(o=!0,i=te(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),s=[1,e[0],e[1],e[2],e[3]]);let u=s[4],d=i.shape[4];U(s.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`),U(i.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),U(n.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),U(u===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${u}) must match input depth for filter ${n.shape[3]}.`),U(d===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${d}) must match output depth for filter ${n.shape[4]}.`);let c={dy:i,filter:n},p={pad:r,strides:a,inputShape:s},m=q.runKernel(hp,c,p);return o?te(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}var YO=X({conv3DBackpropInput_:v8});function x8(e,t,n,a,r){let s=F(e,"x","conv3dTranspose"),i=F(t,"filter","conv3dTranspose");return YO(n,s,i,a,r)}var D_=X({conv3dTranspose_:x8});function w8(e){let t={x:F(e,"x","cos","float32")};return q.runKernel(oc,t)}var ey=X({cos_:w8});function S8(e){let t={x:F(e,"x","cosh","float32")};return q.runKernel(lc,t)}var E0=X({cosh_:S8});function k8(e,t=0,n=!1,a=!1){let r={x:F(e,"x","cumprod")},s={axis:t,exclusive:n,reverse:a};return q.runKernel(pp,r,s)}var ag=X({cumprod_:k8});function _8(e,t=0,n=!1,a=!1){let r={x:F(e,"x","cumsum")},s={axis:t,exclusive:n,reverse:a};return q.runKernel(uc,r,s)}var C0=X({cumsum_:_8});function N8(e,t,n,a=!1){let r=F(e,"x","denseBincount"),s=F(t,"weights","denseBincount");U(r.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${r.dtype}`),U(r.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`),U(n>=0,()=>`size must be non-negative, but got ${n}.`),U(s.size===r.size||s.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${s.shape}.`);let i={x:r,weights:s},o={size:n,binaryOutput:a};return q.runKernel(Ag,i,o)}var Ev=X({denseBincount_:N8});function I8(e,t,n="NHWC"){let a=F(e,"x","depthToSpace","float32"),r=n==="NHWC"?a.shape[1]:a.shape[2],s=n==="NHWC"?a.shape[2]:a.shape[3],i=n==="NHWC"?a.shape[3]:a.shape[1];U(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),U(r*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${r} and ${t}  for depthToSpace with input shape
    ${a.shape}`),U(s*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${t} for depthToSpace with input shape
        ${a.shape}`),U(i%(t*t)===0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${a.shape}`);let o={x:a},u={blockSize:t,dataFormat:n};return q.runKernel(mp,o,u)}var O_=X({depthToSpace_:I8});function T8(e,t,n,a,r="NHWC",s=[1,1],i){let o=F(e,"x","depthwiseConv2d","float32"),u=F(t,"filter","depthwiseConv2d","float32"),d=o,c=!1;o.rank===3&&(c=!0,d=te(o,[1,o.shape[0],o.shape[1],o.shape[2]])),U(d.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${d.rank}.`),U(u.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`);let p=r==="NHWC"?d.shape[3]:d.shape[1];U(p===u.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${p}) must match the inChannels dimension in filter ${u.shape[2]}.`),Za("depthwiseConv2d",a,i);let m={x:d,filter:u},g={strides:n,pad:a,dataFormat:r,dilations:s,dimRoundingMode:i},b=q.runKernel(cc,m,g);return c?te(b,[b.shape[1],b.shape[2],b.shape[3]]):b}var dd=X({depthwiseConv2d_:T8});function E8(e){let t={x:F(e,"x","diag")};return q.runKernel($g,t)}var JO=X({diag_:E8});function C8(e,t,n,a,r=[1,1],s="NHWC"){let i=F(e,"x","dilation2d"),o=F(t,"filter","dilation2d");U(i.rank===3||i.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),U(o.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`),U(s==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`);let u=i,d=!1;i.rank===3&&(u=te(i,[1,i.shape[0],i.shape[1],i.shape[2]]),d=!0),U(u.shape[3]===o.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${u.shape[3]} vs ${o.shape[2]}`);let c={x:u,filter:o},p={strides:n,pad:a,dilations:r},m=q.runKernel(dc,c,p);return d?te(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var M_=X({dilation2d_:C8}),af={};ot(af,{assertAndGetBroadcastShape:()=>Jt,getBroadcastDims:()=>ZO,getReductionAxes:()=>jn});function ZO(e,t){let n=e.length,a=[];for(let r=0;r<n;r++){let s=n-1-r,i=e[s]||1;(t[t.length-1-r]||1)>1&&i===1&&a.unshift(s)}return a}function jn(e,t){let n=[];for(let a=0;a<t.length;a++){let r=e[e.length-a-1],s=t.length-a-1,i=t[s];(r==null||r===1&&i>1)&&n.unshift(s)}return n}function Jt(e,t){let n=Math.max(e.length,t.length),a=new Array(n);for(let r=0;r<n;r++){let s=e[e.length-r-1];s==null&&(s=1);let i=t[t.length-r-1];if(i==null&&(i=1),s===1)a[n-r-1]=i;else if(i===1)a[n-r-1]=s;else if(s!==i){let o=`Operands could not be broadcast together with shapes ${e} and ${t}.`;throw Error(o)}else a[n-r-1]=s}return a}function A8(e,t){let n=F(e,"a","equal","string_or_numeric"),a=F(t,"b","equal","string_or_numeric");[n,a]=Sn(n,a),Jt(n.shape,a.shape);let r={a:n,b:a};return q.runKernel(yp,r)}var Ar=X({equal_:A8});function $8(e,t,n){let a=F(t,"a","where"),r=F(n,"b","where"),s=F(e,"condition","where","bool"),i=Jt(Jt(s.shape,a.shape),r.shape),o=xu(s,i),u=xu(a,i),d=xu(r,i),c={condition:o,t:u,e:d};return q.runKernel(Hp,c)}var pa=X({where_:$8});function R8(e){let t={x:F(e,"x","zerosLike")};return q.runKernel(tf,t)}var _t=X({zerosLike_:R8});function D8(e,t){let n=F(e,"a","div"),a=F(t,"b","div");[n,a]=Sn(n,a);let r=Le(n,a),s=_t(r),i=Ar(a,s);return pa(i,s,r)}var F_=X({divNoNan_:D8});function O8(e,t){let n=F(e,"t1","dot"),a=F(t,"t2","dot");U((n.rank===1||n.rank===2)&&(a.rank===1||a.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${a.rank}.`);let r=n.rank===1?n.size:n.shape[1],s=a.rank===1?a.size:a.shape[0];if(U(r===s,()=>`Error in dot: inner dimensions of inputs must match, but got ${r} and ${s}.`),n.rank===1&&a.rank===1){let i=te(n,[1,-1]),o=te(a,[-1,1]),u=pt(i,o);return te(u,[])}else if(n.rank===1&&a.rank===2){let i=te(n,[1,-1]),o=te(a,[a.shape[0],a.shape[1]]),u=pt(i,o);return te(u,[u.size])}else if(n.rank===2&&a.rank===1){let i=te(a,[-1,1]),o=pt(n,i);return te(o,[o.size])}else{let i=te(a,[a.shape[0],a.shape[1]]);return pt(n,i)}}var z_=X({dot_:O8});function M8(e,...t){let n=t.map((r,s)=>F(r,`tensors${s}`,"einsum")),a={equation:e};return q.runKernel(p0,n,a)}var du=X({einsum_:M8});function F8(e){let t={x:F(e,"x","elu","float32")};return q.runKernel(pc,t)}var rf=X({elu_:F8});function z8(e,t){let n=F(e,"x","ensureShape","string_or_numeric");if(!nO(n.shape,t))throw new Error(`EnsureShape: Shape of tensor ${n.shape} is not compatible with expected shape ${t}`);return e}var QO=X({ensureShape_:z8});function L8(e){let t=F(e,"x","erf");U(t.dtype==="int32"||t.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),t.dtype==="int32"&&(t=Te(t,"float32"));let n={x:t};return q.runKernel(fc,n)}var A0=X({erf_:L8});function L_(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function eM(e,t,n){let a=e.length+t.length,r=[],s=0,i=0;for(let o=0;o<a;o++)n.indexOf(o)===-1?r.push(e[s++]):r.push(t[i++]);return r}function tM(e,t){let n=[],a=e.length;for(let s=0;s<a;s++)t.indexOf(s)===-1&&n.push(e[s]);let r=t.map(s=>e[s]);return[n,r]}function Ou(e,t){let n=t.map(a=>1);return eM(e,n,t)}function B8(e,t,n){U(L_(t,n),()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`)}function nM(e,t){if(L_(e,t))return null;let n=[];for(let a=0;a<t;++a)e.indexOf(a)===-1&&n.push(a);return e.forEach(a=>n.push(a)),n}function B_(e){return e.map((t,n)=>[n,t]).sort((t,n)=>t[1]-n[1]).map(t=>t[0])}function P8(e,t){let n=[];for(let a=t-e;a<t;++a)n.push(a);return n}function U8(e,t=null,n=!1){let a={x:F(e,"x","max")},r={reductionIndices:t,keepDims:n};return q.runKernel(Cc,a,r)}var Yr=X({max_:U8});function j8(e,t=null,n=!1){let a={x:F(e,"x","min")},r={axis:t,keepDims:n};return q.runKernel(Dc,a,r)}var Lh=X({min_:j8});function W8(e,t){let n=F(e,"base","pow"),a=F(t,"exp","pow");[n,a]=Sn(n,a);let r={a:n,b:a};return q.runKernel(Pc,r)}var hi=X({pow_:W8});function He(e,t){if((ca(e)&&t!=="string"||Array.isArray(e))&&t!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(t==="string"&&ca(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Sl(e,[],[],t)}function V8(e){let t={x:F(e,"x","sqrt","float32")};return q.runKernel(ad,t)}var fa=X({sqrt_:V8});function H8(e){let t=F(e,"x","square"),n={};return q.runKernel("Square",{x:t},n)}var Xt=X({square_:H8});function G8(e,t=null,n=!1){let a=F(e,"x","sum");a.dtype==="bool"&&(a=Te(a,"int32"));let r={x:a},s={axis:t,keepDims:n};return q.runKernel(rd,r,s)}var Be=X({sum_:G8});function q8(e,t="euclidean",n=null,a=!1){e=F(e,"x","norm");let r=aM(e,t,n),s=r.shape;if(a){let i=ws(n,e.shape);s=Ou(r.shape,i)}return te(r,s)}function aM(e,t,n=null){if(e.rank===0)return Ln(e);if(e.rank!==1&&n===null)return aM(te(e,[-1]),t,n);if(e.rank===1||typeof n=="number"||Array.isArray(n)&&n.length===1){if(t===1)return Be(Ln(e),n);if(t===1/0)return Yr(Ln(e),n);if(t===-1/0)return Lh(Ln(e),n);if(t==="euclidean"||t===2)return fa(Be(hi(Ln(e),He(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&n.length===2){if(t===1)return Yr(Be(Ln(e),n[0]),n[1]-1);if(t===1/0)return Yr(Be(Ln(e),n[1]),n[0]);if(t===-1/0)return Lh(Be(Ln(e),n[1]),n[0]);if(t==="fro"||t==="euclidean")return fa(Be(Xt(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}var sf=X({norm_:q8});function K8(e,t=null,n=!1){return sf(e,"euclidean",t,n)}var P_=X({euclideanNorm_:K8});function X8(e){let t={x:F(e,"x","exp")};return q.runKernel(mc,t)}var La=X({exp_:X8});function Y8(e,t=0){let n=F(e,"x","expandDims","string_or_numeric");U(t<=n.rank,()=>"Axis must be <= rank of the tensor");let a={input:n},r={dim:t};return q.runKernel(bp,a,r)}var da=X({expandDims_:Y8});function J8(e){let t={x:F(e,"x","expm1")};return q.runKernel(gc,t)}var U_=X({expm1_:J8});function Z8(e,t){let n=F(e,"x","tile","string_or_numeric");U(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`);let a={x:n},r={reps:t};return q.runKernel(xl,a,r)}var Er=X({tile_:Z8});function Q8(e,t,n,a="float32"){t==null&&(t=e);let r=mt([e,t],a),s=e<=t?e:t;for(let o=0;o<s;++o)r.set(1,o,o);let i=te(r.toTensor(),[e,t]);if(n==null)return i;if(n.length===1)return Er(da(i,0),[n[0],1,1]);if(n.length===2)return Er(da(da(i,0),0),[n[0],n[1],1,1]);if(n.length===3)return Er(da(da(da(i,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}var $0=X({eye_:Q8});function eK(e){let t={x:F(e,"x","floor","float32")};return q.runKernel(yc,t)}var of=X({floor_:eK});function tK(e,t,n=0,a=0){let r=F(e,"x","gather"),s=F(t,"indices","gather","int32"),i={x:r,indices:s},o={axis:n,batchDims:a};return q.runKernel(xp,i,o)}var lf=X({gather_:tK});function nK(e,t){let n=F(e,"a","greater","string_or_numeric"),a=F(t,"b","greater","string_or_numeric");[n,a]=Sn(n,a),Jt(n.shape,a.shape);let r={a:n,b:a};return q.runKernel(Sp,r)}var Qa=X({greater_:nK});function aK(e,t){let n=F(e,"a","greaterEqual","string_or_numeric"),a=F(t,"b","greaterEqual","string_or_numeric");[n,a]=Sn(n,a),Jt(n.shape,a.shape);let r={a:n,b:a};return q.runKernel(xc,r)}var to=X({greaterEqual_:aK});function rK(e){let t={input:F(e,"input","imag")};return q.runKernel(g0,t)}var ty=X({imag_:rK});function sK(e){let t={x:F(e,"x","isFinite")};return q.runKernel(Sc,t)}var j_=X({isFinite_:sK});function iK(e){let t={x:F(e,"x","isInf")};return q.runKernel(kc,t)}var W_=X({isInf_:iK});function oK(e){let t={x:F(e,"x","isNaN")};return q.runKernel(_c,t)}var V_=X({isNaN_:oK});function lK(e,t=.2){let n={x:F(e,"x","leakyRelu")},a={alpha:t};return q.runKernel(Nc,n,a)}var ny=X({leakyRelu_:lK});function uK(e,t){let n=F(e,"a","less","string_or_numeric"),a=F(t,"b","less","string_or_numeric");[n,a]=Sn(n,a),Jt(n.shape,a.shape);let r={a:n,b:a};return q.runKernel(kp,r)}var Bh=X({less_:uK});function cK(e,t){let n=F(e,"a","lessEqual","string_or_numeric"),a=F(t,"b","lessEqual","string_or_numeric");[n,a]=Sn(n,a),Jt(n.shape,a.shape);let r={a:n,b:a};return q.runKernel(_p,r)}var kl=X({lessEqual_:cK});function rM(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");let a={start:e,stop:t,num:n};return q.runKernel(Np,{},a)}function dK(e,t=5,n=1,a=1,r=.5){let s=F(e,"x","localResponseNormalization");U(s.rank===4||s.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${s.rank}.`),U(Oh(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let i=s,o=!1;s.rank===3&&(o=!0,i=te(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let u={x:i},d={depthRadius:t,bias:n,alpha:a,beta:r},c=q.runKernel(Ec,u,d);return o?te(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var H_=X({localResponseNormalization_:dK});function hK(e){let t={x:F(e,"x","log","float32")};return q.runKernel(Ic,t)}var $r=X({log_:hK});function pK(e){let t={x:F(e,"x","log1p")};return q.runKernel(Tc,t)}var ay=X({log1p_:pK});function fK(e){return U(tl(e),()=>"The f passed in grad(f) must be a function"),(t,n)=>{let a=F(t,"x","tf.grad","string_or_numeric"),r=n!=null?F(n,"dy","tf.grad"):null;return q.tidy(()=>{let{value:s,grads:i}=q.gradients(()=>e(a),[a],r);return r!=null&&Ja(s.shape,r.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),R0(i),i[0]})}}function mK(e){return U(tl(e),()=>"The f passed in grads(f) must be a function"),(t,n)=>{U(Array.isArray(t),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");let a=Qm(t,"args","tf.grads","string_or_numeric"),r=n!=null?F(n,"dy","tf.grads"):null;return q.tidy(()=>{let{value:s,grads:i}=q.gradients(()=>e(...a),a,r);return r!=null&&Ja(s.shape,r.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),R0(i),i})}}function gK(e){return U(tl(e),()=>"The f passed in valueAndGrad(f) must be a function"),(t,n)=>{U(t instanceof dt,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),U(n==null||n instanceof dt,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");let{grads:a,value:r}=q.gradients(()=>e(t),[t],n);return R0(a),{grad:a[0],value:r}}}function yK(e){return U(tl(e),()=>"The f passed in valueAndGrads(f) must be a function"),(t,n)=>{U(Array.isArray(t)&&t.every(r=>r instanceof dt),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),U(n==null||n instanceof dt,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");let a=q.gradients(()=>e(...t),t,n);return n!=null&&Ja(a.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),R0(a.grads),a}}function sM(e,t){U(tl(e),()=>"The f passed in variableGrads(f) must be a function"),U(t==null||Array.isArray(t)&&t.every(d=>d instanceof Eu),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");let n=t!=null;if(!n){t=[];for(let d in q.registeredVariables)t.push(q.registeredVariables[d])}let a=n?t.filter(d=>!d.trainable):null,r=t.length;t=t.filter(d=>d.trainable),U(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`);let s=!0,{value:i,grads:o}=q.gradients(e,t,null,s);U(o.some(d=>d!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),U(i.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);let u={};return t.forEach((d,c)=>{o[c]!=null&&(u[d.name]=o[c])}),a?.forEach(d=>u[d.name]=null),{value:i,grads:u}}function pi(e){return q.customGrad(e)}function R0(e){if(e.filter(t=>t==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}function bK(e){let t={x:F(e,"x","neg")};return q.runKernel(Rp,t)}var un=X({neg_:bK});function vK(e){let t={x:F(e,"x","softplus")};return q.runKernel(nd,t)}var hd=X({softplus_:vK});function xK(e){let t=F(e,"x","logSigmoid");return pi(n=>({value:un(hd(un(n))),gradFunc:a=>Y(a,ys(un(n)))}))(t)}var G_=X({logSigmoid_:xK});function wK(e,t){let n=F(e,"a","sub"),a=F(t,"b","sub");[n,a]=Sn(n,a);let r={a:n,b:a};return q.runKernel(od,r)}var Fe=X({sub_:wK});function SK(e,t=-1){let n=F(e,"logits","logSoftmax");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);return pi((a,r)=>{let s=Yr(a,t,!0),i=Fe(a,s),o=Fe(Te(i,"float32"),$r(Be(La(i),t,!0)));return r([o]),{value:o,gradFunc:(u,d)=>{let[c]=d,p=!0,m=La(c);return Fe(u,Y(Be(u,t,p),m))}}})(n)}var D0=X({logSoftmax_:SK});function kK(e,t=null,n=!1){let a=F(e,"x","logSumExp"),r=ws(t,a.shape),s=Yr(a,r,!0),i=Fe(a,s),o=La(i),u=Be(o,r),d=$r(u),c=ye(te(s,d.shape),d);if(n){let p=Ou(c.shape,r);return te(c,p)}return c}var ry=X({logSumExp_:kK});function _K(e,t){let n=F(e,"a","logicalAnd","bool"),a=F(t,"b","logicalAnd","bool");Jt(n.shape,a.shape);let r={a:n,b:a};return q.runKernel(Ip,r)}var bs=X({logicalAnd_:_K});function NK(e){let t={x:F(e,"x","logicalNot","bool")};return q.runKernel(Tp,t)}var sy=X({logicalNot_:NK});function IK(e,t){let n=F(e,"a","logicalOr","bool"),a=F(t,"b","logicalOr","bool");Jt(n.shape,a.shape);let r={a:n,b:a};return q.runKernel(Ep,r)}var O0=X({logicalOr_:IK});function TK(e,t){let n=F(e,"a","logicalXor","bool"),a=F(t,"b","logicalXor","bool");return Jt(n.shape,a.shape),bs(O0(e,t),sy(bs(e,t)))}var q_=X({logicalXor_:TK}),Wb=2147483648;function EK(e,t,n="left"){let a=F(e,"sortedSequence","searchSorted"),r=F(t,"values","searchSorted"),s=a.shape[a.shape.length-1],i=r.shape[r.shape.length-1],o=te(a,[-1,s]),u=te(r,[-1,i]);if(o.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==u.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(Wt(u.shape)>=Wb)throw new Error(`values tensor size must less than ${Wb}`);if(o.shape[1]>=Wb)throw new Error(`trailing dim_size must less than ${Wb} for int32 output type, was ${o.shape[1]}`);let d={sortedSequence:o,values:u},c={side:n};return q.runKernel(Vp,d,c)}var M0=X({searchSorted_:EK});function iM(e,t){return M0(e,t,"left")}function CK(e,t,n,a,r){let s=F(e,"x","maxPool"),i=1,o=s,u=!1;s.rank===3&&(u=!0,o=te(s,[1,s.shape[0],s.shape[1],s.shape[2]])),U(o.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${o.rank}.`),U(mi(n,i),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),Za("maxPool",a,r);let d={x:o},c={filterSize:t,strides:n,pad:a,dimRoundingMode:r},p=q.runKernel($c,d,c);return u?te(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var la=X({maxPool_:CK});function AK(e,t=[1,1,1],n,a,r,s="NDHWC"){let i=F(e,"x","maxPool3d"),o=i,u=!1;i.rank===4&&(u=!0,o=te(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),U(o.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`),U(s==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),Za("maxPool3d",a,r);let d={x:o},c={filterSize:t,strides:n,pad:a,dimRoundingMode:r,dataFormat:s},p=q.runKernel(Ap,d,c);return u?te(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}var K_=X({maxPool3d_:AK});function $K(e,t,n,a,r=!1){let s={x:F(e,"x","maxPoolWithArgmax")},i={filterSize:t,strides:n,pad:a,includeBatchInIndex:r},o=q.runKernel(Mg,s,i);return{result:o[0],indexes:o[1]}}var oM=X({maxPoolWithArgmax_:$K});function RK(e,t){let n=F(e,"a","maximum"),a=F(t,"b","maximum");[n,a]=Sn(n,a),n.dtype==="bool"&&(n=Te(n,"int32"),a=Te(a,"int32")),Jt(n.shape,a.shape);let r={a:n,b:a};return q.runKernel(Ac,r)}var gi=X({maximum_:RK});function DK(e,t=null,n=!1){let a={x:F(e,"x","mean")},r={axis:t,keepDims:n};return q.runKernel(Rc,a,r)}var vn=X({mean_:DK});function xn(e,t="float32"){if(Or(e),t==="complex64"){let a=xn(e,"float32"),r=xn(e,"float32");return Xi(a,r)}let n=i0(Wt(e),t);return q.makeTensor(n,e,t)}function or(e,t="float32"){if(Or(e),t==="complex64"){let a=or(e,"float32"),r=xn(e,"float32");return Xi(a,r)}let n=t_(Wt(e),t);return q.makeTensor(n,e,t)}function lM(e,t,{indexing:n="xy"}={}){if(n!=="xy"&&n!=="ij")throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(e===void 0)return[];let a=F(e,"x","meshgrid",e instanceof dt?e.dtype:"float32");if(t===void 0)return[a];let r=F(t,"y","meshgrid",t instanceof dt?t.dtype:"float32"),s=Wt(a.shape),i=Wt(r.shape);return n==="xy"?(a=te(a,[1,-1]),r=te(r,[-1,1]),[pt(or([i,1],a.dtype),a),pt(r,or([1,s],r.dtype))]):(a=te(a,[-1,1]),r=te(r,[1,-1]),[pt(a,or([1,i],a.dtype)),pt(or([s,1],r.dtype),r)])}function OK(e,t){let n=F(e,"a","minimum"),a=F(t,"b","minimum");[n,a]=Sn(n,a),n.dtype==="bool"&&(n=Te(n,"int32"),a=Te(a,"int32")),Jt(n.shape,a.shape);let r={a:n,b:a};return q.runKernel(Oc,r)}var ol=X({minimum_:OK});function MK(e,t,n){U(n==="reflect"||n==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);let a=F(e,"x","mirrorPad");if(a.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");U(t.length===a.rank,()=>`Padding doesn't match input. Must be ${a.rank}. Got ${t.length}.`);let r=n==="reflect"?1:0;for(let o=0;o<a.rank;o++)U(t[o].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),U(t[o][0]>=0&&t[o][0]<=a.shape[o]-r&&t[o][1]>=0&&t[o][1]<=a.shape[o]-r,()=>`Padding in dimension ${o} cannot be greater than or equal to ${a.shape[o]-r} or less than 0 for input of shape ${a.shape}`);let s={paddings:t,mode:n},i={x:a};return q.runKernel(Mc,i,s)}var X_=X({mirrorPad_:MK});function FK(e,t){let n=F(e,"a","mod"),a=F(t,"b","mod");[n,a]=Sn(n,a);let r={a:n,b:a};return q.runKernel(Fc,r)}var Y_=X({mod_:FK});function zK(e,t=null,n=!1){e=F(e,"x","moments");let a=ws(t,e.shape),r=vn(e,a,n),s=r.shape;n||(s=Ou(r.shape,a));let i=Xt(Fe(Te(e,"float32"),te(r,s))),o=vn(i,a,n);return{mean:r,variance:o}}var iy=X({moments_:zK});function LK(e,t,n,a){let r=F(t,"data","multiRNNCell"),s=Qm(n,"c","multiRNNCell"),i=Qm(a,"h","multiRNNCell"),o=r,u=[];for(let p=0;p<e.length;p++){let m=e[p](o,s[p],i[p]);u.push(m[0]),u.push(m[1]),o=m[1]}let d=[],c=[];for(let p=0;p<u.length;p+=2)d.push(u[p]),c.push(u[p+1]);return[d,c]}var uM=X({multiRNNCell_:LK});function BK(e,t,n,a=!1){let r=F(e,"logits","multinomial"),s=r.size,i=r.rank;if(s<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);n=n||Math.random();let o={logits:i===1?te(r,[1,-1]):r},u={numSamples:t,seed:n,normalized:a},d=q.runKernel($p,o,u);return i===1?te(d,[d.size]):d}var cM=X({multinomial_:BK});function PK(e,t){let n=F(e,"a","notEqual","string_or_numeric"),a=F(t,"b","notEqual","string_or_numeric");[n,a]=Sn(n,a),Jt(n.shape,a.shape);let r={a:n,b:a};return q.runKernel(Dp,r)}var Mu=X({notEqual_:PK});function UK(e,t,n=1,a=0,r="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);let s={indices:F(e,"indices","oneHot","int32")},i={dtype:r,depth:t,onValue:n,offValue:a};return q.runKernel(Lc,s,i)}var Ph=X({oneHot_:UK});function jK(e){let t={x:F(e,"x","onesLike")};return q.runKernel(zp,t)}var Rr=X({onesLike_:jK});function WK(e,t){let n=F(e,"v1","outerProduct"),a=F(t,"v2","outerProduct");U(n.rank===1&&a.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${a.rank}.`);let r=te(n,[-1,1]),s=te(a,[1,-1]);return pt(r,s)}var dM=X({outerProduct_:WK});function VK(e,t,n=0){let a=F(e,"x","pad");if(a.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");let r={paddings:t,constantValue:n},s={x:a};return q.runKernel(Bc,s,r)}var Vs=X({pad_:VK});function HK(e,t,n=0){return U(t.length===2,()=>"Invalid number of paddings. Must be length of 2."),Vs(e,[t],n)}var hM=X({pad1d_:HK});function GK(e,t,n=0){return U(t.length===2&&t[0].length===2&&t[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Vs(e,t,n)}var pM=X({pad2d_:GK});function qK(e,t,n=0){return U(t.length===3&&t[0].length===2&&t[1].length===2&&t[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Vs(e,t,n)}var fM=X({pad3d_:qK});function KK(e,t,n=0){return U(t.length===4&&t[0].length===2&&t[1].length===2&&t[2].length===2&&t[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Vs(e,t,n)}var mM=X({pad4d_:KK});function XK(e,t,n){let a=F(e,"x","spaceToBatchND");U(a.rank>=1+t.length,()=>`input rank ${a.rank} should be > than [blockShape] ${t.length}`),U(n.length===t.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`),U(a.shape.reduce((i,o,u)=>u>0&&u<=t.length?i&&(o+n[u-1][0]+n[u-1][1])%t[u-1]===0:i,!0),()=>`input spatial dimensions ${a.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`);let r={x:a},s={blockShape:t,paddings:n};return q.runKernel(qp,r,s)}var oy=X({spaceToBatchND_:XK});function YK(e,t,n,a,r,s,i){r==null&&(r=[1,1]),s==null&&(s=1),a===0&&(a="valid");let o=F(e,"x","maxPool"),u=o,d=!1;o.rank===3&&(d=!0,u=te(o,[1,o.shape[0],o.shape[1],o.shape[2]])),U(mi(s,r),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${r}'`);let c=VO(u.shape,t,s,r,a),p=[c.dilationHeight,c.dilationWidth],m;a==="same"?m=ZK([c.filterHeight,c.filterWidth],p):m=[[0,0],[0,0]];let g=p[0]===1&&p[1]===1,[b,v]=JK([c.inHeight,c.inWidth],p,m),x=g?a:"valid",w=g?u:oy(u,p,b),k=(n==="avg"?()=>eo(w,t,s,x,i):()=>la(w,t,s,x,i))(),N=g?k:Qg(k,p,v);return d?te(N,[N.shape[1],N.shape[2],N.shape[3]]):N}function JK(e,t,n){let a=n.map(c=>c[0]),r=n.map(c=>c[1]),s=e.concat(a,r),i=t.map((c,p)=>(c-s[p]%c)%c),o=r.map((c,p)=>c+i[p]),u=t.map((c,p)=>[a[p],o[p]]),d=t.map((c,p)=>[0,i[p]]);return[u,d]}function ZK(e,t){let n=e.map((s,i)=>s+(s-1)*(t[i]-1)).map(s=>s-1),a=n.map(s=>Math.floor(s/2)),r=n.map((s,i)=>s-a[i]);return n.map((s,i)=>[a[i],r[i]])}var J_=X({pool_:YK});function QK(e,t){let n=F(e,"x","prelu"),a=F(t,"alpha","prelu"),r={x:n,alpha:a};return q.runKernel(Uc,r)}var ly=X({prelu_:QK});function e7(e,t=null,n=!1){let a=F(e,"x","prod");a.dtype==="bool"&&(a=Te(a,"int32"));let r={x:a},s={axis:t,keepDims:n};return q.runKernel(jc,r,s)}var Z_=X({prod_:e7});function t7(e,t,n,a){let r=e.map((c,p)=>F(c,`tensors${p}`,"raggedGather","int32")),s=F(t,"paramsDenseValues","raggedGather"),i=F(n,"indices","raggedGather","int32"),o={paramsNestedSplits:r,paramsDenseValues:s,indices:i},u={outputRaggedRank:a},d=q.runKernel(y0,o,u);return{outputNestedSplits:d.slice(0,d.length-1),outputDenseValues:d[d.length-1]}}var gM=X({raggedGather_:t7});function n7(e,t,n){let a=F(e,"starts","raggedRange"),r=F(t,"limits","raggedRange",a.dtype),s=F(n,"deltas","raggedRange",a.dtype),i={starts:a,limits:r,deltas:s},o=q.runKernel(b0,i);return{rtNestedSplits:o[0],rtDenseValues:o[1]}}var yM=X({raggedRange_:n7});function a7(e,t,n,a,r){let s=F(e,"shape","raggedTensorToTensor","int32"),i=F(t,"values","raggedTensorToTensor"),o=F(n,"defaultValue","raggedTensorToTensor",i.dtype),u=a.map((p,m)=>F(p,`tensors${m}`,"raggedTensorToTensor","int32")),d={shape:s,values:i,defaultValue:o,rowPartitionTensors:u},c={rowPartitionTypes:r};return q.runKernel(v0,d,c)}var bM=X({raggedTensorToTensor_:a7});function r7(e,t,n){Or(e);let a=Wt(e),r=null;if(n==null||n==="float32")r=new Float32Array(a);else if(n==="int32")r=new Int32Array(a);else if(n==="bool")r=new Uint8Array(a);else throw new Error(`Unknown data type ${n}`);for(let s=0;s<a;s++)r[s]=t();return q.makeTensor(r,e,n)}var vM=X({rand_:r7}),Q_=yl(r0()),xM={};ot(xM,{TEST_EPSILON_FLOAT16:()=>wM,createVideoElement:()=>h7,encodeStrings:()=>SM,expectArrayBuffersEqual:()=>d7,expectArraysClose:()=>i7,expectArraysEqual:()=>l7,expectNumbersClose:()=>u7,expectPromiseToFail:()=>o7,expectValuesInRange:()=>c7,play:()=>p7,testEpsilon:()=>e2});var s7=.001,wM=.1;function i7(e,t,n){return n==null&&(n=e2()),jS(e,t,(a,r)=>t2(a,r,n))}function e2(){return q.backend.floatPrecision()===32?s7:wM}function jS(e,t,n){let a=!0;if((ca(e)||ca(t))&&(a=!1),ca(e)&&ca(t)&&(a=!0),a){let i=e.constructor.name,o=t.constructor.name;if(i!==o)throw new Error(`Arrays are of different type. Actual: ${i}. Expected: ${o}`)}if(Array.isArray(e)&&Array.isArray(t)){let i=di(e),o=di(t);if(!Zi(i,o))throw new Error(`Arrays have different shapes. Actual: [${i}]. Expected: [${o}]`)}let r=ca(e)?e:nl(e),s=ca(t)?t:nl(t);if(r.length!==s.length)throw new Error(`Arrays have different lengths actual: ${r.length} vs expected: ${s.length}.
Actual:   ${r}.
Expected: ${s}.`);for(let i=0;i<s.length;++i){let o=r[i],u=s[i];if(!n(o,u))throw new Error(`Arrays differ: actual[${i}] = ${o}, expected[${i}] = ${u}.
Actual:   ${r}.
Expected: ${s}.`)}typeof expect<"u"&&expect().nothing()}function o7(e,t){e().then(()=>t.fail(),()=>t()),typeof expect<"u"&&expect().nothing()}function l7(e,t){let n=typeof t=="string"||typeof t=="number"||typeof t=="boolean"?[t]:t;return Ko(e)||Ko(e[0])||Ko(t)||Ko(t[0])?jS(e,n,(a,r)=>a==r):jS(e,t,(a,r)=>t2(a,r,0))}function u7(e,t,n){if(n==null&&(n=e2()),!t2(e,t,n))throw new Error(`Numbers differ: actual === ${e}, expected === ${t}`);typeof expect<"u"&&expect().nothing()}function t2(e,t,n){return!isFinite(e)&&!isFinite(t)?!0:!(isNaN(e)||isNaN(t)||Math.abs(e-t)>n)}function c7(e,t,n){for(let a=0;a<e.length;a++)if(e[a]<t||e[a]>n)throw new Error(`Value out of range:${e[a]} low: ${t}, high: ${n}`)}function d7(e,t){let n=new Float32Array(e),a=new Float32Array(t);if(n.length!==a.length)throw new Error(`Expected ArrayBuffer to be of length ${a.length}, but it was ${n.length}`);for(let r=0;r<a.length;r++)if(n[r]!==a[r])throw new Error(`Expected ArrayBuffer value at ${r} to be ${a[r]} but got ${n[r]} instead`)}function SM(e){for(let t=0;t<e.length;t++){let n=e[t];Array.isArray(n)?SM(n):e[t]=Xg(n)}return e}function h7(e){let t=document.createElement("video");return"playsInline"in t&&(t.playsInline=!0),t.muted=!0,t.loop=!0,t.style.position="fixed",t.style.left="0px",t.style.top="0px",t.preload="auto",t.appendChild(e),new Promise(n=>{t.addEventListener("loadeddata",a=>n(t)),t.load()})}async function p7(e){await e.play(),"requestVideoFrameCallback"in e&&await new Promise(t=>{e.requestVideoFrameCallback(t)})}var n2=class{constructor(e,t,n,a,r){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=a,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);let s=r||Math.random();this.random=Q_.alea(s.toString())}nextValue(){if(!isNaN(this.nextVal)){let a=this.nextVal;return this.nextVal=NaN,a}let e,t,n=!1;for(;!n;){let a,r,s;do a=2*this.random()-1,r=2*this.random()-1,s=a*a+r*r;while(s>=1||s===0);let i=Math.sqrt(-2*Math.log(s)/s);e=this.mean+this.stdDev*a*i,t=this.mean+this.stdDev*r*i,(!this.truncated||this.isValidTruncated(e))&&(n=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}},f7=class{constructor(e,t,n,a){this.alpha=e,this.beta=1/t,this.dtype=n;let r=a||Math.random();this.randu=Q_.alea(r.toString()),this.randn=new n2(0,1,n,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,a,r,s;for(;;){do a=this.randn.nextValue(),s=1+this.c*a;while(s<=0);if(s*=s*s,e=a*a,t=1-.331*e*e,n=.5*e+this.d*(1-s+Math.log(s)),r=this.randu(),r<t||Math.log(r)<n)break}return s=1/this.beta*this.d*s,this.alpha<1&&(s*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(s)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}},m7=class{constructor(e=0,t=1,n,a){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=n,a==null&&(a=Math.random()),typeof a=="number"&&(a=a.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=Q_.alea(a)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}};function g7(e,t,n=1,a="float32",r){if(Or(e),n==null&&(n=1),a==null&&(a="float32"),a!=="float32"&&a!=="int32")throw new Error(`Unsupported data type ${a}`);let s=new f7(t,n,a,r),i=mt(e,a);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}var kM=X({randomGamma_:g7});function y7(e,t=0,n=1,a,r){if(Or(e),a!=null&&a==="bool")throw new Error(`Unsupported data type ${a}`);let s=new n2(t,n,a,!1,r),i=mt(e,a);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}var F0=X({randomNormal_:y7});function b7(e,t,n){if(t!=null&&t==="bool")throw new Error(`Unsupported data type ${t}`);return F0(e,0,1,t,n)}var _M=X({randomStandardNormal_:b7});function v7(e,t=0,n=1,a="float32",r){Or(e);let s=mt(e,a),i=new m7(t,n,null,r);for(let o=0;o<s.values.length;o++)s.values[o]=i.nextValue();return s.toTensor()}var _l=X({randomUniform_:v7});function x7(e,t,n,a){return _l(e,t,n,"int32",a)}var NM=X({randomUniformInt_:x7});function Fu(e,t,n=1,a="float32"){if(n===0)throw new Error("Cannot have a step of zero");let r={start:e,stop:t,step:n,dtype:a};return q.runKernel(Fg,{},r)}function w7(e){let t={input:F(e,"input","real")};return q.runKernel(x0,t)}var Uh=X({real_:w7});function S7(e){let t={x:F(e,"x","reciprocal")};return q.runKernel(Wc,t)}var a2=X({reciprocal_:S7});function k7(e){let t={x:F(e,"x","relu")};return q.runKernel(Vc,t)}var jt=X({relu_:k7});function _7(e){let t={x:F(e,"x","relu6")};return q.runKernel(qc,t)}var z0=X({relu6_:_7});function N7(e,t){let n={x:F(e,"x","reverse")},a={dims:t};return q.runKernel(Kc,n,a)}var Qr=X({reverse_:N7});function I7(e){let t=F(e,"x","reverse");return U(t.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`),Qr(t,0)}var IM=X({reverse1d_:I7});function T7(e,t){let n=F(e,"x","reverse");return U(n.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`),Qr(n,t)}var TM=X({reverse2d_:T7});function E7(e,t){let n=F(e,"x","reverse");return U(n.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`),Qr(n,t)}var EM=X({reverse3d_:E7});function C7(e,t){let n=F(e,"x","reverse");return U(n.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`),Qr(n,t)}var CM=X({reverse4d_:C7});function A7(e){let t={x:F(e,"x","round")};return q.runKernel(Xc,t)}var L0=X({round_:A7});function $7(e){let t={x:F(e,"x","rsqrt","float32")};return q.runKernel(Yc,t)}var B0=X({rsqrt_:$7});function R7(e){let t={x:F(e,"x","selu")};return q.runKernel(Jc,t)}var P0=X({selu_:R7});function D7(e,t,n,a,r,s=[1,1],i="NHWC"){let o=F(e,"x","separableConv2d"),u=F(t,"depthwiseFilter","separableConv2d"),d=F(n,"pointwiseFilter","separableConv2d"),c=o,p=!1;if(o.rank===3&&(p=!0,c=te(o,[1,o.shape[0],o.shape[1],o.shape[2]])),i==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");U(c.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),U(u.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${u.rank}.`),U(d.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${u.rank}.`),U(d.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${d.shape[0]}.`),U(d.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${d.shape[1]}.`);let m=u.shape[2],g=u.shape[3];U(d.shape[2]===m*g,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${m*g}, but got ${d.shape[2]}.`);let b=dd(c,u,a,r,i,s),v=Ka(b,d,1,"valid",i);return p?te(v,[v.shape[1],v.shape[2],v.shape[3]]):v}var uf=X({separableConv2d_:D7});async function O7(e,t){let n=F(e,"x","setdiff1d"),a=F(t,"y","setdiff1d");U(n.dtype===a.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${a.dtype}).`),U(n.rank===1,()=>`x should be 1D tensor, but got x (${n.shape}).`),U(a.rank===1,()=>`y should be 1D tensor, but got y (${a.shape}).`);let r=await n.data(),s=await a.data(),i=new Set(s),o=0;for(let c=0;c<r.length;c++)i.has(r[c])||o++;let u=new Pn([o],n.dtype),d=new Pn([o],"int32");for(let c=0,p=0;c<r.length;c++)i.has(r[c])||(u.values[p]=r[c],d.values[p]=c,p++);return[u.toTensor(),d.toTensor()]}var AM=O7;function M7(e){let t={x:F(e,"x","sign")};return q.runKernel(ed,t)}var r2=X({sign_:M7});function F7(e){let t={x:F(e,"x","sin","float32")};return q.runKernel(Zc,t)}var U0=X({sin_:F7});function z7(e){let t={x:F(e,"x","sinh")};return q.runKernel(Qc,t)}var j0=X({sinh_:z7});function L7(e,t,n){let a=F(e,"x","slice1d");return U(a.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${a.rank} tensor`),wt(a,[t],[n])}var uy=X({slice1d_:L7});function B7(e,t,n){let a=F(e,"x","slice2d");return U(a.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${a.rank} tensor`),wt(a,t,n)}var W0=X({slice2d_:B7});function P7(e,t,n){let a=F(e,"x","slice3d");return U(a.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${a.rank} tensor`),wt(a,t,n)}var cf=X({slice3d_:P7});function U7(e,t,n){let a=F(e,"x","slice4d");return U(a.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${a.rank} tensor`),wt(a,t,n)}var jh=X({slice4d_:U7});function j7(e,t=-1){let n=F(e,"logits","softmax","float32");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);let a={logits:n},r={dim:t};return q.runKernel(sd,a,r)}var Nl=X({softmax_:j7});function W7(e){U(e.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`);let t={input:e};return q.runKernel(f0,t)}var cy=X({fft_:W7});function V7(e){U(e.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`);let t={input:e};return q.runKernel(m0,t)}var Wh=X({ifft_:V7});function H7(e){let t=e.shape[e.shape.length-1],n=e.size/t,a;if(t<=2){let r=te(e,[n,t]);a=Wh(r)}else{let r=[n,2*(t-1)],s=te(Uh(e),[n,t]),i=te(ty(e),[n,t]),o=Qr(wt(s,[0,1],[n,t-2]),1),u=Y(Qr(wt(i,[0,1],[n,t-2]),1),He(-1)),d=Yt([s,o],1),c=Yt([i,u],1),p=te(Xi(d,c),[r[0],r[1]]);a=Wh(p)}if(a=Uh(a),e.rank===3&&e.shape[0]!==0){let r=a,s=e.shape[0];a=te(a,[s,a.shape[0]/s,a.shape[1]]),r.dispose()}return a}var V0=X({irfft_:H7});function G7(e,t,n=0){let a={x:F(e,"x","split")},r={numOrSizeSplits:t,axis:n};return q.runKernel(Kp,a,r)}var lr=X({split_:G7});function q7(e,t){U(e.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${e.dtype}`);let n=e.shape[e.shape.length-1],a=e.size/n,r;if(t!=null&&t<n){let b=e.shape.map(x=>0),v=e.shape.map(x=>x);v[e.shape.length-1]=t,r=wt(e,b,v),n=t}else if(t!=null&&t>n){let b=e.shape.map(v=>v);b[e.shape.length-1]=t-n,r=Yt([e,xn(b)],e.shape.length-1),n=t}else r=e;let s=_t(r),i=te(Xi(r,s),[a,n]),o=cy(i),u=Math.floor(n/2)+1,d=Uh(o),c=ty(o),p=lr(d,[u,n-u],d.shape.length-1),m=lr(c,[u,n-u],c.shape.length-1),g=r.shape.slice();return g[r.shape.length-1]=u,te(Xi(p[0],m[0]),g)}var dy=X({rfft_:q7});function K7(e,t){let n=F(e,"a","squaredDifference"),a=F(t,"b","squaredDifference");[n,a]=Sn(n,a),Jt(n.shape,a.shape);let r={a:n,b:a},s={};return q.runKernel(id,r,s)}var H0=X({squaredDifference_:K7});function X7(e,t){let n=F(e,"x","squeeze","string_or_numeric");return te(n,aO(n.shape,t).newShape)}var Il=X({squeeze_:X7});function Y7(e,t=0){let n=Qm(e,"tensors","stack","string_or_numeric");U(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&U(t<=n[0].rank,()=>"Axis must be <= rank of the tensor");let a=n,r={axis:t};return q.runKernel(Lp,a,r)}var Un=X({stack_:Y7});function J7(e,t=0){let n={x:F(e,"x","step")},a={alpha:t};return q.runKernel(wl,n,a)}var pd=X({step_:J7});function Z7(e,t,n,a,r=0,s=0,i=0,o=0,u=0){let d={x:F(e,"x","stridedSlice","string_or_numeric")},c={begin:t,end:n,strides:a,beginMask:r,endMask:s,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:u};return q.runKernel(Jp,d,c)}var s2=X({stridedSlice_:Z7});function Q7(e){let t={x:F(e,"x","tan","float32")};return q.runKernel(ld,t)}var i2=X({tan_:Q7});function Lt(e,t){Hu(e);let n=di(e,t);if(n.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Sl(e,null,n,t)}function ui(e,t,n){if(Hu(e),t!=null&&t.length!==2)throw new Error("tensor2d() requires shape to have two numbers");let a=di(e,n);if(a.length!==2&&a.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(a.length===1&&t==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Sl(e,t,a,n)}function G0(e,t,n){if(Hu(e),t!=null&&t.length!==3)throw new Error("tensor3d() requires shape to have three numbers");let a=di(e,n);if(a.length!==3&&a.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(a.length===1&&t==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Sl(e,t,a,n)}function ll(e,t,n){if(Hu(e),t!=null&&t.length!==4)throw new Error("tensor4d() requires shape to have four numbers");let a=di(e,n);if(a.length!==4&&a.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(a.length===1&&t==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Sl(e,t,a,n)}function $M(e,t,n){if(Hu(e),t!=null&&t.length!==5)throw new Error("tensor5d() requires shape to have five numbers");let a=di(e,n);if(a.length!==5&&a.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(a.length===1&&t==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Sl(e,t,a,n)}function RM(e,t,n){if(Hu(e),t!=null&&t.length!==6)throw new Error("tensor6d() requires shape to have six numbers");let a=di(e,n);if(a.length!==6&&a.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(a.length===1&&t==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return t=t||a,Sl(e,t,a,n)}var q0={};ot(q0,{calculateShapes:()=>DM,validateInput:()=>K0,validateUpdateShape:()=>o2});function o2(e,t,n){let a=t.rank>1?t.shape[t.rank-1]:1,r=t.rank>1?t.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${a}, and batchDim: ${r}.`;if(n.rank<r)throw new Error(s+` update.rank < ${r}. `);if(e.length<a+(n.rank-r))throw new Error(s+` Output shape length < ${a+(n.rank-r)}`);if(n.rank!==r+e.length-a)throw new Error(s+` update.rank != ${r+e.length-a}`);for(let i=0;i<r;++i)if(n.shape[i]!==t.shape[i])throw new Error(s+` updates.shape[${i}] (${n.shape[i]}) != indices.shape[${i}] (${t.shape[i]}).`);for(let i=0;i<n.rank-r;++i)if(n.shape[i+r]!==e[i+a])throw new Error(s+` updates.shape[${i+r}] (${n.shape[i+r]}) != shape[${i+r}] (${e[i+r]})`)}function K0(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(n.length===0){if(t.size===0)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(e.size===0)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}o2(n,t,e)}function DM(e,t,n){let a=t.shape.length,r=a>1?t.shape[a-1]:1,s=n.length,i=1;for(let p=r;p<s;++p)i*=n[p];let o=r<1?1:r,u=Wt(t.shape)/o,d=[...ep(n.slice(0,r)),1],c=Wt(n);return{sliceRank:r,numUpdates:u,sliceSize:i,strides:d,outputSize:c}}function e9(e,t,n){let a=F(e,"tensor","tensorScatterupdate"),r=F(t,"indices","tensorScatterupdate","int32"),s=F(n,"updates","tensorScatterupdate");if(K0(s,r,a.shape),a.dtype!==s.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${a.dtype} and ${s.dtype}.`);let i={tensor:a,indices:r,updates:s},o={};return q.runKernel(Wp,i,o)}var OM=X({tensorScatterUpdate_:e9});function t9(e,t=1,n=!0){let a=F(e,"x","topk");if(a.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");let r=a.shape[a.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${t}`);let s={x:a},i={k:t,sorted:n},[o,u]=q.runKernel(Zp,s,i);return{values:o,indices:u}}var l2=X({topk_:t9});function n9(e,t=0,n=1,a,r){if(Or(e),a!=null&&a==="bool")throw new Error("Unsupported data type $ { dtype }");let s=new n2(t,n,a,!0,r),i=mt(e,a);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}var X0=X({truncatedNormal_:n9});function a9(e,t=0){let n=F(e,"x","unique","string_or_numeric");U(n.rank>0,()=>"The input tensor must be at least 1D");let a={x:n},r={axis:t},[s,i]=q.runKernel(Hg,a,r);return{values:s,indices:i}}var u2=X({unique_:a9});function r9(e,t,n){let a=F(e,"x","unsortedSegmentSum"),r=F(t,"segmentIds","unsortedSegmentSum","int32");U(Oh(n),()=>"numSegments must be of dtype int");let s={x:a,segmentIds:r},i={numSegments:n};return q.runKernel(Gg,s,i)}var Y0=X({unsortedSegmentSum_:r9});function s9(e,t=0){let n=F(e,"x","unstack","string_or_numeric");U(t>=-n.shape.length&&t<n.shape.length,()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`);let a={value:n},r={axis:t};return q.runKernel(ef,a,r)}var Nn=X({unstack_:s9});function MM(e,t){return M0(e,t,"right")}function c2(e,t=!0,n,a){return q.makeVariable(e,t,n,a)}function FM(e,t){let n=[];for(let s=0;s<t.length;s++)t[s]&&n.push(s);let a=mt(e,"int32"),r=mt([n.length,e.length],"int32");for(let s=0;s<n.length;s++){let i=a.indexToLoc(n[s]),o=s*e.length;r.values.set(i,o)}return r.toTensor()}async function i9(e){let t=F(e,"condition","whereAsync","bool"),n=await t.data(),a=FM(t.shape,n);return e!==t&&t.dispose(),a}var d2=i9;async function o9(e,t,n){let a=F(e,"tensor","boolMask"),r=F(t,"mask","boolMask","bool"),s=n??0,i=r.rank,o=a.shape;U(i>0,()=>"mask cannot be scalar"),Ja(o.slice(s,s+i),r.shape,"mask's shape must match the first K dimensions of tensor's shape,");let u=1;for(let v=s;v<s+i;v++)u*=o[v];let d=o.slice(0,s).concat([u],o.slice(s+i)),c=te(a,d),p=te(r,[-1]),m=await d2(p),g=Il(m,[1]),b=lf(c,g,s);return e!==a&&a.dispose(),t!==r&&r.dispose(),g.dispose(),c.dispose(),p.dispose(),m.dispose(),b}var zM=o9;function l9(e,t,n){let a=F(e,"x","transpose");if(t==null&&(t=a.shape.map((i,o)=>o).reverse()),U(a.rank===t.length,()=>`Error in transpose: rank of input ${a.rank} must match length of perm ${t}.`),t.forEach(i=>{U(i>=0&&i<a.rank,()=>`All entries in 'perm' must be between 0 and ${a.rank-1} but got ${t}`)}),a.rank<=1)return a.clone();let r={x:a},s={perm:t};return a.dtype==="complex64"?ne(()=>{let i=Uh(a),o=ty(a);return i=q.runKernel(Hi,{x:i},s),o=q.runKernel(Hi,{x:o},s),n&&(o=un(o)),Xi(i,o)}):q.runKernel(Hi,r,s)}var ft=X({transpose_:l9});function u9(e,t,n,a,r=!0){let s=F(e,"v","movingAverage"),i=F(t,"x","movingAverage"),o=F(n,"decay","movingAverage");kO(s,i),U(Zi(s.shape,i.shape),()=>"Shape mismatch in v and x");let u=He(1),d=Fe(u,o),c=Y(Fe(i,s),d);if(r){U(a!=null,()=>"When using zeroDebias: true, step is required.");let p=F(a,"step","movingAverage");c=Le(c,Fe(u,hi(o,p)))}return ye(s,c)}var LM=X({movingAverage_:u9});function c9(e,t,n){Or(n);let a=F(e,"indices","scatterND","int32"),r=F(t,"updates","scatterND");K0(r,a,n);let s={indices:a,updates:r},i={shape:n};return q.runKernel(jp,s,i)}var BM=X({scatterND_:c9});function d9(e,t,n,a){if(e.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);let r=e.rank>0?e.shape[0]:1,s=e.rank>1?e.shape[1]:1;if(n.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${s}.`);let i=t.size;if(!(t.rank===0||t.rank===1&&i===r))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${r}]`);if(t.dtype!==a.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function h9(e,t,n,a=0){Or(n);let r=F(e,"sparseIndices","sparseToDense","int32"),s=F(t,"sparseValues","sparseToDense","string_or_numeric"),i=F(a,"defaultValue","sparseToDense",s.dtype);d9(r,s,n,i);let o={sparseIndices:r,sparseValues:s,defaultValue:i},u={outputShape:n};return q.runKernel(Yp,o,u)}var PM=X({sparseToDense_:h9});function p9(e,t){let n=F(t,"indices","gatherND","int32"),a={params:F(e,"x","gatherND","string_or_numeric"),indices:n};return q.runKernel(wp,a)}var UM=X({gatherND_:p9});function f9(e,t){if(t==null)return e.shape.slice();if(Zi(e.shape,t))return t;if(e.shape.length===t.length){let n=[];for(let a=0;a<e.shape.length;a++)t[a]==null&&e.shape[a]!=null?n.push(e.shape[a]):n.push(t[a]);return n}return t}function m9(e,t,n,a){let r=F(e,"x","dropout");if(U(r.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`),U(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),t===0)return e instanceof dt?r.clone():r;let s=f9(r,n),i=1-t,o=Le(of(ye(_l(s,0,1,"float32",a),i)),i);return Y(r,o)}var h2=X({dropout_:m9});function p2(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function J0(e,t,n){let a=1-e%2,r=new Float32Array(e);for(let s=0;s<e;++s){let i=2*Math.PI*s/(e+a-1);r[s]=t-n*Math.cos(i)}return Lt(r,"float32")}async function g9(e,t,n=1){let a=F(e,"predictions","inTopK"),r=F(t,"targets","inTopK");U(a.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${a.rank}`),U(a.rank-1===r.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${a.rank} and targets rank ${r.rank}`),Ja(a.shape.slice(0,a.shape.length-1),r.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");let s=a.shape[a.shape.length-1];U(n>0&&n<=s,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${n}`);let i=await a.data(),o=await r.data(),[u,d]=[i.length/s,s],c=rO("bool",u);for(let p=0;p<u;p++){let m=p*d,g=i.subarray(m,m+d),b=[];for(let v=0;v<g.length;v++)b.push({value:g[v],index:v});b.sort((v,x)=>x.value-v.value),c[p]=0;for(let v=0;v<n;v++)if(b[v].index===o[p]){c[p]=1;break}}return e!==a&&a.dispose(),t!==r&&r.dispose(),qa(c,r.shape,"bool")}var jM=g9,Vh={};ot(Vh,{conv2d:()=>v9,depthwiseConv2d:()=>k9,matMul:()=>N9});function y9(e,t,n,a,r,s="NHWC",i){let o=e;e.rank===3&&(o=te(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let u=t;u.rank===3&&(u=te(t,[1,t.shape[0],t.shape[1],t.shape[2]])),U(o.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`),U(u.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`),U(n.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);let d=s==="NHWC"?o.shape[3]:o.shape[1],c=s==="NHWC"?u.shape[3]:u.shape[1];U(d===n[2],()=>`Error in conv2dDerFilter: depth of input ${d}) must match input depth in filter (${n[2]}.`),U(c===n[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`),Za("conv2dDerFilter",r,i);let p={x:o,dy:u},m={strides:a,pad:r,dataFormat:s,dimRoundingMode:i,filterShape:n};return q.runKernel(u0,p,m)}var f2=X({conv2DBackpropFilter_:y9});function Z0(e,t,n){if(n==null||n==="linear")return e;if(n==="relu")return Y(e,pd(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function Q0(e,t){let n=t,a=jn(e.shape,t.shape);return a.length>0&&(n=Be(n,a)),te(n,e.shape)}function ex(e,t,n,a){if(t==="linear")return e;if(t==="relu")return jt(e);if(t==="elu")return rf(e);if(t==="relu6")return z0(e);if(t==="prelu")return ly(e,n);if(t==="leakyrelu")return ny(e,a);if(t==="sigmoid")return ys(e);throw new Error(`Unknown fused activation ${t}.`)}var tx=(e,t)=>!(e>0)||t==="linear";function b9({x:e,filter:t,strides:n,pad:a,dataFormat:r="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:o,activation:u="linear",preluActivationWeights:d,leakyreluAlpha:c}){if(u=u||"linear",tx(q.state.gradientDepth,u)===!1){U(r==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${r} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let $=Ka(e,t,n,a,r,s,i);return o!=null&&($=ye($,o)),ex($,u,d,c)}let p=F(e,"x","conv2d","float32"),m=F(t,"filter","conv2d","float32"),g=p,b=!1;p.rank===3&&(b=!0,g=te(p,[1,p.shape[0],p.shape[1],p.shape[2]])),U(g.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${g.rank}.`),U(m.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${m.rank}.`),Za("fused conv2d",a,i);let v=r==="NHWC"?g.shape[3]:g.shape[1];U(m.shape[2]===v,()=>`Error in conv2d: depth of input (${v}) must match input depth for filter ${m.shape[2]}.`),U(mi(n,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`);let x=Zg(g.shape,m.shape,n,s,a,i),w;o!=null&&(w=F(o,"bias","fused conv2d"),[w]=Sn(w,p),r==="NHWC"?Jt(x.outShape,w.shape):(U(w.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${w.shape.length}.`),U(w.shape.length===0||w.shape[0]===x.outChannels||w.shape[0]===1,()=>`Error in fused conv2d: bias shape (${w.shape}) is not compatible with the number of output channels (${x.outChannels})`)));let k;if(d!=null){let $=d.shape;if(U($.length<=1||$.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${$.length}.`),$.length===1)U($[0]===1||$[0]===x.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${$}) is not compatible with the number of output channels (${x.outChannels}).`);else if($.length===3)try{Jt($,x.outShape)}catch{let M=`Error in fused conv2d: PReLU activation weights (${$}) is not compatible with the output shape of the conv2d (${x.outShape}).`;throw Error(M)}k=F(d,"prelu weights","fused conv2d")}let N=($,D)=>{U(r==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${r} but only NHWC is currently supported.`);let[M,B,V,W]=D,R=Z0($,V,u);U(sl(s),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);let H=$_(B.shape,R,M,n,a),Z=f2(B,R,M.shape,n,a),ae=[H,Z];if(W!=null){let j=Q0(W,R);ae.push(j)}return ae},I={x:g,filter:m,bias:w,preluActivationWeights:k},T={strides:n,pad:a,dataFormat:r,dilations:s,dimRoundingMode:i,activation:u,leakyreluAlpha:c};return o==null?pi(($,D,M)=>{let B=q.runKernel(Iu,I,T);return M([D,$,B]),b&&(B=te(B,[B.shape[1],B.shape[2],B.shape[3]])),{value:B,gradFunc:N}})(g,m):pi(($,D,M,B)=>{let V=q.runKernel(Iu,I,T);return B([D,$,V,M]),b&&(V=te(V,[V.shape[1],V.shape[2],V.shape[3]])),{value:V,gradFunc:N}})(g,m,w)}var v9=X({fusedConv2d_:b9});function x9(e,t,n,a,r,s=[1,1],i){let o=e;e.rank===3&&(o=te(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let u=t;u.rank===3&&(u=te(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let d={x:o,dy:u},c={strides:a,pad:r,dimRoundingMode:i,dilations:s,filterShape:n};return q.runKernel(c0,d,c)}var WM=X({depthwiseConv2dNativeBackpropFilter_:x9});function w9(e,t,n,a,r,s=[1,1],i){let o=t,u=!1;t.rank===3&&(u=!0,o=te(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let d={dy:o,filter:n},c={strides:a,pad:r,dimRoundingMode:i,dilations:s,inputShape:e},p=q.runKernel(d0,d,c);return u?te(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var VM=X({depthwiseConv2dNativeBackpropInput_:w9});function S9({x:e,filter:t,strides:n,pad:a,dataFormat:r="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:o,activation:u="linear",preluActivationWeights:d,leakyreluAlpha:c}){if(tx(q.state.gradientDepth,u)===!1){let T=dd(e,t,n,a,r,s,i);return o!=null&&(T=ye(T,o)),ex(T,u,d,c)}let p=F(e,"x","depthwiseConv2d","float32"),m=F(t,"filter","depthwiseConv2d","float32"),g=p,b=!1;p.rank===3&&(b=!0,g=te(p,[1,p.shape[0],p.shape[1],p.shape[2]])),U(g.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${g.rank}.`),U(m.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${m.rank}.`),U(g.shape[3]===m.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${g.shape[3]}) must match the inChannels dimension in filter ${m.shape[2]}.`),s==null&&(s=[1,1]),U(mi(n,s),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`),Za("fused depthwiseConv2d",a,i);let v=Zg(g.shape,m.shape,n,s,a,i,!0),x;o!=null&&(x=F(o,"bias","fused conv2d"),[x]=Sn(x,p),Jt(v.outShape,x.shape));let w;d!=null&&(w=F(d,"prelu weights","fused depthwiseConv2d"));let k=(T,$)=>{U(sl(s),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`);let[D,M,B,V]=$,W=Z0(T,B,u),R=VM(M.shape,W,D,n,a,s,i),H=WM(M,W,D.shape,n,a,s,i);if(V!=null){let Z=Q0(x,W);return[R,H,Z]}return[R,H]},N={x:g,filter:m,bias:x,preluActivationWeights:w},I={strides:n,pad:a,dataFormat:r,dilations:s,dimRoundingMode:i,activation:u,leakyreluAlpha:c};return o==null?pi((T,$,D)=>{let M=q.runKernel(Tu,N,I);return D([$,T,M]),b&&(M=te(M,[M.shape[1],M.shape[2],M.shape[3]])),{value:M,gradFunc:k}})(g,m):pi((T,$,D,M)=>{let B=q.runKernel(Tu,N,I);return M([$,T,B,D]),b&&(B=te(B,[B.shape[1],B.shape[2],B.shape[3]])),{value:B,gradFunc:k}})(g,m,x)}var k9=X({fusedDepthwiseConv2d_:S9});function _9({a:e,b:t,transposeA:n=!1,transposeB:a=!1,bias:r,activation:s="linear",preluActivationWeights:i,leakyreluAlpha:o=.2}){if(tx(q.state.gradientDepth,s)===!1){let V=pt(e,t,n,a);return r!=null&&(V=ye(V,r)),ex(V,s,i,o)}let u=F(e,"a","fused matMul"),d=F(t,"b","fused matMul");[u,d]=Sn(u,d);let c=n?u.shape[u.rank-2]:u.shape[u.rank-1],p=a?d.shape[d.rank-1]:d.shape[d.rank-2],m=n?u.shape[u.rank-1]:u.shape[u.rank-2],g=a?d.shape[d.rank-2]:d.shape[d.rank-1],b=u.shape.slice(0,-2),v=d.shape.slice(0,-2),x=Wt(b),w=Wt(v);U(c===p,()=>`Error in fused matMul: inner shapes (${c}) and (${p}) of Tensors with shapes ${u.shape} and ${d.shape} and transposeA=${n} and transposeB=${a} must match.`);let k=Jt(u.shape.slice(0,-2),d.shape.slice(0,-2)).concat([m,g]),N=n?te(u,[x,c,m]):te(u,[x,m,c]),I=a?te(d,[w,g,p]):te(d,[w,p,g]),T;r!=null&&(T=F(r,"bias","fused matMul"),[T]=Sn(T,u),Jt(k,T.shape));let $;i!=null&&($=F(i,"prelu weights","fused matMul"));let D=(V,W)=>{let[R,H,Z,ae]=W,j=Z0(te(V,Z.shape),Z,s),K,Q;if(!n&&!a?(K=pt(j,H,!1,!0),Q=pt(R,j,!0,!1)):!n&&a?(K=pt(j,H,!1,!1),Q=pt(j,R,!0,!1)):n&&!a?(K=pt(H,j,!1,!0),Q=pt(R,j,!1,!1)):(K=pt(H,j,!0,!0),Q=pt(j,R,!0,!0)),r!=null){let ce=Q0(ae,j);return[K,Q,ce]}else return[K,Q]},M={a:N,b:I,bias:T,preluActivationWeights:$},B={transposeA:n,transposeB:a,activation:s,leakyreluAlpha:o};return r==null?pi((V,W,R)=>{let H=q.runKernel(Nu,M,B);return R([V,W,H]),{value:te(H,k),gradFunc:D}})(N,I):pi((V,W,R,H)=>{let Z=q.runKernel(Nu,M,B);return H([V,W,Z,R]),{value:te(Z,k),gradFunc:D}})(N,I,T)}var N9=X({fusedMatMul_:_9});function I9(e){return J0(e,.54,.46)}var T9=X({hammingWindow_:I9});function E9(e){return J0(e,.5,.5)}var HM=X({hannWindow_:E9});function C9(e,t,n,a=!1,r=0){let s=0,i=[];for(;s+t<=e.size;)i.push(wt(e,s,t)),s+=n;if(a)for(;s<e.size;){let o=s+t-e.size,u=Yt([wt(e,s,t-o),Cr([o],r)]);i.push(u),s+=n}return i.length===0?ui([],[0,t]):te(Yt(i),[i.length,t])}var GM=X({frame_:C9});function A9(e,t,n,a,r=HM){a==null&&(a=p2(t));let s=GM(e,t,n),i=Y(s,r(t));return dy(i,a)}var $9=X({stft_:A9});function R9(e,t,n,a,r="bilinear",s=0){let i=F(e,"image","cropAndResize"),o=F(t,"boxes","cropAndResize","float32"),u=F(n,"boxInd","cropAndResize","int32"),d=o.shape[0];U(i.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),U(o.rank===2&&o.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${d},4] but had shape ${o.shape}.`),U(u.rank===1&&u.shape[0]===d,()=>`Error in cropAndResize: boxInd must be have size [${d}] but had shape ${o.shape}.`),U(a.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${a.length}.`),U(a[0]>=1&&a[1]>=1,()=>`cropSize must be atleast [1,1], but was ${a}`),U(r==="bilinear"||r==="nearest",()=>`method must be bilinear or nearest, but was ${r}`);let c={image:i,boxes:o,boxInd:u},p={method:r,extrapolationValue:s,cropSize:a};return q.runKernel(fp,c,p)}var D9=X({cropAndResize_:R9});function O9(e){let t=F(e,"image","flipLeftRight","float32");U(t.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);let n={image:t};return q.runKernel(vp,n,{})}var M9=X({flipLeftRight_:O9});function F9(e){let t=F(e,"image","grayscaleToRGB"),n=t.rank-1,a=t.shape[n];U(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),U(a===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${a}.`);let r=new Array(t.rank);return r.fill(1,0,n),r[n]=3,Er(t,r)}var z9=X({grayscaleToRGB_:F9});function L9(e){let t=F(e,"image","RGBToGrayscale"),n=t.rank-1,a=t.shape[n];U(t.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`),U(a===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${a}.`);let r=t.dtype,s=Te(t,"float32"),i=Lt([.2989,.587,.114]),o;switch(t.rank){case 2:o=du("ij,j->i",s,i);break;case 3:o=du("ijk,k->ij",s,i);break;case 4:o=du("ijkl,l->ijk",s,i);break;case 5:o=du("ijklm,m->ijkl",s,i);break;case 6:o=du("ijklmn,n->ijklm",s,i);break;default:throw new Error("Not a valid tensor rank.")}return o=da(o,-1),Te(o,r)}var B9=X({rgbToGrayscale_:L9});function P9(e,t,n=0,a=.5){let r=F(e,"image","rotateWithOffset","float32");U(r.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`);let s={image:r},i={radians:t,fillValue:n,center:a};return q.runKernel(nf,s,i)}var U9=X({rotateWithOffset_:P9});function df(e,t,n,a,r,s){a==null&&(a=.5),r==null&&(r=Number.NEGATIVE_INFINITY),s==null&&(s=0);let i=e.shape[0];return n=Math.min(n,i),U(0<=a&&a<=1,()=>`iouThreshold must be in [0, 1], but was '${a}'`),U(e.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`),U(e.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`),U(t.rank===1,()=>"scores must be a 1D tensor"),U(t.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`),U(0<=s&&s<=1,()=>`softNmsSigma must be in [0, 1], but was '${s}'`),{maxOutputSize:n,iouThreshold:a,scoreThreshold:r,softNmsSigma:s}}function j9(e,t,n,a=.5,r=Number.NEGATIVE_INFINITY){let s=F(e,"boxes","nonMaxSuppression","float32"),i=F(t,"scores","nonMaxSuppression","float32"),o=df(s,i,n,a,r);n=o.maxOutputSize,a=o.iouThreshold,r=o.scoreThreshold;let u={maxOutputSize:n,iouThreshold:a,scoreThreshold:r};return q.runKernel(Op,{boxes:s,scores:i},u)}var W9=X({nonMaxSuppression_:j9});function V9(e,t,n){let a=H9(e,t,n),r=a<0?-(a+1):a;e.splice(r,0,t)}function H9(e,t,n){return q9(e,t,n||G9)}function G9(e,t){return e>t?1:e<t?-1:0}function q9(e,t,n){let a=0,r=e.length,s=0,i=!1;for(;a<r;){s=a+(r-a>>>1);let o=n(t,e[s]);o>0?a=s+1:(r=s,i=!o)}return i?a:-a-1}function qM(e,t,n,a,r){return m2(e,t,n,a,r,0)}function KM(e,t,n,a,r,s){return m2(e,t,n,a,r,0,!1,s,!0)}function XM(e,t,n,a,r,s){return m2(e,t,n,a,r,s,!0)}function m2(e,t,n,a,r,s,i=!1,o=!1,u=!1){let d=[];for(let x=0;x<t.length;x++)t[x]>r&&d.push({score:t[x],boxIndex:x,suppressBeginIndex:0});d.sort(T$);let c=s>0?-.5/s:0,p=[],m=[];for(;p.length<n&&d.length>0;){let x=d.pop(),{score:w,boxIndex:k,suppressBeginIndex:N}=x;if(w<r)break;let I=!1;for(let T=p.length-1;T>=N;--T){let $=K9(e,k,p[T]);if($>=a){I=!0;break}if(x.score=x.score*X9(a,c,$),x.score<=r)break}x.suppressBeginIndex=p.length,I||(x.score===w?(p.push(k),m.push(x.score)):x.score>r&&V9(d,x,T$))}let g=p.length,b=n-g;o&&b>0&&(p.push(...new Array(b).fill(0)),m.push(...new Array(b).fill(0)));let v={selectedIndices:p};return i&&(v.selectedScores=m),u&&(v.validOutputs=g),v}function K9(e,t,n){let a=e.subarray(t*4,t*4+4),r=e.subarray(n*4,n*4+4),s=Math.min(a[0],a[2]),i=Math.min(a[1],a[3]),o=Math.max(a[0],a[2]),u=Math.max(a[1],a[3]),d=Math.min(r[0],r[2]),c=Math.min(r[1],r[3]),p=Math.max(r[0],r[2]),m=Math.max(r[1],r[3]),g=(o-s)*(u-i),b=(p-d)*(m-c);if(g<=0||b<=0)return 0;let v=Math.max(s,d),x=Math.max(i,c),w=Math.min(o,p),k=Math.min(u,m),N=Math.max(w-v,0)*Math.max(k-x,0);return N/(g+b-N)}function X9(e,t,n){let a=Math.exp(t*n*n);return n<=e?a:0}function T$(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}async function Y9(e,t,n,a=.5,r=Number.NEGATIVE_INFINITY){let s=F(e,"boxes","nonMaxSuppressionAsync"),i=F(t,"scores","nonMaxSuppressionAsync"),o=df(s,i,n,a,r);n=o.maxOutputSize,a=o.iouThreshold,r=o.scoreThreshold;let u=await Promise.all([s.data(),i.data()]),d=u[0],c=u[1],{selectedIndices:p}=qM(d,c,n,a,r);return s!==e&&s.dispose(),i!==t&&i.dispose(),Lt(p,"int32")}var J9=Y9;function Z9(e,t,n,a=.5,r=Number.NEGATIVE_INFINITY,s=0){let i=F(e,"boxes","nonMaxSuppression"),o=F(t,"scores","nonMaxSuppression"),u=df(i,o,n,a,r,s);n=u.maxOutputSize,a=u.iouThreshold,r=u.scoreThreshold,s=u.softNmsSigma;let d={boxes:i,scores:o},c={maxOutputSize:n,iouThreshold:a,scoreThreshold:r,softNmsSigma:s},p=q.runKernel(Fp,d,c);return{selectedIndices:p[0],selectedScores:p[1]}}var Q9=X({nonMaxSuppressionWithScore_:Z9});async function eX(e,t,n,a=.5,r=Number.NEGATIVE_INFINITY,s=0){let i=F(e,"boxes","nonMaxSuppressionAsync"),o=F(t,"scores","nonMaxSuppressionAsync"),u=df(i,o,n,a,r,s);n=u.maxOutputSize,a=u.iouThreshold,r=u.scoreThreshold,s=u.softNmsSigma;let d=await Promise.all([i.data(),o.data()]),c=d[0],p=d[1],{selectedIndices:m,selectedScores:g}=XM(c,p,n,a,r,s);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:Lt(m,"int32"),selectedScores:Lt(g)}}var tX=eX;function nX(e,t,n,a=.5,r=Number.NEGATIVE_INFINITY,s=!1){let i=F(e,"boxes","nonMaxSuppression"),o=F(t,"scores","nonMaxSuppression"),u=df(i,o,n,a,r,null),d=u.maxOutputSize,c=u.iouThreshold,p=u.scoreThreshold,m={boxes:i,scores:o},g={maxOutputSize:d,iouThreshold:c,scoreThreshold:p,padToMaxOutputSize:s},b=q.runKernel(Mp,m,g);return{selectedIndices:b[0],validOutputs:b[1]}}var aX=X({nonMaxSuppressionPadded_:nX});async function rX(e,t,n,a=.5,r=Number.NEGATIVE_INFINITY,s=!1){let i=F(e,"boxes","nonMaxSuppressionAsync"),o=F(t,"scores","nonMaxSuppressionAsync"),u=df(i,o,n,a,r,null),d=u.maxOutputSize,c=u.iouThreshold,p=u.scoreThreshold,[m,g]=await Promise.all([i.data(),o.data()]),{selectedIndices:b,validOutputs:v}=KM(m,g,d,c,p,s);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:Lt(b,"int32"),validOutputs:He(v,"int32")}}var sX=rX;function iX(e,t,n=!1,a=!1){let r=F(e,"images","resizeBilinear");U(r.rank===3||r.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),U(t.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),U(a===!1||n===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let s=r,i=!1;r.rank===3&&(i=!0,s=te(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let o={images:s},u={alignCorners:n,halfPixelCenters:a,size:t},d=q.runKernel(Gc,o,u);return i?te(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var YM=X({resizeBilinear_:iX});function oX(e,t,n=!1,a=!1){let r=F(e,"images","resizeNearestNeighbor");U(r.rank===3||r.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),U(t.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),U(r.dtype==="float32"||r.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),U(a===!1||n===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let s=r,i=!1;r.rank===3&&(i=!0,s=te(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let o={images:s},u={alignCorners:n,halfPixelCenters:a,size:t},d=q.runKernel(Hc,o,u);return i?te(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var JM=X({resizeNearestNeighbor_:oX});function lX(e,t="binary",n=!1,a=.5){let r=F(e,"image","threshold"),s=.2989,i=.587,o=.114,u=r.shape[0]*r.shape[1],d=Y(Lt([a]),255),c,p,m,g;if(U(r.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`),U(r.shape[2]===3||r.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`),U(r.dtype==="int32"||r.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`),U(t==="otsu"||t==="binary",()=>`Method must be binary or otsu, but was ${t}`),r.shape[2]===3){[c,p,m]=lr(r,[1,1,1],-1);let v=Y(c,s),x=Y(p,i),w=Y(m,o);g=ye(ye(v,x),w)}else g=e;if(t==="otsu"){let v=N_(Te(L0(g),"int32"),qa([]),256);d=uX(v,u)}let b=n?kl(g,d):Qa(g,d);return Te(Y(b,255),"int32")}function uX(e,t){let n=Lt([-1]),a=Lt([0]),r=Lt([0]),s,i,o,u,d,c;for(let p=0;p<e.size-1;p++){s=wt(e,0,p+1),i=wt(e,p+1),d=Le(Be(s),t),c=Le(Be(i),t);let m=Be(Y(s,Fu(0,s.size)));o=Le(m,Be(s));let g=Cr(i.shape,s.size),b=ye(Fu(0,i.size),g),v=Y(i,b);u=Le(Be(v),Be(i));let x=Fe(o,u),w=Fe(o,u),k=Y(d,c);r=Y(Y(k,x),w);let N=Qa(r,a);a=pa(N,r,a),n=pa(N,Lt([p]),n)}return n}var cX=X({threshold_:lX});function dX(e,t,n="nearest",a="constant",r=0,s){let i=F(e,"image","transform","float32"),o=F(t,"transforms","transform","float32");U(i.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),U(o.rank===2&&(o.shape[0]===i.shape[0]||o.shape[0]===1)&&o.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),U(s==null||s.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`);let u={image:i,transforms:o},d={interpolation:n,fillMode:a,fillValue:r,outputShape:s};return q.runKernel(Qp,u,d)}var hX=X({transform_:dX});function pX(e,t,n){let a=F(e,"a","bandPart");U(a.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${a.rank}.`);let r=a.shape,[s,i]=a.shape.slice(-2),o,u;typeof t=="number"?(U(t%1===0,()=>`bandPart(): numLower must be an integer, got ${t}.`),U(t<=s,()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${s}).`),o=F(t<0?s:t,"numLower","bandPart")):(U(t.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),o=pa(Bh(t,0),s,ol(t,s))),typeof n=="number"?(U(n%1===0,()=>`bandPart(): numUpper must be an integer, got ${n}.`),U(n<=i,()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${i}).`),u=F(n<0?i:n,"numUpper","bandPart")):(U(n.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),u=pa(Bh(n,0),i,ol(n,i)));let d=te(Fu(0,s,1,"int32"),[-1,1]),c=Fu(0,i,1,"int32"),p=Fe(d,c),m=bs(kl(p,o),to(p,un(u))),g=xn([s,i],a.dtype);return te(Un(Nn(te(a,[-1,s,i])).map(b=>pa(m,b,g))),r)}var fX=X({bandPart_:pX});function mX(e){let t;if(Array.isArray(e)){t=!1,U(e!=null&&e.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");let r=e[0].shape[0];for(let s=1;s<e.length;++s)U(e[s].shape[0]===r,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[s].shape[0]} vs. ${r})`)}else t=!0,e=lr(e,e.shape[0],0).map(r=>Il(r,[0]));U(e.length<=e[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`);let n=[],a=e;for(let r=0;r<e.length;++r)n.push(q.tidy(()=>{let s=a[r];if(r>0)for(let i=0;i<r;++i){let o=Y(Be(Y(n[i],s)),n[i]);s=Fe(s,o)}return Le(s,sf(s,"euclidean"))}));return t?Un(n,0):n}var gX=X({gramSchmidt_:mX});function yX(e,t=!1){if(U(e.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`),e.rank===2)return E$(e,t);{let n=e.shape.slice(0,e.shape.length-2).reduce((u,d)=>u*d),a=Nn(te(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),r=[],s=[];a.forEach(u=>{let[d,c]=E$(u,t);r.push(d),s.push(c)});let i=te(Un(r,0),e.shape),o=te(Un(s,0),e.shape);return[i,o]}}function E$(e,t=!1){return q.tidy(()=>{U(e.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`);let n=e.shape[0],a=e.shape[1],r=$0(n),s=li(e),i=ui([[1]],[1,1]),o=li(i),u=n>=a?a:n;for(let d=0;d<u;++d){let c=s,p=o,m=r;[o,s,r]=q.tidy(()=>{let g=wt(s,[d,d],[n-d,1]),b=sf(g),v=wt(s,[d,d],[1,1]),x=pa(Qa(v,0),ui([[-1]]),ui([[1]])),w=Fe(v,Y(x,b)),k=Le(g,w);k.shape[0]===1?o=li(i):o=Yt([i,wt(k,[1,0],[k.shape[0]-1,k.shape[1]])],0);let N=un(Le(pt(x,w),b)),I=wt(s,[d,0],[n-d,a]),T=Y(N,o),$=ft(o);if(d===0)s=Fe(I,pt(T,pt($,I)));else{let B=Fe(I,pt(T,pt($,I)));s=Yt([wt(s,[0,0],[d,a]),B],0)}let D=ft(T),M=wt(r,[0,d],[n,r.shape[1]-d]);if(d===0)r=Fe(M,pt(pt(M,o),D));else{let B=Fe(M,pt(pt(M,o),D));r=Yt([wt(r,[0,0],[n,d]),B],1)}return[o,s,r]}),it([c,p,m])}return!t&&n>a&&(r=wt(r,[0,0],[n,a]),s=wt(s,[0,0],[a,a])),[r,s]})}var bX=X({qr_:yX}),Ha;(function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(Ha||(Ha={}));function vX(e,t,n=Ha.SUM_BY_NONZERO_WEIGHTS){let a=F(e,"losses","computeWeightedLoss"),r=null;t!=null&&(r=F(t,"weights","computeWeightedLoss"));let s=r==null?a:Y(a,r);if(n===Ha.NONE)return s;if(n===Ha.SUM)return Be(s);if(n===Ha.MEAN){if(r==null)return vn(s);{let i=a.size/r.size,o=Le(Be(s),Be(r));return i>1?Le(o,He(i)):o}}if(n===Ha.SUM_BY_NONZERO_WEIGHTS){if(r==null)return Le(Be(s),He(a.size));{let i=Y(r,or(a.shape)),o=Te(Be(Mu(i,He(0))),"float32");return Le(Be(s),o)}}throw Error(`Unknown reduction: ${n}`)}var no=X({computeWeightedLoss_:vX});function xX(e,t,n,a=Ha.SUM_BY_NONZERO_WEIGHTS){let r=F(e,"labels","absoluteDifference"),s=F(t,"predictions","absoluteDifference"),i=null;n!=null&&(i=F(n,"weights","absoluteDifference")),Ja(r.shape,s.shape,"Error in absoluteDifference: ");let o=Ln(Fe(r,s));return no(o,i,a)}var wX=X({absoluteDifference_:xX});function SX(e,t,n,a,r=Ha.SUM_BY_NONZERO_WEIGHTS){let s=F(e,"labels","cosineDistance"),i=F(t,"predictions","cosineDistance"),o=null;a!=null&&(o=F(a,"weights","cosineDistance")),Ja(s.shape,i.shape,"Error in cosineDistance: ");let u=He(1),d=Fe(u,Be(Y(s,i),n,!0));return no(d,o,r)}var kX=X({cosineDistance_:SX});function _X(e,t,n,a=Ha.SUM_BY_NONZERO_WEIGHTS){let r=F(e,"labels","hingeLoss"),s=F(t,"predictions","hingeLoss"),i=null;n!=null&&(i=F(n,"weights","hingeLoss")),Ja(r.shape,s.shape,"Error in hingeLoss: ");let o=He(1);r=Fe(Y(He(2),r),o);let u=jt(Fe(o,Y(r,s)));return no(u,i,a)}var NX=X({hingeLoss_:_X});function IX(e,t,n,a=1,r=Ha.SUM_BY_NONZERO_WEIGHTS){let s=F(e,"labels","huberLoss"),i=F(t,"predictions","huberLoss"),o=null;n!=null&&(o=F(n,"weights","huberLoss")),Ja(s.shape,i.shape,"Error in huberLoss: ");let u=He(a),d=Ln(Fe(i,s)),c=ol(d,u),p=Fe(d,c),m=ye(Y(He(.5),Xt(c)),Y(u,p));return no(m,o,r)}var TX=X({huberLoss_:IX});function EX(e,t,n,a=1e-7,r=Ha.SUM_BY_NONZERO_WEIGHTS){let s=F(e,"labels","logLoss"),i=F(t,"predictions","logLoss"),o=null;n!=null&&(o=F(n,"weights","logLoss")),Ja(s.shape,i.shape,"Error in logLoss: ");let u=He(1),d=He(a),c=un(Y(s,$r(ye(i,d)))),p=Y(Fe(u,s),$r(ye(Fe(u,i),d))),m=Fe(c,p);return no(m,o,r)}var CX=X({logLoss_:EX});function AX(e,t,n,a=Ha.SUM_BY_NONZERO_WEIGHTS){let r=F(e,"labels","meanSquaredError"),s=F(t,"predictions","meanSquaredError"),i=null;n!=null&&(i=F(n,"weights","meanSquaredError")),Ja(r.shape,s.shape,"Error in meanSquaredError: ");let o=H0(r,s);return no(o,i,a)}var $X=X({meanSquaredError_:AX});function RX(e,t){let n=F(e,"labels","sigmoidCrossEntropyWithLogits"),a=F(t,"logits","sigmoidCrossEntropyWithLogits");Ja(n.shape,a.shape,"Error in sigmoidCrossEntropyWithLogits: ");let r=jt(a),s=Y(a,n),i=ay(La(un(Ln(a))));return ye(Fe(r,s),i)}function DX(e,t,n,a=0,r=Ha.SUM_BY_NONZERO_WEIGHTS){let s=F(e,"multiClassLabels","sigmoidCrossEntropy"),i=F(t,"logits","sigmoidCrossEntropy"),o=null;if(n!=null&&(o=F(n,"weights","sigmoidCrossEntropy")),Ja(s.shape,i.shape,"Error in sigmoidCrossEntropy: "),a>0){let d=He(a),c=He(1),p=He(.5);s=ye(Y(s,Fe(c,d)),Y(p,d))}let u=RX(s,i);return no(u,o,r)}var OX=X({sigmoidCrossEntropy_:DX});function MX(e,t,n=-1){if(n===-1&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);return pi((a,r,s)=>{let i=ry(r,[n],!0),o=Fe(Te(r,"float32"),i);s([a,o]);let u=un(Y(o,a));return{value:Be(u,[n]),gradFunc:(d,c)=>{let[p,m]=c,g=Ou(d.shape,[n]);return[Y(te(d,g),Fe(Te(p,"float32"),La(m))),Y(te(d,g),Fe(La(m),Te(p,"float32")))]}}})(e,t)}function FX(e,t,n,a=0,r=Ha.SUM_BY_NONZERO_WEIGHTS){let s=F(e,"onehotLabels","softmaxCrossEntropy"),i=F(t,"logits","softmaxCrossEntropy"),o=null;if(n!=null&&(o=F(n,"weights","softmaxCrossEntropy")),Ja(s.shape,i.shape,"Error in softmaxCrossEntropy: "),a>0){let d=He(a),c=He(1),p=He(s.shape[1]);s=ye(Y(s,Fe(c,d)),Le(d,p))}let u=MX(s,i);return no(u,o,r)}var zX=X({softmaxCrossEntropy_:FX});function LX(e,t,n,a){let r=F(e,"indices","sparseFillEmptyRows","int32"),s=F(t,"values","sparseFillEmptyRows"),i=F(n,"denseShape","sparseFillEmptyRows","int32"),o=F(a,"defaultValue","sparseFillEmptyRows",s.dtype);if(r.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${r.shape}`);if(s.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);if(i.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(o.rank!==0)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);let u={indices:r,values:s,denseShape:i,defaultValue:o},d=q.runKernel(zg,u);return{outputIndices:d[0],outputValues:d[1],emptyRowIndicator:d[2],reverseIndexMap:d[3]}}var BX=X({sparseFillEmptyRows_:LX});function PX(e,t,n){let a=F(e,"inputIndices","sparseReshape","int32"),r=F(t,"inputShape","sparseReshape","int32"),s=F(n,"newShape","sparseReshape","int32");if(a.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${a.shape}`);if(r.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${r.shape}`);if(s.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);let i={inputIndices:a,inputShape:r,newShape:s},o=q.runKernel(Xp,i);return{outputIndices:o[0],outputShape:o[1]}}var UX=X({sparseReshape_:PX});function jX(e,t,n){let a=F(e,"data","sparseSegmentMean"),r=F(t,"indices","sparseSegmentMean","int32"),s=F(n,"segmentIds","sparseSegmentMean","int32");if(a.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${r.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${s.shape}`);let i={data:a,indices:r,segmentIds:s};return q.runKernel(Lg,i)}var WX=X({sparseSegmentMean_:jX});function VX(e,t,n){let a=F(e,"data","sparseSegmentSum"),r=F(t,"indices","sparseSegmentSum","int32"),s=F(n,"segmentIds","sparseSegmentSum","int32");if(a.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${r.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${s.shape}`);let i={data:a,indices:r,segmentIds:s};return q.runKernel(Bg,i)}var HX=X({sparseSegmentSum_:VX});function GX(e,t,n,a,r,s,i,o){let u=F(e,"data","stringNGrams","string");if(u.dtype!=="string")throw new Error("Data must be of datatype string");if(u.shape.length!==1)throw new Error(`Data must be a vector, saw: ${u.shape}`);let d=F(t,"dataSplits","stringNGrams");if(d.dtype!=="int32")throw new Error("Data splits must be of datatype int32");let c={separator:n,nGramWidths:a,leftPad:r,rightPad:s,padWidth:i,preserveShortSequences:o},p={data:u,dataSplits:d},m=q.runKernel(jg,p,c);return{nGrams:m[0],nGramsSplits:m[1]}}var qX=X({stringNGrams_:GX});function KX(e,t,n=!0){let a=F(e,"input","stringSplit","string"),r=F(t,"delimiter","stringSplit","string");if(a.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${a.shape}`);if(r.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${r.shape}`);let s={skipEmpty:n},i={input:a,delimiter:r},o=q.runKernel(Wg,i,s);return{indices:o[0],values:o[1],shape:o[2]}}var XX=X({stringSplit_:KX});function YX(e,t){let n=F(e,"input","stringToHashBucketFast","string"),a={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");let r={input:n};return q.runKernel(Vg,r,a)}var JX=X({stringToHashBucketFast_:YX});function ZX(e,t,n,a=!0){let r=F(e,"input","staticRegexReplace","string"),s={pattern:t,rewrite:n,replaceGlobal:a};return q.runKernel(Ug,{x:r},s)}var QX=X({staticRegexReplace_:ZX}),ZM={fft:cy,ifft:Wh,rfft:dy,irfft:V0},QM={hammingWindow:T9,hannWindow:HM,frame:GM,stft:$9},Gr={flipLeftRight:M9,grayscaleToRGB:z9,resizeNearestNeighbor:JM,resizeBilinear:YM,rgbToGrayscale:B9,rotateWithOffset:U9,cropAndResize:D9,nonMaxSuppression:W9,nonMaxSuppressionAsync:J9,nonMaxSuppressionWithScore:Q9,nonMaxSuppressionWithScoreAsync:tX,nonMaxSuppressionPadded:aX,nonMaxSuppressionPaddedAsync:sX,threshold:cX,transform:hX},g2={bandPart:fX,gramSchmidt:gX,qr:bX},eF={absoluteDifference:wX,computeWeightedLoss:no,cosineDistance:kX,hingeLoss:NX,huberLoss:TX,logLoss:CX,meanSquaredError:$X,sigmoidCrossEntropy:OX,softmaxCrossEntropy:zX},tF={sparseFillEmptyRows:BX,sparseReshape:UX,sparseSegmentMean:WX,sparseSegmentSum:HX},nF={stringNGrams:qX,stringSplit:XX,stringToHashBucketFast:JX,staticRegexReplace:QX},_e={};ot(_e,{Serializable:()=>aF,SerializationMap:()=>rF,getRegisteredName:()=>tY,registerClass:()=>sF});var eY=new Map,WS=new Map,aF=class{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}},rF=class Sh{constructor(){this.classNameMap={}}static getMap(){return Sh.instance==null&&(Sh.instance=new Sh),Sh.instance}static register(t){Sh.getMap().classNameMap[t.className]=[t,t.fromConfig]}};function sF(e,t,n){U(e.className!=null,()=>"Class being registered does not have the static className property defined."),U(typeof e.className=="string",()=>"className is required to be a string, but got type "+typeof e.className),U(e.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof t>"u"&&(t="Custom"),typeof n>"u"&&(n=e.className);let a=n,r=t+">"+a;return rF.register(e),eY.set(r,e),WS.set(e,r),e}function tY(e){return WS.has(e)?WS.get(e):e.className}var ao=class extends aF{minimize(e,t=!1,n){let{value:a,grads:r}=this.computeGradients(e,n);if(n!=null){let s=n.map(i=>({name:i.name,tensor:r[i.name]}));this.applyGradients(s)}else this.applyGradients(r);return it(r),t?a:(a.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return sM(e,t)}dispose(){this.iterations_!=null&&it(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:He(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}};Object.defineProperty(ao,Symbol.hasInstance,{value:e=>e.minimize!=null&&e.computeGradients!=null&&e.applyGradients!=null});var y2=class extends ao{static get className(){return"Adadelta"}constructor(e,t,n=null){super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],n==null&&(this.epsilon=q.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let a=q.registeredVariables[t],r=!1;this.accumulatedGrads[n]==null&&(this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:ne(()=>_t(a).variable(r))}),this.accumulatedUpdates[n]==null&&(this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:ne(()=>_t(a).variable(r))});let s=Array.isArray(e)?e[n].tensor:e[t];if(s==null)return;let i=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;ne(()=>{let u=ye(Y(i,this.rho),Y(Xt(s),1-this.rho)),d=Y(Le(fa(ye(o,this.epsilon)),fa(ye(i,this.epsilon))),s),c=ye(Y(o,this.rho),Y(Xt(d),1-this.rho));i.assign(u),o.assign(c);let p=ye(Y(d,-this.learningRate),a);a.assign(p)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(it(this.accumulatedGrads.map(e=>e.variable)),it(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){let e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=e.length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map(a=>({originalName:a.name,variable:a.tensor.variable(n)})),this.accumulatedUpdates=e.slice(t,t*2).map(a=>({originalName:a.name,variable:a.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}},b2=class extends ao{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let a=q.registeredVariables[t];this.accumulatedGrads[n]==null&&(this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:ne(()=>Cr(a.shape,this.initialAccumulatorValue).variable(!1))});let r=Array.isArray(e)?e[n].tensor:e[t];if(r==null)return;let s=this.accumulatedGrads[n].variable;ne(()=>{let i=ye(s,Xt(r));s.assign(i);let o=ye(Y(Le(r,fa(ye(i,q.backend.epsilon()))),-this.learningRate),a);a.assign(o)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&it(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=!1;this.accumulatedGrads=e.map(n=>({originalName:n.name,variable:n.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}},v2=class extends ao{static get className(){return"Adam"}constructor(e,t,n,a=null){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=a,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],ne(()=>{this.accBeta1=He(t).variable(),this.accBeta2=He(n).variable()}),a==null&&(this.epsilon=q.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(n=>n.name):Object.keys(e);ne(()=>{let n=Fe(1,this.accBeta1),a=Fe(1,this.accBeta2);t.forEach((r,s)=>{let i=q.registeredVariables[r],o=!1;this.accumulatedFirstMoment[s]==null&&(this.accumulatedFirstMoment[s]={originalName:`${r}/m`,variable:ne(()=>_t(i).variable(o))}),this.accumulatedSecondMoment[s]==null&&(this.accumulatedSecondMoment[s]={originalName:`${r}/v`,variable:ne(()=>_t(i).variable(o))});let u=Array.isArray(e)?e[s].tensor:e[r];if(u==null)return;let d=this.accumulatedFirstMoment[s].variable,c=this.accumulatedSecondMoment[s].variable,p=ye(Y(d,this.beta1),Y(u,1-this.beta1)),m=ye(Y(c,this.beta2),Y(Xt(u),1-this.beta2)),g=Le(p,n),b=Le(m,a);d.assign(p),c.assign(m);let v=ye(Y(Le(g,ye(fa(b),this.epsilon)),-this.learningRate),i);i.assign(v)}),this.accBeta1.assign(Y(this.accBeta1,this.beta1)),this.accBeta2.assign(Y(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&it(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&it(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),ne(()=>{this.accBeta1.assign(hi(this.beta1,this.iterations_+1)),this.accBeta2.assign(hi(this.beta2,this.iterations_+1))});let t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map(a=>({originalName:a.name,variable:a.tensor.variable(n)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(a=>({originalName:a.name,variable:a.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}},x2=class extends ao{static get className(){return"Adamax"}constructor(e,t,n,a=null,r=0){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=a,this.decay=r,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],ne(()=>{this.iteration=He(0).variable(),this.accBeta1=He(t).variable()}),a==null&&(this.epsilon=q.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(n=>n.name):Object.keys(e);ne(()=>{let n=Fe(1,this.accBeta1),a=Le(-this.learningRate,ye(Y(this.iteration,this.decay),1));t.forEach((r,s)=>{let i=q.registeredVariables[r],o=!1;this.accumulatedFirstMoment[s]==null&&(this.accumulatedFirstMoment[s]={originalName:`${r}/m`,variable:_t(i).variable(o)}),this.accumulatedWeightedInfNorm[s]==null&&(this.accumulatedWeightedInfNorm[s]={originalName:`${r}/v`,variable:_t(i).variable(o)});let u=Array.isArray(e)?e[s].tensor:e[r];if(u==null)return;let d=this.accumulatedFirstMoment[s].variable,c=this.accumulatedWeightedInfNorm[s].variable,p=ye(Y(d,this.beta1),Y(u,1-this.beta1)),m=Y(c,this.beta2),g=Ln(u),b=gi(m,g);d.assign(p),c.assign(b);let v=ye(Y(Le(a,n),Le(p,ye(b,this.epsilon))),i);i.assign(v)}),this.iteration.assign(ye(this.iteration,1)),this.accBeta1.assign(Y(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&it(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&it(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}},nx=class extends ao{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let a=Array.isArray(e)?e[n].tensor:e[t];if(a==null)return;let r=q.registeredVariables[t];ne(()=>{let s=ye(Y(this.c,a),r);r.assign(s)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=Zn(He(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}},w2=class extends nx{static get className(){return"Momentum"}constructor(e,t,n=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=He(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let a=q.registeredVariables[t];this.accumulations[n]==null&&(this.accumulations[n]={originalName:`${t}/momentum`,variable:ne(()=>_t(a).variable(!1))});let r=this.accumulations[n].variable,s=Array.isArray(e)?e[n].tensor:e[t];s!=null&&ne(()=>{let i,o=ye(Y(this.m,r),s);this.useNesterov?i=ye(Y(this.c,ye(s,Y(o,this.m))),a):i=ye(Y(this.c,o),a),r.assign(o),a.assign(i)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&it(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=!1;this.accumulations=e.map(n=>({originalName:n.name,variable:n.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}},S2=class extends ao{static get className(){return"RMSProp"}constructor(e,t=.9,n=0,a=null,r=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=a,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=r,a==null&&(this.epsilon=q.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let a=q.registeredVariables[t],r=!1;this.accumulatedMeanSquares[n]==null&&(this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:ne(()=>_t(a).variable(r))}),this.accumulatedMoments[n]==null&&(this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:ne(()=>_t(a).variable(r))}),this.accumulatedMeanGrads[n]==null&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:ne(()=>_t(a).variable(r))});let s=Array.isArray(e)?e[n].tensor:e[t];if(s==null)return;let i=this.accumulatedMeanSquares[n].variable,o=this.accumulatedMoments[n].variable;ne(()=>{let u=ye(Y(i,this.decay),Y(Xt(s),1-this.decay));if(this.centered){let d=this.accumulatedMeanGrads[n].variable,c=ye(Y(d,this.decay),Y(s,1-this.decay)),p=Le(Y(s,this.learningRate),fa(Fe(u,ye(Xt(c),this.epsilon)))),m=ye(Y(o,this.momentum),p);i.assign(u),d.assign(c),o.assign(m);let g=Fe(a,m);a.assign(g)}else{let d=ye(Y(i,this.decay),Y(Xt(s),1-this.decay)),c=ye(Y(o,this.momentum),Le(Y(s,this.learningRate),fa(ye(d,this.epsilon))));i.assign(d),o.assign(c);let p=Fe(a,c);a.assign(p)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&it(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&it(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&it(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map(a=>({originalName:a.name,variable:a.tensor.variable(n)})),this.accumulatedMoments=e.slice(t,t*2).map(a=>({originalName:a.name,variable:a.tensor.variable(n)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(a=>({originalName:a.name,variable:a.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}},nY=[y2,b2,v2,x2,w2,S2,nx];function aY(){for(let e of nY)sF(e)}var Na={};ot(Na,{CompositeArrayBuffer:()=>Qi,browserFiles:()=>cY,browserHTTPRequest:()=>gY,concatenateArrayBuffers:()=>V5,copyModel:()=>hq,decodeWeights:()=>$O,decodeWeightsStream:()=>DO,encodeWeights:()=>L5,fromMemory:()=>bY,fromMemorySync:()=>cF,getLoadHandlers:()=>Z5,getModelArtifactsForJSON:()=>c_,getModelArtifactsForJSONSync:()=>MO,getModelArtifactsInfoForJSON:()=>Jg,getSaveHandlers:()=>J5,getWeightSpecs:()=>zS,http:()=>_2,isHTTPScheme:()=>HS,listModels:()=>cq,loadWeights:()=>hY,moveModel:()=>pq,registerLoadRouter:()=>Y5,registerSaveRouter:()=>X5,removeModel:()=>dq,weightsLoaderFactory:()=>oF,withSaveHandler:()=>vY,withSaveHandlerSync:()=>xY});var rY="model",sY=".json",iY=".weights.bin";function C$(e){return new Promise(t=>setTimeout(t)).then(e)}var Cv=class VS{constructor(t){if(!oe().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(VS.URL_SCHEME)&&(t=t.slice(VS.URL_SCHEME.length)),(t==null||t.length===0)&&(t=rY),this.modelJsonFileName=t+sY,this.weightDataFileName=t+iY}async save(t){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");let n=Qi.join(t.weightData),a=window.URL.createObjectURL(new Blob([n],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let r=[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}],s=OO(t,r),i=window.URL.createObjectURL(new Blob([JSON.stringify(s)],{type:"application/json"})),o=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(o.download=this.modelJsonFileName,o.href=i,await C$(()=>o.dispatchEvent(new MouseEvent("click"))),t.weightData!=null){let u=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;u.download=this.weightDataFileName,u.href=a,await C$(()=>u.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Jg(t)}}}};Cv.URL_SCHEME="downloads://";var oY=class{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{let n=new FileReader;n.onload=a=>{let r=JSON.parse(a.target.result),s=r.modelTopology;if(s==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(r.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:s});return}let i=c_(r,o=>this.loadWeights(o));e(i)},n.onerror=a=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)})}loadWeights(e){let t=[],n=[];for(let s of e)t.push(...s.weights),n.push(...s.paths);let a=this.checkManifestAndWeightFiles(e),r=n.map(s=>this.loadWeightsFile(s,a[s]));return Promise.all(r).then(s=>[t,s])}loadWeightsFile(e,t){return new Promise((n,a)=>{let r=new FileReader;r.onload=s=>{let i=s.target.result;n(i)},r.onerror=s=>a(`Failed to weights data from file of path '${e}'.`),r.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){let t=[],n=this.weightsFiles.map(r=>I$(r.name)),a={};for(let r of e)r.paths.forEach(s=>{let i=I$(s);if(t.indexOf(i)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${i}'`);if(t.push(i),n.indexOf(i)===-1)throw new Error(`Weight file with basename '${i}' is not provided.`);a[s]=this.weightsFiles[n.indexOf(i)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return a}},lY=e=>oe().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Cv.URL_SCHEME)?uY(e.slice(Cv.URL_SCHEME.length)):null;Zr.registerSaveRouter(lY);function uY(e="model"){return new Cv(e)}function cY(e){return new oY(e)}function A$(e,t,n,a){i(e),n=n??0,a=a??1,o(n,a);let r=0,s=u=>(u.then(d=>{let c=n+ ++r/e.length*(a-n);return t(c),d}),u);function i(u){U(u!=null&&Array.isArray(u)&&u.length>0,()=>"promises must be a none empty array")}function o(u,d){U(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${u}`),U(d>=0&&d<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${d}`),U(d>=u,()=>`startFraction must be no more than endFraction, but got startFraction ${u} and endFraction ${d}`)}return Promise.all(e.map(s))}async function iF(e,t){t==null&&(t={});let n=t.fetchFunc==null?oe().platform.fetch:t.fetchFunc,a=e.map(s=>n(s,t.requestInit,{isBinary:!0})),r=(t.onProgress==null?await Promise.all(a):await A$(a,t.onProgress,0,.5)).map(s=>s.arrayBuffer());return t.onProgress==null?await Promise.all(r):await A$(r,t.onProgress,.5,1)}function dY(e,t){var n;let a=t.fetchFunc==null?oe().platform.fetch:t.fetchFunc,r=0,s;return(n=t.onProgress)===null||n===void 0||n.call(t,0),new ReadableStream({pull:async i=>{for(var o;r<e.length;){s||(s=(await a(e[r],t.requestInit,{isBinary:!0})).body.getReader());let{done:u,value:d}=await s.read();if(u){r++,s=void 0,(o=t.onProgress)===null||o===void 0||o.call(t,r/e.length);continue}i.enqueue(d);return}i.close()}})}async function hY(e,t="",n,a){return oF(r=>iF(r,{requestInit:a}))(e,t,n)}function oF(e){return async(t,n="",a)=>{let r=t.map(()=>!1),s={},i=a!=null?a.map(()=>!1):[],o=[];if(t.forEach((g,b)=>{let v=0;g.weights.forEach(x=>{let w="quantization"in x?x.quantization.dtype:x.dtype,k=Cu[w]*Wt(x.shape),N=()=>{r[b]=!0,s[b]==null&&(s[b]=[]),s[b].push({manifestEntry:x,groupOffset:v,sizeBytes:k})};a!=null?a.forEach((I,T)=>{I===x.name&&(N(),i[T]=!0)}):N(),o.push(x.name),v+=k})}),!i.every(g=>g)){let g=a.filter((b,v)=>!i[v]);throw new Error(`Could not find weights in manifest with names: ${g.join(", ")}. 
Manifest JSON has weights with names: ${o.join(", ")}.`)}let u=r.reduce((g,b,v)=>(b&&g.push(v),g),[]),d=[];u.forEach(g=>{t[g].paths.forEach(b=>{let v=n+(n.endsWith("/")?"":"/")+b;d.push(v)})});let c=await e(d),p={},m=0;return u.forEach(g=>{let b=t[g].paths.length,v=new Qi(c.slice(m,m+b));s[g].forEach(x=>{let w=v.slice(x.groupOffset,x.groupOffset+x.sizeBytes),k=$O(w,[x.manifestEntry]);for(let N in k)p[N]=k[N]}),m+=b}),p}}var pY="application/octet-stream",fY="application/json",k2=class{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(U(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=oe().platform.fetch,U(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&U(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;let n=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],a=OO(e,n);if(t.body.append("model.json",new Blob([JSON.stringify(a)],{type:fY}),"model.json"),e.weightData!=null){let s=Qi.join(e.weightData);t.body.append("model.weights.bin",new Blob([s],{type:pY}),"model.weights.bin")}let r=await this.fetch(this.path,t);if(r.ok)return{modelArtifactsInfo:Jg(e),responses:[r]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${r.status}.`)}async loadModelJSON(){let e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let s=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?s+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":s+=" Please make sure the server is serving valid JSON for this request.",new Error(s)}let n=t.modelTopology,a=t.weightsManifest;if(n==null&&a==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return t}async load(){if(this.loadOptions.streamWeights)return this.loadStream();let e=await this.loadModelJSON();return c_(e,t=>this.loadWeights(t))}async loadStream(){let e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),n=zS(e.weightsManifest),a=()=>dY(t,this.loadOptions);return Object.assign(Object.assign({},e),{weightSpecs:n,getWeightStream:a})}async getWeightUrls(e){let t=Array.isArray(this.path)?this.path[1]:this.path,[n,a]=mY(t),r=this.weightPathPrefix||n,s=[],i=[];for(let o of e)for(let u of o.paths)this.weightUrlConverter!=null?i.push(this.weightUrlConverter(u)):s.push(r+u+a);return this.weightUrlConverter&&s.push(...await Promise.all(i)),s}async loadWeights(e){let t=await this.getWeightUrls(e),n=zS(e),a=await iF(t,this.loadOptions);return[n,a]}};k2.URL_SCHEME_REGEX=/^https?:\/\//;function mY(e){let t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),a=e.substring(0,t),r=n>t?e.substring(n):"";return[a+"/",r]}function HS(e){return e.match(k2.URL_SCHEME_REGEX)!=null}var lF=(e,t)=>{if(typeof fetch>"u"&&(t==null||t.fetchFunc==null))return null;{let n=!0;if(Array.isArray(e)?n=e.every(a=>HS(a)):n=HS(e),n)return _2(e,t)}return null};Zr.registerSaveRouter(lF);Zr.registerLoadRouter(lF);function _2(e,t){return new k2(e,t)}function gY(e,t){return _2(e,t)}var Z1=class{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}},uF=class{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}},yY=class{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}};function bY(e,t,n,a){let r=arguments;return new yY(cF(...r))}function cF(e,t,n,a){return arguments.length===1?e.modelTopology!=null||e.weightSpecs!=null?new Z1(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Z1({modelTopology:e})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Z1({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:a}))}function vY(e){return new uF(e)}function xY(e){return new uF(e)}var dF={};ot(dF,{confusionMatrix:()=>SY});function wY(e,t,n){let a=F(e,"labels","confusionMatrix"),r=F(t,"predictions","confusionMatrix");U(n==null||n>0&&Number.isInteger(n),()=>`If provided, numClasses must be a positive integer, but got ${n}`),U(a.rank===1,()=>`Expected the rank of labels to be 1, but got ${a.rank}`),U(r.rank===1,()=>`Expected the rank of predictions to be 1, but got ${r.rank}`),U(a.shape[0]===r.shape[0],()=>`Mismatch in the number of examples: ${a.shape[0]} vs. ${r.shape[0]}. Labels and predictions should have the same number of elements.`),U(n>0&&Number.isInteger(n),()=>`numClasses is required to be a positive integer, but got ${n}`);let s=Ph(Te(a,"int32"),n),i=Ph(Te(r,"int32"),n),o=ft(s),u=pt(o,i);return Te(u,"int32")}var SY=X({confusionMatrix_:wY}),hy={};ot(hy,{draw:()=>AY,fromPixels:()=>$Y,fromPixelsAsync:()=>TY,toPixels:()=>CY});var nu,$$=!1;function hF(e,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(e==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,a=!1,r=!1,s=!1,i=!1,o=!1;if(e.data instanceof Uint8Array)n=!0;else if(typeof ImageData<"u"&&e instanceof ImageData)a=!0;else if(typeof HTMLVideoElement<"u"&&e instanceof HTMLVideoElement)r=!0;else if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement)s=!0;else if(e.getContext!=null)i=!0;else if(typeof ImageBitmap<"u"&&e instanceof ImageBitmap)o=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);if(Jm(Nv,q.backendName)!=null){let m={pixels:e},g={numChannels:t};return q.runKernel(Nv,m,g)}let[u,d]=r?[e.videoWidth,e.videoHeight]:[e.width,e.height],c;if(i)c=e.getContext("2d").getImageData(0,0,u,d).data;else if(a||n)c=e.data;else if(s||r||o){if(nu==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")nu=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else nu=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});nu.canvas.width=u,nu.canvas.height=d,nu.drawImage(e,0,0,u,d),c=nu.getImageData(0,0,u,d).data}let p;if(t===4)p=new Int32Array(c);else{let m=u*d;p=new Int32Array(m*t);for(let g=0;g<m;g++)for(let b=0;b<t;++b)p[g*t+b]=c[g*4+b]}return G0(p,[d,u,t],"int32")}function kY(e){return e!=null&&e.data instanceof Uint8Array}function _Y(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}function NY(e){return e!=null&&e.width!==0&&e.height!==0}function IY(e){return _Y()&&!(e instanceof ImageBitmap)&&NY(e)&&!kY(e)}async function TY(e,t=3){let n=null;if(oe().getBool("WRAP_TO_IMAGEBITMAP")&&IY(e)){let a;try{a=await createImageBitmap(e,{premultiplyAlpha:"none"})}catch{a=null}a!=null&&a.width===e.width&&a.height===e.height?n=a:n=e}else n=e;return hF(n,t)}function pF(e){if(e.rank!==2&&e.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${e.rank}.`);let t=e.rank===2?1:e.shape[2];if(t>4||t===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${t}`);if(e.dtype!=="float32"&&e.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${e.dtype}. Please use float32 or int32 tensors.`)}function EY(e){let t=e?.alpha||1;if(t>1||t<0)throw new Error(`Alpha value ${t} is suppoed to be in range [0 - 1].`)}async function CY(e,t){let n=F(e,"img","toPixels");if(!(e instanceof dt)){let d=n;n=Te(d,"int32"),d.dispose()}pF(n);let[a,r]=n.shape.slice(0,2),s=n.rank===2?1:n.shape[2],i=await n.data(),o=n.dtype==="float32"?255:1,u=new Uint8ClampedArray(r*a*4);for(let d=0;d<a*r;++d){let c=[0,0,0,255];for(let m=0;m<s;m++){let g=i[d*s+m];if(n.dtype==="float32"){if(g<0||g>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${g}.`)}else if(n.dtype==="int32"&&(g<0||g>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${g}.`);s===1?(c[0]=g*o,c[1]=g*o,c[2]=g*o):c[m]=g*o}let p=d*4;u[p+0]=Math.round(c[0]),u[p+1]=Math.round(c[1]),u[p+2]=Math.round(c[2]),u[p+3]=Math.round(c[3])}if(t!=null){$$||Jm(h0,q.backendName)!=null&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),$$=!0),t.width=r,t.height=a;let d=t.getContext("2d"),c=new ImageData(u,r,a);d.putImageData(c,0,0)}return n!==e&&n.dispose(),u}function AY(e,t,n){let a=F(e,"img","draw");if(!(e instanceof dt)){let i=a;a=Te(i,"int32"),i.dispose()}pF(a),EY(n?.imageOptions);let r={image:a},s={canvas:t,options:n};q.runKernel(h0,r,s)}var $Y=X({fromPixels_:hF}),N2={};ot(N2,{prepareAndValidate:()=>fF});function fF(e,t){let n=e.shape.length,a=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(a<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${a}.`);if(t.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[a-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[a-1]} vs. ${n}`);if(Wt(e.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);let r=t.shape,s=r[r.length-1],i=1;for(let p=0;p<r.length-1;++p)i*=r[p];let o=e.shape,u=r.slice();u.pop();let d=1;for(let p=s;p<n;++p)d*=o[p],u.push(o[p]);let c=[...ep(e.shape).map(p=>p/d),1].slice(0,s);return[u,i,d,c]}var ea={};ot(ea,{assertParamsValid:()=>DY,computeFlatOffset:()=>LY,computeOutShape:()=>MY,getNormalizedAxes:()=>FY,isSliceContinous:()=>zY,maskToAxes:()=>OY,parseSliceParams:()=>kF,sliceInfo:()=>BY,startForAxis:()=>wF,startIndicesWithElidedDims:()=>bF,stopForAxis:()=>SF,stopIndicesWithElidedDims:()=>vF,stridesForAxis:()=>xF,stridesWithElidedDims:()=>mF});var GS=-2,RY=-1;function DY(e,t,n){let a=e.shape.length;U(a===t.length,()=>`Error in slice${a}D: Length of begin ${t} must match the rank of the array (${a}).`),U(a===n.length,()=>`Error in slice${a}D: Length of size ${n} must match the rank of the array (${a}).`);for(let r=0;r<a;++r)U(t[r]+n[r]<=e.shape[r],()=>`Error in slice${a}D: begin[${r}] + size[${r}] (${t[r]+n[r]}) would overflow input.shape[${r}] (${e.shape[r]})`)}function OY(e){let t=[],n=0;for(;e>0;)e&1&&t.push(n),e/=2,n++;return t}function MY(e,t,n){let a=[];for(let r=0;r<e.length;r++)a[r]=Math.ceil((t[r]-e[r])/n[r]);return a}function mF(e,t,n,a){let r=[...e];for(let s=r.length;s<a.length;s++)r.push(1);for(let s=0;s<n;s++)s===0?r[t]=1:(r.splice(t,0,1),r.pop());return r}function gF(e,t,n){return n<=e?n:n-(t-1)}function yF(e,t){let n=[];for(let a=0;a<e;a++)n.push(t+a);return n}function FY(e,t,n,a,r,s,i,o,u){let d=e.length,c=new Array(d),p=new Array(d),m=new Array(d);if(t.length&&n>0){let g=t[0],b=n+1;c=bF(i,g,b,a,e),p=vF(o,g,b,r,e),m=mF(s,g,b,e)}else for(let g=0;g<d;g++)c[g]=wF(i,a,s,e,g,u),p[g]=SF(o,r,s,e,g,u),m[g]=xF(s,g,u);return{begin:c,end:p,strides:m}}function bF(e,t,n,a,r){let s=[...r],i=yF(n,t);for(let o=0;o<s.length;o++)if(i.indexOf(o)>-1)s[o]=0;else{let u=gF(t,n,o),d=a[u];e&1<<u&&(d=0),s[o]=d}return s}function vF(e,t,n,a,r){let s=[...r],i=yF(n,t);for(let o=0;o<s.length;o++)if(i.indexOf(o)>-1)s[o]=Number.MAX_SAFE_INTEGER;else{let u=gF(t,n,o),d=a[u];e&1<<u&&(d=Number.MAX_SAFE_INTEGER),s[o]=d}for(let o=0;o<s.length;o++){let u=r[o];s[o]<0&&(s[o]+=u),s[o]=Xm(0,s[o],r[o])}return s}function xF(e,t,n){let a=e[t];return(n&1<<t||a==null)&&(a=1),a}function wF(e,t,n,a,r,s){let i=t[r],o=n[r]||1;(e&1<<r||s&1<<r||i==null)&&(o>0?i=Number.MIN_SAFE_INTEGER:i=Number.MAX_SAFE_INTEGER);let u=a[r];return i<0&&(i+=u),i=Xm(0,i,u-1),i}function SF(e,t,n,a,r,s){let i=t[r],o=n[r]||1;(e&1<<r||s&1<<r||i==null)&&(o>0?i=Number.MAX_SAFE_INTEGER:i=Number.MIN_SAFE_INTEGER);let u=a[r];return i<0&&(i+=u),o>0?i=Xm(0,i,u):i=Xm(-1,i,u-1),i}function zY(e,t,n){let a=n.length;for(let r=0;r<n.length;r++)if(n[r]>1){a=r;break}for(let r=a+1;r<n.length;r++)if(t[r]>0||n[r]!==e[r])return!1;return!0}function LY(e,t){let n=e.length>0?e[e.length-1]:1;for(let a=0;a<e.length-1;a++)n+=e[a]*t[a];return n}function kF(e,t,n){let a,r=e.shape.length;typeof t=="number"?a=[t,...new Array(r-1).fill(0)]:t.length<r?a=t.concat(new Array(r-t.length).fill(0)):a=t.slice(),a.forEach(i=>{U(i!==-1,()=>"slice() does not support negative begin indexing.")});let s;return n==null?s=new Array(r).fill(-1):typeof n=="number"?s=[n,...new Array(r-1).fill(-1)]:n.length<r?s=n.concat(new Array(r-n.length).fill(-1)):s=n,s=s.map((i,o)=>i>=0?i:(U(i===-1,()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${o}.`),e.shape[o]-a[o])),[a,s]}function BY(e,t,n,a,r,s,i,o,u){let d;if(a==null?(d=new Array(t.length),d.fill(1)):d=a,i!=null&&i&i-1)throw new Error("Multiple ellipses in slice is not allowed.");let c=!1,p={dims:d.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:d.slice(),beginMask:r,endMask:s,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:u};for(let k=0;k<p.dims;k++)c&&1<<k&o&&p.numAddAxisAfterEllipsis++,1<<k&i&&(c=!0);c||(p.ellipsisMask|=1<<p.dims,p.dims++);let m={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};PY(p,m);let g=!0,b=!0,v=!0,x=[],w=[];for(let k=0;k<e.length;++k){if(m.strides[k]===0)throw Error(`strides[${k}] must be non-zero`);let N=!!(m.shrinkAxisMask&1<<k),I=e[k];if(I===-1){x.push(N?1:-1);continue}let T=[m.beginMask&1<<k,m.endMask&1<<k],$=[m.strides[k]>0?0:-1,m.strides[k]>0?I:I-1];if(N&&m.strides[k]<=0)throw Error("only stride 1 allowed on non-range indexing.");v=v&&m.strides[k]===1;let D=!!(m.beginMask&1<<k&&m.endMask&1<<k);if(m.beginValid&&m.endValid){if(N){let W=m.begin[k]<0?I+m.begin[k]:m.begin[k];if(m.begin[k]=W,m.end[k]=m.begin[k]+1,W<0||W>=I)throw Error(`slice index ${m.begin[k]} of dimension ${k} out of bounds.`)}else m.begin[k]=R$(m.begin[k],0,m.strides[k],I,T,$),m.end[k]=R$(m.end[k],1,m.strides[k],I,T,$);let V=m.strides[k]===1&&m.begin[k]===0&&m.end[k]===I;g=g&&V,b=b&&(k===0&&m.strides[k]===1||V)}else g=g&&m.strides[k]===1&&D,b=b&&(k===0&&m.strides[k]===1||D);let M,B=!1;if(m.beginValid&&m.endValid?(M=m.end[k]-m.begin[k],B=!0):N?(M=1,B=!0):D&&I>=0&&(m.strides[k]<0?M=-I:M=I,B=!0),B){let V;M===0||M<0!=m.strides[k]<0?V=0:V=Math.trunc(M/m.strides[k])+(M%m.strides[k]!==0?1:0),x.push(V)}else x.push(-1)}for(let k=0;k<m.finalShapeGatherIndices.length;++k){let N=m.finalShapeGatherIndices[k];N>=0?w.push(x[N]):N===GS&&w.push(1)}return{finalShapeSparse:w.filter((k,N)=>m.finalShapeGatherIndices[N]!==GS),finalShape:w,isIdentity:g,sliceDim0:b,isSimpleSlice:v,begin:m.begin,end:m.end,strides:m.strides}}function PY(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=e.begin!=null,t.endValid=e.end!=null,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let a=0;a<e.dims;a++)if(1<<a&e.ellipsisMask){let r=Math.min(t.dims-(e.dims-a)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<r;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=a}else if(1<<a&e.newAxisMask)t.finalShapeGatherIndices.push(GS),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);e.begin!=null&&(t.begin[n]=e.begin[a]),e.end!=null&&(t.end[n]=e.end[a]),t.strides[n]=e.strides[a],e.beginMask&1<<a&&(t.beginMask|=1<<n),e.endMask&1<<a&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<a?(t.finalShapeGatherIndices.push(RY),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(a)),t.inputShapeGatherIndicesSparse[n]=a,n++}}function R$(e,t,n,a,r,s){if(r[t])return n>0?s[t]:s[t+1&1];{let i=e<0?a+e:e;return i<s[0]?s[0]:i>s[1]?s[1]:i}}var UY="4.22.0",_F=class{static sgd(e){return new nx(e)}static momentum(e,t,n=!1){return new w2(e,t,n)}static rmsprop(e,t=.9,n=0,a=null,r=!1){return new S2(e,t,n,a,r)}static adam(e=.001,t=.9,n=.999,a=null){return new v2(e,t,n,a)}static adadelta(e=.001,t=.95,n=null){return new y2(e,t,n)}static adamax(e=.002,t=.9,n=.999,a=null,r=0){return new x2(e,t,n,a,r)}static adagrad(e,t=.1){return new b2(e,t)}},ou=_F,jY=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:e=>e();function I2(){return new Promise(e=>jY(()=>e()))}var O={};ot(O,{ERF_A1:()=>aJ,ERF_A2:()=>rJ,ERF_A3:()=>sJ,ERF_A4:()=>iJ,ERF_A5:()=>oJ,ERF_P:()=>nJ,PARALLELIZE_THRESHOLD:()=>T2,RowPartitionType:()=>ai,SELU_SCALE:()=>IF,SELU_SCALEALPHA:()=>NF,applyActivation:()=>ex,assertAndGetBroadcastShape:()=>Jt,assertAxesAreInnerMostDims:()=>B8,assertParamsConsistent:()=>WY,assignToTypedArray:()=>pJ,axesAreInnerMostDims:()=>L_,calculateShapes:()=>DM,checkEinsumDimSizes:()=>vJ,checkPadOnDimRoundingMode:()=>Za,combineLocations:()=>eM,combineRaggedTensorToTensorShapes:()=>HY,complexWithEvenIndex:()=>cJ,complexWithOddIndex:()=>dJ,computeConv2DInfo:()=>Zg,computeConv3DInfo:()=>HO,computeDefaultPad:()=>x_,computeDilation2DInfo:()=>zq,computeOptimalWindowSize:()=>XY,computeOutAndReduceShapes:()=>tM,computeOutShape:()=>VY,computePool2DInfo:()=>VO,computePool3DInfo:()=>Lq,convertConv2DDataFormat:()=>GO,decodeEinsumEquation:()=>yJ,eitherStridesOrDilationsAreOne:()=>mi,expandShapeToKeepDim:()=>Ou,exponent:()=>mJ,exponents:()=>fJ,fromStringArrayToUint8:()=>PJ,fromUint8ToStringArray:()=>BJ,getAxesPermutation:()=>nM,getBroadcastDims:()=>ZO,getComplexWithIndex:()=>hJ,getEinsumComputePath:()=>xJ,getEinsumPermutation:()=>bJ,getFusedBiasGradient:()=>Q0,getFusedDyActivation:()=>Z0,getImageCenter:()=>YY,getInnerMostAxes:()=>P8,getPermuted:()=>ZY,getRaggedRank:()=>qY,getReductionAxes:()=>jn,getReshaped:()=>JY,getReshapedPermuted:()=>QY,getRowPartitionTypesHelper:()=>GY,getSliceBeginCoords:()=>eJ,getSliceSize:()=>tJ,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>_J,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>NJ,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>IJ,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>CJ,getSparseReshapeInputOutputMismatchErrorMessage:()=>$J,getSparseReshapeInputOutputMultipleErrorMessage:()=>AJ,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>TJ,getSparseReshapeNegativeOutputDimErrorMessage:()=>EJ,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>MJ,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>RJ,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>DJ,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>OJ,getUndoAxesPermutation:()=>B_,isIdentityPermutation:()=>wJ,log:()=>XG,mergeRealAndImagArrays:()=>lJ,prepareAndValidate:()=>fF,prepareSplitSize:()=>kJ,segment_util:()=>TF,shouldFuse:()=>tx,slice_util:()=>ea,splitRealAndImagArrays:()=>uJ,stridesOrDilationsArePositive:()=>Du,tupleValuesAreOne:()=>sl,upcastType:()=>Jr,validateDefaultValueShape:()=>KY,validateInput:()=>K0,validateUpdateShape:()=>o2,warn:()=>Go});function WY(e,t){let n=e[0].length;e.forEach((r,s)=>{U(r.length===n,()=>`Error in concat${n}D: rank of tensors[${s}] must be the same as the rank of the rest (${n})`)}),U(t>=0&&t<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);let a=e[0];e.forEach((r,s)=>{for(let i=0;i<n;i++)U(i===t||r[i]===a[i],()=>`Error in concat${n}D: Shape of tensors[${s}] (${r}) does not match the shape of the rest (${a}) along the non-concatenated axis ${s}.`)})}function VY(e,t){let n=e[0].slice();for(let a=1;a<e.length;a++)n[t]+=e[a][t];return n}var ai;(function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"})(ai||(ai={}));function HY(e,t,n){let a=new Array;if(n==null&&t==null)return a;if(t==null)for(;a.length<e+n.length;)a.push(-1);else a=t.slice();if(n==null)return a;if(e+n.length!==a.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+n.length}, but shape.rank = ${a.length}`);for(let r=1;r<n.length;++r){let s=n[r],i=a[a.length-n.length+r],o=a[i];if(s>=0)if(o>=0){if(o!==s)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${r+e}] = ${s} but shape[${r+e}] = ${o}`)}else a[i]=s}return a}function GY(e){let t={FIRST_DIM_SIZE:ai.FIRST_DIM_SIZE,VALUE_ROWIDS:ai.VALUE_ROWIDS,ROW_LENGTHS:ai.ROW_LENGTHS,ROW_SPLITS:ai.ROW_SPLITS,ROW_LIMITS:ai.ROW_LIMITS,ROW_STARTS:ai.ROW_STARTS},n=[];for(let a of e)if(a in t)n.push(t[a]);else break;return n}function qY(e){return e.length===0?0:e[0]===ai.FIRST_DIM_SIZE?e.length-1:e.length}function KY(e,t){if(e==null||t==null)return;let n=e.length,a=t.length;if(n>=a)throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${a})`);for(let r=0;r<Math.min(n,a-1);++r){let s=e[r],i=t[r+1];if(s>=0&&i>=0&&s!==1&&s!==i)throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${r-e.length}] = ${s} but ragged tensor input.flatValues.shape[${r-e.length}] = ${i}`)}}var T2=30;function XY(e){return e<=T2?e:_v(e,Math.floor(Math.sqrt(e)))}function YY(e,t,n){let a=n*(typeof e=="number"?e:e[0]),r=t*(typeof e=="number"?e:e[1]);return[a,r]}function JY(e,t,n,a=!0){let r=[];if(a)r=r.concat(t.slice(0)),r.push(e[0]/n),r=r.concat(e.slice(1));else{r=r.concat(e[0]);let s=t.length;for(let i=0;i<s;++i)r=r.concat([e[i+1]/t[i],t[i]]);r=r.concat(e.slice(s+1))}return r}function ZY(e,t,n=!0){let a=[];if(n){a.push(t);for(let r=t+1;r<e;++r)r<=2*t?(a.push(r),a.push(r-(t+1))):a.push(r)}else{let r=[],s=[];for(let i=1;i<e;++i)i>=t*2+1||i%2===1?s.push(i):r.push(i);a.push(...r),a.push(0),a.push(...s)}return a}function QY(e,t,n,a=!0){let r=[];a?r.push(e[0]/n):r.push(e[0]*n);for(let s=1;s<e.length;++s)s<=t.length?a?r.push(t[s-1]*e[s]):r.push(e[s]/t[s-1]):r.push(e[s]);return r}function eJ(e,t){let n=[0];for(let a=0;a<t;++a)n.push(e[a][0]);return n}function tJ(e,t,n){let a=e.slice(0,1);for(let r=0;r<n;++r)a.push(e[r+1]-t[r][0]-t[r][1]);return a}var NF=1.7580993408473768,IF=1.0507009873554805,nJ=.3275911,aJ=.254829592,rJ=-.284496736,sJ=1.421413741,iJ=-1.453152027,oJ=1.061405429;function lJ(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);let n=new Float32Array(e.length*2);for(let a=0;a<n.length;a+=2)n[a]=e[a/2],n[a+1]=t[a/2];return n}function uJ(e){let t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let a=0;a<e.length;a+=2)t[a/2]=e[a],n[a/2]=e[a+1];return{real:t,imag:n}}function cJ(e){let t=Math.ceil(e.length/4),n=new Float32Array(t),a=new Float32Array(t);for(let r=0;r<e.length;r+=4)n[Math.floor(r/4)]=e[r],a[Math.floor(r/4)]=e[r+1];return{real:n,imag:a}}function dJ(e){let t=Math.floor(e.length/4),n=new Float32Array(t),a=new Float32Array(t);for(let r=2;r<e.length;r+=4)n[Math.floor(r/4)]=e[r],a[Math.floor(r/4)]=e[r+1];return{real:n,imag:a}}function hJ(e,t){let n=e[t*2],a=e[t*2+1];return{real:n,imag:a}}function pJ(e,t,n,a){e[a*2]=t,e[a*2+1]=n}function fJ(e,t){let n=new Float32Array(e/2),a=new Float32Array(e/2);for(let r=0;r<Math.ceil(e/2);r++){let s=(t?2:-2)*Math.PI*(r/e);n[r]=Math.cos(s),a[r]=Math.sin(s)}return{real:n,imag:a}}function mJ(e,t,n){let a=(n?2:-2)*Math.PI*(e/t),r=Math.cos(a),s=Math.sin(a);return{real:r,imag:s}}var Q1="->",gJ=/->/g,D$=",",O$="...";function yJ(e,t){e=e.replace(/\s/g,"");let n=(e.length-e.replace(gJ,"").length)/Q1.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${Q1}").`);let[a,r]=e.split(Q1);U(a.indexOf(O$)===-1,()=>`The ellipsis notation ("${O$}") is not supported yet.`);let s=a.split(D$),i=s.length;if(t!==i)throw new Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");let o=[];for(let m=0;m<r.length;++m){let g=r[m];if(!s.some(b=>b.indexOf(g)!==-1))throw new Error(`Output subscripts contain the label ${g} not present in the input subscripts.`);o.indexOf(g)===-1&&o.push(g)}for(let m=0;m<a.length;++m){let g=a[m];o.indexOf(g)===-1&&g!==D$&&o.push(g)}let u=new Array(s.length);for(let m=0;m<i;++m){if(new Set(s[m].split("")).size!==s[m].length)throw new Error(`Found duplicate axes in input component ${s[m]}. Support for duplicate axes in input is not implemented yet.`);u[m]=[];for(let g=0;g<s[m].length;++g)u[m].push(o.indexOf(s[m][g]))}let d=o.length,c=r.length,p=[];for(let m=c;m<d;++m)p.push(m);return{allDims:o,summedDims:p,idDims:u}}function bJ(e,t){let n=new Array(e);n.fill(-1);for(let r=0;r<t.length;++r)n[t[r]]=r;let a=[];for(let r=0;r<e;++r)n[r]===-1&&a.push(r);return n=n.filter(r=>r!==-1),{permutationIndices:n,expandDims:a}}function vJ(e,t,n){let a=new Array(e);for(let r=0;r<n.length;++r){let s=n[r].shape;for(let i=0;i<t[r].length;++i)a[t[r][i]]===void 0?a[t[r][i]]=s[i]:U(a[t[r][i]]===s[i],()=>`Expected dimension ${a[t[r][i]]} at axis ${i} of input shaped ${JSON.stringify(s)}, but got dimension ${s[i]}`)}}function xJ(e,t){let n=e,a=[],r=0;e.length===0&&n.push(-1),r=e.length+1;for(let i=0;i<r;++i)a.push([]);let s=[];for(let i=0;i<n.length;++i){let o=n[i],u=SJ(t,o);for(let d of u)s.indexOf(d)===-1&&(a[i].push(d),s.push(d))}return{path:n,steps:a}}function wJ(e){return e.every((t,n)=>t===n)}function SJ(e,t){let n=[];for(let a=0;a<e.length;++a)(e[a].length===0||e[a].indexOf(t)!==-1||t===-1)&&n.push(a);return n}function kJ(e,t,n=0){let a=[];if(typeof t=="number")U(e.shape[n]%t===0,()=>"Number of splits must evenly divide the axis."),a=new Array(t).fill(e.shape[n]/t);else{let r=t.reduce((i,o)=>(o===-1&&(i+=1),i),0);U(r<=1,()=>"There should be only one negative value in split array.");let s=t.indexOf(-1);if(s!==-1){let i=t.reduce((o,u)=>u>0?o+u:o);t[s]=e.shape[n]-i}U(e.shape[n]===t.reduce((i,o)=>i+o),()=>"The sum of sizes must match the size of the axis dimension."),a=t}return a}function _J(e){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${e}`}function NJ(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function IJ(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}function TJ(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function EJ(e,t){return`size ${e} must be non-negative, not ${t}`}function CJ(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function AJ(e,t){let n=Wt(e),a=Wt(t);return`Input to reshape is a SparseTensor with ${n}
  dense values, but the requested shape requires a multiple of ${a}. inputShape=${e} outputShape= ${t}`}function $J(e,t){let n=Wt(e),a=Wt(t);return`Input to reshape is a tensor with ${n} dense values, but the requested shape has ${a}. inputShape=${e} outputShape=${t}`}function RJ(){return"segment ids must be >= 0"}function DJ(){return"segment ids are not increasing"}function OJ(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function MJ(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}var TF={};ot(TF,{collectGatherOpShapeInfo:()=>LJ,computeOutShape:()=>zJ,segOpComputeOptimalWindowSize:()=>FJ});function FJ(e,t){let n=!1,a;for(e<=T2?(a=e,n=!0):a=_v(e,Math.floor(Math.sqrt(e)));!n;)a>t||a===e?n=!0:a=_v(e,a+1);return a}function zJ(e,t,n){let a=[],r=e.length;for(let s=0;s<r;s++)s!==t?a.push(e[s]):a.push(n);return a}function LJ(e,t,n,a){let r=t.shape.length,s=e.shape.length;if(a!==0&&(a<-r||a>r))throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${a}`);if(a<0&&(a+=r),a>s)throw new Error(`batchDims (${a}) must be less than rank(x) (
    ${s}).`);if(n<a)throw new Error(`batchDims (${a}) must be less than or equal to axis (${n}).`);for(let p=0;p<a;++p)if(e.shape[p]!==t.shape[p])throw new Error(`x.shape[${p}]: ${e.shape[p]} should be equal to indices.shape[${p}]: ${t.shape[p]}.`);let i=e.shape[n],o=[],u=1,d=1,c=1;for(let p=0;p<a;++p)o.push(e.shape[p]),u*=e.shape[p];for(let p=a;p<n;p++)o.push(e.shape[p]),d*=e.shape[p];for(let p=a;p<r;p++)o.push(t.shape[p]);for(let p=n+1;p<s;p++)o.push(e.shape[p]),c*=e.shape[p];return{batchSize:u,sliceSize:c,outerSize:d,dimSize:i,outputShape:o}}function BJ(e){try{return e.map(t=>Tv(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function PJ(e){return e.map(t=>Xg(t))}var yi={};ot(yi,{nonMaxSuppressionV3Impl:()=>qM,nonMaxSuppressionV4Impl:()=>KM,nonMaxSuppressionV5Impl:()=>XM,whereImpl:()=>FM});aY();var EF={kernelName:tp,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Y(e,pd(Te(n,"float32"),-1))}}},UJ={kernelName:Gu,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let a=Xt(Te(n,"float32")),r=fa(Fe(He(1),a));return un(Le(e,r))}}}},jJ={kernelName:qu,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let a=fa(Fe(Xt(Te(n,"float32")),1));return Le(e,a)}}}},WJ={kernelName:bl,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,a]=t,r=Jt(n.shape,a.shape);return{a:()=>{let s=e,i=jn(n.shape,r);return i.length>0&&(s=Be(s,i)),te(s,n.shape)},b:()=>{let s=e,i=jn(a.shape,r);return i.length>0&&(s=Be(s,i)),te(s,a.shape)}}}},VJ={kernelName:Ku,saveAllInputs:!0,gradFunc:(e,t)=>{let n={};return t.forEach((a,r)=>{n[r]=()=>e.clone()}),n}},HJ={kernelName:rp,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>_t(n)}}},GJ={kernelName:sp,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>_t(n)}}},qJ={kernelName:Xu,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Le(e,fa(Fe(He(1),Xt(Te(n,"float32")))))}}},KJ={kernelName:Yu,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let a=fa(ye(He(1),Xt(Te(n,"float32"))));return Le(e,a)}}}},XJ={kernelName:Qu,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,a]=t,r=Jt(n.shape,a.shape);return{a:()=>{let s=ye(Xt(n),Xt(a)),i=Y(e,Le(a,s)),o=jn(n.shape,r);return o.length>0&&(i=Be(i,o)),te(i,n.shape)},b:()=>{let s=ye(Xt(n),Xt(a)),i=un(Y(e,Le(n,s))),o=jn(a.shape,r);return o.length>0&&(i=Be(i,o)),te(i,a.shape)}}}},YJ={kernelName:Ju,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Le(e,ye(Xt(Te(n,"float32")),1))}}},JJ={kernelName:Zu,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Le(e,Fe(He(1),Xt(Te(n,"float32"))))}}};function ZJ(e,t,n,a,r,s){let i=F(e,"dy","avgPool3dGrad"),o=F(t,"input","avgPool3dGrad"),u=i,d=o,c=!1;o.rank===4&&(c=!0,u=te(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),d=te(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),U(u.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`),U(d.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${d.rank}.`),Za("avgPool3dGrad",r,s);let p={dy:u,input:d},m={filterSize:n,strides:a,pad:r,dimRoundingMode:s},g=q.runKernel(Tg,p,m);return c?te(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}var QJ=X({avgPool3dGrad_:ZJ}),eZ={kernelName:ip,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[a]=t,{filterSize:r,strides:s,pad:i,dimRoundingMode:o}=n;return{x:()=>QJ(e,a,r,s,i,o)}}};function tZ(e,t,n,a,r){let s=F(e,"dy","avgPoolGrad"),i=F(t,"input","avgPoolGrad");U(i.rank===s.rank,()=>`Rank of input (${i.rank}) does not match rank of dy (${s.rank})`);let o=i,u=s,d=!1;i.rank===3&&(d=!0,o=te(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=te(s,[1,s.shape[0],s.shape[1],s.shape[2]])),U(u.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${u.rank}.`),U(o.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`);let c={dy:u,input:o},p={filterSize:n,strides:a,pad:r},m=q.runKernel(Ig,c,p);return d?te(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var nZ=X({avgPoolGrad_:tZ}),aZ={kernelName:ec,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[a]=t,{filterSize:r,strides:s,pad:i}=n;return{x:()=>nZ(e,a,r,s,i)}}},rZ={kernelName:tc,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{let[a,r]=t,{transposeA:s,transposeB:i}=n;return!s&&!i?{a:()=>pt(e,r,!1,!0),b:()=>pt(a,e,!0,!1)}:!s&&i?{a:()=>pt(e,r,!1,!1),b:()=>pt(e,a,!0,!1)}:s&&!i?{a:()=>pt(r,e,!1,!0),b:()=>pt(a,e,!1,!1)}:{a:()=>pt(r,e,!0,!0),b:()=>pt(e,a,!0,!0)}}},sZ={kernelName:op,gradFunc:(e,t,n)=>{let{blockShape:a,crops:r}=n;return{x:()=>oy(e,a,r)}}},iZ={kernelName:pO,gradFunc:(e,t,n)=>{let a=n,r=a.inputShape,s=a.shape,i=Array.from(s);for(let u=r.length-1;u>=0;u--)if(r[u]===s[u])i[u]=1;else if(r[u]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${s}].`);let o=[];for(let u=0;u<i.length;u++)i[u]>1&&o.push(u);return{x:()=>Be(e,o,!0)}}},oZ={kernelName:nc,gradFunc:e=>({x:()=>e.clone()})},lZ={kernelName:ac,gradFunc:e=>({x:()=>_t(e)})},uZ={kernelName:vl,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[a]=t,{clipValueMin:r,clipValueMax:s}=n;return{x:()=>pa(bs(to(a,r),kl(a,s)),e,_t(e))}}},cZ={kernelName:Cg,inputsToSave:["x"],gradFunc:EF.gradFunc},dZ={kernelName:cp,saveAllInputs:!0,gradFunc:(e,t,n)=>{let a=t.map(o=>o.shape),{axis:r}=n,s=ws(r,t[0].shape)[0],i=a.map(o=>o[s]);return lr(e,i,s).map(o=>()=>o)}},hZ={kernelName:rc,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let[a,r]=t,{dilations:s,strides:i,pad:o,dataFormat:u}=n;return U(sl(s),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`),{x:()=>$_(a.shape,e,r,i,o,u),filter:()=>f2(a,e,r.shape,i,o,u)}}},pZ={kernelName:sc,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{let[a,r]=t,{strides:s,pad:i,dataFormat:o,dimRoundingMode:u}=n;return{dy:()=>Ka(e,r,s,i,o,1,u),filter:()=>f2(e,a,r.shape,s,i,o,u)}}};function fZ(e,t,n,a,r){let s=e;e.rank===4&&(s=te(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let i=t;i.rank===4&&(i=te(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),U(s.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${s.shape}.`),U(i.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`),U(n.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`),U(s.shape[4]===n[3],()=>`Error in conv3dDerFilter: depth of input ${s.shape[4]}) must match input depth in filter (${n[3]}.`),U(i.shape[4]===n[4],()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${n[4]}).`);let o={x:s,dy:i},u={strides:a,pad:r,filterShape:n};return q.runKernel(dp,o,u)}var mZ=X({conv3DBackpropFilter_:fZ}),gZ={kernelName:ic,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let{dilations:a,strides:r,pad:s}=n;U(sl(a),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`);let[i,o]=t;return{x:()=>YO(i.shape,e,o,r,s),filter:()=>mZ(i,e,o.shape,r,s)}}},yZ={kernelName:oc,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Y(un(U0(Te(n,"float32"))),e)}}},bZ={kernelName:lc,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Y(j0(Te(n,"float32")),e)}}},vZ={kernelName:uc,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[a]=t,{axis:r,exclusive:s,reverse:i}=n;return{x:()=>{let o=nM([r],a.rank),u=C0(e,r,s,!i);return o!=null&&(u=ft(u,o)),u}}}},xZ={kernelName:cc,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let{dilations:a,strides:r,pad:s,dimRoundingMode:i}=n,o=a??[1,1];U(sl(o),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);let[u,d]=t;return U(u.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${u.rank}.`),U(d.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${d.rank}.`),U(u.shape[3]===d.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${u.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`),U(mi(r,o),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${r} and dilations '${o}'.`),Za("depthwiseConv2d",s,i),{x:()=>VM(u.shape,e,d,r,s,o,i),filter:()=>WM(u,e,d.shape,r,s,o,i)}}},wZ={kernelName:dc,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let[a,r]=t,s={x:a,filter:r,dy:e},i={x:a,filter:r,dy:e};return{x:()=>q.runKernel(Mh,s,n),filter:()=>q.runKernel(Fh,i,n)}}},SZ={kernelName:pc,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t,a={dy:e,y:n};return{x:()=>q.runKernel(gp,a)}}},kZ={kernelName:fc,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t,a=Y(La(un(Xt(n))),2/Math.sqrt(Math.PI));return{x:()=>Y(e,a)}}},_Z={kernelName:mc,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Y(e,n)}}},NZ={kernelName:bp,inputsToSave:["input"],gradFunc:(e,t)=>{let[n]=t;return{input:()=>te(e,n.shape)}}},IZ={kernelName:gc,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Y(e,La(n))}}},TZ={kernelName:yc,gradFunc:e=>({x:()=>_t(e)})},EZ={kernelName:bc,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,a]=t,r=Jt(n.shape,a.shape);return{a:()=>{let s=Le(e,Te(a,"float32")),i=jn(n.shape,r);return i.length>0?te(Be(s,i),n.shape):s},b:()=>{let s=Y(e,Te(n,"float32")),i=jn(a.shape,r);i.length>0&&(s=te(Be(s,i),a.shape));let o=Xt(a);return un(Le(s,Te(o,"float32")))}}}},CZ={kernelName:vc,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{let{varianceEpsilon:a}=n,[r,s,i,o]=t,u=o??He(1),d=jn(s.shape,r.shape),c=[];if(s.rank===1){for(let v=0;v<r.shape.length-1;++v)c.push(r.shape[v]);c.push(1)}let p=Fe(r,s),m=Y(e,u),g=B0(ye(i,He(a))),b=Y(Y(Y(g,g),g),He(-.5));return{x:()=>s.rank===1?te(Y(Y(e,Er(te(g,[1,1,1,s.shape[0]]),c)),u),r.shape):te(Y(Y(e,g),u),r.shape),mean:()=>{let v=Y(Y(g,He(-1)),m);return s.rank===1&&(v=Be(v,d)),te(v,s.shape)},variance:()=>{let v=Y(Y(b,p),m);return s.rank===1&&(v=Be(v,d)),te(v,s.shape)},scale:()=>{let v=Y(p,g),x=Y(e,v);return s.rank===1&&(x=Be(x,d)),te(x,s.shape)},offset:()=>{let v=e;return s.rank===1&&(v=Be(v,d)),te(v,s.shape)}}}},AZ={kernelName:xp,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{let[a,r]=t,{axis:s,batchDims:i}=n,o=ws(s,a.shape)[0],u=(d,c,p)=>()=>{let m=d.shape,g=c.size,b=m.slice(0,o),v=b.length,x=m.slice(s,m.length).slice(1),w=x.length,k=M$(0,v),N=M$(v+1,v+1+w),I=F$([b,[g],x]),T=te(p,I),$=te(c,[g]),D=F$([[v],k,N]),M=ft(T,D),B=Y0(M,$,d.shape[o]),V=B_(D);return B=ft(B,V),B};if(i===1){let d=a.shape[0],c=a.split(d,0);return{x:()=>Un(c.map((p,m)=>u(p,r.slice(m,1),e.slice(m,1))())).reshape(a.shape),indices:()=>r}}else return{x:u(a,r,e),indices:()=>r}}};function M$(e,t){let n=[];for(let a=e;a<t;++a)n.push(a);return n}function F$(e){let t=[];for(let n=0;n<e.length;++n)for(let a=0;a<e[n].length;++a)t.push(e[n][a]);return t}var $Z={kernelName:xc,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,a]=t;return{a:()=>_t(n),b:()=>_t(a)}}},RZ={kernelName:wc,gradFunc:e=>({x:()=>Te(e,"float32")})},DZ={kernelName:Sc,gradFunc:e=>({x:()=>_t(e)})},OZ={kernelName:kc,gradFunc:e=>({x:()=>_t(e)})},MZ={kernelName:_c,gradFunc:e=>({x:()=>_t(e)})},FZ={kernelName:Nc,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[a]=t,{alpha:r}=n,s=Qa(a,0);return{x:()=>pa(s,e,Y(e,r))}}},zZ={kernelName:Tc,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Le(e,ye(n,1))}}},LZ={kernelName:Ic,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Le(e,Te(n,"float32"))}}},BZ={kernelName:mO,inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[a]=t,{axis:r}=n;return{logits:()=>{let s=La(a);return Fe(e,Y(Be(e,r,!0),s))}}}};function PZ(e,t,n,a=5,r=1,s=1,i=.5){let o={x:e,y:t,dy:n},u={depthRadius:a,bias:r,alpha:s,beta:i};return q.runKernel(Cp,o,u)}var UZ=X({localResponseNormalizationBackprop_:PZ}),jZ={kernelName:Ec,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[a,r]=t,{depthRadius:s,bias:i,alpha:o,beta:u}=n;return{x:()=>UZ(a,r,e,s,i,o,u)}}};function CF(e,t,n,a){return t.rank<n.rank&&(t=te(t,Ou(t.shape,a))),e.rank<n.rank&&(e=te(e,Ou(e.shape,a))),{x:()=>Y(e,Te(Ar(n,t),e.dtype))}}var z$={kernelName:Cc,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let a=n,{reductionIndices:r}=a,s=t[0],i=t[1],o=ws(r,s.shape),u=CF(e,i,s,o);return{x:()=>u.x()}}},WZ={kernelName:Ac,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,a]=t;return{a:()=>Y(e,Te(to(n,a),"float32")),b:()=>Y(e,Te(Bh(n,a),"float32"))}}};function VZ(e,t,n,a,r,s,i){let o=F(e,"dy","maxPool3dGrad"),u=F(t,"input","maxPool3dGrad"),d=F(n,"output","maxPool3dGrad"),c=o,p=u,m=d,g=!1;u.rank===4&&(g=!0,c=te(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),p=te(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]]),m=te(d,[1,d.shape[0],d.shape[1],d.shape[2],d.shape[3]])),U(c.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),U(p.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${p.rank}.`),U(m.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${m.rank}.`),Za("maxPool3dGrad",s,i);let b={dy:c,input:p,output:m},v={filterSize:a,strides:r,pad:s,dimRoundingMode:i},x=q.runKernel(Og,b,v);return g?te(x,[x.shape[1],x.shape[2],x.shape[3],x.shape[4]]):x}var HZ=X({maxPool3dGrad_:VZ}),GZ={kernelName:Ap,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[a,r]=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:u}=n;return{x:()=>HZ(e,a,r,s,i,o,u)}}};function qZ(e,t,n,a,r,s,i){let o=F(e,"dy","maxPoolGrad"),u=F(t,"input","maxPoolGrad"),d=F(n,"output","maxPoolGrad");U(u.rank===o.rank,()=>`Rank of input (${u.rank}) does not match rank of dy (${o.rank})`),U(o.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`),U(u.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${u.rank}.`),Za("maxPoolGrad",s,i);let c={dy:o,input:u,output:d},p={filterSize:a,strides:r,pad:s,dimRoundingMode:i};return q.runKernel(Dg,c,p)}var KZ=X({maxPoolGrad_:qZ}),XZ={kernelName:$c,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[a,r]=t,{filterSize:s,strides:i,pad:o}=n;return{x:()=>KZ(e,a,r,s,i,o)}}},YZ={kernelName:Rc,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[a]=t,{axis:r}=n,s=ws(r,a.shape),i=tM(a.shape,s)[1],o=Wt(i);return{x:()=>{let u=a.shape.slice();s.forEach(c=>{u[c]=1});let d=te(e,u);return Le(Y(d,or(a.shape,"float32")),o)}}}},JZ={kernelName:Dc,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let a=n,{axis:r}=a,[s,i]=t,o=ws(r,s.shape),u=CF(e,i,s,o);return{x:()=>u.x()}}},ZZ={kernelName:Oc,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,a]=t;return{a:()=>Y(e,Te(kl(n,a),"float32")),b:()=>Y(e,Te(Qa(n,a),"float32"))}}},QZ={kernelName:Mc,inputsToSave:["x"],gradFunc:(e,t,n)=>{let a=t[0],{paddings:r}=n,s=r.map(i=>i[0]);return{x:()=>wt(e,s,a.shape)}}},eQ={kernelName:Fc,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,a]=t,r=Jt(n.shape,a.shape);return{a:()=>{let s=jn(n.shape,r);return s.length>0?te(Be(e,s),n.shape):e},b:()=>{let s=Y(e,un(of(Le(n,a)))),i=jn(a.shape,r);return i.length>0?te(Be(s,i),a.shape):s}}}},tQ={kernelName:zc,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,a]=t,r=Jt(n.shape,a.shape);return{a:()=>{let s=Y(e,Te(a,"float32")),i=jn(n.shape,r);return i.length>0?te(Be(s,i),n.shape):s},b:()=>{let s=Y(e,Te(n,"float32")),i=jn(a.shape,r);return i.length>0?te(Be(s,i),a.shape):s}}}},nQ={kernelName:Rp,gradFunc:e=>({x:()=>un(e)})},aQ={kernelName:Lc,inputsToSave:["indices"],gradFunc:(e,t)=>{let n=t[0];return{indices:()=>xn(n.shape,"float32")}}},rQ={kernelName:zp,gradFunc:e=>({x:()=>_t(e)})},sQ={kernelName:Lp,saveAllInputs:!0,gradFunc:(e,t,n)=>{let{axis:a}=n;return Nn(e,a).map(r=>()=>r)}},L$={kernelName:Bc,inputsToSave:["x"],gradFunc:(e,t,n)=>{let a=t[0],{paddings:r}=n,s=r.map(i=>i[0]);return{x:()=>wt(e,s,a.shape)}}},iQ={kernelName:Pc,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{let[n,a,r]=t,s=n,i=a,o=Jt(s.shape,i.shape);return{a:()=>{let u=Te(i,"float32"),d=Y(e,Y(u,hi(s,Fe(u,He(1))))),c=jn(s.shape,o);return c.length>0&&(d=Be(d,c)),te(d,s.shape)},b:()=>{let u=Qa(s,0),d=pa(u,$r(s),_t(s)),c=Y(e,Y(r,d)),p=jn(i.shape,o);return p.length>0&&(c=Be(c,p)),te(c,i.shape)}}}},oQ={kernelName:Uc,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{let[n,a]=t,r=Qa(n,0);return{x:()=>pa(r,e,Y(e,a)),alpha:()=>{let s=pa(r,_t(e),Y(e,n)),i=jn(a.shape,e.shape);return i.length>0&&(s=Be(s,i)),te(s,a.shape)}}}};function lQ(e,t,n){let a=e.shape.slice();a[n]=1;let r=te(t,a),s=ag(e,n,!0,!1),i=ag(e,n,!0,!0),o=Y(s,i);return Y(r,o)}function uQ(e,t,n){let a=e.shape.length,r=a-n.length,s=O.getAxesPermutation(n,a),i=e;s!=null&&(i=ft(e,s));let o=i.shape.slice(),u=o.splice(a-n.length,n.length).reduce((p,m)=>p*m,1);o.push(u);let d=i.reshape(o),c=lQ(d,t,r);if(c=c.reshape(i.shape),s!=null){let p=O.getUndoAxesPermutation(s);c=ft(c,p)}return c}var cQ={kernelName:jc,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[a]=t,{axis:r}=n,s=[];return r==null?s=a.shape.map((i,o)=>o):typeof r=="number"?s=[r]:s=r,{x:()=>uQ(a,e,s)}}},dQ={kernelName:hc,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,a]=t,r=Jt(n.shape,a.shape);return{a:()=>{let s=Le(e,Te(a,"float32")),i=jn(n.shape,r);return i.length>0?te(Be(s,i),n.shape):s},b:()=>{let s=Y(e,Te(n,"float32")),i=jn(a.shape,r);i.length>0&&(s=te(Be(s,i),a.shape));let o=Xt(a);return un(Le(s,Te(o,"float32")))}}}},hQ={kernelName:Wc,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Le(e,un(Xt(n)))}}},pQ={kernelName:qc,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t,a=Y(kl(n,6),pd(n));return{x:()=>Y(e,Te(a,"float32"))}}},fQ={kernelName:Vc,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Y(e,Te(pd(n),"float32"))}}},mQ={kernelName:Bp,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>te(e,n.shape)}}},gQ={kernelName:Gc,inputsToSave:["images"],gradFunc:(e,t,n)=>{let[a]=t,r={dy:e,images:a};return{images:()=>q.runKernel(Up,r,n)}}},yQ={kernelName:Hc,inputsToSave:["images"],gradFunc:(e,t,n)=>{let[a]=t,r={dy:e,images:a};return{images:()=>q.runKernel(Pp,r,n)}}},bQ={kernelName:Kc,gradFunc:(e,t,n)=>{let{dims:a}=n,r=ws(a,e.shape);return{x:()=>Qr(e,r)}}},vQ={kernelName:Xc,gradFunc:e=>({x:()=>_t(e)})},xQ={kernelName:Yc,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>un(Le(e,Y(hi(n,1.5),2)))}}},wQ={kernelName:Hp,inputsToSave:["condition"],gradFunc:(e,t)=>{let[n]=t;return{condition:()=>Te(_t(n),"float32"),t:()=>Y(e,Te(n,e.dtype)),e:()=>Y(e,Te(sy(n),e.dtype))}}},SQ={kernelName:Jc,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let a=Qa(n,He(0)),r=He(NF),s=He(IF),i=Y(e,s),o=Y(Y(e,r),La(Te(n,"float32")));return pa(a,i,o)}}}},kQ={kernelName:td,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Y(e,Y(n,Fe(He(1),n)))}}},_Q={kernelName:ed,gradFunc:e=>({x:()=>_t(e)})},NQ={kernelName:Zc,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Y(ey(Te(n,"float32")),e)}}},IQ={kernelName:Qc,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Y(E0(Te(n,"float32")),e)}}},TQ={kernelName:Gp,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[a]=t,{begin:r,size:s}=n,i=a.shape,[o,u]=kF(a,r,s),d=[];for(let c=0;c<e.rank;c++)d.push([o[c],i[c]-o[c]-u[c]]);return{x:()=>Vs(e,d)}}},EQ={kernelName:sd,outputsToSave:[!0],gradFunc:(e,t,n)=>{let[a]=t,{dim:r}=n,s=!0,i=Y(e,a);return{logits:()=>Fe(i,Y(Be(i,[r],s),a))}}},CQ={kernelName:nd,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Y(e,ys(n))}}},B$={kernelName:qp,gradFunc:(e,t,n)=>{let{blockShape:a,paddings:r}=n;return{x:()=>Qg(e,a,r)}}},P$={kernelName:Kp,gradFunc:(e,t,n)=>{let{axis:a}=n;return{x:()=>Yt(e,a)}}},AQ={kernelName:ad,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Le(e,Y(fa(Te(n,"float32")),2))}}},$Q={kernelName:Pg,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Y(e,Y(Te(n,"float32"),2))}}},RQ={kernelName:id,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,a]=t,r=He(2);return{a:()=>Y(e,Y(r,Fe(n,a))),b:()=>Y(e,Y(r,Fe(a,n)))}}},DQ={kernelName:wl,gradFunc:e=>({x:()=>_t(e)})},OQ={kernelName:od,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,a]=t,r=Jt(n.shape,a.shape);return{a:()=>{let s=e,i=jn(n.shape,r);return i.length>0&&(s=Be(s,i)),te(s,n.shape)},b:()=>{let s=e,i=jn(a.shape,r);return i.length>0&&(s=Be(s,i)),te(un(s),a.shape)}}}},MQ={kernelName:rd,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[a]=t,r=a.shape.slice(),{axis:s}=n;ws(s,a.shape).forEach(u=>{r[u]=1});let i=te(e,r),o=Y(i,or(a.shape,"float32"));return{x:()=>o}}},FQ={kernelName:ld,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Le(e,Xt(ey(n)))}}},zQ={kernelName:ud,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Y(Fe(He(1),Xt(n)),e)}}},LQ={kernelName:xl,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[a]=t,{reps:r}=n;return{x:()=>{let s=_t(a);if(a.rank===1)for(let i=0;i<r[0];++i)s=ye(s,wt(e,[i*a.shape[0]],[a.shape[0]]));else if(a.rank===2)for(let i=0;i<r[0];++i)for(let o=0;o<r[1];++o)s=ye(s,wt(e,[i*a.shape[0],o*a.shape[1]],[a.shape[0],a.shape[1]]));else if(a.rank===3)for(let i=0;i<r[0];++i)for(let o=0;o<r[1];++o)for(let u=0;u<r[2];++u)s=ye(s,wt(e,[i*a.shape[0],o*a.shape[1],u*a.shape[2]],[a.shape[0],a.shape[1],a.shape[2]]));else if(a.rank===4)for(let i=0;i<r[0];++i)for(let o=0;o<r[1];++o)for(let u=0;u<r[2];++u)for(let d=0;d<r[3];++d)s=ye(s,wt(e,[i*a.shape[0],o*a.shape[1],u*a.shape[2],d*a.shape[3]],[a.shape[0],a.shape[1],a.shape[2],a.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${a.rank} tensors yet.`);return s}}}},BQ={kernelName:Hi,gradFunc:(e,t,n)=>{let a=n,{perm:r}=a,s=B_(r);return{x:()=>ft(e,s)}}},PQ={kernelName:ef,gradFunc:(e,t,n)=>{let a=n,{axis:r}=a;return{value:()=>Un(e,r)}}},UQ={kernelName:Gg,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>jQ(e,n)}}};function jQ(e,t){let n=gi(t,_t(t)),a=lf(e,n),r=to(t,He(0,"int32")),s=a.rank-r.rank;for(let o=0;o<s;++o)r=da(r,o+1);r=bs(r,or(a.shape,"bool"));let i=_t(a);return pa(r,a,i)}var WQ={kernelName:tf,gradFunc:e=>({x:()=>_t(e)})},VQ=[EF,UJ,jJ,WJ,VJ,HJ,GJ,qJ,KJ,XJ,YJ,JJ,eZ,aZ,rZ,sZ,iZ,oZ,lZ,uZ,cZ,dZ,pZ,hZ,gZ,yZ,bZ,vZ,xZ,wZ,dQ,SZ,kZ,_Z,NZ,IZ,EZ,TZ,CZ,AZ,$Z,RZ,DZ,OZ,MZ,FZ,zZ,LZ,BZ,jZ,z$,z$,WZ,GZ,XZ,YZ,JZ,ZZ,QZ,eQ,tQ,nQ,aQ,rQ,sQ,L$,L$,iQ,oQ,cQ,hQ,pQ,fQ,mQ,gQ,yQ,bQ,vQ,xQ,wQ,SQ,kQ,_Q,NQ,IQ,TQ,EQ,CQ,B$,B$,P$,P$,AQ,RQ,$Q,DQ,OQ,MQ,FQ,zQ,LQ,BQ,PQ,UQ,WQ];for(let e of VQ)gO(e);ve().prototype.abs=function(){return this.throwIfDisposed(),Ln(this)};ve().prototype.acos=function(){return this.throwIfDisposed(),h_(this)};ve().prototype.acosh=function(){return this.throwIfDisposed(),p_(this)};ve().prototype.add=function(e){return this.throwIfDisposed(),ye(this,e)};ve().prototype.all=function(e,t){return this.throwIfDisposed(),N0(this,e,t)};ve().prototype.any=function(e,t){return this.throwIfDisposed(),eg(this,e,t)};ve().prototype.argMax=function(e){return this.throwIfDisposed(),Ru(this,e)};ve().prototype.argMin=function(e){return this.throwIfDisposed(),f_(this,e)};ve().prototype.asScalar=function(){return this.throwIfDisposed(),U(this.size===1,()=>"The array must have only 1 element."),te(this,[])};ve().prototype.asType=function(e){return this.throwIfDisposed(),Te(this,e)};ve().prototype.as1D=function(){return this.throwIfDisposed(),te(this,[this.size])};ve().prototype.as2D=function(e,t){return this.throwIfDisposed(),te(this,[e,t])};ve().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),te(this,[e,t,n])};ve().prototype.as4D=function(e,t,n,a){return this.throwIfDisposed(),te(this,[e,t,n,a])};ve().prototype.as5D=function(e,t,n,a,r){return this.throwIfDisposed(),te(this,[e,t,n,a,r])};ve().prototype.asin=function(){return this.throwIfDisposed(),m_(this)};ve().prototype.asinh=function(){return this.throwIfDisposed(),g_(this)};ve().prototype.atan=function(){return this.throwIfDisposed(),y_(this)};ve().prototype.atan2=function(e){return this.throwIfDisposed(),b_(this,e)};ve().prototype.atanh=function(){return this.throwIfDisposed(),v_(this)};ve().prototype.avgPool=function(e,t,n,a){return this.throwIfDisposed(),eo(this,e,t,n,a)};ve().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),Qg(this,e,t)};ve().prototype.batchNorm=function(e,t,n,a,r){return this.throwIfDisposed(),cd(this,e,t,n,a,r)};ve().prototype.broadcastTo=function(e){return this.throwIfDisposed(),xu(this,e)};ve().prototype.cast=function(e){return this.throwIfDisposed(),Te(this,e)};ve().prototype.ceil=function(){return this.throwIfDisposed(),I_(this)};ve().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),za(this,e,t)};ve().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof dt&&(e=[e]),Yt([this,...e],t)};ve().prototype.conv1d=function(e,t,n,a,r,s){return this.throwIfDisposed(),I0(this,e,t,n,a,r,s)};ve().prototype.conv2dTranspose=function(e,t,n,a,r){return this.throwIfDisposed(),T0(this,e,t,n,a,r)};ve().prototype.conv2d=function(e,t,n,a,r,s){return this.throwIfDisposed(),Ka(this,e,t,n,a,r,s)};ve().prototype.cos=function(){return this.throwIfDisposed(),ey(this)};ve().prototype.cosh=function(){return this.throwIfDisposed(),E0(this)};ve().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),ag(this,e,t,n)};ve().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),C0(this,e,t,n)};ve().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),O_(this,e,t)};ve().prototype.depthwiseConv2d=function(e,t,n,a,r,s){return this.throwIfDisposed(),dd(this,e,t,n,a,r,s)};ve().prototype.dilation2d=function(e,t,n,a,r){return this.throwIfDisposed(),M_(this,e,t,n,a,r)};ve().prototype.divNoNan=function(e){return this.throwIfDisposed(),F_(this,e)};ve().prototype.div=function(e){return this.throwIfDisposed(),Le(this,e)};ve().prototype.dot=function(e){return this.throwIfDisposed(),z_(this,e)};ve().prototype.elu=function(){return this.throwIfDisposed(),rf(this)};ve().prototype.equal=function(e){return this.throwIfDisposed(),Ar(this,e)};ve().prototype.erf=function(){return this.throwIfDisposed(),A0(this)};ve().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),P_(this,e,t)};ve().prototype.exp=function(){return this.throwIfDisposed(),La(this)};ve().prototype.expandDims=function(e){return this.throwIfDisposed(),da(this,e)};ve().prototype.expm1=function(){return this.throwIfDisposed(),U_(this)};ve().prototype.fft=function(){return this.throwIfDisposed(),cy(this)};ve().prototype.flatten=function(){return this.throwIfDisposed(),te(this,[this.size])};ve().prototype.floor=function(){return this.throwIfDisposed(),of(this)};ve().prototype.floorDiv=function(e){return this.throwIfDisposed(),_0(this,e)};ve().prototype.gather=function(e,t,n){return this.throwIfDisposed(),lf(this,e,t,n)};ve().prototype.greaterEqual=function(e){return this.throwIfDisposed(),to(this,e)};ve().prototype.greater=function(e){return this.throwIfDisposed(),Qa(this,e)};ve().prototype.ifft=function(){return this.throwIfDisposed(),Wh(this)};ve().prototype.irfft=function(){return this.throwIfDisposed(),V0(this)};ve().prototype.isFinite=function(){return this.throwIfDisposed(),j_(this)};ve().prototype.isInf=function(){return this.throwIfDisposed(),W_(this)};ve().prototype.isNaN=function(){return this.throwIfDisposed(),V_(this)};ve().prototype.leakyRelu=function(e){return this.throwIfDisposed(),ny(this,e)};ve().prototype.lessEqual=function(e){return this.throwIfDisposed(),kl(this,e)};ve().prototype.less=function(e){return this.throwIfDisposed(),Bh(this,e)};ve().prototype.localResponseNormalization=function(e,t,n,a){return this.throwIfDisposed(),H_(this,e,t,n,a)};ve().prototype.logSigmoid=function(){return this.throwIfDisposed(),G_(this)};ve().prototype.logSoftmax=function(e){return this.throwIfDisposed(),D0(this,e)};ve().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),ry(this,e,t)};ve().prototype.log=function(){return this.throwIfDisposed(),$r(this)};ve().prototype.log1p=function(){return this.throwIfDisposed(),ay(this)};ve().prototype.logicalAnd=function(e){return this.throwIfDisposed(),bs(this,e)};ve().prototype.logicalNot=function(){return this.throwIfDisposed(),sy(this)};ve().prototype.logicalOr=function(e){return this.throwIfDisposed(),O0(this,e)};ve().prototype.logicalXor=function(e){return this.throwIfDisposed(),q_(this,e)};ve().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),pt(this,e,t,n)};ve().prototype.maxPool=function(e,t,n,a){return this.throwIfDisposed(),la(this,e,t,n,a)};ve().prototype.max=function(e,t){return this.throwIfDisposed(),Yr(this,e,t)};ve().prototype.maximum=function(e){return this.throwIfDisposed(),gi(this,e)};ve().prototype.mean=function(e,t){return this.throwIfDisposed(),vn(this,e,t)};ve().prototype.min=function(e,t){return this.throwIfDisposed(),Lh(this,e,t)};ve().prototype.minimum=function(e){return this.throwIfDisposed(),ol(this,e)};ve().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),X_(this,e,t)};ve().prototype.mod=function(e){return this.throwIfDisposed(),Y_(this,e)};ve().prototype.mul=function(e){return this.throwIfDisposed(),Y(this,e)};ve().prototype.neg=function(){return this.throwIfDisposed(),un(this)};ve().prototype.norm=function(e,t,n){return this.throwIfDisposed(),sf(this,e,t,n)};ve().prototype.notEqual=function(e){return this.throwIfDisposed(),Mu(this,e)};ve().prototype.oneHot=function(e,t=1,n=0){return this.throwIfDisposed(),Ph(this,e,t,n)};ve().prototype.onesLike=function(){return this.throwIfDisposed(),Rr(this)};ve().prototype.pad=function(e,t){return this.throwIfDisposed(),Vs(this,e,t)};ve().prototype.pool=function(e,t,n,a,r,s){return this.throwIfDisposed(),J_(this,e,t,n,a,r,s)};ve().prototype.pow=function(e){return this.throwIfDisposed(),hi(this,e)};ve().prototype.prelu=function(e){return this.throwIfDisposed(),ly(this,e)};ve().prototype.prod=function(e,t){return this.throwIfDisposed(),Z_(this,e,t)};ve().prototype.reciprocal=function(){return this.throwIfDisposed(),a2(this)};ve().prototype.relu=function(){return this.throwIfDisposed(),jt(this)};ve().prototype.relu6=function(){return this.throwIfDisposed(),z0(this)};ve().prototype.reshapeAs=function(e){return this.throwIfDisposed(),te(this,e.shape)};ve().prototype.reshape=function(e){return this.throwIfDisposed(),te(this,e)};ve().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),YM(this,e,t,n)};ve().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),JM(this,e,t,n)};ve().prototype.reverse=function(e){return this.throwIfDisposed(),Qr(this,e)};ve().prototype.rfft=function(){return this.throwIfDisposed(),dy(this)};ve().prototype.round=function(){return this.throwIfDisposed(),L0(this)};ve().prototype.rsqrt=function(){return this.throwIfDisposed(),B0(this)};ve().prototype.selu=function(){return this.throwIfDisposed(),P0(this)};ve().prototype.separableConv2d=function(e,t,n,a,r,s){return this.throwIfDisposed(),uf(this,e,t,n,a,r,s)};ve().prototype.sigmoid=function(){return this.throwIfDisposed(),ys(this)};ve().prototype.sign=function(){return this.throwIfDisposed(),r2(this)};ve().prototype.sin=function(){return this.throwIfDisposed(),U0(this)};ve().prototype.sinh=function(){return this.throwIfDisposed(),j0(this)};ve().prototype.slice=function(e,t){return this.throwIfDisposed(),wt(this,e,t)};ve().prototype.softmax=function(e){return this.throwIfDisposed(),Nl(this,e)};ve().prototype.softplus=function(){return this.throwIfDisposed(),hd(this)};ve().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),oy(this,e,t)};ve().prototype.split=function(e,t){return this.throwIfDisposed(),lr(this,e,t)};ve().prototype.sqrt=function(){return this.throwIfDisposed(),fa(this)};ve().prototype.square=function(){return this.throwIfDisposed(),Xt(this)};ve().prototype.squaredDifference=function(e){return this.throwIfDisposed(),H0(this,e)};ve().prototype.squeeze=function(e){return this.throwIfDisposed(),Il(this,e)};ve().prototype.stack=function(e,t){this.throwIfDisposed();let n=e instanceof dt?[this,e]:[this,...e];return Un(n,t)};ve().prototype.step=function(e){return this.throwIfDisposed(),pd(this,e)};ve().prototype.stridedSlice=function(e,t,n,a,r,s,i,o){return this.throwIfDisposed(),s2(this,e,t,n,a,r,s,i,o)};ve().prototype.sub=function(e){return this.throwIfDisposed(),Fe(this,e)};ve().prototype.sum=function(e,t){return this.throwIfDisposed(),Be(this,e,t)};ve().prototype.tan=function(){return this.throwIfDisposed(),i2(this)};ve().prototype.tanh=function(){return this.throwIfDisposed(),il(this)};ve().prototype.tile=function(e){return this.throwIfDisposed(),Er(this,e)};ve().prototype.toBool=function(){return this.throwIfDisposed(),Te(this,"bool")};ve().prototype.toFloat=function(){return this.throwIfDisposed(),Te(this,"float32")};ve().prototype.toInt=function(){return this.throwIfDisposed(),Te(this,"int32")};ve().prototype.topk=function(e,t){return this.throwIfDisposed(),l2(this,e,t)};ve().prototype.transpose=function(e){return this.throwIfDisposed(),ft(this,e)};ve().prototype.unique=function(e){return this.throwIfDisposed(),u2(this,e)};ve().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),Y0(this,e,t)};ve().prototype.unstack=function(e){return this.throwIfDisposed(),Nn(this,e)};ve().prototype.where=function(e,t){return this.throwIfDisposed(),pa(e,this,t)};ve().prototype.zerosLike=function(){return this.throwIfDisposed(),_t(this)};var Wo=class AF extends Error{constructor(t){super(t),Object.setPrototypeOf(this,AF.prototype)}},ii=class $F extends Error{constructor(t){super(t),Object.setPrototypeOf(this,$F.prototype)}},re=class RF extends Error{constructor(t){super(t),Object.setPrototypeOf(this,RF.prototype)}},bt=class DF extends Error{constructor(t){super(t),Object.setPrototypeOf(this,DF.prototype)}},HQ=class OF extends Error{constructor(t){super(t),Object.setPrototypeOf(this,OF.prototype)}},MF=class{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){let n=this.cache.keys().next().value;this.cache.delete(n)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){let n=this.cache.keys().next().value;this.cache.delete(n)}this.maxEntries=e}};function zu(e,t){if(Array.isArray(e)){let n=[];for(let a=0;a<t;a++)n=n.concat(e);return n}else{let n=new Array(t);return n.fill(e),n}}function ri(e,t){if(!e)throw new HQ(t)}function U$(e,t){let n=0;for(let a of e)a===t&&n++;return n}function sr(e){return e.length===1?e[0]:e}function Ut(e){return Array.isArray(e)?e:[e]}function Pi(e){let t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return t[0]!=="_"?t:"private"+t}function hu(e){return e.length<=1||e.indexOf("_")===-1?e:e.replace(/[_]+(\w|$)/g,(t,n)=>n.toUpperCase())}var ps={};function E2(e){if(e==null)return null;let t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function qS(e){if(!(e==null||typeof e!="object"))if(Array.isArray(e))e.forEach(t=>qS(t));else{let t=Object.keys(e);for(let n of t){let a=e[n];a!=null&&typeof a=="object"&&(!Array.isArray(a)&&a.type==="ndarray"&&typeof a.value=="number"?e[n]=a.value:qS(a))}}}function py(e,t={},n={},a="object",r=!1){if(typeof e=="string"){let s=e,i;if(s in n)i=n[s];else if(s in ps)i=ps[s];else if(i=t[s],i==null)throw new re(`Unknown ${a}: ${e}. This may be due to one of the following reasons:
1. The ${a} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${a} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return i}else{let s=e;if(s.className==null||s.config==null)throw new re(`${a}: Improper config format: ${JSON.stringify(s)}.
'className' and 'config' must set.`);let i=s.className,o,u;if(i in n?[o,u]=n[i]:i in ps?[o,u]=ps.className:i in t&&([o,u]=t[i]),o==null)throw new re(`Unknown ${a}: ${i}. This may be due to one of the following reasons:
1. The ${a} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${a} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(u!=null){let d={};for(let g of Object.keys(ps))d[g]=ps[g];for(let g of Object.keys(n))d[g]=n[g];let c=s.config;c.customObjects=d;let p=Object.assign({},ps);for(let g of Object.keys(n))ps[g]=n[g];qS(s.config);let m=u(o,s.config,n,r);return ps=Object.assign({},p),m}else{let d=Object.assign({},ps);for(let p of Object.keys(n))ps[p]=n[p];let c=new o(s.config);return ps=Object.assign({},d),c}}}function GQ(e,t){return e<t?-1:e>t?1:0}function Vb(e,t){return-1*GQ(e,t)}function Qo(e){if(e==null)return e;let t=[];for(let n of e)t.indexOf(n)===-1&&t.push(n);return t}function qQ(e){if(e==null)throw new re(`Invalid value in obj: ${JSON.stringify(e)}`);for(let t in e)if(e.hasOwnProperty(t))return!1;return!0}function fd(e,t,n){if(n!=null&&e.indexOf(n)<0)throw new re(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function C2(e,t,n=0,a=1/0){return ri(n>=0),ri(a>=n),Array.isArray(e)&&e.length>=n&&e.length<=a&&e.every(r=>typeof r===t)}function ha(e,t){Array.isArray(e)?(E.assert(e.length>0,()=>`${t} is unexpectedly an empty array.`),e.forEach((n,a)=>ha(n,`element ${a+1} of ${t}`))):E.assert(Number.isInteger(e)&&e>0,()=>`Expected ${t} to be a positive integer, but got ${FF(e)}.`)}function FF(e){return e===null?"null":Array.isArray(e)?"["+e.map(t=>FF(t)).join(",")+"]":typeof e=="string"?`"${e}"`:`${e}`}function KQ(e,t,n){let a=n!=null?n():E.now(),r;return(...s)=>{let i=n!=null?n():E.now();return i-a<t||(a=i,r=e(...s)),r}}function zF(e){return e==="relu"?"relu":e==="linear"?"linear":e==="elu"?"elu":null}var XQ=0;function LF(){return XQ++}var Hb={};function ax(e=""){return e in Hb||(Hb[e]=0),Hb[e]+=1,e+Hb[e].toString()}var YQ=["channelsFirst","channelsLast"],JQ=["nearest","bilinear"],ZQ=["valid","same","causal"],QQ=["max","avg"],eee=["sum","mul","concat","ave"],dh=new Map;function Dn(e){fd(YQ,"DataFormat",e)}function tee(e){fd(JQ,"InterpolationFormat",e)}function es(e){fd(ZQ,"PaddingMode",e)}function BF(e){fd(QQ,"PoolMode",e)}var jm=[],j$="/";function wu(e,t){jm.push(e);try{let n=t();return jm.pop(),n}catch(n){throw jm.pop(),n}}function nee(){return jm.length===0?"":jm.join(j$)+j$}function PF(e){if(!jF(e))throw new Error("Not a valid tensor name: '"+e+"'");return nee()+e}function UF(e){if(!jF(e))throw new Error("Not a valid tensor name: '"+e+"'");dh.has(e)||dh.set(e,0);let t=dh.get(e);if(dh.set(e,dh.get(e)+1),t>0){let n=`${e}_${t}`;return dh.set(n,1),n}else return e}var aee=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function jF(e){return!!e.match(aee)}function ree(e){return e===parseInt(e.toString(),10)}function el(e,t,n){t==null&&(t=0),n==null&&(n=e.length);let a=1;for(let r=t;r<n;++r)a*=e[r];return a}function Hh(e){if(e.length===0)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){let a=e[n];a<t&&(t=a)}return t}function ul(e){if(e.length===0)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){let a=e[n];a>t&&(t=a)}return t}function Ps(e,t){if(t<e)throw new re(`end (${t}) < begin (${e}) is forbidden.`);let n=[];for(let a=e;a<t;++a)n.push(a);return n}var eS;function Qn(){return eS==null&&(eS=l_().epsilon()),eS}function Us(){return"channelsLast"}function Yi(e,t){return Te(e,t)}function fy(e,t=-1){let n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),te(e,n)}function see(e,t){return ne(()=>{if(e.shape.length!==2)throw new re(`repeat() expects a rank-2 tensor, but received a rank-${e.shape.length} tensor.`);let n=fy(e,1);return KS(n,[1,t,1])})}function iee(e){let t=[el(e.shape)];return te(e,t)}function oee(e){if(e.rank<=1)throw new re(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);let t=[e.shape[0],el(e.shape,1)];return te(e,t)}function Su(e,t,n){return ne(()=>{switch(e.rank){case 1:return uy(e,t,n);case 2:return W0(e,[t,0],[n,e.shape[1]]);case 3:return cf(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return jh(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return wt(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return wt(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new re(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}})}function tS(e,t,n){return ne(()=>{switch(e.rank){case 1:return uy(e,t,n);case 2:return W0(e,[0,t],[e.shape[0],n]);case 3:return cf(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return jh(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new re(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function Gb(e,t,n,a){return ne(()=>{switch(e.rank){case 1:return uy(e,t,n);case 2:switch(a){case 1:return Su(e,t,n);case 2:return tS(e,t,n);default:throw new re(`The axis is not within the rank of the tensor ${a}`)}case 3:switch(a){case 1:return Su(e,t,n);case 2:return cf(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return tS(e,t,n);default:throw new re(`The axis is not within the rank of the tensor ${a}`)}case 4:switch(a){case 1:return Su(e,t,n);case 2:return jh(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return jh(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return tS(e,t,n);default:throw new re(`The axis is not within the rank of the tensor ${a}`)}default:throw new re(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function A2(e,t=-1){let n;return t<0&&(n=e[0].rank,n!==0?t=n:t=0),t===e[0].rank&&(t=-1),Yt(e,t)}function W$(e,t){switch(e.rank){case 1:return T_([e,t]);case 2:return E_([e,t],0);case 3:return C_([e,t],0);case 4:return A_([e,t],0);default:throw new re(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function KS(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new re(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return Er(e,t)}function rx(e,t=0,n=1,a,r){return F0(e,t,n,a,r)}function ci(e,t,n,a){if(e.rank<2||t.rank<2)throw new bt(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3){let r=e.shape.slice(-1)[0],s=t.shape.slice(-2)[0];if(r!==s)throw new bt(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`)}if(e.rank===2&&t.rank===2)return Vh.matMul({a:e,b:t,transposeA:!1,transposeB:!1,bias:a?XS(e.rank,a,Us()):null,activation:n});{let r=e.shape.slice(),s=r.pop();e=te(e,[-1,s]);let i=t.shape.slice(),o=i.pop(),u=i.pop(),d=[...i,o],c=Array.from({length:t.rank},(m,g)=>g===0?t.rank-2:g<=t.rank-2?g-1:g);t=te(ft(t,c),[u,-1]);let p=[...r,...d];return te(Vh.matMul({a:e,b:t,transposeA:!1,transposeB:!1,bias:a?XS(e.rank,a,Us()):null,activation:n}),p)}}function WF(e,t,n){return ne(()=>(Array.isArray(t)?t=Lt(t,"int32"):t=Te(t,"int32"),lf(e,t,n)))}function my(e){return Y(e,e)}function XS(e,t,n){let a=t.shape;if(t.rank!==1&&t.rank!==e)throw new re(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(e===5){if(n==="channelsFirst")return a.length===1?te(t,[1,a[0],1,1,1]):te(t,[1,a[3],a[0],a[1],a[2]]);if(n==="channelsLast")return a.length===1?te(t,[1,1,1,1,a[0]]):te(t,[1].concat(a))}else if(e===4){if(n==="channelsFirst")return a.length===1?te(t,[1,a[0],1,1]):te(t,[1,a[2],a[0],a[1]]);if(n==="channelsLast")return a.length===1?te(t,[1,1,1,a[0]]):te(t,[1].concat(a))}else if(e===3){if(n==="channelsFirst")return a.length===1?te(t,[1,a[0],1]):te(t,[1,a[1],a[0]]);if(n==="channelsLast")return a.length===1?te(t,[1,1,a[0]]):te(t,[1].concat(a))}else if(e<3)return t;throw new re(`Unsupported input rank by biasAdd: ${t.rank}`)}function Hs(e,t,n){return ne(()=>(n==null&&(n=Us()),Dn(n),ye(e,XS(e.rank,t,n))))}function lee(e,t=1){if(t!==1)throw new bt(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return rf(e)}function uee(e){return ne(()=>Le(e,ye(Ln(e),1)))}function VF(e,t,n,a){return ne(()=>h2(e,t,n,a))}function cee(e){return ne(()=>{let t=ye(.5,Y(.2,e));return za(t,0,1)})}function gy(e,t,n=!1){return n?e():t()}var dee=["fanIn","fanOut","fanAvg"],hee=["normal","uniform","truncatedNormal"];function pee(e){fd(dee,"FanMode",e)}function fee(e){fd(hee,"Distribution",e)}var Ss=class extends _e.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}},$2=class extends Ss{apply(e,t){return xn(e,t)}};$2.className="Zeros";_e.registerClass($2);var sx=class extends Ss{apply(e,t){return or(e,t)}};sx.className="Ones";_e.registerClass(sx);var R2=class extends Ss{constructor(e){if(super(),typeof e!="object")throw new re(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new re(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return ne(()=>Y(He(this.value),or(e,t)))}getConfig(){return{value:this.value}}};R2.className="Constant";_e.registerClass(R2);var D2=class extends Ss{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return _l(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}};D2.className="RandomUniform";_e.registerClass(D2);var O2=class extends Ss{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new bt(`randomNormal does not support dType ${t}.`);return rx(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};O2.className="RandomNormal";_e.registerClass(O2);var M2=class extends Ss{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new bt(`truncatedNormal does not support dType ${t}.`);return X0(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};M2.className="TruncatedNormal";_e.registerClass(M2);var F2=class extends Ss{constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,t){return ne(()=>{if(e.length!==2||e[0]!==e[1])throw new re("Identity matrix initializer can only be used for 2D square matrices.");return Y(this.gain,$0(e[0]))})}getConfig(){return{gain:this.gain}}};F2.className="Identity";_e.registerClass(F2);function mee(e,t="channelsLast"){let n,a;if(Dn(t),e.length===2)n=e[0],a=e[1];else if([3,4,5].indexOf(e.length)!==-1){if(t==="channelsFirst"){let r=el(e,2);n=e[1]*r,a=e[0]*r}else if(t==="channelsLast"){let r=el(e,0,e.length-2);n=e[e.length-2]*r,a=e[e.length-1]*r}}else{let r=el(e);n=Math.sqrt(r),a=Math.sqrt(r)}return[n,a]}var dr=class extends Ss{constructor(e){if(super(),e.scale<0)throw new re(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,pee(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,fee(this.distribution),this.seed=e.seed}apply(e,t){let n=mee(e),a=n[0],r=n[1],s=this.scale;if(this.mode==="fanIn"?s/=Math.max(1,a):this.mode==="fanOut"?s/=Math.max(1,r):s/=Math.max(1,(a+r)/2),this.distribution==="normal"){let i=Math.sqrt(s);if(t=t||"float32",t!=="float32"&&t!=="int32")throw new bt(`${this.getClassName()} does not support dType ${t}.`);return X0(e,0,i,t,this.seed)}else{let i=Math.sqrt(3*s);return _l(e,-i,i,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}};dr.className="VarianceScaling";_e.registerClass(dr);var ix=class extends dr{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return dr.className}};ix.className="GlorotUniform";_e.registerClass(ix);var ox=class extends dr{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return dr.className}};ox.className="GlorotNormal";_e.registerClass(ox);var lx=class extends dr{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return dr.className}};lx.className="HeNormal";_e.registerClass(lx);var ux=class extends dr{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return dr.className}};ux.className="HeUniform";_e.registerClass(ux);var cx=class extends dr{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return dr.className}};cx.className="LeCunNormal";_e.registerClass(cx);var dx=class extends dr{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return dr.className}};dx.className="LeCunUniform";_e.registerClass(dx);var z2=class extends Ss{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return ne(()=>{if(e.length<2)throw new bt("Shape must be at least 2D.");if(t!=="int32"&&t!=="float32"&&t!==void 0)throw new TypeError(`Unsupported data type ${t}.`);t=t;let n=E.sizeFromShape(e.slice(0,-1)),a=e[e.length-1],r=n*a;r>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${r}) elements: Slowness may result.`);let s=[Math.max(a,n),Math.min(a,n)],i=rx(s,0,1,t,this.seed),o=g2.qr(i,!1),u=o[0],d=o[1].flatten().stridedSlice([0],[Math.min(a,n)*Math.min(a,n)],[Math.min(a,n)+1]);return u=Y(u,d.sign()),n<a&&(u=u.transpose()),Y(He(this.gain),u.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}};z2.className="Orthogonal";_e.registerClass(z2);var V$={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function H$(e,t={}){return py(e,_e.SerializationMap.getMap().classNameMap,t,"initializer")}function wn(e){return E2(e)}function gn(e){if(typeof e=="string"){let t=e in V$?V$[e]:e;if(t==="GlorotNormal")return new ox;if(t==="GlorotUniform")return new ix;if(t==="HeNormal")return new lx;if(t==="HeUniform")return new ux;if(t==="LeCunNormal")return new cx;if(t==="LeCunUniform")return new dx;{let n={};return n.className=t,n.config={},H$(n)}}else return e instanceof Ss?e:H$(e)}function YS(e){return Array.isArray(e)&&Array.isArray(e[0])}function Av(e){return e.length===0?[]:Array.isArray(e[0])?e:[e]}function et(e){let t;if(Array.isArray(e)){if(e.length!==1)throw new re(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function $t(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(e.length===1)return e=e,e[0];throw new re(`Expected exactly 1 Shape; got ${e.length}`)}else return e}function $v(e){let t=0;for(let n of e)n.shape.length===0?t+=1:t+=n.shape.reduce((a,r)=>a*r);return t}var G$="Variable",HF=class{constructor(e,t="float32",n=G$,a=!0,r=null){this.dtype=t??"float32",this.shape=e.shape,this.id=LF(),n=n??G$,this.originalName=PF(n),this.name=UF(this.originalName),this.trainable_=a,this.constraint=r,this.val=c2(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),gee(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}};function gee(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}function JS(e){return e.map(t=>t.read())}function L2(e){e.forEach(t=>{t[0].write(t[1])})}var Bn=class{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}},js=class{constructor(e,t,n,a,r,s,i){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=a,this.callArgs=r,this.outputTensorIndex=i,this.id=LF(),s!=null&&(this.originalName=PF(s),this.name=UF(this.originalName)),this.rank=t.length}},yee=0,hx=class{constructor(e,t){this.callArgs=t,this.id=yee++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(let n of e.inboundLayers)n?.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){let e=[];for(let t of this.inboundLayers)t!=null?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},bee=0,vt=class extends _e.Serializable{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=bee++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){let n=this.getClassName();t=Pi(n)+"_"+ax(n)}if(this.name=t,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let n;if(e.batchInputShape!=null)n=e.batchInputShape;else if(e.inputShape!=null){let r=null;e.batchSize!=null&&(r=e.batchSize),n=[r].concat(e.inputShape)}this.batchInputShape=n;let a=e.dtype;a==null&&(a=e.inputDType),a==null&&(a="float32"),this.dtype=a}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(this.inboundNodes.length===0)throw new ii(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new re(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return sr(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return sr(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Wo(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new Wo(`Layer ${this.name} is not connected, no input to return.`);return sr(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new Wo(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Wo(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return sr(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){let t=Ut(e);if(this.inputSpec==null||this.inputSpec.length===0)return;let n=Ut(this.inputSpec);if(t.length!==n.length)throw new re(`Layer ${this.name} expects ${n.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let a=0;a<t.length;a++){let r=t[a],s=n[a];if(s==null)continue;let i=r.rank;if(s.ndim!=null&&i!==s.ndim)throw new re(`Input ${a} is incompatible with layer ${this.name}: expected ndim=${s.ndim}, found ndim=${i}`);if(s.maxNDim!=null&&i>s.maxNDim)throw new re(`Input ${a} is incompatible with layer ${this.name}: expected max_ndim=${s.maxNDim}, found ndim=${i}`);if(s.minNDim!=null&&i<s.minNDim)throw new re(`Input ${a} is incompatible with layer ${this.name}: expected min_ndim=${s.minNDim}, found ndim=${i}.`);if(s.dtype!=null&&r.dtype!==s.dtype)throw new re(`Input ${a} is incompatible with layer ${this.name} : expected dtype=${s.dtype}, found dtype=${r.dtype}.`);if(s.axes){let o=r.shape;for(let u in s.axes){let d=Number(u),c=s.axes[u],p=d>=0?o[d]:o[o.length+d];if(c!=null&&[c,null].indexOf(p)===-1)throw new re(`Input ${a} is incompatible with layer ${this.name}: expected axis ${d} of input shape to have value ${c} but got shape ${o}.`)}}if(s.shape!=null)for(let o=0;o<s.shape.length;++o){let u=s.shape[o],d=r.shape[o];if(u!=null&&d!=null&&u!==d)throw new re(`Input ${a} is incompatible with layer ${this.name}: expected shape=${s.shape}, found shape=${r.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){this._callHook!=null&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();let n=Ut(e),a=wee(e),r=See(e);if(a===r)throw new re("Arguments to apply() must be all SymbolicTensors or all Tensors");return wu(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);let s=[];for(let i of Ut(e))s.push(i.shape);this.build(sr(s)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&r&&(this._refCount=1)}if(this.assertInputCompatibility(e),r){let s=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,s);let i=Ut(s),o=[];for(let u of i)n.indexOf(u)!==-1&&(u=u.clone()),o.push(u);if(s=sr(o),this.activityRegularizer!=null)throw new bt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return s}else{let s=vee(e),i=this.computeOutputShape(s),o,u=xee(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?s[0]:s),i!=null&&i.length>0&&Array.isArray(i[0])?o=i.map((d,c)=>new js(u,d,this,Ut(e),t,this.name,c)):o=new js(u,i,this,Ut(e),t,this.name),this.addInboundNode(e,o,null,null,s,i,t),this._refCount++,this.activityRegularizer!=null)throw new bt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return o}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((n,a)=>{n!=null&&e[a]!=null&&e[a]!==n&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new Wo(`The layer ${this.name} has never been called and thus has no defined output shape.`);let e=[];for(let t of this.inboundNodes){let n=JSON.stringify(t.outputShapes);e.indexOf(n)===-1&&e.push(n)}if(e.length===1){let t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&t.length===1?t[0]:t}else throw new Wo(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new ii(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return $v(this.weights)}build(e){this.built=!0}getWeights(e=!1){return JS(e?this.trainableWeights:this.weights)}setWeights(e){ne(()=>{let t=this.weights;if(t.length!==e.length)throw new re(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(t.length===0)return;let n=[],a=JS(t);for(let r=0;r<a.length;++r){let s=a[r],i=t[r],o=e[r];if(!E.arraysEqual(s.shape,o.shape))throw new re(`Layer weight shape ${s.shape} not compatible with provided weight shape ${o.shape}`);n.push([i,o])}L2(n)})}addWeight(e,t,n,a,r,s,i,o){if(this._addedWeightNames.indexOf(e)!==-1)throw new re(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),n==null&&(n="float32"),this.fastWeightInitDuringBuild&&(a=o!=null?o():gn("zeros"));let u=a.apply(t,n),d=new HF(u,n,e,s,i);return u.dispose(),r!=null&&this.addLoss(()=>r.apply(d.read())),s==null&&(s=!0),s?this._trainableWeights.push(d):this._nonTrainableWeights.push(d),d}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=Ut(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(t!=null)if(Array.isArray(t))t.forEach(n=>{if(n!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return t}setMaskMetadata(e,t,n){if(!this.supportsMasking)return;let a=this.computeMask(e,n),r=Ut(t),s=Ut(a);if(r.length!==s.length)throw new Error(`${this.name} outputs ${r.length} tensors but ${r.length} masks for those tensors`);for(let i=0;i<r.length;i++)r[i].kerasMask=s[i]}addInboundNode(e,t,n,a,r,s,i=null){let o=Ut(e);t=Ut(t),n=Ut(n),a=Ut(a),r=Av(r),s=Av(s);let u=[],d=[],c=[];for(let p of o)u.push(p.sourceLayer),d.push(p.nodeIndex),c.push(p.tensorIndex);new hx({outboundLayer:this,inboundLayers:u,nodeIndices:d,tensorIndices:c,inputTensors:o,outputTensors:t,inputMasks:n,outputMasks:a,inputShapes:r,outputShapes:s},i);for(let p=0;p<t.length;p++)t[p].sourceLayer=this,t[p].nodeIndex=this.inboundNodes.length-1,t[p].tensorIndex=p}getConfig(){let e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount===0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}};function vee(e){e=Ut(e);let t=[];for(let n of e)t.push(n.shape);return sr(t)}function xee(e){return"float32"}function GF(e,t,n){if((t==null||n!=null&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),t.inboundNodes.length===0)return[e];{let a=t.inboundNodes[n];if(a.inboundLayers.length===0)return a.inputTensors;{let r=[];for(let s=0;s<a.inboundLayers.length;s++){let i=a.inputTensors[s],o=a.inboundLayers[s],u=a.nodeIndices[s],d=GF(i,o,u);for(let c of d)r.indexOf(c)===-1&&r.push(c)}return r}}}function wee(e){let t=!0;for(let n of Ut(e))if(!(n instanceof js)){t=!1;break}return t}function See(e){let t=!0;for(let n of Ut(e))if(n instanceof js){t=!1;break}return t}var hf=class extends vt{constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:ax("input").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new re("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(t==null){if(e.inputShape==null)throw new re("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new re("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");let n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];let a=new js(this.dtype,this.batchInputShape,this,[],{},this.name);a.nodeIndex=0,a.tensorIndex=0,new hx({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[a],outputTensors:[a],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new re(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}};hf.className="InputLayer";_e.registerClass(hf);function qF(e){if(e.batchShape==null&&e.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(e.batchShape!=null&&e.shape!=null)throw new re("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;e.shape!=null&&t==null&&(t=[null].concat(e.shape));let n=e.dtype;return n==null&&(n="float32"),new hf({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}function kee(e,t){if(e.dtype==null||e.dtype===t.dtype)return t;try{return Te(t,e.dtype)}catch{throw new re(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}var Th=class KF{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof KF)for(let n in t.id2Value)this.id2Value[n]=t.id2Value[n],n in t.id2Mask&&(this.id2Mask[n]=t.id2Mask[n]);else{if(t==null)return;for(let n of t)this.add(n.key,n.value)}}add(t,n,a){if(this.id2Value[t.id]==null)this.id2Value[t.id]=kee(t,n),this.name2Id[t.name]=t.id,a!=null&&(this.id2Mask[t.id]=a);else throw new re(`Duplicate key: name=${t.name}, id=${t.id}`);return this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return this.id2Value[t.id]!=null}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof js){if(this.id2Value[t.id]==null)throw new re(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}else{let n=this.name2Id[t];if(n==null)throw new re(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[n]}}getMask(t){if(t instanceof js){if(this.id2Value[t.id]==null)throw new re(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}else{let n=this.name2Id[t];if(n==null)throw new re(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[n]}}disposeMasks(){this.id2Mask!=null&&it(this.id2Mask)}},Rv=new MF,Dv=new MF;function _ee(e){Rv?.setMaxEntries(e),Dv?.setMaxEntries(e)}function Am(e,t,n,a){let r=n==null?!1:n.training,s=Array.isArray(e),i=s?e:[e],o=i.map(b=>b.name),u=[],d=t.names();for(let b of o)d.indexOf(b)!==-1?u.push(t.getValue(b)):u.push(null);let c=o.join(",")+"|"+t.names().sort().join(","),p=Rv.get(c),m;if(p==null){let b=Nee(i,t);p=b.sorted,m=b.recipientCounts,Rv.put(c,p),Dv.put(c,m)}m={},r||Object.assign(m,Dv.get(c));let g=new Th(t);for(let b=0;b<p.length;++b){let v=p[b],x=v.sourceLayer;if(x instanceof hf)continue;let w=[],k=[],N=[],I=!1;for(let B of v.inputs){let V=g.getValue(B),W=g.getMask(B);w.push(V),k.push(W),W!=null&&(I=!0),r||(m[B.name]--,m[B.name]===0&&!t.hasKey(B)&&o.indexOf(B.name)===-1&&!V.isDisposed&&B.sourceLayer.stateful!==!0&&N.push(V))}I&&(n=n||{},n.mask=k[0]);let T=Ut(x.apply(w,n)),$=null;x.supportsMasking&&($=x.computeMask(w,k));let D=Tee(v),M=Array.isArray(D)?D:[D];for(let B=0;B<M.length;++B){g.hasKey(M[B])||g.add(M[B],T[B],Array.isArray($)?$[0]:$);let V=o.indexOf(M[B].name);V!==-1&&(u[V]=T[B])}r||it(N)}return g.disposeMasks(),s?u:u[0]}function Nee(e,t){E.assert(e!=null&&e.length>0,()=>"Expected at least one fetch, got none");let n=[],a={};if(e.length===1){let r=q$(e[0],t);n=r.sorted,a=r.recipientMap}else{let r=new Set;for(let s of e){let{sorted:i,recipientMap:o}=q$(s,t);for(let u of i)r.has(u.name)||(n.push(u),r.add(u.name));for(let u in o)a[u]==null&&(a[u]=new Set),o[u].forEach(d=>a[u].add(d))}}return{sorted:n,recipientCounts:Iee(a)}}function Iee(e){let t={};for(let n in e)t[n]=e[n].size;return t}function q$(e,t){let n=new Set,a=[],r={};for(let o of t.names())n.add(o);let s=[],i=[];for(s.push(e);s.length>0;){let o=s[s.length-1];if(n.has(o.name)){s.pop();continue}let u=i[i.length-1]===s.length-1;if(o.inputs.length===0||u)s.pop(),a.push(o),n.add(o.name),u&&i.pop();else{i.push(s.length-1);for(let d of o.inputs)r[d.name]==null&&(r[d.name]=new Set),r[d.name].add(o.name),!n.has(d.name)&&s.push(d)}}return{sorted:a,recipientMap:r}}function Tee(e){let t;if(e.sourceLayer.inboundNodes.length===1)t=e.sourceLayer.output;else{let n=null;for(let a=0;a<e.sourceLayer.inboundNodes.length;++a)for(let r of e.sourceLayer.inboundNodes[a].outputTensors)if(r.id===e.id){n=a;break}t=e.sourceLayer.getOutputAt(n)}return t}var Eee=oe();Eee.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,_ee);var XF={};ot(XF,{maxNorm:()=>Cee,minMaxNorm:()=>Ree,nonNeg:()=>$ee,unitNorm:()=>Aee});function B2(e,t){return ne(()=>fa(Be(Y(e,e),t,!0)))}var yy=class extends _e.Serializable{getConfig(){return{}}},P2=class extends yy{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return ne(()=>{let t=B2(e,this.axis),n=za(t,0,this.maxValue);return Y(e,Le(n,ye(Qn(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}};P2.className="MaxNorm";_e.registerClass(P2);var U2=class extends yy{constructor(e){super(),this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return ne(()=>Le(e,ye(Qn(),B2(e,this.axis))))}getConfig(){return{axis:this.axis}}};U2.className="UnitNorm";_e.registerClass(U2);var j2=class extends yy{apply(e){return jt(e)}};j2.className="NonNeg";_e.registerClass(j2);var W2=class extends yy{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return ne(()=>{let t=B2(e,this.axis),n=ye(Y(this.rate,za(t,this.minValue,this.maxValue)),Y(1-this.rate,t));return Y(e,Le(n,ye(Qn(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}};W2.className="MinMaxNorm";_e.registerClass(W2);var K$={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function ta(e){return E2(e)}function X$(e,t={}){return py(e,_e.SerializationMap.getMap().classNameMap,t,"constraint")}function na(e){if(e==null)return null;if(typeof e=="string"){let t={className:e in K$?K$[e]:e,config:{}};return X$(t)}else return e instanceof yy?e:X$(e)}function Cee(e){return new P2(e)}function Aee(e){return new U2(e)}function $ee(){return new j2}function Ree(e){return new W2(e)}var YF={};ot(YF,{constant:()=>Mee,glorotNormal:()=>jee,glorotUniform:()=>Uee,heNormal:()=>Wee,heUniform:()=>Vee,identity:()=>Bee,leCunNormal:()=>Hee,leCunUniform:()=>Gee,ones:()=>Oee,orthogonal:()=>qee,randomNormal:()=>zee,randomUniform:()=>Fee,truncatedNormal:()=>Lee,varianceScaling:()=>Pee,zeros:()=>Dee});function Dee(){return new $2}function Oee(){return new sx}function Mee(e){return new R2(e)}function Fee(e){return new D2(e)}function zee(e){return new O2(e)}function Lee(e){return new M2(e)}function Bee(e){return new F2(e)}function Pee(e){return new dr(e)}function Uee(e){return new ix(e)}function jee(e){return new ox(e)}function Wee(e){return new lx(e)}function Vee(e){return new ux(e)}function Hee(e){return new cx(e)}function Gee(e){return new dx(e)}function qee(e){return new z2(e)}var JF={};ot(JF,{Layer:()=>vt,RNN:()=>ro,RNNCell:()=>vy,activation:()=>_ne,add:()=>Dne,alphaDropout:()=>gae,average:()=>One,averagePooling1d:()=>tI,averagePooling2d:()=>nI,averagePooling3d:()=>aI,avgPool1d:()=>Wne,avgPool2d:()=>Hne,avgPool3d:()=>qne,avgPooling1d:()=>Vne,avgPooling2d:()=>Gne,avgPooling3d:()=>Kne,batchNormalization:()=>Pne,bidirectional:()=>lae,categoryEncoding:()=>wae,centerCrop:()=>vae,concatenate:()=>Mne,conv1d:()=>mne,conv2d:()=>gne,conv2dTranspose:()=>yne,conv3d:()=>bne,conv3dTranspose:()=>vne,convLstm2d:()=>rae,convLstm2dCell:()=>sae,cropping2D:()=>wne,dense:()=>Nne,depthwiseConv2d:()=>kne,dot:()=>Bne,dropout:()=>Ine,elu:()=>une,embedding:()=>Rne,flatten:()=>Ene,gaussianDropout:()=>mae,gaussianNoise:()=>fae,globalAveragePooling1d:()=>Xne,globalAveragePooling2d:()=>Yne,globalMaxPool1d:()=>cae,globalMaxPool2d:()=>dae,globalMaxPooling1d:()=>Q3,globalMaxPooling2d:()=>ez,gru:()=>Zne,gruCell:()=>Qne,input:()=>m3,inputLayer:()=>lne,layerNormalization:()=>Une,leakyReLU:()=>dne,lstm:()=>eae,lstmCell:()=>tae,masking:()=>yae,maxPool1d:()=>hae,maxPool2d:()=>pae,maxPooling1d:()=>tz,maxPooling2d:()=>nz,maxPooling3d:()=>Jne,maximum:()=>Fne,minimum:()=>zne,multiply:()=>Lne,permute:()=>$ne,prelu:()=>hne,randomWidth:()=>Sae,reLU:()=>cne,repeatVector:()=>Cne,rescaling:()=>bae,reshape:()=>Ane,resizing:()=>xae,rnn:()=>iae,separableConv2d:()=>xne,simpleRNN:()=>nae,simpleRNNCell:()=>aae,softmax:()=>pne,spatialDropout1d:()=>Tne,stackedRNNCells:()=>oae,thresholdedReLU:()=>fne,timeDistributed:()=>uae,upSampling2d:()=>Sne,zeroPadding2d:()=>jne});async function Uo(e){if(e==null)return;let t=[],n=[],a=[];for(let r in e){let s=e[r];if(typeof s!="number"){let i=s;t.push(i.data()),n.push(r),a.push(i)}}if(t.length>0){let r=await Promise.all(t);for(let s=0;s<r.length;++s)e[n[s]]=r[s][0];it(a)}}function ZF(e){if(e!=null)for(let t in e){let n=e[t];typeof n!="number"&&n.dispose()}}var Y$;(function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"})(Y$||(Y$={}));var Kee=125,Gh=class{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}},QF=class{constructor(e,t=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(let t of this.callbacks)t.setParams(e)}setModel(e){for(let t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){e==null&&(e={});for(let t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(let t of this.callbacks)await t.onTrainEnd(e)}},Xee=class extends Gh{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){t==null&&(t={});let n=t.size==null?0:t.size;this.seen+=n;for(let a in t){let r=t[a];if(typeof r=="number")this.totals.hasOwnProperty(a)||(this.totals[a]=0),this.totals[a]=this.totals[a]+r*n;else{let s;a in this.totals?s=this.totals[a]:this.totals[a]=0;let i=ne(()=>ye(this.totals[a],Y(r,n)));this.totals[a]=i,s?.dispose()}}}async onEpochEnd(e,t){if(t!=null)for(let n of this.params.metrics)this.totals[n]!=null&&(typeof this.totals[n]=="number"?t[n]=this.totals[n]/this.seen:ne(()=>{let a=Y(Le(1,this.seen),this.totals[n]);t[n]=a,this.totals[n].dispose(),Zn(t[n])}))}},e3=class extends Gh{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){t==null&&(t={}),this.epoch.push(e);for(let n in t)this.history[n]==null&&(this.history[n]=[]),this.history[n].push(t[n])}async syncData(){let e=[],t=[],n=[];for(let r in this.history){let s=this.history[r];for(let i=0;i<s.length;++i)if(typeof s[i]!="number"){let o=s[i];e.push(o.data()),t.push(r),n.push(i)}}let a=await Promise.all(e);for(let r=0;r<a.length;++r)this.history[t[r]][n[r]].dispose(),this.history[t[r]][n[r]]=a[r][0]}},t3=class extends Gh{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||I2,this.yieldEvery=t||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=Kee),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");E.isNumber(this.yieldEvery)&&(this.maybeWait=KQ(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){let a=[];this.yield!=null&&(await Uo(n),a.push(this.yield(e,t,n))),a.push(this.nextFrameFunc()),await Promise.all(a)}async onEpochBegin(e,t){this.currentEpoch=e,this.epochBegin!=null&&(await Uo(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){let n=[];this.epochEnd!=null&&(await Uo(t),n.push(this.epochEnd(e,t))),this.yieldEvery==="epoch"&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){this.batchBegin!=null&&(await Uo(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){let n=[];this.batchEnd!=null&&(await Uo(t),n.push(this.batchEnd(e,t))),this.yieldEvery==="batch"?n.push(this.nextFrameFunc()):E.isNumber(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){this.trainBegin!=null&&(await Uo(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await Uo(e),await this.trainEnd(e))}};function n3(e,t){return e==null&&(e={}),e instanceof Gh?[e]:Array.isArray(e)&&e[0]instanceof Gh?e:Ut(e).map(n=>new t3(n,t))}var V2=class ei{constructor(){}static registerCallbackConstructor(t,n){E.assert(t>=0&&Number.isInteger(t),()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`),ei.checkForDuplicate(n),ei.constructors[t]==null&&(ei.constructors[t]=[]),ei.constructors[t].push(n)}static checkForDuplicate(t){for(let n in ei.constructors)ei.constructors[+n].forEach(a=>{if(a===t)throw new re("Duplicate callback constructor.")})}static clear(){ei.constructors={}}static createCallbacks(t){let n=[];for(let a in ei.constructors){let r=+a;t>=r&&n.push(...ei.constructors[r])}return n.map(a=>new a)}};V2.constructors={};function a3(e,t,n,a,r,s,i,o,u){let d=new e3,c=[new Xee,...V2.createCallbacks(t)];e!=null&&c.push(...e),c.push(d);let p=new QF(c);return p.setParams({epochs:n,initialEpoch:a,samples:r,steps:s,batchSize:i,verbose:t,doValidation:o,metrics:u}),{callbackList:p,history:d}}function zs(e,t={},n=!1){return py(e,_e.SerializationMap.getMap().classNameMap,t,"layer",n)}function Ov(e,t){return ne(()=>{e.dtype!=="float32"&&(e=Te(e,"float32"));let n=Be(my(e),t,!0),a=Cr(n.shape,Qn()),r=fa(gi(n,a));return Le(e,r)})}function md(e,t){return ne(()=>vn(my(Fe(t,e)),-1))}function px(e,t){return ne(()=>vn(Ln(Fe(t,e)),-1))}function pf(e,t){return ne(()=>{let n=Fe(e,t),a=za(Ln(e),Qn(),Number.MAX_VALUE),r=Ln(Le(n,a));return Y(100,vn(r,-1))})}function Yee(e,t){return ne(()=>{let n=za(t,Qn(),Number.MAX_VALUE),a=$r(ye(1,n)),r=za(e,Qn(),Number.MAX_VALUE),s=$r(ye(1,r));return vn(my(Fe(a,s)),-1)})}function Jee(e,t){return ne(()=>{let n=gi(0,Fe(1,Y(e,t)));return vn(my(n),-1)})}function Zee(e,t){return ne(()=>{let n=gi(0,Fe(1,Y(e,t)));return vn(n,-1)})}function Qee(e,t){return ne(()=>{let n=Be(Y(e,t),-1),a=Yr(Y(Fe(1,e),t),-1);return gi(0,ye(1,Fe(a,n)))})}function ete(e,t){return ne(()=>{let n=Math.log(2),a=Fe(t,e),r=Fe(ye(a,hd(Y(-2,a))),n);return vn(r,-1)})}function rg(e,t,n=!1){return ne(()=>{if(n)t=Nl(t);else{let a=Be(t,t.shape.length-1,!0);t=Le(t,a)}return t=za(t,Qn(),1-Qn()),un(Be(Y(Te(e,"float32"),$r(t)),t.shape.length-1))})}function Mv(e,t,n=!1){return ne(()=>{let a=Te(of(iee(e)),"int32");t=za(t,Qn(),1-Qn());let r=t.shape,s=te(Ph(a,r[r.length-1]),r);return rg(s,t,n)})}function tte(e,t){if(!E.arraysEqual(e.shape,t.shape))throw new re(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return ne(()=>{let n=jt(t),a=un(Ln(t));return ye(Fe(n,Y(t,e)),ay(La(a)))})}function fx(e,t){return ne(()=>{let n;return n=za(t,Qn(),1-Qn()),n=$r(Le(n,Fe(1,n))),vn(tte(e,n),-1)})}function nte(e,t){return ne(()=>{let n=za(e,Qn(),1),a=za(t,Qn(),1);return Be(Y(e,$r(Le(n,a))),-1)})}function ate(e,t){return ne(()=>{let n=$r(ye(Qn(),t));return vn(Fe(t,Y(e,n)),-1)})}function H2(e,t){return ne(()=>{let n=Ov(e,-1),a=Ov(t,-1),r=Y(n,a);return un(Be(r,-1))})}var Fv={meanSquaredError:md,meanAbsoluteError:px,meanAbsolutePercentageError:pf,meanSquaredLogarithmicError:Yee,squaredHinge:Jee,hinge:Zee,categoricalHinge:Qee,logcosh:ete,categoricalCrossentropy:rg,sparseCategoricalCrossentropy:Mv,binaryCrossentropy:fx,kullbackLeiblerDivergence:nte,poisson:ate,cosineProximity:H2};function nS(e){if(typeof e=="string"){if(e in Fv)return Fv[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new re(t)}else return e}function G2(e,t){return ne(()=>{let n=Y(.5,Rr(t)),a=Yi(Qa(t,n),e.dtype);return vn(Ar(e,a),-1)})}function q2(e,t){return ne(()=>Yi(Ar(Ru(e,-1),Ru(t,-1)),"float32"))}function r3(e,t){return ne(()=>Te(Be(bs(Ar(e,1),Ar(t,1))),"float32"))}function rte(e,t){return ne(()=>Te(Be(bs(Ar(e,1),Ar(t,0))),"float32"))}function ste(e,t){return ne(()=>Te(Be(bs(Ar(e,0),Ar(t,1))),"float32"))}function s3(e,t){return ne(()=>{let n=r3(e,t),a=ste(e,t),r=ye(n,a);return Te(pa(Qa(r,0),Le(n,r),0),"float32")})}function ite(e,t){return ne(()=>{let n=r3(e,t),a=rte(e,t),r=ye(n,a);return Te(pa(Qa(r,0),Le(n,r),0),"float32")})}function i3(e,t){return fx(e,t)}function o3(e,t){return e.rank===t.rank&&(e=Il(e,[e.rank-1])),t=Ru(t,-1),t.dtype!==e.dtype&&(t=Te(t,e.dtype)),Te(Ar(e,t),"float32")}function ote(e,t){return ne(()=>{let n=e.sub(t).square().sum(),a=e.sub(e.mean()).square().sum();return He(1).sub(n.div(a))})}var lte=md,ute=md,cte=px,dte=px,hte=pf,pte=pf,K2=rg,fte=H2,l3=Mv,zv={binaryAccuracy:G2,categoricalAccuracy:q2,precision:s3,categoricalCrossentropy:K2,sparseCategoricalCrossentropy:l3,mse:lte,MSE:ute,mae:cte,MAE:dte,mape:hte,MAPE:pte,cosine:fte};function mte(e){if(typeof e=="string"&&e in zv)return zv[e];if(typeof e!="string"&&e!=null)return e;throw new re(`Unknown metric ${e}`)}function qb(e){if(ri(e!==null,`Unknown LossOrMetricFn ${e}`),typeof e=="string")return e;{let t;for(let n of Object.keys(Fv))if(Fv[n]===e){t=n;break}if(t!==void 0)return t;for(let n of Object.keys(zv))if(zv[n]===e){t=n;break}return t!==void 0?t:e.name}}function gte(e){let t={Adagrad:()=>ou.adagrad(.01),Adadelta:()=>ou.adadelta(1,.95,Qn()),Adam:()=>ou.adam(.001,.9,.999,Qn()),Adamax:()=>ou.adamax(.002,.9,.999,Qn(),0),RMSProp:()=>ou.rmsprop(.001,.9,0,Qn()),SGD:()=>ou.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new re(`Unknown Optimizer ${e}`)}function J$(e,t,n=!1){if(e==null||typeof e!="object"||Object.getPrototypeOf(e)!==Object.prototype||!ZS(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){let a=JSON.stringify(e);a.length>1048576&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${a.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function ZS(e){if(e===null)return!0;if(typeof e=="object")if(Object.getPrototypeOf(e)===Object.prototype){let t=Object.keys(e);for(let n of t)if(typeof n!="string"||!ZS(e[n]))return!1;return!0}else if(Array.isArray(e)){for(let t of e)if(!ZS(t))return!1;return!0}else return!1;else{let t=typeof e;return t==="string"||t==="number"||t==="boolean"}}function yte(e,t,n,a=console.log){let r=vte(e),s=["Layer (type)","Input Shape","Output shape","Param #"];r?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map(c=>Math.floor(t*c)));let i;if(!r){s.push("Receives inputs"),i=[];for(let c in e.nodesByDepth)i.push(...e.nodesByDepth[c])}a("_".repeat(t)),Lv(s,n,a),a("=".repeat(t));let o=e.layers;for(let c=0;c<o.length;++c)r?xte(o[c],n,a):wte(o[c],n,i,a),a((c===o.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();let u=bte(e),d=$v(e.nonTrainableWeights);a(`Total params: ${u+d}`),a(`Trainable params: ${u}`),a(`Non-trainable params: ${d}`),a("_".repeat(t))}function bte(e){let t;return e.collectedTrainableWeights!=null?t=$v(e.collectedTrainableWeights):t=$v(e.trainableWeights),t}function vte(e){let t=!0,n=[],a=[];for(let r in e.nodesByDepth)n.push(e.nodesByDepth[r]);for(let r of n){if(r.length>1||r.length===1&&r[0].inboundLayers.length>1){t=!1;break}a.push(...r)}if(t)for(let r of e.layers){let s=!1;for(let i of r.inboundNodes)if(a.indexOf(i)!==-1)if(s){t=!1;break}else s=!0;if(!t)break}return t}function Lv(e,t,n=console.log){let a="";for(let r=0;r<e.length;++r)r>0&&(a=a.slice(0,a.length-1)+" "),a+=e[r],a=a.slice(0,t[r]),a+=" ".repeat(t[r]-a.length);n(a)}function xte(e,t,n){let a,r;try{r=e.inboundNodes.map(u=>JSON.stringify(u.inputShapes)).join(",")}catch{r="multiple"}try{a=JSON.stringify(e.outputShape)}catch{a="multiple"}let s=e.name,i=e.getClassName(),o=[`${s} (${i})`,r,a,e.countParams().toString()];Lv(o,t,n)}function wte(e,t,n,a){let r,s;try{s=e.inboundNodes.map(p=>JSON.stringify(p.inputShapes)).join(",")}catch{s="multiple"}try{r=JSON.stringify(e.outputShape)}catch{r="multiple"}let i=[];for(let p of e.inboundNodes)if(!(n!=null&&n.length>0&&n.indexOf(p)===-1))for(let m=0;m<p.inboundLayers.length;++m){let g=p.inboundLayers[m].name,b=p.nodeIndices[m],v=p.tensorIndices[m];i.push(`${g}[${b}][${v}]`)}let o=e.name,u=e.getClassName(),d=i.length===0?"":i[0],c=[`${o} (${u})`,s,r,e.countParams().toString(),d];Lv(c,t,a);for(let p=1;p<i.length;++p)Lv(["","","","",i[p]],t,a)}function u3(e,t,n){return(e==="inboundNodes"||e==="outputLayers"||e==="inputLayers")&&t===0&&typeof n=="string"}function sg(e,t){if(e===null)return null;if(typeof e=="string")return hu(e);if(typeof e=="number"||typeof e=="boolean")return e;if(e instanceof Array){let n=[],a=e.length;for(let r=0;r<a;++r){let s=e[r];u3(t,r,s)?n.push(s):n.push(sg(s,t))}return n}else{let n={};for(let a of Object.keys(e)){let r=e[a];if(a==="name"&&typeof r=="string")n[a]=r;else{let s=hu(a);n[s]=sg(r,s)}}return n}}function QS(e,t){if(e==null)return null;if(typeof e=="string")return Pi(e);if(typeof e=="number"||typeof e=="boolean")return e;if(e instanceof Array){let n=[],a=e.length;for(let r=0;r<a;++r){let s=e[r];u3(t,r,s)?n.push(s):n.push(QS(s,t))}return n}else{let n={};for(let a of Object.keys(e)){let r=e[a],s=Pi(a);(a==="name"||a==="className")&&typeof r=="string"?n[s]=r:n[s]=QS(r,a)}return n}}var X2="4.22.0",Ste=e=>{let t=Object.keys(e);if(t.length===0)return!1;let n=t[0].split("/");return!isNaN(parseInt(n[n.length-1],10))},kte=class ti extends vt{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,this.name==null){let k=this.getClassName().toLowerCase();this.name=ax(k)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],Qo(this.inputs).length!==this.inputs.length)throw new re(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(k=>k.name)}`);Qo(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(k=>k.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(let k of this.outputs){let N=k.sourceLayer,I=k.nodeIndex,T=k.tensorIndex;this.outputLayers.push(N),this.outputLayersNodeIndices.push(I),this.outputLayersTensorIndices.push(T)}for(let k of this.inputs){let N=k.sourceLayer,I=k.nodeIndex,T=k.tensorIndex;ri(I===0,"input layer has >1 nodes"),ri(T===0,"input layer has >1 tensors"),this.inputLayers.push(N),this.inputLayersNodeIndices.push(I),this.inputLayersTensorIndices.push(T)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let k=0;k<this.inputLayers.length;k++){let N=this.inputLayers[k];if(!(N instanceof hf))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${k} (0-based) originates from layer type ${N.getClassName()}.`);this.inputNames.push(N.name),this.feedInputShapes.push(N.batchInputShape),this.feedInputNames.push(N.name)}for(let k of this.outputLayers)this.outputNames.push(k.name);this.internalInputShapes=this.inputs.map(k=>k.shape),this.internalOutputShapes=this.outputs.map(k=>k.shape);let n={},a={},r={},s={},i={},o=[],u=(k,N,I,T,$,D)=>{(T==null||$==null||D==null)&&(T=k.sourceLayer,$=k.nodeIndex,D=k.tensorIndex);let M=T.inboundNodes[$];if(I.indexOf(M)!==-1)throw new ii(`The tensor ${k.name} at layer "${T.name}" is part of a cycle.`);if(N.indexOf(M)!==-1)return;this.containerNodes.add(ti.nodeKey(T,$)),T.id in i||(i[T.id]=Object.keys(i).length),I.indexOf(M)===-1&&I.push(M);let B=M.inboundLayers.length;for(let V=0;V<B;V++){let W=M.inputTensors[V],R=M.inboundLayers[V],H=M.nodeIndices[V],Z=M.tensorIndices[V];u(W,N,I,R,H,Z)}for(N.push(M);I.indexOf(M)>=0;)I.splice(I.indexOf(M),1);o.push(M)},d=[],c=[];for(let k of this.outputs)u(k,d,c);let p=o.slice().reverse();for(let k of p){a[k.id]=k,k.id in n||(n[k.id]=0);let N=n[k.id],I=r[k.outboundLayer.id]==null?0:r[k.outboundLayer.id];N=Math.max(N,I),r[k.outboundLayer.id]=N,s[k.outboundLayer.id]=k.outboundLayer,n[k.id]=N;for(let T=0;T<k.inboundLayers.length;T++){let $=k.inboundLayers[T],D=k.nodeIndices[T],M=$.inboundNodes[D],B=n[M.id]==null?0:n[M.id];n[M.id]=Math.max(N+1,B),a[M.id]=M}}let m={};for(let k in n){let N=n[k];N in m||(m[N]=[]),m[N].push(a[k])}let g={};for(let k in r){let N=r[k];N in g||(g[N]=[]),g[N].push(s[k])}let b=Object.keys(g).map(k=>parseInt(k,10)).sort(Vb);this.layers=[];for(let k of b){let N=g[k];N.sort((I,T)=>{let $=i[I.id],D=i[T.id];return $<D?-1:$>D?1:0});for(let I of N)I instanceof ti&&this.internalContainerRefs.push(I),this.layers.push(I)}this.layersByDepth=g,b=Object.keys(m).map(k=>parseInt(k,10)).sort(Vb);let v=this.inputs.slice(),x=[];for(let k of b)for(let N of m[k]){let I=N.outboundLayer;if(I!=null){for(let T of N.inputTensors)if(v.indexOf(T)===-1)throw new ii(`Graph disconnected: cannot obtain value for tensor ${T} at layer "${I.name}". The following previous layers were accessed without issue: ${x}`);for(let T of N.outputTensors)v.push(T);x.push(I.name)}}this.nodesByDepth=m;let w=this.layers.map(k=>k.name);for(let k of w){let N=w.filter(I=>I===k).length;if(N!==1)throw new ii(`The name "${k}" is used ${N} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(w))}this.outboundNodes=[],this.inboundNodes=[],new hx({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(k=>null),outputMasks:this.outputs.map(k=>null),inputShapes:this.inputs.map(k=>k.shape),outputShapes:this.outputs.map(k=>k.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();let t={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(let n of this.layers)t.numDisposedVariables+=n.dispose().numDisposedVariables;for(let n of this.internalContainerRefs)t.numDisposedVariables+=n.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(n=>{n._trainableWeights.forEach(a=>a.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new re("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(let n of this.layers)t=t.concat(n.trainableWeights);return t}get nonTrainableWeights(){let t=[];for(let n of this.layers)t.push(...n.nonTrainableWeights);if(!this.trainable){let n=[];for(let a of this.layers)n.push(...a.trainableWeights);return n.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,n=!0){let a={},r=0,s=Ste(t);s&&this.parseWeights(t);for(let o of this.layers)for(let[u,d]of o.weights.entries()){let c=s?`${d.name.split("/").slice(0,-1).join("/")+"/"}${u}`:d.originalName;if(a[c]!=null)throw new re(`Duplicate weight name: ${c}`);a[c]=d,r++}let i=[];for(let o in t){let u=o;if(a[o]==null){let d=o.split("/");u=d.slice(0,-2).concat([d[d.length-1]]).join("/")}if(a[u]!=null)i.push([a[u],t[o]]);else if(n)throw new re(`Provided weight data has no target variable: ${o}`);delete a[u]}if(n){let o=[];for(let u in a)o.push(u);if(o.length>0)throw new re(`${o.length} of ${r} weights are not set: ${o}`)}L2(i)}parseWeights(t){for(let n in Object.keys(t)){let a=n.split("/"),r=["vars","layer_checkpoint_dependencies"],s=a.map(i=>i.startsWith("_")?i.slice(1):i).filter(i=>!r.includes(i)).join("/");s!==n&&(t[s]=t[n],delete t[n])}}updatedConfig(){let t=this.getConfig(),n={};return n.className=this.getClassName(),n.config=t,n.kerasVersion=`tfjs-layers ${X2}`,n.backend="TensorFlow.js",n}toJSON(t,n=!0){let a=QS(this.updatedConfig());return n?JSON.stringify(a):a}call(t,n){return ne(()=>{t=Ut(t);let a=new Th;for(let r=0;r<this.inputs.length;++r)a.add(this.inputs[r],t[r]);return Am(this.outputs,a,n)})}computeMask(t,n){return ne(()=>{t=Ut(t);let a;return n==null?a=zu(null,t.length):a=Ut(n),this.runInternalGraph(t,a)[1]})}computeOutputShape(t){let n=Av(t);if(n.length!==this.inputLayers.length)throw new re(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);let a={};for(let o=0;o<n.length;o++){let u=this.inputLayers[o],d=n[o],c=u.name+"_0_0";a[c]=d}let r=Object.keys(this.nodesByDepth).map(o=>parseInt(o,10)).sort(Vb);if(r.length>1)for(let o of r){let u=this.nodesByDepth[o];for(let d of u){let c=d.outboundLayer;if(this.inputLayers.map(v=>v.id).indexOf(c.id)!==-1)continue;let p=[];for(let v=0;v<d.inboundLayers.length;v++){let x=d.inboundLayers[v],w=d.nodeIndices[v],k=d.tensorIndices[v],N=`${x.name}_${w}_${k}`,I=a[N];p.push(I)}let m=c.computeOutputShape(sr(p)),g=Av(m),b=c.inboundNodes.indexOf(d);for(let v=0;v<g.length;v++){let x=`${c.name}_${b}_${v}`;a[x]=g[v]}}}let s=[],i=[];for(let o=0;o<this.outputLayers.length;o++){let u=this.outputLayers[o],d=this.outputLayersNodeIndices[o],c=this.outputLayersTensorIndices[o],p=`${u.name}_${d}_${c}`;i.push(p)}for(let o=0;o<i.length;o++){let u=i[o];ri(u in a),s.push(a[u])}return sr(s)}runInternalGraph(t,n){n==null&&(n=zu(null,t.length));let a={};for(let u=0;u<this.inputs.length;++u){let d=this.inputs[u],c=t[u],p=n[u];a[d.id]=[c,p]}let r=Object.keys(this.nodesByDepth).map(u=>parseInt(u,10)).sort(Vb);for(let u of r){let d=this.nodesByDepth[u];for(let c of d){let p=c.outboundLayer,m=c.inputTensors,g=c.outputTensors,b=new Array;for(let v of m)v.id in a&&b.push(a[v.id]);if(b.length===m.length){let v={},x,w,k,N;if(c.callArgs!=null&&(v=c.callArgs),b.length===1){let[I,T]=b[0];v.mask==null&&(v.mask=T),k=Ut(p.call(I,v)),N=Ut(p.computeMask(I,T)),x=[I],w=[T]}else x=b.map(I=>I[0]),w=b.map(I=>I[1]),v.mask==null&&(v.mask=w),k=Ut(p.call(x,v)),N=Ut(p.computeMask(x,w));if(p.activityRegularizer)throw new bt("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let I=0;I<g.length;++I){let T=g[I],$=k[I],D=N[I];a[T.id]=[$,D]}}}}let s=[],i=[],o=[];for(let u of this.outputs){ri(u.id in a,`Could not compute output ${u.name} : ${u.id}`);let[d,c]=a[u.id];o.push(d.shape),s.push(d),i.push(c)}return[s,i,o]}buildNodeConversionMap(t){let n={},a;for(let r of this.layers){a=r instanceof ti?1:0;for(let s=0;s<r.inboundNodes.length;s++){let i=ti.nodeKey(r,s);this.containerNodes.has(i)&&(n[i]=a,a+=1)}}return n}getLayer(t,n){if(n!=null)return this.findLayer(n);if(t==null)throw new re("Provide either a layer name or layer index");if(typeof t=="number")return this.findLayer(t);for(let a of this.layers)if(a.name===t)return a;throw new re(`No such layer: ${t}`)}findLayer(t){if(this.layers.length<=t)throw new re(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}calculateLosses(){return ne(()=>{let t=[];for(let n of this.layers)for(let a=0;a<n.inboundNodes.length;++a){let r=ti.nodeKey(n,a);this.containerNodes.has(r)&&t.push(...n.calculateLosses())}return t})}getConfig(){let t={name:this.name},n=this.buildNodeConversionMap(this.layers),a=[];for(let i of this.layers){let o=i.getClassName(),u=i.getConfig(),d=[];for(let p=0;p<i.inboundNodes.length;p++){let m=i.inboundNodes[p],g=ti.nodeKey(i,p),b={};if(this.containerNodes.has(g)){if(m.callArgs)try{JSON.stringify(m.callArgs),b=m.callArgs}catch{console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: ${m.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),b={}}if(m.inboundLayers.length>0){let v=[];for(let x=0;x<m.inboundLayers.length;x++){let w=m.inboundLayers[x],k=m.nodeIndices[x],N=m.tensorIndices[x],I=ti.nodeKey(w,k),T=n[I];T==null&&(T=0),v.push([w.name,T,N,b])}d.push(v)}}}let c={};c.name=i.name,c.className=o,c.config=u,c.inboundNodes=d,a.push(c)}t.layers=a;let r=[];for(let i=0;i<this.inputLayers.length;i++){let o=this.inputLayers[i],u=this.inputLayersNodeIndices[i],d=ti.nodeKey(o,u);if(!this.containerNodes.has(d))continue;let c=n[d];c==null&&(c=0);let p=this.inputLayersTensorIndices[i];r.push([o.name,c,p])}t.inputLayers=r;let s=[];for(let i=0;i<this.outputLayers.length;i++){let o=this.outputLayers[i],u=this.outputLayersNodeIndices[i],d=ti.nodeKey(o,u);if(!this.containerNodes.has(d))continue;let c=n[d];c==null&&(c=0);let p=this.outputLayersTensorIndices[i];s.push([o.name,c,p])}return t.outputLayers=s,t}static fromConfig(t,n,a={},r=!1){let s={},i={};function o(x,w){x.name in i?i[x.name].push(w):i[x.name]=[w]}function u(x,w){let k=[],N;for(let I of w){let T=I[0],$=I[1],D=I[2];if(N=I[3]==null?{}:I[3],!(T in s)){o(x,w);return}let M=s[T];if(M.inboundNodes.length<=$){o(x,w);return}let B=M.inboundNodes[$];k.push(B.outputTensors[D])}k.length>0&&x.apply(sr(k),N)}function d(x){let w=x.name,k=zs(x,n.customObjects!=null?n.customObjects:{});k.setFastWeightInitDuringBuild(r),s[w]=k,x.inboundNodes.forEach(N=>{if(!(N instanceof Array))throw new re(`Corrupted configuration, expected array for nodeData: ${N}`);o(k,N)})}let c=n.name,p=n.layers;for(let x of p)d(x);for(;!qQ(i);)for(let x of p){let w=s[x.name];if(w.name in i){let k=i[w.name];delete i[w.name];for(let N of k)u(w,N)}}let m=[],g=[],b=n.inputLayers;for(let x of b){let w=x[0],k=x[1],N=x[2];ri(w in s);let I=s[w].inboundNodes[k].outputTensors;m.push(I[N])}let v=n.outputLayers;for(let x of v){let w=x[0],k=x[1],N=x[2];ri(w in s);let I=s[w].inboundNodes[k].outputTensors;g.push(I[N])}return new t({inputs:m,outputs:g,name:c})}get stateful(){if(this._stateful)throw new re("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(let t of this.layers)if(t.stateful)return!0;return!1}resetStates(){ne(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}};function _te(e,t,n){let a=t.length;if(e==null||Array.isArray(e)&&e.length===0)return t.map(r=>null);if(a===1)return Array.isArray(e)&&e.length===1?e:typeof e=="object"&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==a)throw new Error(`Provided ${n} is an array of ${e.length} element(s), but the model has ${a} outputs. Make sure a set of weights is provided for each model output.`);return e}else if(typeof e=="object"&&Object.keys(e).length>0&&typeof e[Object.keys(e)[0]]=="object"){let r=[];return t.forEach(s=>{s in e?r.push(e[s]):r.push(null)}),r}else throw new Error(`The model has multiple (${a}) outputs, so ${n} must be either an array with ${a} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(e)}`)}function c3(e,t){return _te(e,t,"classWeight")}async function d3(e,t,n,a){if(n!=null){let r=ne(()=>{if(e.shape.length===1)return li(e);if(e.shape.length===2){if(e.shape[1]>1)return Ru(e,1);if(e.shape[1]===1)return te(e,[e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),s=Array.from(await r.data());it(r);let i=[];return s.forEach(o=>{if(n[o]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${o} exists in the data but not in classWeight`);i.push(n[o])}),Lt(i,"float32")}else return null}function Nte(e,t){return Y(e,t)}var Ite=32;function h3(e,t){let n,a,r=t;n=r.xs,a=r.ys,E.assert(n!=null&&a!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);let s=Z$("input",e.inputNames,n),i=Z$("output",e.outputNames,a),o=s[0].shape[0];E.assert(s.length===e.inputs.length,()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${s.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`),E.assert(i.length===e.outputs.length,()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`);for(let u=0;u<s.length;u++)E.assert(s[u].shape[0]===o,()=>`Batch size mismatch: input ${e.inputNames[u]} has ${s[u].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`);for(let u=0;u<i.length;u++)E.assert(i[u].shape[0]===o,()=>`Batch size mismatch: output ${e.outputNames[u]} has ${i[u].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`);return{xs:s,ys:i}}function Z$(e,t,n){if(n instanceof dt)return[n];if(Array.isArray(n))return E.assert(n.length===t.length,()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`),n;{let a=[];for(let r of t){if(n[r]==null)throw new re(`The feature data generated by the dataset lacks the required ${e} key '${r}'.`);a.push(n[r])}return a}}function Tte(e){if(e.length===3)throw new bt("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}async function Ete(e,t,n){let a=n.batchesPerEpoch!=null;if(E.assert(e.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),E.assert(n!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),E.assert(n.epochs!=null&&n.epochs>0&&Number.isInteger(n.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`),E.assert(!a||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`),E.assert(n.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{let r=n.validationData!=null,s,i;if(r)if(Q$(n.validationData))E.assert(n.validationBatches==null||n.validationBatches>0&&Number.isInteger(n.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`);else{let x=Tte(n.validationData);s=x.xs,i=x.ys}let o=e.makeTrainFunction(),u=e.getDedupedMetricsNames(),d;r?d=u.slice().concat(u.map(x=>"val_"+x)):d=u.slice();let c=n3(n.callbacks,n.yieldEvery),p=n.verbose==null?1:n.verbose,{callbackList:m,history:g}=a3(c,p,n.epochs,null,null,Cte(t,n),null,r,d);m.setModel(e),e.history=g,await m.onTrainBegin(),e.stopTraining_=!1;let b=n.initialEpoch==null?0:n.initialEpoch,v=await t.iterator();for(;b<n.epochs;){let x={};await m.onEpochBegin(b);let w=0,k=0;for(a||(v=await t.iterator());!a||w<n.batchesPerEpoch;){let N=await v.next();if(a&&N.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${w} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${n.batchesPerEpoch*n.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(N.value!=null){let{xs:I,ys:T}=h3(e,N.value),$={};$.batch=k,$.size=I[0].shape[0],await m.onBatchBegin(k,$);let D=[];if(n.classWeight!=null){let V=c3(n.classWeight,e.outputNames);for(let W=0;W<V.length;++W)D.push(await d3(T[W],null,V[W]))}let M=I.concat(T).concat(D),B=o(M);it(M);for(let V=0;V<u.length;++V){let W=u[V],R=B[V];$[W]=R,Zn(R)}await m.onBatchEnd(k,$),ZF($),k++,w++}if(a?w>=n.batchesPerEpoch:N.done){if(r){let I;Q$(n.validationData)?I=Ut(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):I=Ut(e.evaluate(s,i,{batchSize:n.validationBatchSize==null?Ite:n.validationBatchSize,verbose:0}));for(let T=0;T<e.metricsNames.length;++T)x[`val_${e.metricsNames[T]}`]=I[T]}break}if(e.stopTraining_)break}if(await m.onEpochEnd(b,x),b++,e.stopTraining_)break}return await m.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function Cte(e,t){let n=null;return t.batchesPerEpoch!=null?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size),n}function Q$(e){return typeof e.iterator=="function"}function Ate(e){return typeof e.next=="function"}async function $te(e,t,n){n=n||{};let a=n.batches!=null,r=e.testFunction,s=[];if(n.verbose>0)throw new bt("Verbose mode is not implemented yet.");E.assert(!a||n.batches>0&&Number.isInteger(n.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`);let i=Ate(t)?t:await t.iterator(),o=0,u=0;for(;!a||u<n.batches;){let d=await i.next();if(s=ne(()=>{if(d.value){let{xs:c,ys:p}=h3(e,d.value),m=c.concat(p),g=ne(()=>r(m));if(it(m),u===0)for(let v=0;v<g.length;++v)s.push(He(0));let b=m[0].shape[0];for(let v=0;v<g.length;++v){let x=g[v],w=s[v];s[v]=ne(()=>ye(s[v],Y(b,x))),u>0&&it(w)}it(g),o+=b,++u}return s}),d.done){a&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let d=0;d<s.length;++d){let c=s[d];s[d]=Le(s[d],o),it(c)}return sr(s)}function aS(e){E.assert(e>0&&Number.isInteger(e),()=>`batchSize is required to be a positive integer, but got ${e}`)}function km(e,t,n){return e==null?[null]:Array.isArray(e)?e.map(a=>Su(a,t,n-t)):Su(e,t,n-t)}function ek(e,t){return ne(()=>e==null?null:Array.isArray(e)?e.map(n=>ek(n,t)):WF(e,t.dtype==="int32"?t:Te(t,"int32")))}function rS(e,t){let n=[],a=0,r=null;for(;a<e;)r=a+t,r>=e&&(r=e),n.push([a,r]),a=r;return n}function p3(e){let t=[];e instanceof dt&&(e=[e]);for(let n=0;n<e.length;++n){let a=e[n];if(a.rank===1)t.push(fy(a,1));else{if(a.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(a)}}return t}function Cs(e,t){if(e==null)return;let n=[];if(t instanceof dt)n.push(t.id);else if(Array.isArray(t))t.forEach(r=>n.push(r.id));else if(t!=null)for(let r in t){let s=t[r];n.push(s.id)}let a=[];if(e instanceof dt)n.indexOf(e.id)===-1&&a.push(e);else if(Array.isArray(e))e.forEach(r=>{n.indexOf(r.id)===-1&&a.push(r)});else if(e!=null)for(let r in e){let s=e[r];n.indexOf(s.id)===-1&&a.push(s)}a.forEach(r=>{r.isDisposed||r.dispose()})}function Rte(e){return e instanceof dt}function tk(e){return Array.isArray(e)}function eR(e){return!Rte(e)&&!tk(e)}function tR(e,t,n,a=!0,r=""){if(t==null||t.length===0){if(e!=null){let i=!1;if(tk(e)&&e.length>0)i=!0;else if(eR(e)){for(let o in e)if(e.hasOwnProperty(o)){i=!0;break}}else i=!0;if(i)throw new re(`Error when checking model ${r} expected no data, but got ${e}`)}return[]}if(e==null)return t.map(i=>null);let s;if(eR(e)){e=e,s=[];for(let i of t){if(e[i]==null)throw new re(`No data provided for "${i}". Need data for each key in: ${t}`);s.push(e[i])}}else if(tk(e)){if(e=e,e.length!==t.length)throw new re(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);s=e}else{if(e=e,t.length>1)throw new re(`The model ${r} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);s=[e]}if(s=p3(s),n!=null)for(let i=0;i<t.length;++i){if(n[i]==null)continue;let o=s[i];if(o.shape.length!==n[i].length)throw new re(`Error when checking ${r}: expected ${t[i]} to have ${n[i].length} dimension(s). but got array with shape ${o.shape}`);for(let u=0;u<n[i].length;++u){if(u===0&&!a)continue;let d=o.shape[u],c=n[i][u];if(c!=null&&c>=0&&d!==c)throw new re(`${r} expected a batch of elements where each example has shape [${n[i].slice(1,n[i].length)}] (i.e.,tensor shape [*,${n[i].slice(1,n[i].length)}]) but the ${r} received an input with ${o.shape[0]} examples, each with shape [${o.shape.slice(1,o.shape.length)}] (tensor shape [${o.shape}])`)}}return s}function Dte(e,t,n){let a=Qo(e.map(s=>s.shape[0]));a.sort();let r=Qo(t.map(s=>s.shape[0]));if(r.sort(),a.length>1)throw new re(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(s=>s.shape))}`);if(r.length>1)throw new re(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(s=>s.shape))}`);if(a.length>0&&r.length>0&&!E.arraysEqual(a,r))throw new re(`Input Tensors should have the same number of samples as target Tensors. Found ${a[0]} input sample(s) and ${r[0]} target sample(s).`)}function Ote(e,t,n){let a=[md,fx,rg];for(let r=0;r<e.length;++r){let s=e[r],i=t[r],o=n[r];if(i!=null){if(i===rg&&s.shape[s.shape.length-1]===1)throw new re(`You are passing a target array of shape ${s.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(a.indexOf(i)!==-1){let u=s.shape.slice(1),d=o.slice(1);for(let c=0;c<u.length;++c){let p=u[c],m=d[c];if(m!=null&&p!==m)throw new re(`A target Tensor with shape ${s.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function nR(e,t,n,a=!0,r=""){let s;if(Array.isArray(e)){if(e.length!==t.length)throw new re(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);s=e}else{if(t.length>1)throw new re(`The model expects ${t.length} ${r} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);s=[e]}if(n!=null)for(let i=0;i<t.length;++i){if(n[i]==null)continue;let o=s[i];if(o.shape.length!==n[i].length)throw new re(`Error when checking ${r}: expected ${t[i]} to have ${n[i].length} dimension(s), but got array with shape ${JSON.stringify(o.shape)}`);for(let u=0;u<n[i].length;++u){if(u===0&&!a)continue;let d=o.shape[u],c=n[i][u];if(c!=null&&c!==d)throw new re(`Error when checking ${r}: expected ${t[i]} to have shape ${JSON.stringify(n[i])} but got array with shape ${JSON.stringify(o.shape)}.`)}}}function Mte(e,t){if(e==null||Array.isArray(e)&&e.length===0)return t.map(a=>[]);let n;if(typeof e=="string"||typeof e=="function")n=[e];else if(Array.isArray(e)||typeof e=="object")n=e;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);if(Array.isArray(n))return t.map(a=>n);{let a=[];for(let r of t){let s=n.hasOwnProperty(r)?n[r]:[];Array.isArray(s)||(s=[s]),a.push(s)}return a}}var Fte="layers-model",Gi=class extends kte{constructor(e){super(e),this.isTraining=!1}summary(e,t,n=console.log){if(!this.built)throw new re("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");yte(this,e,t,n)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=gte(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof ao))throw new re("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(let s in e.loss)if(this.outputNames.indexOf(s)===-1)throw new re(`Unknown entry in loss dictionary: "${s}". Only expected the following keys: ${this.outputNames}`);for(let s of this.outputNames)e.loss[s]==null&&console.warn(`Output "${s}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${s} during training`),t.push(nS(e.loss[s]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new re(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(s=>nS(s))}else{let s=nS(e.loss);this.outputs.forEach(i=>{t.push(s)})}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let s=0;s<this.outputs.length;++s){let i=this.internalOutputShapes[s],o=this.outputNames[s];this.feedOutputNames.push(o),this.feedOutputShapes.push(i),this.feedLossFns.push(this.lossFunctions[s])}let n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],wu("loss",()=>{for(let s=0;s<this.outputs.length;++s){if(n.indexOf(s)!==-1)continue;let i=this.lossFunctions[s];this.outputs.length>1&&(this.metricsTensors.push([i,s]),this.metricsNames.push(this.outputNames[s]+"_loss"))}});let a=Mte(e.metrics,this.outputNames),r=(s,i,o)=>{this.outputNames.length>1&&(i=this.outputNames[s]+"_"+i),this.metricsNames.push(i),this.metricsTensors.push([o,s])};wu("metric",()=>{for(let s=0;s<this.outputs.length;++s){if(n.indexOf(s)!==-1)continue;let i=a[s];(o=>{let u="",d,c,p;for(let m of o){if(typeof m=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(m)!==-1){let b=this.internalOutputShapes[s];b[b.length-1]===1||this.lossFunctions[s]===fx?["accuracy","acc"].indexOf(m)!==-1?c=G2:["crossentropy","ce"].indexOf(m)!==-1&&(c=i3):this.lossFunctions[s]===Mv?["accuracy","acc"].indexOf(m)!==-1?c=o3:["crossentropy","ce"].indexOf(m)!==-1&&(c=l3):["accuracy","acc"].indexOf(m)!==-1?c=q2:["crossentropy","ce"].indexOf(m)!==-1&&(c=K2);let v;["accuracy","acc"].indexOf(m)!==-1?v="acc":["crossentropy","ce"].indexOf(m)!==-1&&(v="ce"),p=c,d=u+v}else p=mte(m),d=u+qb(m);let g;wu(d,()=>{g=p}),r(s,d,g)}})(i)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,n={}){let a=n.batchSize==null?32:n.batchSize;aS(a);let r=this.standardizeUserDataXY(e,t,!0,a);try{let s=r[0].concat(r[1]);this.makeTestFunction();let i=this.testFunction,o=this.testLoop(i,s,a,n.verbose,n.steps);return sr(o)}finally{Cs(r[0],e),Cs(r[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),$te(this,e,t)}checkNumSamples(e,t,n,a="steps"){let r;if(n!=null){if(r=null,t!=null)throw new re(`If ${a} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else if(e!=null)Array.isArray(e)?r=e[0].shape[0]:r=e.shape[0];else throw new re(`Either the input data should have a defined shape, or ${a} shoud be specified.`);return r}execute(e,t){if(Array.isArray(t)&&t.length===0)throw new re("`outputs` is an empty Array, which is not allowed.");let n=Array.isArray(t),a=n?t:[t],r=this.retrieveSymbolicTensors(a),s=new Th;if(e instanceof dt&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new re(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let o=0;o<this.inputs.length;++o)s.add(this.inputs[o],e[o])}else for(let o of this.inputs){let u=e[o.name];if(u==null)throw new re(`No value is provided for the model's input ${o.name}`);s.add(o,u)}let i=Am(r,s);return n?i:i[0]}retrieveSymbolicTensors(e){let t=zu(null,e.length),n=e.length;for(let a of this.layers){let r=Array.isArray(a.output)?a.output:[a.output],s=r.map(i=>i.name);for(let i=0;i<e.length;++i){let o=s.indexOf(e[i]);if(o!==-1&&(t[i]=r[o],n--),n===0)break}if(n===0)break}if(n>0){let a=[];throw t.forEach((r,s)=>{r==null&&a.push(e[s])}),new re(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(a)}`)}return t}predictLoop(e,t=32,n=!1){return ne(()=>{let a=this.checkNumSamples(e);if(n)throw new bt("Verbose predictLoop() is not implemented yet.");let r=rS(a,t),s=this.outputs.map(i=>[]);for(let i=0;i<r.length;++i)ne(()=>{let o=r[i][0],u=r[i][1],d=km(e,o,u),c=[];if(Array.isArray(d))for(let m=0;m<d.length;++m)c.push({key:this.inputs[m],value:d[m]});else c.push({key:this.inputs[0],value:d});let p=new Th(c);return Am(this.outputs,p)}).forEach((o,u)=>s[u].push(o));return sr(s.map(i=>Yt(i,0)))})}predict(e,t={}){let n=p3(e);nR(n,this.inputNames,this.feedInputShapes,!1);try{let a=t.batchSize==null?32:t.batchSize;return aS(a),this.predictLoop(n,a)}finally{Cs(n,e)}}predictOnBatch(e){nR(e,this.inputNames,this.feedInputShapes,!0);let t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,n=!0,a){if(this.optimizer_==null)throw new ii("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");let r=[];for(let s=0;s<this.feedOutputShapes.length;++s){let i=this.feedOutputShapes[s];this.feedLossFns[s]===Mv?r.push(i.slice(0,i.length-1).concat([1])):r.push(i)}if(e=tR(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=tR(t,this.feedOutputNames,r,!1,"target"),Dte(e,t),Ote(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&a!=null&&a>0&&e[0].shape[0]%a!==0)throw new re(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${a}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,n,a,r=!0,s){let[i,o]=this.standardizeUserDataXY(e,t,r,s);if(n!=null)throw new Error("sample weight is not supported yet.");let u=null;if(a!=null){let d=c3(a,this.outputNames);u=[];for(let c=0;c<d.length;++c)u.push(await d3(o[c],null,d[c]))}return[i,o,u]}testLoop(e,t,n,a=0,r){return ne(()=>{let s=this.checkNumSamples(t,n,r,"steps"),i=[];if(a>0)throw new bt("Verbose mode is not implemented yet.");if(r!=null)throw new bt("steps mode in testLoop() is not implemented yet");{let o=rS(s,n),u=Lt(Ps(0,s));for(let d=0;d<o.length;++d){let c=o[d][0],p=o[d][1],m=Su(u,c,p-c),g=ek(t,m),b=e(g);if(d===0)for(let v=0;v<b.length;++v)i.push(He(0));for(let v=0;v<b.length;++v){let x=b[v];i[v]=ye(i[v],Y(p-c,x))}}for(let d=0;d<i.length;++d)i[d]=Le(i[d],s)}return i})}getDedupedMetricsNames(){let e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){let a=e[n],r=a;if(U$(e,a)>1){let s=U$(e.slice(0,n),a);r+=`_${s}`}t.push(r)}return t}makeTrainFunction(){return e=>{let t=[],n=e.slice(0,this.inputs.length),a=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),r=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),s=[],i=()=>{let u=[];for(let m=0;m<this.inputs.length;++m)u.push({key:this.inputs[m],value:n[m]});let d=new Th(u),c=Am(this.outputs,d,{training:!0}),p;for(let m=0;m<this.lossFunctions.length;++m){let g=this.lossFunctions[m],b=g(a[m],c[m]);r[m]!=null&&(b=Nte(b,r[m]));let v=vn(b);t.push(v),m===0?p=b:p=ye(p,b)}for(let m=0;m<this.metricsTensors.length;++m){let g;if(this.outputs.length>1&&m<this.outputs.length)g=t[m];else{let b=this.metricsTensors[m][0],v=this.metricsTensors[m][1];g=vn(b(a[v],c[v]))}Zn(g),s.push(g)}return p=vn(p),this.calculateLosses().forEach(m=>{p=ye(p,m)}),p},o=this.collectedTrainableWeights.map(u=>u.read());return[this.optimizer_.minimize(i,!0,o)].concat(s)}}makeTestFunction(){this.testFunction=e=>ne(()=>{let t=[],n,a=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=[];for(let u=0;u<this.inputs.length;++u)s.push({key:this.inputs[u],value:a[u]});let i=new Th(s),o=Am(this.outputs,i);for(let u=0;u<this.lossFunctions.length;++u){let d=this.lossFunctions[u],c=vn(d(r[u],o[u]));u===0?n=c:n=ye(n,c),t.push(n)}for(let u=0;u<this.metricsTensors.length;++u){let d=this.metricsTensors[u][0],c=this.metricsTensors[u][1],p=vn(d(r[c],o[c]));t.push(p)}return t})}async fit(e,t,n={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let a,r,s,i,o,u,d,c,p;try{let m=n.batchSize==null?32:n.batchSize;aS(m);let g=await this.standardizeUserData(e,t,n.sampleWeight,n.classWeight,!1,m);a=g[0],r=g[1],p=g[2];let b=!1,v;if(n.validationData!=null&&n.validationData.length>0){if(b=!0,n.validationData.length===2)o=n.validationData[0],u=n.validationData[1];else throw n.validationData.length===3?new bt("validationData including sample weights is not supported yet."):new re(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${n.validationData} is invalid.`);let $=await this.standardizeUserData(o,u,null,null,!0,m);d=$[0],c=$[1],v=d.concat(c)}else if(n.validationSplit!=null&&n.validationSplit>0&&n.validationSplit<1){b=!0;let $=Math.floor(a[0].shape[0]*(1-n.validationSplit)),D=a[0].shape[0];d=km(a,$,D),s=a,a=km(a,0,$),c=km(r,$,D),i=r,r=km(r,0,$),v=d.concat(c)}else n.validationSteps!=null&&(b=!0);let x=a.concat(r).concat(p);this.checkTrainableWeightsConsistency();let w=this.makeTrainFunction(),k=this.getDedupedMetricsNames(),N,I;b?(this.makeTestFunction(),N=this.testFunction,I=k.slice().concat(k.map($=>"val_"+$))):(N=null,v=[],I=k.slice());let T=n3(n.callbacks,n.yieldEvery);return await this.fitLoop(w,x,k,m,n.epochs,n.verbose,T,N,v,n.shuffle,I,n.initialEpoch,null,null)}finally{this.isTraining=!1,Cs(a,e),Cs(r,t),Cs(s,e),Cs(i,t),Cs(d,o),Cs(c,u),p!=null&&it(p)}}async fitLoop(e,t,n,a,r,s,i,o,u,d,c,p,m,g){a==null&&(a=32),r==null&&(r=1),d==null&&(d=!0),p==null&&(p=0);let b=!1;if(o!=null&&u!=null&&(b=!0),g!=null&&(b=!0,m==null))throw new re("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");let v=this.checkNumSamples(t,a,m,"steps_per_epoch"),x;v!=null&&(x=Ps(0,v)),s==null&&(s=1);let{callbackList:w,history:k}=a3(i,s,r,p,v,m,a,b,c);w.setModel(this),this.history=k,await w.onTrainBegin(),this.stopTraining_=!1;for(let N=p;N<r;++N){await w.onEpochBegin(N);let I={};if(m!=null)throw new bt("stepsPerEpoch mode is not implemented yet.");{if(d==="batch")throw new bt("batch shuffling is not implemneted yet");d&&E.shuffle(x);let T=Lt(x),$=rS(v,a);for(let D=0;D<$.length;++D){let M={};if(await w.onBatchBegin(D,M),ne(()=>{let B=$[D][0],V=$[D][1],W=Su(T,B,V-B);M.batch=D,M.size=V-B;let R=ek(t,W),H=e(R);for(let Z=0;Z<n.length;++Z){let ae=n[Z],j=H[Z];M[ae]=j,Zn(j)}if(D===$.length-1&&b){let Z=this.testLoop(o,u,a);for(let ae=0;ae<n.length;++ae){let j=n[ae],K=Z[ae];Zn(K),I["val_"+j]=K}}}),await w.onBatchEnd(D,M),ZF(M),this.stopTraining_)break}T.dispose()}if(await w.onEpochEnd(N,I),this.stopTraining_)break}return await w.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return Ete(this,e,t)}async trainOnBatch(e,t){let n=await this.standardizeUserData(e,t),a=n[0],r=n[1],s=this.makeTrainFunction()(a.concat(r)),i=[];for(let o of s){let u=await o.data();i.push(u[0])}return it(s),Cs(n[0],e),Cs(n[1],t),sr(i)}getNamedWeights(e){let t=[],n=e!=null&&e.trainableOnly,a=n?this.trainableWeights:this.weights,r=this.getWeights(n);for(let s=0;s<a.length;++s)n&&!a[s].trainable||t.push({name:a[s].originalName,tensor:r[s]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){let e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){let t=FS().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-FS().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=Pi(this.loss);else if(Array.isArray(this.loss)){for(let t of this.loss)if(typeof t!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(t=>Pi(t))}else{let t=Object.keys(this.loss);e={};let n=this.loss;for(let a of t)if(typeof n[a]=="string")e[a]=Pi(n[a]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[Pi(qb(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>Pi(qb(e)));{let e={};for(let t in this.metrics)e[t]=Pi(qb(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");let t=sg(e.optimizer_config),n=zs(t),a;if(typeof e.loss=="string")a=hu(e.loss);else if(Array.isArray(e.loss))a=e.loss.map(s=>hu(s));else if(e.loss!=null){a={};for(let s in e.loss)a[s]=hu(e.loss[s])}let r;if(Array.isArray(e.metrics))r=e.metrics.map(s=>hu(s));else if(e.metrics!=null){r={};for(let s in e.metrics)r[s]=hu(e.metrics[s])}this.compile({loss:a,metrics:r,optimizer:n})}async save(e,t){if(typeof e=="string"){let r=Na.getSaveHandlers(e);if(r.length===0)throw new re(`Cannot find any save handlers for URL '${e}'`);if(r.length>1)throw new re(`Found more than one (${r.length}) save handlers for URL '${e}'`);e=r[0]}if(e.save==null)throw new re("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");let n=await Na.encodeWeights(this.getNamedWeights(t)),a={modelTopology:this.toJSON(null,!1),format:Fte,generatedBy:`TensorFlow.js tfjs-layers v${X2}`,convertedBy:null};if(t!=null&&t.includeOptimizer&&this.optimizer!=null){a.trainingConfig=this.getTrainingConfig();let r="optimizer",{data:s,specs:i}=await Na.encodeWeights(await this.optimizer.getWeights(),r);n.specs.push(...i),n.data=Na.concatenateArrayBuffers([n.data,s])}return this.userDefinedMetadata!=null&&(J$(this.userDefinedMetadata,this.name,!0),a.userDefinedMetadata=this.userDefinedMetadata),a.weightData=n.data,a.weightSpecs=n.specs,e.save(a)}setUserDefinedMetadata(e){J$(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}};Gi.className="Model";_e.registerClass(Gi);var f3=class extends Gi{};f3.className="Functional";_e.registerClass(f3);async function zte(e,t){"modelTopology"in e||(e={modelTopology:e}),e=e;let n=e.modelTopology;n.model_config!=null&&(n=n.model_config);let a=sg(n),r=zs(a,t);if(e.weightsManifest!=null){let s=await Na.loadWeights(e.weightsManifest,e.pathPrefix,r.weights.map(o=>o.originalName)),i={};for(let o of r.weights)i[o.originalName]=s[o.originalName];r.loadWeights(i),it(s)}return r}async function Lte(e,t){if(t==null&&(t={}),typeof e=="string"){let n=Na.getLoadHandlers(e,t);if(n.length===0)n.push(Na.browserHTTPRequest(e,t));else if(n.length>1)throw new re(`Found more than one (${n.length}) load handlers for URL '${e}'`);e=n[0]}return Bte(e,void 0,t)}async function Bte(e,t,n){if(n==null&&(n={}),e.load==null)throw new re("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let a=await e.load(),r=a.modelTopology;r.model_config!=null&&(r=r.model_config);let s=n.strict==null?!0:n.strict,i=a.weightData!=null&&a.weightSpecs!=null&&s,o=zs(sg(r),t,i),u=a.trainingConfig;if(u!=null&&o.loadTrainingConfig(u),a.userDefinedMetadata!=null&&o.setUserDefinedMetadata(a.userDefinedMetadata),a.weightData!=null){if(a.weightSpecs==null)throw new re("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");let{modelWeights:d,optimizerWeights:c}=Pte(a.weightData,a.weightSpecs);o.loadWeights(d,s),o.optimizer!=null&&c.length>0&&await o.optimizer.setWeights(c),it(d),it(c.map(p=>p.tensor))}return o}function Pte(e,t){let n=Na.decodeWeights(e,t),a={},r=[];return t.forEach(s=>{s.group==="optimizer"?r.push({name:s.name,tensor:n[s.name]}):a[s.name]=n[s.name]}),{modelWeights:a,optimizerWeights:r}}var mx=class nk extends Gi{constructor(t){if(super({inputs:[],outputs:[]}),t=t||{},this.trainable=!0,this.built=!1,this.name=t.name!=null?t.name:ax("sequential_"),t.layers!=null)for(let n of t.layers)this.add(n)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some(n=>n<0))throw new re(`Negative dimension size caused by adding layer ${t.name} with input shape [${t.inboundNodes[0].inputTensors[0].shape}]`)}add(t){let n=t instanceof nk||t instanceof Gi,a;if(n){if(a=t,a.outputs.length!==1)throw new re("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(a.inputs.length!==1)throw new re("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(t.inboundNodes.length===0){if(t.batchInputShape==null)throw new re("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");let r=qF({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(r)}if(n)this.outputs=a.outputs,this.inputs=a.inputs;else{if(t.inboundNodes.length!==1)throw new re(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(t.inboundNodes[0].outputTensors.length!==1)throw new re("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=GF(this.outputs[0])}this.inboundNodes=[],new hx({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:zu(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(r=>r.shape),outputShapes:this.outputs[0].shape})}else{let r=t.apply(this.outputs[0]);if(Array.isArray(r))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[r],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{let t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,n){return this.model==null&&this.build(),this.model.call(t,n)}build(t){if($t(t),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Gi({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,n,a=console.log){this.built||this.build(),super.summary(t,n,a)}setWeights(t){this.model==null&&this.build(),this.model.setWeights(t)}evaluate(t,n,a={}){if(!this.built)throw new ii("The model needs to be compiled before being used.");return this.model.evaluate(t,n,a)}async evaluateDataset(t,n){if(!this.built)throw new ii("The model needs to be compiled before being used.");return this.model.evaluateDataset(t,n)}predict(t,n={}){return this.model==null&&this.build(),this.model.predict(t,n)}predictOnBatch(t){return this.model==null&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,n,a={}){if(!this.built)throw new ii("The model needs to be compiled before being used.");return this.model.fit(t,n,a)}async fitDataset(t,n){if(!this.built)throw new ii("The model needs to be compiled before being used.");return this.model.fitDataset(t,n)}async trainOnBatch(t,n){return this.model.trainOnBatch(t,n)}static fromConfig(t,n,a={},r=!1){let s,i={};if(n instanceof Array){if(n[0].className==null||n[0].className==="Merge")throw new re("Legacy serialization format not supported yet.");s=n}else E.assert(n.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),s=n.layers,delete n.layers,i=n;let o=new t(i);if(!(o instanceof nk))throw new bt(`Sequential.fromConfig called on non-Sequential input: ${o}`);for(let u of s){let d=zs(u,void 0,r);r&&d.setFastWeightInitDuringBuild(!0),o.add(d)}return o}set stopTraining(t){if(this.model==null)throw new re("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(this.model==null)throw new re("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){let t=[];for(let n of this.layers){let a={};a.className=n.getClassName(),a.config=n.getConfig(),t.push(a)}return{name:this.name,layers:t}}};mx.className="Sequential";_e.registerClass(mx);function Ute(e){return new Gi(e)}function jte(e){return new mx(e)}function m3(e){return qF(e)}function Wte(e,t){V2.registerCallbackConstructor(e,t)}var Ba=class extends _e.Serializable{getConfig(){return{}}},g3=class extends Ba{apply(e,t=1){return lee(e,t)}};g3.className="elu";_e.registerClass(g3);var y3=class extends Ba{apply(e){return P0(e)}};y3.className="selu";_e.registerClass(y3);var b3=class extends Ba{apply(e){return jt(e)}};b3.className="relu";_e.registerClass(b3);var v3=class extends Ba{apply(e){return ne(()=>ol(6,jt(e)))}};v3.className="relu6";_e.registerClass(v3);var x3=class extends Ba{apply(e){return e}};x3.className="linear";_e.registerClass(x3);var w3=class extends Ba{apply(e){return ys(e)}};w3.className="sigmoid";_e.registerClass(w3);var S3=class extends Ba{apply(e){return cee(e)}};S3.className="hardSigmoid";_e.registerClass(S3);var k3=class extends Ba{apply(e){return hd(e)}};k3.className="softplus";_e.registerClass(k3);var _3=class extends Ba{apply(e){return uee(e)}};_3.className="softsign";_e.registerClass(_3);var N3=class extends Ba{apply(e){return il(e)}};N3.className="tanh";_e.registerClass(N3);var Y2=class extends Ba{apply(e,t=-1){return Nl(e,t)}};Y2.className="softmax";_e.registerClass(Y2);var I3=class extends Ba{apply(e,t=-1){return D0(e,t)}};I3.className="logSoftmax";_e.registerClass(I3);var T3=class extends Ba{apply(e){return ne(()=>ne(()=>{let t=Math.sqrt(2),n=Y(.5,ye(1,A0(Le(e,t))));return Y(e,n)}))}};T3.className="gelu";_e.registerClass(T3);var E3=class extends Ba{apply(e){return ne(()=>Y(.5,Y(e,ye(1,il(Y(fa(Le(2,Math.PI)),ye(e,Y(.044715,hi(e,3)))))))))}};E3.className="gelu_new";_e.registerClass(E3);var C3=class extends Ba{apply(e){return ne(()=>Y(e,il(hd(e))))}};C3.className="mish";_e.registerClass(C3);var A3=class extends Ba{apply(e,t=1){return ne(()=>Y(ys(Y(e,t)),e))}};A3.className="swish";_e.registerClass(A3);function cl(e){return e.getClassName()}function sS(e,t={}){return py(e,_e.SerializationMap.getMap().classNameMap,t,"activation")}function dl(e){if(e==null){let t={};return t.className="linear",t.config={},sS(t)}if(typeof e=="string"){let t={};return t.className=e,t.config={},sS(t)}else return e instanceof Ba?e:sS(e)}function J2(e){if(e!=null&&typeof e!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}var $3=class extends _e.Serializable{},by=class extends $3{constructor(e){super(),J2(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return ne(()=>{let t=xn([1]);return this.hasL1&&(t=ye(t,Be(Y(this.l1,Ln(e))))),this.hasL2&&(t=ye(t,Be(Y(this.l2,my(e))))),te(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}};by.className="L1L2";_e.registerClass(by);function Vte(e){return J2(e),new by({l1:e!=null?e.l1:null,l2:0})}function Hte(e){return J2(e),new by({l2:e!=null?e.l2:null,l1:0})}var aR={l1l2:"L1L2"};function an(e){return E2(e)}function rR(e,t={}){return py(e,_e.SerializationMap.getMap().classNameMap,t,"regularizer")}function yn(e){if(e==null)return null;if(typeof e=="string"){let t={className:e in aR?aR[e]:e,config:{}};return rR(t)}else return e instanceof $3?e:rR(e)}var Z2=class extends vt{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,t){e=et(e);let n=jt(e);return this.maxValue!=null&&(n=za(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){let e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}};Z2.className="ReLU";_e.registerClass(Z2);var Q2=class extends vt{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=et(e);return ny(n,this.alpha)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};Q2.className="LeakyReLU";_e.registerClass(Q2);var eN=class extends vt{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=gn(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=yn(e.alphaRegularizer),this.alphaConstraint=na(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new re(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=$t(e);let t=e.slice(1);if(this.sharedAxes!=null)for(let a of this.sharedAxes)t[a-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);let n={};if(this.sharedAxes!=null)for(let a=1;a<e.length;++a)n[a]=e[a];this.inputSpec=[new Bn({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=et(e),ly(e,this.alpha.read())}getConfig(){let e={alphaInitializer:wn(this.alphaInitializer),alphaRegularizer:an(this.alphaRegularizer),alphaConstraint:ta(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}};eN.className="PReLU";_e.registerClass(eN);var tN=class extends vt{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new bt(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=et(e);return rf(n)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};tN.className="ELU";_e.registerClass(tN);var nN=class extends vt{constructor(e){super(e??{}),this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,t){let n=et(e);return Y(n,Te(Qa(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){let e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}};nN.className="ThresholdedReLU";_e.registerClass(nN);var aN=class extends vt{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new Y2().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,t){return ne(()=>{let n=et(e),a=t.mask;if(a!=null){let r=Y(Fe(or(n.shape),Te(a,n.dtype)),He(-1e9));n=ye(n,r)}return this.axis instanceof Array?this.axis.length>1?La(Fe(n,ry(n,this.axis,!0))):this.softmax(n,this.axis[0]):this.softmax(n,this.axis)})}computeOutputShape(e){return e}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};aN.className="Softmax";_e.registerClass(aN);function Rh(e,t,n){if(typeof e=="number")return zu(e,t);if(e.length!==t)throw new re(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let a=0;a<t;++a){let r=e[a];if(!ree(r))throw new re(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${r}`)}return e}function Ls(e,t,n,a,r=1){if(e==null)return e;let s=t+(t-1)*(r-1),i;return n==="same"?i=e:i=e-s+1,Math.floor((i+a-1)/a)}function si(e,t,n,a){if(e==null)return null;if(a==="valid")e=e*t+ul([n-t,0]);else if(a==="same")e=e*t;else throw new re(`Unsupport padding mode: ${a}.`);return e}function rN(e,t){return ne(()=>(Dn(t),t==="channelsFirst"?ft(e,[0,2,3,1]):e))}function R3(e,t){return ne(()=>(Dn(t),t==="channelsFirst"?ft(e,[0,2,3,4,1]):e))}function Gte(e,t,n,a=1,r="valid",s,i=1){return ne(()=>{if(s==null&&(s=Us()),Dn(s),e.shape.length!==3)throw new re(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(t.shape.length!==3)throw new re(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(n!=null&&n.shape.length!==1)throw new re(`The bias for a conv1dWithBias operation should be 1, but is ${n.shape.length} instead`);if(s==="channelsFirst"&&(e=ft(e,[0,2,1])),r==="causal")throw new bt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=I0(e,t,a,r==="same"?"same":"valid","NWC",i);return n!=null&&(o=Hs(o,n)),o})}function sR(e,t,n,a=[1,1],r="valid",s,i,o=null){return ne(()=>{if(s==null&&(s=Us()),Dn(s),e.rank!==3&&e.rank!==4)throw new re(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(t.rank!==3&&t.rank!==4)throw new re(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let u=rN(e,s);if(r==="causal")throw new bt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return u=Vh.conv2d({x:u,filter:t,strides:a,pad:r==="same"?"same":"valid",dilations:i,dataFormat:"NHWC",bias:n,activation:o}),s==="channelsFirst"&&(u=ft(u,[0,3,1,2])),u})}function qte(e,t,n,a=[1,1,1],r="valid",s,i){return ne(()=>{if(s==null&&(s=Us()),Dn(s),e.rank!==4&&e.rank!==5)throw new re(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(t.rank!==4&&t.rank!==5)throw new re(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let o=R3(e,s);if(r==="causal")throw new bt("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=R_(o,t,a,r==="same"?"same":"valid","NDHWC",i),n!=null&&(o=Hs(o,n)),s==="channelsFirst"&&(o=ft(o,[0,4,1,2,3])),o})}var D3=class O3 extends vt{constructor(t,n){if(super(n),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",O3.verifyArgs(n),this.rank=t,ha(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new bt(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Rh(n.kernelSize,t,"kernelSize"),this.strides=Rh(n.strides==null?1:n.strides,t,"strides"),this.padding=n.padding==null?"valid":n.padding,es(this.padding),this.dataFormat=n.dataFormat==null?"channelsLast":n.dataFormat,Dn(this.dataFormat),this.activation=dl(n.activation),this.useBias=n.useBias==null?!0:n.useBias,this.biasInitializer=gn(n.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=na(n.biasConstraint),this.biasRegularizer=yn(n.biasRegularizer),this.activityRegularizer=yn(n.activityRegularizer),this.dilationRate=Rh(n.dilationRate==null?1:n.dilationRate,t,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new re(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new re(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new re(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(t){if(ri("kernelSize"in t,"required key 'kernelSize' not in config"),typeof t.kernelSize!="number"&&!C2(t.kernelSize,"number",1,3))throw new re(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){let t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:cl(this.activation),useBias:this.useBias,biasInitializer:wn(this.biasInitializer),biasRegularizer:an(this.biasRegularizer),activityRegularizer:an(this.activityRegularizer),biasConstraint:ta(this.biasConstraint)},n=super.getConfig();return Object.assign(t,n),t}},gx=class M3 extends D3{constructor(t,n){super(t,n),this.kernel=null,M3.verifyArgs(n),this.filters=n.filters,ha(this.filters,"filters"),this.kernelInitializer=gn(n.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=na(n.kernelConstraint),this.kernelRegularizer=yn(n.kernelRegularizer)}build(t){t=$t(t);let n=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[n]==null)throw new re(`The channel dimension of the input should be defined. Found ${t[n]}`);let a=t[n],r=this.kernelSize.concat([a,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[n]:a}}],this.built=!0}call(t,n){return ne(()=>{t=et(t);let a,r=this.bias==null?null:this.bias.read(),s=zF(this.activation.getClassName());if(s!=null&&this.rank===2)a=sR(t,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate,s);else{if(this.rank===1)a=Gte(t,this.kernel.read(),r,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)a=sR(t,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)a=qte(t,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new bt("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(a=this.activation.apply(a))}return a})}computeOutputShape(t){t=$t(t);let n=[],a=this.dataFormat==="channelsLast"?t.slice(1,t.length-1):t.slice(2);for(let s=0;s<a.length;++s){let i=Ls(a[s],this.kernelSize[s],this.padding,this.strides[s],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[s]);n.push(i)}let r=[t[0]];return this.dataFormat==="channelsLast"?(r=r.concat(n),r.push(this.filters)):(r.push(this.filters),r=r.concat(n)),r}getConfig(){let t={filters:this.filters,kernelInitializer:wn(this.kernelInitializer),kernelRegularizer:an(this.kernelRegularizer),kernelConstraint:ta(this.kernelConstraint)},n=super.getConfig();return Object.assign(t,n),t}static verifyArgs(t){if(!("filters"in t)||typeof t.filters!="number"||t.filters<1)throw new re(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}},yx=class F3 extends gx{constructor(t){super(2,t),F3.verifyArgs(t)}getConfig(){let t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!C2(t.kernelSize,"number",1,2))throw new re(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}};yx.className="Conv2D";_e.registerClass(yx);var bx=class z3 extends gx{constructor(t){super(3,t),z3.verifyArgs(t)}getConfig(){let t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!(Array.isArray(t.kernelSize)&&(t.kernelSize.length===1||t.kernelSize.length===3)))throw new re(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}};bx.className="Conv3D";_e.registerClass(bx);var sN=class extends yx{constructor(e){if(super(e),this.inputSpec=[new Bn({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new re(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=$t(e),e.length!==4)throw new re("Input should have rank 4; Received input shape: "+JSON.stringify(e));let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new re("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],a=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",a,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Bn({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return ne(()=>{let n=et(e);if(n.shape.length!==4)throw new re(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let a=n.shape,r=a[0],s,i;this.dataFormat==="channelsFirst"?(s=2,i=3):(s=1,i=2);let o=a[s],u=a[i],d=this.kernelSize[0],c=this.kernelSize[1],p=this.strides[0],m=this.strides[1],g=si(o,p,d,this.padding),b=si(u,m,c,this.padding),v=[r,g,b,this.filters];this.dataFormat!=="channelsLast"&&(n=ft(n,[0,2,3,1]));let x=T0(n,this.kernel.read(),v,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(x=ft(x,[0,3,1,2])),this.bias!=null&&(x=Hs(x,this.bias.read(),this.dataFormat)),this.activation!=null&&(x=this.activation.apply(x)),x})}computeOutputShape(e){e=$t(e);let t=e.slice(),n,a,r;this.dataFormat==="channelsFirst"?(n=1,a=2,r=3):(n=3,a=1,r=2);let s=this.kernelSize[0],i=this.kernelSize[1],o=this.strides[0],u=this.strides[1];return t[n]=this.filters,t[a]=si(t[a],o,s,this.padding),t[r]=si(t[r],u,i,this.padding),t}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};sN.className="Conv2DTranspose";_e.registerClass(sN);var iN=class extends bx{constructor(e){if(super(e),this.inputSpec=[new Bn({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new re(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=$t(e),e.length!==5)throw new re("Input should have rank 5; Received input shape: "+JSON.stringify(e));let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new re("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],a=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",a,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Bn({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return ne(()=>{let n=et(e);if(n.shape.length!==5)throw new re(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let a=n.shape,r=a[0],s,i,o;this.dataFormat==="channelsFirst"?(o=2,s=3,i=4):(o=1,s=2,i=3);let u=a[o],d=a[s],c=a[i],p=this.kernelSize[0],m=this.kernelSize[1],g=this.kernelSize[2],b=this.strides[0],v=this.strides[1],x=this.strides[2],w=si(u,b,p,this.padding),k=si(d,v,m,this.padding),N=si(c,x,g,this.padding),I=[r,w,k,N,this.filters];this.dataFormat!=="channelsLast"&&(n=ft(n,[0,2,3,4,1]));let T=D_(n,this.kernel.read(),I,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(T=ft(T,[0,4,1,2,3])),this.bias!==null&&(T=Hs(T,this.bias.read(),this.dataFormat)),this.activation!==null&&(T=this.activation.apply(T)),T})}computeOutputShape(e){e=$t(e);let t=e.slice(),n,a,r,s;this.dataFormat==="channelsFirst"?(n=1,a=2,r=3,s=4):(n=4,a=1,r=2,s=3);let i=this.kernelSize[0],o=this.kernelSize[1],u=this.kernelSize[2],d=this.strides[0],c=this.strides[1],p=this.strides[2];return t[n]=this.filters,t[a]=si(t[a],d,i,this.padding),t[r]=si(t[r],c,o,this.padding),t[s]=si(t[s],p,u,this.padding),t}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};iN.className="Conv3DTranspose";_e.registerClass(iN);var L3=class extends gx{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,t.filters==null)throw new re("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(t.kernelInitializer!=null||t.kernelRegularizer!=null||t.kernelConstraint!=null)throw new re("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(t.padding!=null&&t.padding!=="same"&&t.padding!=="valid")throw new re(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=gn(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=yn(t.depthwiseRegularizer),this.depthwiseConstraint=na(t.depthwiseConstraint),this.pointwiseInitializer=gn(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=yn(t.pointwiseRegularizer),this.pointwiseConstraint=na(t.pointwiseConstraint)}build(e){if(e=$t(e),e.length<this.rank+2)throw new re(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null||e[t]<0)throw new re(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);let n=e[t],a=this.kernelSize.concat([n,this.depthMultiplier]),r=[];for(let i=0;i<this.rank;++i)r.push(1);r.push(n*this.depthMultiplier,this.filters);let s=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",a,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,s,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",r,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,s,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,s,this.biasConstraint):this.bias=null,this.inputSpec=[new Bn({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return ne(()=>{e=et(e);let n;if(this.rank===1)throw new bt("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=ft(e,[0,2,3,1])),n=uf(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(n=Hs(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),this.dataFormat==="channelsFirst"&&(n=ft(n,[0,3,1,2])),n})}getConfig(){let e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=wn(this.depthwiseInitializer),e.pointwiseInitializer=wn(this.pointwiseInitializer),e.depthwiseRegularizer=an(this.depthwiseRegularizer),e.pointwiseRegularizer=an(this.pointwiseRegularizer),e.depthwiseConstraint=ta(this.depthwiseConstraint),e.pointwiseConstraint=ta(this.pointwiseConstraint),e}};L3.className="SeparableConv";var oN=class extends L3{constructor(e){super(2,e)}};oN.className="SeparableConv2D";_e.registerClass(oN);var lN=class B3 extends gx{constructor(t){super(1,t),B3.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){let t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!C2(t.kernelSize,"number",1,1))throw new re(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)}};lN.className="Conv1D";_e.registerClass(lN);var uN=class extends vt{constructor(e){super(e),typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return ne(()=>{if(e=et(e),this.dataFormat==="channelsLast"){let n=Gb(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Gb(n,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{let n=Gb(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Gb(n,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){let e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};uN.className="Cropping2D";_e.registerClass(uN);var cN=class extends vt{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Dn(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,tee(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){let t=e[2]==null?null:this.size[0]*e[2],n=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],t,n]}else{let t=e[1]==null?null:this.size[0]*e[1],n=e[2]==null?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return ne(()=>{let n=et(e),a=n.shape;if(this.dataFormat==="channelsFirst"){n=ft(n,[0,2,3,1]);let r=this.size[0]*a[2],s=this.size[1]*a[3],i=this.interpolation==="nearest"?Gr.resizeNearestNeighbor(n,[r,s]):Gr.resizeBilinear(n,[r,s]);return ft(i,[0,3,1,2])}else{let r=this.size[0]*a[1],s=this.size[1]*a[2];return this.interpolation==="nearest"?Gr.resizeNearestNeighbor(n,[r,s]):Gr.resizeBilinear(n,[r,s])}})}getConfig(){let e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}};cN.className="UpSampling2D";_e.registerClass(cN);function Kte(e,t,n=[1,1],a="valid",r,s){return ne(()=>{r==null&&(r=Us()),Dn(r);let i=rN(e,r);if(e.rank!==4)throw new re(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(t.rank!==4)throw new re(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return i=dd(i,t,n,a==="same"?"same":"valid","NHWC",s),r==="channelsFirst"&&(i=ft(i,[0,3,1,2])),i})}var dN=class extends D3{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=gn(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=na(e.depthwiseConstraint),this.depthwiseRegularizer=yn(e.depthwiseRegularizer)}build(e){if(e=$t(e),e.length<4)throw new re(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);let t=this.dataFormat==="channelsFirst"?1:3;if(e[t]==null||e[t]<0)throw new re(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);let n=e[t],a=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",a,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return ne(()=>{e=et(e);let n=Kte(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(n=Hs(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),n})}computeOutputShape(e){e=$t(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2],a=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,r=Ls(t,this.kernelSize[0],this.padding,this.strides[0]),s=Ls(n,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],a,r,s]:[e[0],r,s,a]}getConfig(){let e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=wn(this.depthwiseInitializer),e.depthwiseRegularizer=an(this.depthwiseRegularizer),e.depthwiseConstraint=ta(this.depthwiseRegularizer),e}};dN.className="DepthwiseConv2D";_e.registerClass(dN);function P3(e,t,n,a){if(Array.isArray(e)){if(t!=null||n!=null)throw new re("When inputs is an array, neither initialState or constants should be provided");a!=null&&(n=e.slice(e.length-a,e.length),e=e.slice(0,e.length-a)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function r(s){return s==null||Array.isArray(s)?s:[s]}return t=r(t),n=r(n),{inputs:e,initialState:t,constants:n}}function U3(e,t,n,a=!1,r,s,i=!1,o=!1){return ne(()=>{let u=t.shape.length;if(u<3)throw new re(`Input should be at least 3D, but is ${u}D.`);let d=[1,0].concat(Ps(2,u));t=ft(t,d),s!=null,i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),r!=null&&(r=Te(Te(r,"bool"),"float32"),r.rank===u-1&&(r=da(r,-1)),r=ft(r,d)),a&&(t=Qr(t,0),r!=null&&(r=Qr(r,0)));let c=[],p,m=n,g=t.shape[0],b=Nn(t),v;r!=null&&(v=Nn(r));for(let w=0;w<g;++w){let k=b[w],N=ne(()=>e(k,m));if(r==null)p=N[0],m=N[1];else{let I=ne(()=>{let T=v[w],$=Fe(Rr(T),T),D=ye(Y(N[0],T),Y(m[0],$)),M=m.map((B,V)=>ye(Y(N[1][V],T),Y(B,$)));return{output:D,newStates:M}});p=I.output,m=I.newStates}o&&c.push(p)}let x;return o&&(x=Un(c,1)),[p,x,m]})}var ro=class j3 extends vt{constructor(t){super(t);let n;if(t.cell==null)throw new re("cell property is missing for the constructor of RNN.");if(Array.isArray(t.cell)?n=new wx({cells:t.cell}):n=t.cell,n.stateSize==null)throw new re("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=n,this.returnSequences=t.returnSequences==null?!1:t.returnSequences,this.returnState=t.returnState==null?!1:t.returnState,this.goBackwards=t.goBackwards==null?!1:t.goBackwards,this._stateful=t.stateful==null?!1:t.stateful,this.unroll=t.unroll==null?!1:t.unroll,this.supportsMasking=!0,this.inputSpec=[new Bn({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){let t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return Ps(0,t).map(n=>null)}else return this.states_}setStates(t){this.states_=t}computeOutputShape(t){YS(t)&&(t=t[0]),t=t;let n=this.cell.stateSize;Array.isArray(n)||(n=[n]);let a=n[0],r;if(this.returnSequences?r=[t[0],t[1],a]:r=[t[0],a],this.returnState){let s=[];for(let i of n)s.push([t[0],i]);return[r].concat(s)}else return r}computeMask(t,n){return ne(()=>{Array.isArray(n)&&(n=n[0]);let a=this.returnSequences?n:null;if(this.returnState){let r=this.states.map(s=>null);return[a].concat(r)}else return a})}get states(){if(this.states_==null){let t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,n=[];for(let a=0;a<t;++a)n.push(null);return n}else return this.states_}set states(t){this.states_=t}build(t){if(this.numConstants!=null)throw new bt("Constants support is not implemented in RNN yet.");YS(t)&&(t=t[0]),t=t;let n=this.stateful?t[0]:null,a=t.slice(2);this.inputSpec[0]=new Bn({shape:[n,null,...a]});let r=[t[0]].concat(t.slice(2));this.cell.build(r);let s;if(Array.isArray(this.cell.stateSize)?s=this.cell.stateSize:s=[this.cell.stateSize],this.stateSpec!=null){if(!E.arraysEqual(this.stateSpec.map(i=>i.shape[i.shape.length-1]),s))throw new re(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=s.map(i=>new Bn({shape:[null,i]}));this.stateful&&this.resetStates()}resetStates(t,n=!1){ne(()=>{if(!this.stateful)throw new Wo("Cannot call resetStates() on an RNN Layer that is not stateful.");let a=this.inputSpec[0].shape[0];if(a==null)throw new re("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>xn([a,r])):this.states_=[xn([a,this.cell.stateSize])];else if(t==null)it(this.states_),this.keptStates!=null&&(it(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>xn([a,r])):this.states_[0]=xn([a,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new re(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);n===!0?this.keptStates.push(this.states_.slice()):it(this.states_);for(let r=0;r<this.states_.length;++r){let s=t[r],i=Array.isArray(this.cell.stateSize)?this.cell.stateSize[r]:this.cell.stateSize,o=[a,i];if(!E.arraysEqual(s.shape,o))throw new re(`State ${r} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${s.shape}`);this.states_[r]=s}}this.states_=this.states_.map(r=>Zn(r.clone()))})}apply(t,n){let a=n==null?null:n.initialState,r=n==null?null:n.constants;n==null&&(n={});let s=P3(t,a,r,this.numConstants);t=s.inputs,a=s.initialState,r=s.constants;let i=[],o=[];if(a!=null){n.initialState=a,i=i.concat(a),this.stateSpec=[];for(let u of a)this.stateSpec.push(new Bn({shape:u.shape}));o=o.concat(this.stateSpec)}if(r!=null&&(n.constants=r,i=i.concat(r),this.numConstants=r.length),i[0]instanceof js){let u=[t].concat(i),d=this.inputSpec.concat(o),c=this.inputSpec;this.inputSpec=d;let p=super.apply(u,n);return this.inputSpec=c,p}else return super.apply(t,n)}call(t,n){return ne(()=>{let a=n==null?null:n.mask,r=n==null?null:n.training,s=n==null?null:n.initialState;t=et(t),s==null&&(this.stateful?s=this.states_:s=this.getInitialState(t));let i=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(s.length!==i)throw new re(`RNN Layer has ${i} state(s) but was passed ${s.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");let o={training:r},u=U3((g,b)=>{let v=this.cell.call([g].concat(b),o);return[v[0],v.slice(1)]},t,s,this.goBackwards,a,null,this.unroll,this.returnSequences),d=u[0],c=u[1],p=u[2];this.stateful&&this.resetStates(p,r);let m=this.returnSequences?c:d;return this.returnState?[m].concat(p):m})}getInitialState(t){return ne(()=>{let n=xn(t.shape);return n=Be(n,[1,2]),n=fy(n),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(a=>a>1?KS(n,[1,a]):n):this.cell.stateSize>1?[KS(n,[1,this.cell.stateSize])]:[n]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){let t=super.getConfig(),n={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(n.numConstants=this.numConstants);let a=this.cell.getConfig();return this.getClassName()===j3.className&&(n.cell={className:this.cell.getClassName(),config:a}),Object.assign(Object.assign(Object.assign({},a),t),n)}static fromConfig(t,n,a={}){let r=n.cell,s=zs(r,a);return new t(Object.assign(n,{cell:s}))}};ro.className="RNN";_e.registerClass(ro);var vy=class extends vt{},vx=class extends vy{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,ha(this.units,"units"),this.activation=dl(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=gn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=gn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=gn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=yn(e.kernelRegularizer),this.recurrentRegularizer=yn(e.recurrentRegularizer),this.biasRegularizer=yn(e.biasRegularizer),this.kernelConstraint=na(e.kernelConstraint),this.recurrentConstraint=na(e.recurrentConstraint),this.biasConstraint=na(e.biasConstraint),this.dropout=Hh([1,ul([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Hh([1,ul([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=$t(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return ne(()=>{if(e=e,e.length!==2)throw new re(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];let a=t.training==null?!1:t.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=hl({ones:()=>Rr(e),rate:this.dropout,training:a,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=hl({ones:()=>Rr(n),rate:this.recurrentDropout,training:a,dropoutFunc:this.dropoutFunc}));let r,s=this.dropoutMask,i=this.recurrentDropoutMask;s!=null?r=ci(Y(e,s),this.kernel.read()):r=ci(e,this.kernel.read()),this.bias!=null&&(r=Hs(r,this.bias.read())),i!=null&&(n=Y(n,i));let o=ye(r,ci(n,this.recurrentKernel.read()));return this.activation!=null&&(o=this.activation.apply(o)),[o,o]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:cl(this.activation),useBias:this.useBias,kernelInitializer:wn(this.kernelInitializer),recurrentInitializer:wn(this.recurrentInitializer),biasInitializer:wn(this.biasInitializer),kernelRegularizer:an(this.kernelRegularizer),recurrentRegularizer:an(this.recurrentRegularizer),biasRegularizer:an(this.biasRegularizer),activityRegularizer:an(this.activityRegularizer),kernelConstraint:ta(this.kernelConstraint),recurrentConstraint:ta(this.recurrentConstraint),biasConstraint:ta(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}};vx.className="SimpleRNNCell";_e.registerClass(vx);var hN=class extends ro{constructor(e){e.cell=new vx(e),super(e)}call(e,t){return ne(()=>{this.cell.dropoutMask!=null&&(it(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(it(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,a=t==null?null:t.training,r=t==null?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:r})})}static fromConfig(e,t){return new e(t)}};hN.className="SimpleRNN";_e.registerClass(hN);var xx=class extends vy{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new re("GRUCell does not support reset_after parameter set to true.");this.units=e.units,ha(this.units,"units"),this.activation=dl(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=dl(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=gn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=gn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=gn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=yn(e.kernelRegularizer),this.recurrentRegularizer=yn(e.recurrentRegularizer),this.biasRegularizer=yn(e.biasRegularizer),this.kernelConstraint=na(e.kernelConstraint),this.recurrentConstraint=na(e.recurrentConstraint),this.biasConstraint=na(e.biasConstraint),this.dropout=Hh([1,ul([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Hh([1,ul([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=$t(e);let t=e[e.length-1];this.kernel=this.addWeight("kernel",[t,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return ne(()=>{if(e=e,e.length!==2)throw new re(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);let n=t.training==null?!1:t.training,a=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=hl({ones:()=>Rr(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=hl({ones:()=>Rr(a),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));let r=this.dropoutMask,s=this.recurrentDropoutMask,i,o,u;0<this.dropout&&this.dropout<1&&(e=Y(e,r[0]));let d=ci(e,this.kernel.read());this.useBias&&(d=Hs(d,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(a=Y(a,s[0]));let c=this.recurrentKernel.read(),[p,m]=lr(c,[2*this.units,this.units],c.rank-1),g=ci(a,p),[b,v,x]=lr(d,3,d.rank-1),[w,k]=lr(g,2,g.rank-1);i=this.recurrentActivation.apply(ye(b,w)),o=this.recurrentActivation.apply(ye(v,k));let N=ci(Y(o,a),m);u=this.activation.apply(ye(x,N));let I=ye(Y(i,a),Y(ye(1,un(i)),u));return[I,I]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:cl(this.activation),recurrentActivation:cl(this.recurrentActivation),useBias:this.useBias,kernelInitializer:wn(this.kernelInitializer),recurrentInitializer:wn(this.recurrentInitializer),biasInitializer:wn(this.biasInitializer),kernelRegularizer:an(this.kernelRegularizer),recurrentRegularizer:an(this.recurrentRegularizer),biasRegularizer:an(this.biasRegularizer),activityRegularizer:an(this.activityRegularizer),kernelConstraint:ta(this.kernelConstraint),recurrentConstraint:ta(this.recurrentConstraint),biasConstraint:ta(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}};xx.className="GRUCell";_e.registerClass(xx);var pN=class extends ro{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new xx(e),super(e)}call(e,t){return ne(()=>{this.cell.dropoutMask!=null&&(it(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(it(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,a=t==null?null:t.training,r=t==null?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:r})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}};pN.className="GRU";_e.registerClass(pN);var xy=class extends vy{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,ha(this.units,"units"),this.activation=dl(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=dl(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=gn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=gn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=gn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=yn(e.kernelRegularizer),this.recurrentRegularizer=yn(e.recurrentRegularizer),this.biasRegularizer=yn(e.biasRegularizer),this.kernelConstraint=na(e.kernelConstraint),this.recurrentConstraint=na(e.recurrentConstraint),this.biasConstraint=na(e.biasConstraint),this.dropout=Hh([1,ul([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Hh([1,ul([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;e=$t(e);let n=e[e.length-1];this.kernel=this.addWeight("kernel",[n,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let a;if(this.useBias){if(this.unitForgetBias){let r=this.biasInitializer,s=this.units;a=new(t=class extends Ss{apply(i,o){let u=r.apply([s]),d=new sx().apply([s]),c=r.apply([s*2]);return W$(W$(u,d),c)}},t.className="CustomInit",t)}else a=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,a,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return ne(()=>{let n=t.training==null?!1:t.training;if(e=e,e.length!==3)throw new re(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let a=e[1],r=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=hl({ones:()=>Rr(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=hl({ones:()=>Rr(a),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));let s=this.dropoutMask,i=this.recurrentDropoutMask,o,u,d,c;0<this.dropout&&this.dropout<1&&(e=Y(e,s[0]));let p=ci(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(a=Y(a,i[0])),p=ye(p,ci(a,this.recurrentKernel.read())),this.useBias&&(p=Hs(p,this.bias.read()));let[m,g,b,v]=lr(p,4,p.rank-1);o=this.recurrentActivation.apply(m),u=this.recurrentActivation.apply(g),d=ye(Y(u,r),Y(o,this.activation.apply(b))),c=this.recurrentActivation.apply(v);let x=Y(c,this.activation.apply(d));return[x,x,d]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:cl(this.activation),recurrentActivation:cl(this.recurrentActivation),useBias:this.useBias,kernelInitializer:wn(this.kernelInitializer),recurrentInitializer:wn(this.recurrentInitializer),biasInitializer:wn(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:an(this.kernelRegularizer),recurrentRegularizer:an(this.recurrentRegularizer),biasRegularizer:an(this.biasRegularizer),activityRegularizer:an(this.activityRegularizer),kernelConstraint:ta(this.kernelConstraint),recurrentConstraint:ta(this.recurrentConstraint),biasConstraint:ta(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}};xy.className="LSTMCell";_e.registerClass(xy);var fN=class extends ro{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new xy(e),super(e)}call(e,t){return ne(()=>{this.cell.dropoutMask!=null&&(it(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(it(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,a=t==null?null:t.training,r=t==null?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:r})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}};fN.className="LSTM";_e.registerClass(fN);var wx=class extends vy{constructor(e){super(e),this.cells=e.cells}get stateSize(){let e=[];for(let t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return ne(()=>{e=e;let n=e.slice(1),a=[];for(let i of this.cells.slice().reverse())Array.isArray(i.stateSize)?a.push(n.splice(0,i.stateSize.length)):a.push(n.splice(0,1));a.reverse();let r=[],s;for(let i=0;i<this.cells.length;++i){let o=this.cells[i];n=a[i],i===0?s=[e[0]].concat(n):s=[s[0]].concat(n),s=o.call(s,t),r.push(s.slice(1))}n=[];for(let i of r.slice().reverse())n.push(...i);return[s[0]].concat(n)})}build(e){YS(e)&&(e=e[0]),e=e;let t;this.cells.forEach((n,a)=>{wu(`RNNCell_${a}`,()=>{n.build(e),Array.isArray(n.stateSize)?t=n.stateSize[0]:t=n.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){let e=super.getConfig(),t=a=>({className:a.getClassName(),config:a.getConfig()}),n={cells:this.cells.map(t)};return Object.assign(Object.assign({},e),n)}static fromConfig(e,t,n={}){let a=[];for(let r of t.cells)a.push(zs(r,n));return new e({cells:a})}get trainableWeights(){if(!this.trainable)return[];let e=[];for(let t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let n of this.cells)t.push(...n.trainableWeights);return t.concat(e)}return e}getWeights(){let e=[];for(let t of this.cells)e.push(...t.weights);return JS(e)}setWeights(e){let t=[];for(let n of this.cells){let a=n.weights.length,r=e.splice(a);for(let s=0;s<n.weights.length;++s)t.push([n.weights[s],r[s]])}L2(t)}};wx.className="StackedRNNCells";_e.registerClass(wx);function hl(e){let{ones:t,rate:n,training:a=!1,count:r=1,dropoutFunc:s}=e,i=()=>s!=null?s(t(),n):VF(t(),n),o=()=>gy(i,t,a);return!r||r<=1?Zn(o().clone()):Array(r).fill(void 0).map(o).map(u=>Zn(u.clone()))}var Xte=function(e,t){var n={};for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&t.indexOf(a)<0&&(n[a]=e[a]);if(e!=null&&typeof Object.getOwnPropertySymbols=="function")for(var r=0,a=Object.getOwnPropertySymbols(e);r<a.length;r++)t.indexOf(a[r])<0&&Object.prototype.propertyIsEnumerable.call(e,a[r])&&(n[a[r]]=e[a[r]]);return n},W3=class extends ro{constructor(e){if(e.unroll)throw new bt("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new bt("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new Bn({ndim:5})]}call(e,t){return ne(()=>{if(this.cell.dropoutMask!=null&&(it(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(it(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new re("ConvRNN2D cell does not support constants");let n=t==null?null:t.mask,a=t==null?null:t.training,r=t==null?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:r})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return ne(()=>{let{stateSize:t}=this.cell,n=e.shape,a=this.computeSingleOutputShape(n),r=[a[0],...a.slice(2)],s=xn(r);return Array.isArray(t)?Array(t.length).fill(s):[s]})}resetStates(e,t=!1){ne(()=>{if(!this.stateful)throw new Wo("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape,a=this.computeSingleOutputShape(n),r=[a[0],...a.slice(2)];if(n[0]==null)throw new re("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>xn(r)):this.states_=[xn(r)];else if(e==null)it(this.states_),this.keptStates!=null&&(it(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>xn(r)):this.states_[0]=xn(r);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new re(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):it(this.states_);for(let s=0;s<this.states_.length;++s){let i=e[s],o=r;if(!E.arraysEqual(i.shape,o))throw new re(`State ${s} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${i.shape}`);this.states_[s]=i}}this.states_=this.states_.map(s=>Zn(s.clone()))})}computeSingleOutputShape(e){let{dataFormat:t,filters:n,kernelSize:a,padding:r,strides:s,dilationRate:i}=this.cell,o=t==="channelsFirst",u=e[o?3:2],d=e[o?4:3],c=Ls(u,a[0],r,s[0],i[0]),p=Ls(d,a[1],r,s[1],i[1]);return[...e.slice(0,2),...o?[n,c,p]:[c,p,n]]}};W3.className="ConvRNN2D";var Sx=class extends xy{constructor(e){let{filters:t,kernelSize:n,strides:a,padding:r,dataFormat:s,dilationRate:i}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,ha(this.filters,"filters"),this.kernelSize=Rh(n,2,"kernelSize"),this.kernelSize.forEach(o=>ha(o,"kernelSize")),this.strides=Rh(a||1,2,"strides"),this.strides.forEach(o=>ha(o,"strides")),this.padding=r||"valid",es(this.padding),this.dataFormat=s||"channelsLast",Dn(this.dataFormat),this.dilationRate=Rh(i||1,2,"dilationRate"),this.dilationRate.forEach(o=>ha(o,"dilationRate"))}build(e){var t;e=$t(e);let n=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[n]==null)throw new re(`The channel dimension of the input should be defined. Found ${e[n]}`);let a=e[n],r=4,s=this.kernelSize.concat([a,this.filters*r]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);let i=this.kernelSize.concat([this.filters,this.filters*r]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",i,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let o;if(this.unitForgetBias){let u=this.biasInitializer,d=this.filters;o=new(t=class extends Ss{apply(c,p){let m=u.apply([d]),g=or([d]),b=u.apply([d*2]);return A2([m,g,b])}},t.className="CustomInit",t)}else o=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*r],null,o,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return ne(()=>{if(e.length!==3)throw new re(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let n=t.training||!1,a=e[0],r=e[1],s=e[2],i=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=hl({ones:()=>Rr(a),rate:this.dropout,training:n,count:i,dropoutFunc:this.dropoutFunc}));let o=this.dropoutMask,u=(ce,me,L)=>!me||!me[L]?ce:Y(me[L],ce),d=u(a,o,0),c=u(a,o,1),p=u(a,o,2),m=u(a,o,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=hl({ones:()=>Rr(r),rate:this.recurrentDropout,training:n,count:i,dropoutFunc:this.dropoutFunc}));let g=this.recurrentDropoutMask,b=u(r,g,0),v=u(r,g,1),x=u(r,g,2),w=u(r,g,3),k=3,[N,I,T,$]=lr(this.kernel.read(),i,k),[D,M,B,V]=this.useBias?lr(this.bias.read(),i):[null,null,null,null];d=this.inputConv(d,N,D,this.padding),c=this.inputConv(c,I,M,this.padding),p=this.inputConv(p,T,B,this.padding),m=this.inputConv(m,$,V,this.padding);let[W,R,H,Z]=lr(this.recurrentKernel.read(),i,k);b=this.recurrentConv(b,W),v=this.recurrentConv(v,R),x=this.recurrentConv(x,H),w=this.recurrentConv(w,Z);let ae=this.recurrentActivation.apply(ye(d,b)),j=this.recurrentActivation.apply(ye(c,v)),K=ye(Y(j,s),Y(ae,this.activation.apply(ye(p,x)))),Q=Y(this.recurrentActivation.apply(ye(m,w)),this.activation.apply(K));return[Q,Q,K]})}getConfig(){let e=super.getConfig(),{units:t}=e,n=Xte(e,["units"]),a={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},n),a)}inputConv(e,t,n,a){let r=Ka(e,t,this.strides,a||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return n?Hs(r,n,this.dataFormat):r}recurrentConv(e,t){return Ka(e,t,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}};Sx.className="ConvLSTM2DCell";_e.registerClass(Sx);var mN=class extends W3{constructor(e){let t=new Sx(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}};mN.className="ConvLSTM2D";_e.registerClass(mN);var kx=class extends vt{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;let t=e.shape,n=[];for(let a=0;a<this.noiseShape.length;++a)n.push(this.noiseShape[a]==null?t[a]:this.noiseShape[a]);return n}call(e,t){return ne(()=>{this.invokeCallHook(e,t);let n=et(e);if(0<this.rate&&this.rate<1){let a=t.training==null?!1:t.training,r=this.getNoiseShape(n);return gy(()=>VF(n,this.rate,r,this.seed),()=>n,a)}return e})}getConfig(){let e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}};kx.className="Dropout";_e.registerClass(kx);var gN=class extends kx{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){let t=e.shape;return[t[0],1,t[2]]}};gN.className="SpatialDropout1D";_e.registerClass(gN);var yN=class extends vt{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let t=null;e.batchSize!=null&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,ha(this.units,"units"),this.activation=dl(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=gn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=gn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=na(e.kernelConstraint),this.biasConstraint=na(e.biasConstraint),this.kernelRegularizer=yn(e.kernelRegularizer),this.biasRegularizer=yn(e.biasRegularizer),this.activityRegularizer=yn(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=$t(e);let t=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){e=$t(e);let t=e.slice();return t[t.length-1]=this.units,t}call(e,t){return ne(()=>{this.invokeCallHook(e,t);let n=et(e),a=zF(this.activation.getClassName()),r;return a!=null?r=ci(n,this.kernel.read(),a,this.bias?this.bias.read():null):(r=ci(n,this.kernel.read()),this.bias!=null&&(r=Hs(r,this.bias.read())),this.activation!=null&&(r=this.activation.apply(r))),r})}getConfig(){let e={units:this.units,activation:cl(this.activation),useBias:this.useBias,kernelInitializer:wn(this.kernelInitializer),biasInitializer:wn(this.biasInitializer),kernelRegularizer:an(this.kernelRegularizer),biasRegularizer:an(this.biasRegularizer),activityRegularizer:an(this.activityRegularizer),kernelConstraint:ta(this.kernelConstraint),biasConstraint:ta(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}};yN.className="Dense";_e.registerClass(yN);var bN=class extends vt{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=$t(e);for(let t of e.slice(1))if(t==null)throw new re(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],el(e,1)]}call(e,t){return ne(()=>{this.invokeCallHook(e,t);let n=et(e);if(this.dataFormat==="channelsFirst"&&n.rank>1){let a=[0];for(let r=2;r<n.rank;++r)a.push(r);a.push(1),n=ft(n,a)}return oee(n)})}getConfig(){let e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);let t=super.getConfig();return Object.assign(e,t),e}};bN.className="Flatten";_e.registerClass(bN);var vN=class extends vt{constructor(e){super(e),this.supportsMasking=!0,this.activation=dl(e.activation)}call(e,t){return ne(()=>{this.invokeCallHook(e,t);let n=et(e);return this.activation.apply(n)})}getConfig(){let e={activation:cl(this.activation)},t=super.getConfig();return Object.assign(e,t),e}};vN.className="Activation";_e.registerClass(vN);var xN=class extends vt{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return ne(()=>(e=et(e),see(e,this.n)))}getConfig(){let e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}};xN.className="RepeatVector";_e.registerClass(xN);var wN=class extends vt{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,t){let n="Total size of new array must be unchanged.",a=t.slice(),r=1,s=null;for(let o=0;o<a.length;++o){let u=a[o];if(this.isUnknown(u))if(s===null)s=o;else throw new re("Can only specifiy one unknown dimension.");else r*=u}let i=el(e);if(s!==null){if(r===0||i%r!==0)throw new re(n);a[s]=i/r}else if(i!==r)throw new re(n);return a}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return ne(()=>{this.invokeCallHook(e,t);let n=et(e),a=n.shape,r=a.slice(0,1).concat(this.fixUnknownDimension(a.slice(1),this.targetShape));return te(n,r)})}getConfig(){let e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}};wN.className="Reshape";_e.registerClass(wN);var SN=class extends vt{constructor(e){if(super(e),e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);let t=Ps(1,e.dims.length+1);if(!E.arraysEqual(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new Bn({ndim:this.dims.length+1})]}computeOutputShape(e){e=$t(e);let t=e.slice();return this.dims.forEach((n,a)=>{t[a+1]=e[n]}),t}call(e,t){return ft(et(e),this.dimsIncludingBatch)}getConfig(){let e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}};SN.className="Permute";_e.registerClass(SN);var kN=class extends vt{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){let n=et(e);return eg(Mu(n,this.maskValue),-1)}call(e,t){return ne(()=>{this.invokeCallHook(e,t);let n=et(e),a=eg(Mu(n,this.maskValue),-1,!0);return Y(n,Te(a,n.dtype))})}};kN.className="Masking";_e.registerClass(kN);var _N=class extends vt{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let t=null;e.batchSize!=null&&(t=e.batchSize),e.inputLength==null?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(Ut(e.inputLength))}this.inputDim=e.inputDim,ha(this.inputDim,"inputDim"),this.outputDim=e.outputDim,ha(this.outputDim,"outputDim"),this.embeddingsInitializer=gn(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=yn(e.embeddingsRegularizer),this.activityRegularizer=yn(e.activityRegularizer),this.embeddingsConstraint=na(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return ne(()=>this.maskZero?(e=et(e),Mu(e,_t(e))):null)}computeOutputShape(e){if(e=$t(e),this.inputLength==null)return[...e,this.outputDim];let t=Ut(this.inputLength);if(t.length!==e.length-1)throw new re(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let a=0;a<t.length;++a){let r=t[a],s=e[a+1];if(r!=null&&s!=null&&r!==s)throw new re(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);r==null&&(t[n]=s),n++}}return[e[0],...t,this.outputDim]}call(e,t){return ne(()=>{this.invokeCallHook(e,t);let n=et(e);n.dtype!=="int32"&&(n=Yi(n,"int32"));let a=WF(this.embeddings.read(),te(n,[n.size]));return te(a,$t(this.computeOutputShape(n.shape)))})}getConfig(){let e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:wn(this.embeddingsInitializer),embeddingsRegularizer:an(this.embeddingsRegularizer),activityRegularizer:an(this.activityRegularizer),embeddingsConstraint:ta(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}};_N.className="Embedding";_e.registerClass(_N);var gd=class extends vt{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new bt}computeElementwiseOpOutputShape(e,t){if(e==null||t==null)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(t.length===0)return e;let n=e.slice(0,e.length-t.length);for(let a=0;a<t.length;++a){let r=e[e.length-t.length+a],s=t[a];if(r==null||s==null||r<0||s<0)n.push(null);else if(r===1)n.push(s);else if(s===1)n.push(r);else{if(r!==s)throw new re("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(r)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[$t(e)]),e=e,e.length<2)throw new re(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(let r of e)r!=null&&r[0]!==null&&t.push(r[0]);if(t=Qo(t),t.length>1)throw new re(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=e[0]==null?null:e[0].slice(1);for(let r=1;r<e.length;++r){let s=e[r]==null?null:e[r].slice(1);n=this.computeElementwiseOpOutputShape(n,s)}let a=e.map(r=>r.length);e.indexOf(null)===-1&&Qo(a).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return ne(()=>{if(e=e,this.reshapeRequired){let n=[],a=e.map(r=>r.rank);if(a.indexOf(null)===-1){let r=ul(a);for(let s of e){let i=s.rank;for(let o=0;o<r-i;++o)s=fy(s,1);n.push(s)}return this.mergeFunction(n)}else{let r=!1;for(let o of e){let u=o.rank;if(u==null){let d=o.shape,c=d[0],p=d.slice(1).concat([c]),m=te(o,[c].concat(el(d.slice(1))));m=ft(m,[1,0]),m=te(m,p),n.push(m),r=!0}else if(u>1){let d=Ps(1,u).concat([0]);n.push(ft(o,d)),r=!0}else n.push(o)}let s=this.mergeFunction(n),i=s.rank;if(r){if(i==null){let o=s.shape,u=o.length,d=o[u-1],c=[d].concat(o.slice(0,o.length-1));s=te(ft(te(s,[-1,d]),[1,0]),c)}else if(i>1){let o=[i-1].concat(Ps(0,i-1));s=ft(s,o)}}return s}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let t;e[0]==null?t=null:t=e[0].slice(1);for(let a=1;a<e.length;++a){let r=e[a]==null?null:e[a].slice(1);t=this.computeElementwiseOpOutputShape(t,r)}let n=[];for(let a of e)a!=null&&a[0]!==null&&n.push(a[0]);return n=Qo(n),n.length===1?t=n.concat(t):t=[null].concat(t),t}computeMask(e,t){return ne(()=>{if(t==null)return null;if(!Array.isArray(t))throw new re("`mask` should be an Array");if(!Array.isArray(e))throw new re("`inputs` should be an Array");if(t.length!==e.length)throw new re(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(a=>a==null))return null;t=t.map(a=>a==null?a:da(a,0));let n=t[0];for(let a=1;a<t.length-1;++a)n=bs(n,t[a]);return n})}},NN=class extends gd{constructor(e){super(e)}mergeFunction(e){return ne(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=ye(t,e[n]);return t})}};NN.className="Add";_e.registerClass(NN);var IN=class extends gd{constructor(e){super(e)}mergeFunction(e){return ne(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Y(t,e[n]);return t})}};IN.className="Multiply";_e.registerClass(IN);var TN=class extends gd{constructor(e){super(e)}mergeFunction(e){return ne(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=ye(t,e[n]);return Y(1/e.length,t)})}};TN.className="Average";_e.registerClass(TN);var EN=class extends gd{constructor(e){super(e)}mergeFunction(e){return ne(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=gi(t,e[n]);return t})}};EN.className="Maximum";_e.registerClass(EN);var CN=class extends gd{constructor(e){super(e)}mergeFunction(e){return ne(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=ol(t,e[n]);return t})}};CN.className="Minimum";_e.registerClass(CN);var AN=class extends gd{constructor(e){super(e),this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new re("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(let a of e)if(a!=null){t=!1;break}if(t)return;let n=[];for(let a=0;a<e.length;++a){let r=e[a].slice();r.splice(this.axis,1);let s=!1;for(let i of n)if(E.arraysEqual(i,r)){s=!0;break}s||n.push(r)}if(n.length>1)throw new re("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return ne(()=>A2(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new re("A `Concatenate` layer should be called on a list of inputs.");let t=e,n=t[0].slice(),a=this.axis<0?n.length+this.axis:this.axis;for(let r of t.slice(1)){if(n[a]==null||r[a]==null){n[a]=null;break}n[a]+=r[a]}return n}computeMask(e,t){if(t==null)return null;if(!Array.isArray(t))throw new re("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new re("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new re(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return ne(()=>{let n=!0;if(t.forEach(s=>{if(s!=null){n=!1;return}}),n)return null;let a=[];for(let s=0;s<e.length;++s)t[s]==null?a.push(Te(Rr(e[s]),"bool")):t[s].rank<e[s].rank?a.push(da(t[s],-1)):a.push(t[s]);let r=Yt(a,this.axis);return N0(r,-1,!1)})}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};AN.className="Concatenate";_e.registerClass(AN);function _m(e,t){for(;e<0;)e+=t;return e}function Yte(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new bt("batchDot is not implemented for tensors of 4D or higher rank yet");if(E.assert(e.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`),E.assert(e.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),typeof n=="number"&&(n=[n,n]),e.dtype==="complex64"||t.dtype==="complex64")throw new bt("batchDot is not implemented for complex64-type Tensors yet.");let a=e.shape.length,r=t.shape.length;n==null&&(n=[a-1,r-2]);let s=n;return ne(()=>{let i;if(a>r){i=a-r;let u=[];for(let d=0;d<i;++d)u.push(1);t=te(t,t.shape.concat(u))}else if(r>a){i=r-a;let u=[];for(let d=0;d<i;++d)u.push(1);e=te(e,e.shape.concat(u))}else i=0;let o;if(e.shape.length===2&&t.shape.length===2)s[0]===s[1]?o=Be(Y(e,t),s[0]):o=Be(Y(ft(e,[1,0]),t),s[1]);else{let u=s[0]!==e.shape.length-1,d=s[1]===t.shape.length-1;o=pt(e,t,u,d)}if(i>0){let u;a>r?u=a+r-3:u=a-1;let d=[];for(let c=u;c<u+i;++c)d.push(c);o=Il(o,d)}return o.shape.length===1&&(o=da(o,1)),o})}var $N=class extends gd{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){E.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let t=e[0],n=e[1];if(t.length>3||n.length>3)throw new bt("Dot layer does not support tensors of 4D or higher rank yet.");let a=this.interpretAxes(t,n);if(t[a[0]]!==n[a[1]])throw new re(`Dimension incompatibility: ${t[a[0]]} !== ${n[a[1]]}`)}mergeFunction(e){if(e.length!==2)throw new re(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t=e[0],n=e[1],a;return Array.isArray(this.axes)?a=this.axes.map((r,s)=>_m(r,e[s].shape.length)):a=[_m(this.axes,t.shape.length),_m(this.axes,n.shape.length)],this.normalize&&(t=Ov(t,a[0]),n=Ov(n,a[1])),Yte(t,n,a)}interpretAxes(e,t){let n;return Array.isArray(this.axes)?n=this.axes:n=[_m(this.axes,e.length),_m(this.axes,t.length)],n}computeOutputShape(e){E.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new bt("Dot layer does not support tensors of 4D or higher rank yet.");let a=this.interpretAxes(t,n);t.splice(a[0],1),n.splice(a[1],1),n.splice(0,1);let r=t.concat(n);return r.length===1&&r.push(1),r}computeMask(e,t){return null}getConfig(){let e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}};$N.className="Dot";_e.registerClass($N);var RN=class extends vt{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return ne(()=>{this.invokeCallHook(e,t);let n=et(e);return gy(()=>ye(rx(n.shape,0,this.stddev),n),()=>n,t.training||!1)})}};RN.className="GaussianNoise";_e.registerClass(RN);var DN=class extends vt{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return ne(()=>{this.invokeCallHook(e,t);let n=et(e);return this.rate>0&&this.rate<1?gy(()=>{let a=Math.sqrt(this.rate/(1-this.rate));return Y(n,rx(n.shape,1,a))},()=>n,t.training||!1):n})}};DN.className="GaussianDropout";_e.registerClass(DN);var ON=class extends vt{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||et(e).shape}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return ne(()=>{if(this.rate<1&&this.rate>0){let n=this._getNoiseShape(e);return gy(()=>{let a=et(e),r=-1.6732632423543772*1.0507009873554805,s=to(_l(n),this.rate);s=Yi(s,"float32");let i=((1-this.rate)*(1+this.rate*r**2))**-.5,o=-i*r*this.rate,u=ye(Y(a,s),Y(ye(s,-1),r));return ye(Y(u,i),o)},()=>et(e),t.training||!1)}return e})}};ON.className="AlphaDropout";_e.registerClass(ON);function ig(e,t,n,a,r,s=.001){let i;if(e.rank===2)i=S_(e,t,n,a,r,s);else if(e.rank===3)i=k_(e,t,n,a,r,s);else if(e.rank===4)i=__(e,t,n,a,r,s);else throw new bt(`batchNormalization is not implemented for array of rank ${e.rank} yet`);return i}function Jte(e,t,n,a,r=.001){return ne(()=>{let s=iy(e,a),i=s.mean,o=s.variance;return[ig(e,i,o,n,t,r),i,o]})}function Zte(e,t,n,a,r=.001){return ne(()=>{let s=iy(e,a),i=s.mean,o=s.variance,u=[];for(let g of Ps(0,e.rank))a.indexOf(g)!==-1?u.push(1):u.push(e.shape[g]);let d=te(i,u),c=te(o,u),p=t==null?null:te(t,u),m=n==null?null:te(n,u);return[ig(e,d,c,m,p,r),i,o]})}function Qte(e,t,n,a,r=.001){return E.arraysEqual(a.slice().sort(),Ps(0,e.rank-1))?Jte(e,t,n,a,r):Zte(e,t,n,a,r)}var MN=class extends vt{constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=gn(e.betaInitializer||"zeros"),this.gammaInitializer=gn(e.gammaInitializer||"ones"),this.movingMeanInitializer=gn(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=gn(e.movingVarianceInitializer||"ones"),this.betaConstraint=na(e.betaConstraint),this.gammaConstraint=na(e.gammaConstraint),this.betaRegularizer=yn(e.betaRegularizer),this.gammaRegularizer=yn(e.gammaRegularizer)}build(e){e=$t(e);let t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(n==null)throw new re(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new Bn({ndim:e.length,axes:{[t]:n}})];let a=[n];this.scale&&(this.gamma=this.addWeight("gamma",a,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",a,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",a,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",a,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return ne(()=>{let n=t.training==null?!1:t.training,a=et(e),r=a.shape,s=r.length,i=Ps(0,s),o=this.axis>=0?this.axis:this.axis+s;i.splice(o,1);let u=zu(1,s);u[o]=r[o];let d=i.slice();d.sort();let c=!E.arraysEqual(d,Ps(0,s).slice(0,s-1)),p=()=>{if(c){let x=te(this.movingMean.read(),u),w=te(this.movingVariance.read(),u),k=this.center?te(this.beta.read(),u):null,N=this.scale?te(this.gamma.read(),u):null;return ig(a,x,w,k,N,this.epsilon)}else return ig(a,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!n)return p();let[m,g,b]=Qte(a,this.gamma.read(),this.beta.read(),i,this.epsilon),v=(x,w,k)=>{ne(()=>{let N=1-k,I=x.read(),T=Y(Fe(I,w),N);x.write(Fe(I,T))})};return v(this.movingMean,g,this.momentum),v(this.movingVariance,b,this.momentum),m})}getConfig(){let e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:wn(this.betaInitializer),gammaInitializer:wn(this.gammaInitializer),movingMeanInitializer:wn(this.movingMeanInitializer),movingVarianceInitializer:wn(this.movingVarianceInitializer),betaRegularizer:an(this.betaRegularizer),gammaRegularizer:an(this.gammaRegularizer),betaConstraint:ta(this.betaConstraint),gammaConstraint:ta(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}};MN.className="BatchNormalization";_e.registerClass(MN);var FN=class extends vt{constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(let t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=gn(e.betaInitializer||"zeros"),this.gammaInitializer=gn(e.gammaInitializer||"ones"),this.betaRegularizer=yn(e.betaRegularizer),this.gammaRegularizer=yn(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=$t(e);let t=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let r=0;r<this.axis.length;++r)this.axis[r]<0&&(this.axis[r]+=t);for(let r of this.axis)if(r<0||r>=t)throw new Error(`Invalid axis: ${r}`);if(this.axis.length!==Qo(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);let n=this.axis.map(r=>e[r]),a=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,a):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,a):this.beta=null,this.built=!0}call(e,t){let n=et(e),a=n.shape,r=a.length;return ne(()=>{let{mean:s,variance:i}=iy(n,this.axis,!0),o=zu(1,r);for(let g of this.axis)o[g]=a[g];let u=g=>g!=null&&g.shape.length!==r?te(g,o):g,d=this.scale?u(this.gamma.read()):null,c=this.center?u(this.beta.read()):null,p=[],m=[];for(let g=0;g<r;++g)this.axis.indexOf(g)!==-1?(p.push(a[g]),m.push(1)):(p.push(1),m.push(a[g]));return s=Er(s,p),i=Er(i,p),d!=null&&(d=Er(d,m)),c!=null&&(c=Er(c,m)),ig(n,s,i,c,d,this.epsilon)})}getConfig(){let e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:wn(this.betaInitializer),gammaInitializer:wn(this.gammaInitializer),betaRegularizer:an(this.betaRegularizer),gammaRegularizer:an(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}};FN.className="LayerNormalization";_e.registerClass(FN);function ene(e,t,n){return ne(()=>{if(e.rank!==4)throw new re(`temporalPadding expects input tensor to be 4-D, but received a ${e.rank}-D tensor.`);if(t==null&&(t=[[1,1],[1,1]]),t.length!==2||t[0].length!==2||t[1].length!==2)throw new re("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(n==null&&(n=Us()),n!=="channelsLast"&&n!=="channelsFirst")throw new re(`Unknown data format: ${n}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let a;return n==="channelsFirst"?a=[[0,0],[0,0],t[0],t[1]]:a=[[0,0],t[0],t[1],[0,0]],Vs(e,a)})}var zN=class extends vt{constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?Us():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new re(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,n;if(typeof e.padding[0]=="number")t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new re(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],e.padding[1].length!==2)throw new re(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new Bn({ndim:4})]}computeOutputShape(e){e=$t(e);let t,n;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?t=e[2]+this.padding[0][0]+this.padding[0][1]:t=null,e[3]!=null&&e[3]>=0?n=e[3]+this.padding[1][0]+this.padding[1][1]:n=null,[e[0],e[1],t,n]):(e[1]!=null&&e[1]>=0?t=e[1]+this.padding[0][0]+this.padding[0][1]:t=null,e[2]!=null&&e[2]>=0?n=e[2]+this.padding[1][0]+this.padding[1][1]:n=null,[e[0],t,n,e[3]])}call(e,t){return ne(()=>ene(et(e),this.padding,this.dataFormat))}getConfig(){let e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};zN.className="ZeroPadding2D";_e.registerClass(zN);function _x(e,t,n,a,r,s){return ne(()=>{Dn(r),BF(s),es(a),n==null&&(n=[1,1]),a==null&&(a="valid"),r==null&&(r=Us()),s==null&&(s="max"),e=rN(e,r);let i,o=a==="same"?"same":"valid";return s==="max"?i=la(e,t,n,o):i=eo(e,t,n,o),r==="channelsFirst"&&(i=ft(i,[0,3,1,2])),i})}function V3(e,t,n,a,r,s){return ne(()=>{Dn(r),BF(s),es(a),n==null&&(n=[1,1,1]),a==null&&(a="valid"),r==null&&(r=Us()),s==null&&(s="max"),e=R3(e,r);let i,o=a==="same"?"same":"valid";return s==="max"?i=K_(e,t,n,o):i=w_(e,t,n,o),r==="channelsFirst"&&(i=ft(i,[0,4,1,2,3])),i})}var H3=class extends vt{constructor(e){if(e.poolSize==null&&(e.poolSize=2),super(e),typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new re(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(ha(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new re(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);ha(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,es(this.padding),this.inputSpec=[new Bn({ndim:3})]}computeOutputShape(e){e=$t(e);let t=Ls(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return ne(()=>{this.invokeCallHook(e,t),e=fy(et(e),2);let n=this.poolingFunction(et(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Il(n,[2])})}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}},LN=class extends H3{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return Dn(r),es(a),_x(e,t,n,a,r,"max")}};LN.className="MaxPooling1D";_e.registerClass(LN);var BN=class extends H3{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return Dn(r),es(a),_x(e,t,n,a,r,"avg")}};BN.className="AveragePooling1D";_e.registerClass(BN);var G3=class extends vt{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new re(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];ha(this.poolSize,"poolSize"),ha(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Dn(this.dataFormat),es(this.padding),this.inputSpec=[new Bn({ndim:4})]}computeOutputShape(e){e=$t(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2];return t=Ls(t,this.poolSize[0],this.padding,this.strides[0]),n=Ls(n,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return ne(()=>(this.invokeCallHook(e,t),this.poolingFunction(et(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},PN=class extends G3{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return Dn(r),es(a),_x(e,t,n,a,r,"max")}};PN.className="MaxPooling2D";_e.registerClass(PN);var UN=class extends G3{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return Dn(r),es(a),_x(e,t,n,a,r,"avg")}};UN.className="AveragePooling2D";_e.registerClass(UN);var q3=class extends vt{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new re(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];ha(this.poolSize,"poolSize"),ha(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Dn(this.dataFormat),es(this.padding),this.inputSpec=[new Bn({ndim:5})]}computeOutputShape(e){e=$t(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2],a=this.dataFormat==="channelsFirst"?e[4]:e[3];return t=Ls(t,this.poolSize[0],this.padding,this.strides[0]),n=Ls(n,this.poolSize[1],this.padding,this.strides[1]),a=Ls(a,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,n,a]:[e[0],t,n,a,e[4]]}call(e,t){return ne(()=>(this.invokeCallHook(e,t),this.poolingFunction(et(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},jN=class extends q3{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return Dn(r),es(a),V3(e,t,n,a,r,"max")}};jN.className="MaxPooling3D";_e.registerClass(jN);var WN=class extends q3{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return Dn(r),es(a),V3(e,t,n,a,r,"avg")}};WN.className="AveragePooling3D";_e.registerClass(WN);var K3=class extends vt{constructor(e){super(e),this.inputSpec=[new Bn({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new bt}},VN=class extends K3{constructor(e){super(e||{})}call(e,t){return ne(()=>{let n=et(e);return vn(n,1)})}};VN.className="GlobalAveragePooling1D";_e.registerClass(VN);var HN=class extends K3{constructor(e){super(e||{})}call(e,t){return ne(()=>{let n=et(e);return Yr(n,1)})}};HN.className="GlobalMaxPooling1D";_e.registerClass(HN);var X3=class extends vt{constructor(e){super(e),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Dn(this.dataFormat),this.inputSpec=[new Bn({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new bt}getConfig(){let e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},GN=class extends X3{call(e,t){return ne(()=>{let n=et(e);return this.dataFormat==="channelsLast"?vn(n,[1,2]):vn(n,[2,3])})}};GN.className="GlobalAveragePooling2D";_e.registerClass(GN);var qN=class extends X3{call(e,t){return ne(()=>{let n=et(e);return this.dataFormat==="channelsLast"?Yr(n,[1,2]):Yr(n,[2,3])})}};qN.className="GlobalMaxPooling2D";_e.registerClass(qN);var Y3=class extends vt{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){let e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,n={}){let a=t.layer,r=zs(a,n);delete t.layer;let s={layer:r};return Object.assign(s,t),new e(s)}},KN=class extends Y3{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=$t(e),e.length<3)throw new re(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];let t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=$t(e);let t=[e[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),a=e[1];return[n[0],a].concat(n.slice(1))}call(e,t){return ne(()=>(e=et(e),U3((n,a)=>[et(this.layer.call(n,t)),[]],e,[],!1,null,null,!1,!0)[1]))}};KN.className="TimeDistributed";_e.registerClass(KN);function tne(e){fd(eee,"BidirectionalMergeMode",e)}var nne="concat",XN=class extends Y3{constructor(e){super(e);let t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=zs(n),t.goBackwards=t.goBackwards!==!0;let a={};if(a.className=e.layer.getClassName(),a.config=t,this.backwardLayer=zs(a),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?nne:e.mergeMode,tne(this.mergeMode),e.weights)throw new bt("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){let t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t=this.forwardLayer.computeOutputShape(e);Array.isArray(t)&&Array.isArray(t[0])||(t=[t]),t=t;let n,a,r;return this.returnState&&(r=t.slice(1)),n=t[0],n=n,this.mergeMode==="concat"?(n[n.length-1]*=2,a=[n]):this.mergeMode==null?a=[n,n.slice()]:a=[n],this.returnState?this.mergeMode==null?a.concat(r).concat(r.slice()):[n].concat(r).concat(r.slice()):sr(a)}apply(e,t){let n=t==null?null:t.initialState,a=t==null?null:t.constants;t==null&&(t={});let r=P3(e,n,a,this.numConstants);if(e=r.inputs,n=r.initialState,a=r.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(n==null||n.length===0)&&a==null)return super.apply(e,t);let s=[],i=[];if(n!=null){let u=n.length;if(u%2>0)throw new re("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,s.push(...n);let d=n.map(c=>new Bn({shape:c.shape}));this.forwardLayer.stateSpec=d.slice(0,u/2),this.backwardLayer.stateSpec=d.slice(u/2),i.push(...d)}if(a!=null)throw new bt("Support for constants in Bidirectional layers is not implemented yet.");let o=s[0]instanceof js;for(let u of s)if(u instanceof js!==o)throw new re("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(o){let u=[e].concat(s),d=this.inputSpec.concat(i),c=this.inputSpec;this.inputSpec=d;let p=super.apply(u,t);return this.inputSpec=c,p}else return super.apply(e,t)}call(e,t){return ne(()=>{let n=t.initialState,a,r;if(n==null)a=this.forwardLayer.call(e,t),r=this.backwardLayer.call(e,t);else{let o=n.slice(0,n.length/2),u=n.slice(n.length/2);a=this.forwardLayer.call(e,Object.assign(t,{initialState:o})),r=this.backwardLayer.call(e,Object.assign(t,{initialState:u}))}let s;this.returnState&&(Array.isArray(a)&&(s=a.slice(1).concat(r.slice(1))),a=a[0],r=r[0]),this.returnSequences&&(r=Qr(r,1));let i;return this.mergeMode==="concat"?i=A2([a,r]):this.mergeMode==="sum"?i=ye(a,r):this.mergeMode==="ave"?i=Y(.5,ye(a,r)):this.mergeMode==="mul"?i=Y(a,r):this.mergeMode==null&&(i=[a,r]),this.returnState?this.mergeMode==null?i.concat(s):[i].concat(s):i})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){wu(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),wu(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){Array.isArray(t)&&(t=t[0]);let n;if(this.returnSequences?this.mergeMode==null?n=[t,t]:n=t:this.mergeMode==null?n=[null,null]:n=null,this.returnState){let a=this.forwardLayer.states.map(r=>null);return Array.isArray(n)?n.concat(a).concat(a):[n].concat(a).concat(a)}else return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){let e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){let n=zs(t.layer);if(delete t.layer,t.numConstants!=null)throw new bt("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");let a=t;return a.layer=n,new e(a)}};XN.className="Bidirectional";_e.registerClass(XN);var YN=class extends vt{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){let e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return ne(()=>(e=et(e),e.dtype!=="float32"&&(e=Yi(e,"float32")),ye(Y(e,this.scale),this.offset)))}};YN.className="Rescaling";_e.registerClass(YN);var{resizeBilinear:ane,cropAndResize:rne}=Gr,JN=class extends vt{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,n,a,r,s,i,o){return ne(()=>{let u,d=!1,c=t/s,p=n/i,m=(a+t)/s,g=(r+n)/i,b=[c,p,m,g],v=[];e.rank===3?(d=!0,u=Un([e])):u=e;for(let N=0;N<u.shape[0];N++)v.push(b);let x=qa(v,[v.length,4]),w=Fu(0,v.length,1,"int32"),k=rne(u,x,w,[a,r],"nearest");return Yi(d?et(Nn(k)):k,o)})}upsize(e,t,n,a){return ne(()=>{let r=ane(e,[t,n]);return Yi(r,a)})}call(e,t){return ne(()=>{let n=et(e),a=n.dtype,r=n.shape,s=r[r.length-3],i=r[r.length-2],o=0;s!==this.height&&(o=Math.floor((s-this.height)/2));let u=0;return i!==this.width&&(u=Math.floor((i-this.width)/2),u===0&&(u=1)),o>=0&&u>=0?this.centerCrop(n,o,u,this.height,this.width,s,i,a):this.upsize(e,this.height,this.width,a)})}getConfig(){let e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=$t(e);let t=e.length-3,n=e.length-2;return e[t]=this.height,e[n]=this.width,e}};JN.className="CenterCrop";_e.registerClass(JN);function sne(e,t,n,a){let r=et(e);if(r.dtype!=="int32"&&(r=Yi(r,"int32")),t==="int")return r;let s=r.shape;if(r.rank===0&&(r=da(r,-1)),t==="oneHot"&&r.shape[r.shape.length-1]!==1&&(r=da(r,-1)),r.rank>2)throw new re(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${s} which would result in output rank ${r.rank}.`);let i=["multiHot","oneHot"].includes(t),o=r,u;if(typeof a<"u"&&t==="count"?u=Ev(o,a,n,i):u=Ev(o,[],n,i),t!=="tfIdf")return u;if(a)return Y(u,a);throw new re("When outputMode is 'tfIdf', weights must be provided.")}var ZN=class extends vt{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){let e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return e=$t(e),e==null?[this.numTokens]:this.outputMode==="oneHot"&&e[e.length-1]!==1?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return ne(()=>{e=et(e),e.dtype!=="int32"&&(e=Yi(e,"int32"));let n;if(typeof t.countWeights<"u"){if(this.outputMode!=="count")throw new re(`countWeights is not used when outputMode !== count.
              Received countWeights=${t.countWeights}`);n=et(t.countWeights)}let a=Yr(e),r=Lh(e),s=Qa(this.numTokens,a).bufferSync().get(0),i=to(r,0).bufferSync().get(0);if(!(s&&i))throw new re(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return sne(e,this.outputMode,this.numTokens,n)})}};ZN.className="CategoryEncoding";_e.registerClass(ZN);var ine=["bilinear","nearest"],iR=new Set(ine),QN=class extends vt{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(iR.has(e.interpolation))this.interpolation=e.interpolation;else throw new re(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){e=$t(e);let t=e[2];return[this.height,this.width,t]}getConfig(){let e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return ne(()=>{let n=[this.height,this.width];if(this.interpolation==="bilinear")return Gr.resizeBilinear(e,n,!this.cropToAspectRatio);if(this.interpolation==="nearest")return Gr.resizeNearestNeighbor(e,n,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...iR]} are supported`)})}};QN.className="Resizing";_e.registerClass(QN);var J3=class{constructor(e){this.seed=e}next(){if(this.seed!==void 0)return this.seed++}};J3.className="RandomSeed";var Z3=class extends vt{constructor(e){super(e),this.randomGenerator=new J3(e.seed)}getConfig(){let e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}};Z3.className="BaseRandomLayer";var one=["bilinear","nearest"],oR=new Set(one),eI=class extends Z3{constructor(e){super(e);let{factor:t,interpolation:n="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new re(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new re(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new re(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(n)if(oR.has(n))this.interpolation=n;else throw new re(`Invalid interpolation parameter: ${n} is not implemented`)}getConfig(){let e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=$t(e);let t=e[2];return[this.imgHeight,-1,t]}call(e,t){return ne(()=>{let n=et(e);this.imgHeight=n.shape[n.shape.length-3];let a=n.shape[n.shape.length-2];this.widthFactor=_l([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let r=this.widthFactor.dataSync()[0]*a;r=Math.round(r);let s=[this.imgHeight,r];switch(this.interpolation){case"bilinear":return Gr.resizeBilinear(e,s);case"nearest":return Gr.resizeNearestNeighbor(e,s);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...oR]} are supported`)}})}};eI.className="RandomWidth";_e.registerClass(eI);function lne(e){return new hf(e)}function une(e){return new tN(e)}function cne(e){return new Z2(e)}function dne(e){return new Q2(e)}function hne(e){return new eN(e)}function pne(e){return new aN(e)}function fne(e){return new nN(e)}function mne(e){return new lN(e)}function gne(e){return new yx(e)}function yne(e){return new sN(e)}function bne(e){return new bx(e)}function vne(e){return new iN(e)}function xne(e){return new oN(e)}function wne(e){return new uN(e)}function Sne(e){return new cN(e)}function kne(e){return new dN(e)}function _ne(e){return new vN(e)}function Nne(e){return new yN(e)}function Ine(e){return new kx(e)}function Tne(e){return new gN(e)}function Ene(e){return new bN(e)}function Cne(e){return new xN(e)}function Ane(e){return new wN(e)}function $ne(e){return new SN(e)}function Rne(e){return new _N(e)}function Dne(e){return new NN(e)}function One(e){return new TN(e)}function Mne(e){return new AN(e)}function Fne(e){return new EN(e)}function zne(e){return new CN(e)}function Lne(e){return new IN(e)}function Bne(e){return new $N(e)}function Pne(e){return new MN(e)}function Une(e){return new FN(e)}function jne(e){return new zN(e)}function tI(e){return new BN(e)}function Wne(e){return tI(e)}function Vne(e){return tI(e)}function nI(e){return new UN(e)}function Hne(e){return nI(e)}function Gne(e){return nI(e)}function aI(e){return new WN(e)}function qne(e){return aI(e)}function Kne(e){return aI(e)}function Xne(e){return new VN(e)}function Yne(e){return new GN(e)}function Q3(e){return new HN(e)}function ez(e){return new qN(e)}function tz(e){return new LN(e)}function nz(e){return new PN(e)}function Jne(e){return new jN(e)}function Zne(e){return new pN(e)}function Qne(e){return new xx(e)}function eae(e){return new fN(e)}function tae(e){return new xy(e)}function nae(e){return new hN(e)}function aae(e){return new vx(e)}function rae(e){return new mN(e)}function sae(e){return new Sx(e)}function iae(e){return new ro(e)}function oae(e){return new wx(e)}function lae(e){return new XN(e)}function uae(e){return new KN(e)}var cae=Q3,dae=ez,hae=tz,pae=nz;function fae(e){return new RN(e)}function mae(e){return new DN(e)}function gae(e){return new ON(e)}function yae(e){return new kN(e)}function bae(e){return new YN(e)}function vae(e){return new JN(e)}function xae(e){return new QN(e)}function wae(e){return new ZN(e)}function Sae(e){return new eI(e)}var az={};ot(az,{MAPE:()=>Dae,MSE:()=>Fae,binaryAccuracy:()=>kae,binaryCrossentropy:()=>_ae,categoricalAccuracy:()=>Iae,categoricalCrossentropy:()=>Tae,cosineProximity:()=>Aae,mape:()=>Oae,meanAbsoluteError:()=>$ae,meanAbsolutePercentageError:()=>Rae,meanSquaredError:()=>Mae,mse:()=>zae,precision:()=>Eae,r2Score:()=>Lae,recall:()=>Cae,sparseCategoricalAccuracy:()=>Nae});function kae(e,t){return G2(e,t)}function _ae(e,t){return i3(e,t)}function Nae(e,t){return o3(e,t)}function Iae(e,t){return q2(e,t)}function Tae(e,t){return K2(e,t)}function Eae(e,t){return s3(e,t)}function Cae(e,t){return ite(e,t)}function Aae(e,t){return H2(e,t)}function $ae(e,t){return px(e,t)}function Rae(e,t){return pf(e,t)}function Dae(e,t){return pf(e,t)}function Oae(e,t){return pf(e,t)}function Mae(e,t){return md(e,t)}function Fae(e,t){return md(e,t)}function zae(e,t){return md(e,t)}function Lae(e,t){return ote(e,t)}var rz={};ot(rz,{modelFromJSON:()=>zte});var sz={};ot(sz,{l1:()=>Pae,l1l2:()=>Bae,l2:()=>Uae});function Bae(e){return new by(e)}function Pae(e){return Vte(e)}function Uae(e){return Hte(e)}var iz=class extends Gh{constructor(){super(...arguments),this.model=null}setModel(e){if(!(e instanceof Gi))throw new Error("model must be a LayersModel, not some other Container");this.model=e}};function Kb(e,t){return e<t}function lR(e,t){return e>t}var oz=class extends iz{constructor(e){if(super(),e==null&&(e={}),e.restoreBestWeights)throw new bt("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=e.monitor||"val_loss",this.minDelta=Math.abs(e.minDelta||0),this.patience=e.patience||0,this.verbose=e.verbose||0,this.mode=e.mode||"auto",this.baseline=e.baseline,["auto","min","max"].indexOf(this.mode)===-1&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),this.mode==="min"?this.monitorFunc=Kb:this.mode==="max"?this.monitorFunc=lR:this.monitor.indexOf("acc")!==-1?this.monitorFunc=lR:this.monitorFunc=Kb,this.monitorFunc===Kb&&(this.minDelta*=-1)}async onTrainBegin(e){this.wait=0,this.stoppedEpoch=0,this.baseline!=null?this.best=this.baseline:this.best=this.monitorFunc===Kb?1/0:-1/0}async onEpochEnd(e,t){await Uo(t);let n=this.getMonitorValue(t);n!=null&&(this.monitorFunc(n-this.minDelta,this.best)?(this.best=n,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)))}async onTrainEnd(e){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(e){e==null&&(e={});let t=e[this.monitor];return t==null&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`),t}};function jae(e){return new oz(e)}var Wae={earlyStopping:jae},Vae=oe();Vae.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var _r;(function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"})(_r||(_r={}));var uR;(function(e){(function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"})(e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))})(uR||(uR={}));var rI={};function Hae(e,t){let n={tfOpName:e,category:"custom",inputs:[],attrs:[],customExecutor:t};rI[e]=n}function lz(e){return rI[e]}function Gae(e){delete rI[e]}function C(e,t,n,a,r){let s=t.inputParams[e];if(s&&s.inputIndexStart!==void 0){let o=s.inputIndexStart,u=s.inputIndexEnd===0?void 0:s.inputIndexEnd===void 0?o+1:s.inputIndexEnd,d=o<0?t.inputNames.length+o:o;if(s.type==="tensor")return ka(t.inputNames[d],n,a,r);if(s.type==="tensors"){let m=t.inputs.slice(o,u);return t.inputNames.slice(o,u).filter((g,b)=>{var v;return((v=m[b])===null||v===void 0?void 0:v.op)!=="NoOp"}).map(g=>ka(g,n,a,r))}let c=ka(t.inputNames[d],n,a,r),p=c.dataSync();return s.type==="number"?p[0]:E.toNestedArray(c.shape,p)}let i=t.attrParams[e];return i&&i.value}function ka(e,t,n,a){let[r,s]=Ir(e,n);if(a!=null){let o=a.getHashTableHandleByName(r);if(o!=null)return o}let i=n.currentContextIds.find(o=>!!t[Bv(r,o)]);return i!==void 0?t[Bv(r,i)][s]:void 0}function cR(e,t,n){return t[Bv(e,n.currentContextId)]}function Ui(e,t){let[n,a,r]=Ir(e,t);return[Bv(n,t&&t.currentContextId),a,r]}function Bv(e,t){return t?`${e}-${t}`:e}function Ir(e,t){if(e==="")return["",0,void 0];let n=t!=null&&t.parseNodeNameCache!=null;if(n){let s=t.parseNodeNameCache.get(e);if(s!=null)return s}let a=e.split(":"),r;if(a.length===1)r=[e,0,void 0];else{let s=a[0],i=a.length===3?a[1]:void 0,o=Number(a[a.length-1]);r=[s,o,i]}return n&&t.parseNodeNameCache.set(e,r),r}function pv(e,t,n){let a=C("pad",e,t,n);if(a==="explicit"){a=C("explicitPaddings",e,t,n);let r=[[0,0],[0,0],[0,0],[0,0]];for(let s=0;s<4;s++)r[s][0]=a[s*2],r[s][1]=a[s*2+1];return r}return a}function ji(e){return e.kept?e:li(e)}var uz={};ot(uz,{json:()=>qae});var qae=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],cz={};ot(cz,{json:()=>Kae});var Kae=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],dz={};ot(dz,{json:()=>Xae});var Xae=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],hz={};ot(hz,{json:()=>Yae});var Yae=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],pz={};ot(pz,{json:()=>Jae});var Jae=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],fz={};ot(fz,{json:()=>Zae});var Zae=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],mz={};ot(mz,{json:()=>Qae});var Qae=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],gz={};ot(gz,{json:()=>ere});var ere=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],yz={};ot(yz,{json:()=>tre});var tre=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],bz={};ot(bz,{json:()=>nre});var nre=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],vz={};ot(vz,{json:()=>are});var are=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],xz={};ot(xz,{json:()=>rre});var rre=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],wz={};ot(wz,{json:()=>sre});var sre=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],Sz={};ot(Sz,{json:()=>ire});var ire=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],kz={};ot(kz,{json:()=>ore});var ore=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],_z={};ot(_z,{json:()=>lre});var lre=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],Nz={};ot(Nz,{json:()=>ure});var ure=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],Iz={};ot(Iz,{json:()=>cre});var cre=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],Tz={};ot(Tz,{json:()=>dre});var dre=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],dR=class{static get Instance(){return this._instance||(this._instance=new this)}constructor(){let e=[uz,cz,dz,hz,pz,fz,mz,gz,yz,bz,vz,xz,wz,Sz,kz,_z,Nz,Iz,Tz],t=[].concat(...e.map(n=>n.json));this.opMappers=t.reduce((n,a)=>(n[a.tfOpName]=a,n),{})}transformGraph(e,t={}){let n=e.node,a=[],r=[],s=[],i=n.reduce((b,v)=>(b[v.name]=this.mapNode(v),v.op.startsWith("Placeholder")?a.push(b[v.name]):v.op==="Const"?r.push(b[v.name]):(v.input==null||v.input.length===0)&&s.push(b[v.name]),b),{}),o=[],u=[],d={},c={};t!=null&&(d=this.mapSignatureEntries(t.inputs),c=this.mapSignatureEntries(t.outputs));let p=Object.keys(i);p.forEach(b=>{let v=i[b];v.inputNames.forEach((x,w)=>{let[k,,N]=Ui(x),I=i[k];if(I.outputs!=null){let T=I.outputs.indexOf(N);if(T!==-1){let $=`${k}:${T}`;v.inputNames[w]=$}}v.inputs.push(I),I.children.push(v)})}),Object.keys(c).length===0?p.forEach(b=>{let v=i[b];v.children.length===0&&u.push(v)}):Object.keys(c).forEach(b=>{let[v]=Ui(b),x=i[v];x!=null&&(x.signatureKey=c[b],u.push(x))}),Object.keys(d).length>0?Object.keys(d).forEach(b=>{let[v]=Ui(b),x=i[v];x&&(x.signatureKey=d[b],o.push(x))}):o=a;let m={};e.library!=null&&e.library.function!=null&&(m=e.library.function.reduce((b,v)=>(b[v.signature.name]=this.mapFunction(v),b),{}));let g={nodes:i,inputs:o,outputs:u,weights:r,placeholders:a,signature:t,functions:m};return s.length>0&&(g.initNodes=s),g}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,n)=>(t[e[n].name]=n,t),{})}mapNode(e){let t=lz(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});let n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(a=>a.startsWith("^")?a.slice(1):a),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(n.inputParams=t.inputs.reduce((a,r)=>(a[r.name]={type:r.type,inputIndexStart:r.start,inputIndexEnd:r.end},a),{})),t.attrs!=null&&(n.attrParams=t.attrs.reduce((a,r)=>{let s=r.type,i;switch(r.type){case"string":i=ak(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=ak(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"string[]":i=ck(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=ck(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"number":i=sk(e.attr,r.tfName,r.defaultValue||0),i===void 0&&r.tfDeprecatedName&&(i=sk(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"number[]":i=uk(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=uk(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"bool":i=rk(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=rk(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"bool[]":i=hk(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=hk(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"shape":i=lk(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=lk(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"shape[]":i=dk(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=dk(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"dtype":i=ik(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=ik(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"dtype[]":i=ok(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=ok(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"func":i=hR(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=hR(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${r.type} for op: ${e.op}`)}return a[r.name]={value:i,type:s},a},{})),n}mapFunction(e){let t=e.nodeDef,n=[],a=[],r={};t!=null&&(r=t.reduce((d,c)=>(d[c.name]=this.mapNode(c),c.op==="Const"&&a.push(d[c.name]),d),{}));let s=[],i=[];e.signature.inputArg.forEach(d=>{let[c]=Ui(d.name),p={name:c,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:sI(d.type),type:"dtype"}},children:[]};p.signatureKey=d.name,s.push(p),r[c]=p}),Object.keys(r).forEach(d=>{let c=r[d];c.inputNames.forEach((p,m)=>{let[g,,b]=Ui(p),v=r[g];if(v.outputs!=null){let x=v.outputs.indexOf(b);if(x!==-1){let w=`${g}:${x}`;c.inputNames[m]=w}}c.inputs.push(v),v.children.push(c)})});let o=e.ret;e.signature.outputArg.forEach(d=>{let[c,p]=Ui(o[d.name]),m=r[c];m!=null&&(m.defaultOutput=p,i.push(m))});let u=this.mapArgsToSignature(e);return{nodes:r,inputs:s,outputs:i,weights:a,placeholders:n,signature:u}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n),t),{}),outputs:e.signature.outputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t),{})}}mapArgToTensorInfo(e,t){let n=e.name;return t!=null&&(n=t[n]),{name:n,dtype:e.type}}};function hre(e){let t=oe().global;if(typeof t.atob<"u")return t.atob(e);if(typeof Buffer<"u")return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function Ez(e,t){let n=Array.isArray(e)?String.fromCharCode.apply(null,e):hre(e);return t?n:n.toLowerCase()}function ak(e,t,n,a=!1){let r=e[t];return r!=null?Ez(r.s,a):n}function rk(e,t,n){let a=e[t];return a?a.b:n}function sk(e,t,n){let a=e[t]||{},r=a.i!=null?a.i:a.f!=null?a.f:n;return typeof r=="number"?r:parseInt(r,10)}function sI(e){switch(typeof e=="string"&&(e=_r[e]),e){case _r.DT_FLOAT:case _r.DT_HALF:return"float32";case _r.DT_INT32:case _r.DT_INT64:case _r.DT_INT8:case _r.DT_UINT8:return"int32";case _r.DT_BOOL:return"bool";case _r.DT_DOUBLE:return"float32";case _r.DT_STRING:return"string";case _r.DT_COMPLEX64:case _r.DT_COMPLEX128:return"complex64";default:return null}}function hR(e,t,n){let a=e[t];return a&&a.func?a.func.name:n}function ik(e,t,n){let a=e[t];return a&&a.type?sI(a.type):n}function ok(e,t,n){let a=e[t];return a&&a.list&&a.list.type?a.list.type.map(r=>sI(r)):n}function Cz(e){if(!e.unknownRank)return e.dim!=null?e.dim.map(t=>typeof t.size=="number"?t.size:parseInt(t.size,10)):[]}function lk(e,t,n){let a=e[t];return a&&a.shape?Cz(a.shape):n}function uk(e,t,n){let a=e[t];return a?((a.list.f&&a.list.f.length?a.list.f:a.list.i)||[]).map(r=>typeof r=="number"?r:parseInt(r,10)):n}function ck(e,t,n,a=!1){let r=e[t];return r&&r.list&&r.list.s?r.list.s.map(s=>Ez(s,a)):n}function dk(e,t,n){let a=e[t];return a&&a.list&&a.list.shape?a.list.shape.map(r=>Cz(r)):n}function hk(e,t,n){let a=e[t];return a&&a.list&&a.list.b?a.list.b:n}var pre=class{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(a=>this.getInput(a)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((a,r)=>(a[r]=this.getAttr(r),a),{}))}getInput(e){return ka(e,this.tensorMap,this.context)}getAttr(e,t){let n=this.node.rawAttrs[e];if(n.tensor!=null)return ka(e,this.tensorMap,this.context);if(n.i!=null||n.f!=null)return sk(this.node.rawAttrs,e,t);if(n.s!=null)return ak(this.node.rawAttrs,e,t);if(n.b!=null)return rk(this.node.rawAttrs,e,t);if(n.shape!=null)return lk(this.node.rawAttrs,e,t);if(n.type!=null)return ik(this.node.rawAttrs,e,t);if(n.list!=null){if(n.list.i!=null||n.list.f!=null)return uk(this.node.rawAttrs,e,t);if(n.list.s!=null)return ck(this.node.rawAttrs,e,t);if(n.list.shape!=null)return dk(this.node.rawAttrs,e,t);if(n.list.b!=null)return hk(this.node.rawAttrs,e,t);if(n.list.type!=null)return ok(this.node.rawAttrs,e,t)}return t}},ga={};ot(ga,{OP_SCOPE_SUFFIX:()=>o_,abs:()=>Ln,acos:()=>h_,acosh:()=>p_,add:()=>ye,addN:()=>WO,all:()=>N0,any:()=>eg,argMax:()=>Ru,argMin:()=>f_,asin:()=>m_,asinh:()=>g_,atan:()=>y_,atan2:()=>b_,atanh:()=>v_,avgPool:()=>eo,avgPool3d:()=>w_,basicLSTMCell:()=>qO,batchNorm:()=>cd,batchNorm2d:()=>S_,batchNorm3d:()=>k_,batchNorm4d:()=>__,batchToSpaceND:()=>Qg,bincount:()=>N_,bitwiseAnd:()=>KO,booleanMaskAsync:()=>zM,broadcastArgs:()=>XO,broadcastTo:()=>xu,buffer:()=>mt,cast:()=>Te,ceil:()=>I_,clipByValue:()=>za,clone:()=>li,complex:()=>Xi,concat:()=>Yt,concat1d:()=>T_,concat2d:()=>E_,concat3d:()=>C_,concat4d:()=>A_,conv1d:()=>I0,conv2d:()=>Ka,conv2dTranspose:()=>T0,conv3d:()=>R_,conv3dTranspose:()=>D_,cos:()=>ey,cosh:()=>E0,cosineWindow:()=>J0,cumprod:()=>ag,cumsum:()=>C0,denseBincount:()=>Ev,depthToSpace:()=>O_,depthwiseConv2d:()=>dd,diag:()=>JO,dilation2d:()=>M_,div:()=>Le,divNoNan:()=>F_,dot:()=>z_,dropout:()=>h2,einsum:()=>du,elu:()=>rf,enclosingPowerOfTwo:()=>p2,ensureShape:()=>QO,equal:()=>Ar,erf:()=>A0,euclideanNorm:()=>P_,exp:()=>La,expandDims:()=>da,expm1:()=>U_,eye:()=>$0,fft:()=>cy,fill:()=>Cr,floor:()=>of,floorDiv:()=>_0,fused:()=>Vh,gather:()=>lf,gatherND:()=>UM,greater:()=>Qa,greaterEqual:()=>to,ifft:()=>Wh,imag:()=>ty,image:()=>Gr,inTopKAsync:()=>jM,irfft:()=>V0,isFinite:()=>j_,isInf:()=>W_,isNaN:()=>V_,leakyRelu:()=>ny,less:()=>Bh,lessEqual:()=>kl,linalg:()=>g2,linspace:()=>rM,localResponseNormalization:()=>H_,log:()=>$r,log1p:()=>ay,logSigmoid:()=>G_,logSoftmax:()=>D0,logSumExp:()=>ry,logicalAnd:()=>bs,logicalNot:()=>sy,logicalOr:()=>O0,logicalXor:()=>q_,losses:()=>eF,lowerBound:()=>iM,matMul:()=>pt,max:()=>Yr,maxPool:()=>la,maxPool3d:()=>K_,maxPoolWithArgmax:()=>oM,maximum:()=>gi,mean:()=>vn,meshgrid:()=>lM,min:()=>Lh,minimum:()=>ol,mirrorPad:()=>X_,mod:()=>Y_,moments:()=>iy,movingAverage:()=>LM,mul:()=>Y,multiRNNCell:()=>uM,multinomial:()=>cM,neg:()=>un,norm:()=>sf,notEqual:()=>Mu,oneHot:()=>Ph,ones:()=>or,onesLike:()=>Rr,op:()=>X,outerProduct:()=>dM,pad:()=>Vs,pad1d:()=>hM,pad2d:()=>pM,pad3d:()=>fM,pad4d:()=>mM,pool:()=>J_,pow:()=>hi,prelu:()=>ly,print:()=>d_,prod:()=>Z_,raggedGather:()=>gM,raggedRange:()=>yM,raggedTensorToTensor:()=>bM,rand:()=>vM,randomGamma:()=>kM,randomNormal:()=>F0,randomStandardNormal:()=>_M,randomUniform:()=>_l,randomUniformInt:()=>NM,range:()=>Fu,real:()=>Uh,reciprocal:()=>a2,relu:()=>jt,relu6:()=>z0,reshape:()=>te,reverse:()=>Qr,reverse1d:()=>IM,reverse2d:()=>TM,reverse3d:()=>EM,reverse4d:()=>CM,rfft:()=>dy,round:()=>L0,rsqrt:()=>B0,scalar:()=>He,scatterND:()=>BM,searchSorted:()=>M0,selu:()=>P0,separableConv2d:()=>uf,setdiff1dAsync:()=>AM,sigmoid:()=>ys,sign:()=>r2,signal:()=>QM,sin:()=>U0,sinh:()=>j0,slice:()=>wt,slice1d:()=>uy,slice2d:()=>W0,slice3d:()=>cf,slice4d:()=>jh,softmax:()=>Nl,softplus:()=>hd,spaceToBatchND:()=>oy,sparse:()=>tF,sparseToDense:()=>PM,spectral:()=>ZM,split:()=>lr,sqrt:()=>fa,square:()=>Xt,squaredDifference:()=>H0,squeeze:()=>Il,stack:()=>Un,step:()=>pd,stridedSlice:()=>s2,string:()=>nF,sub:()=>Fe,sum:()=>Be,tan:()=>i2,tanh:()=>il,tensor:()=>qa,tensor1d:()=>Lt,tensor2d:()=>ui,tensor3d:()=>G0,tensor4d:()=>ll,tensor5d:()=>$M,tensor6d:()=>RM,tensorScatterUpdate:()=>OM,tile:()=>Er,topk:()=>l2,transpose:()=>ft,truncatedNormal:()=>X0,unique:()=>u2,unsortedSegmentSum:()=>Y0,unstack:()=>Nn,upperBound:()=>MM,variable:()=>c2,where:()=>pa,whereAsync:()=>d2,zeros:()=>xn,zerosLike:()=>_t});var fre=(e,t,n,a=ga)=>{switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[a.add(C("a",e,t,n),C("b",e,t,n))];case"AddN":return[a.addN(C("tensors",e,t,n))];case"FloorMod":case"Mod":return[a.mod(C("a",e,t,n),C("b",e,t,n))];case"Mul":return[a.mul(C("a",e,t,n),C("b",e,t,n))];case"RealDiv":case"Div":return[a.div(C("a",e,t,n),C("b",e,t,n))];case"DivNoNan":return[a.divNoNan(C("a",e,t,n),C("b",e,t,n))];case"FloorDiv":return[a.floorDiv(C("a",e,t,n),C("b",e,t,n))];case"Sub":return[a.sub(C("a",e,t,n),C("b",e,t,n))];case"Minimum":return[a.minimum(C("a",e,t,n),C("b",e,t,n))];case"Maximum":return[a.maximum(C("a",e,t,n),C("b",e,t,n))];case"Pow":return[a.pow(C("a",e,t,n),C("b",e,t,n))];case"SquaredDifference":return[a.squaredDifference(C("a",e,t,n),C("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},mre=(e,t,n,a=ga)=>{switch(e.op){case"Abs":case"ComplexAbs":return[a.abs(C("x",e,t,n))];case"Acos":return[a.acos(C("x",e,t,n))];case"Acosh":return[a.acosh(C("x",e,t,n))];case"Asin":return[a.asin(C("x",e,t,n))];case"Asinh":return[a.asinh(C("x",e,t,n))];case"Atan":return[a.atan(C("x",e,t,n))];case"Atan2":return[a.atan2(C("x",e,t,n),C("y",e,t,n))];case"Atanh":return[a.atanh(C("x",e,t,n))];case"Ceil":return[a.ceil(C("x",e,t,n))];case"Complex":return[a.complex(C("real",e,t,n),C("imag",e,t,n))];case"Cos":return[a.cos(C("x",e,t,n))];case"Cosh":return[a.cosh(C("x",e,t,n))];case"Elu":return[a.elu(C("x",e,t,n))];case"Erf":return[a.erf(C("x",e,t,n))];case"Exp":return[a.exp(C("x",e,t,n))];case"Expm1":return[a.expm1(C("x",e,t,n))];case"Floor":return[a.floor(C("x",e,t,n))];case"Log":return[a.log(C("x",e,t,n))];case"Log1p":return[a.log1p(C("x",e,t,n))];case"Imag":return[a.imag(C("x",e,t,n))];case"Neg":return[a.neg(C("x",e,t,n))];case"Reciprocal":return[a.reciprocal(C("x",e,t,n))];case"Real":return[a.real(C("x",e,t,n))];case"Relu":return[a.relu(C("x",e,t,n))];case"Round":return[a.round(C("x",e,t,n))];case"Selu":return[a.selu(C("x",e,t,n))];case"Sigmoid":return[a.sigmoid(C("x",e,t,n))];case"Sin":return[a.sin(C("x",e,t,n))];case"Sign":return[a.sign(C("x",e,t,n))];case"Sinh":return[a.sinh(C("x",e,t,n))];case"Softplus":return[a.softplus(C("x",e,t,n))];case"Sqrt":return[a.sqrt(C("x",e,t,n))];case"Square":return[a.square(C("x",e,t,n))];case"Tanh":return[a.tanh(C("x",e,t,n))];case"Tan":return[a.tan(C("x",e,t,n))];case"ClipByValue":return[a.clipByValue(C("x",e,t,n),C("clipValueMin",e,t,n),C("clipValueMax",e,t,n))];case"Relu6":return[a.relu6(C("x",e,t,n))];case"Rsqrt":return[a.rsqrt(ka(e.inputNames[0],t,n))];case"LeakyRelu":return[a.leakyRelu(C("x",e,t,n),C("alpha",e,t,n))];case"Prelu":return[a.prelu(C("x",e,t,n),C("alpha",e,t,n))];case"IsNan":return[a.isNaN(ka(e.inputNames[0],t,n))];case"IsInf":return[a.isInf(ka(e.inputNames[0],t,n))];case"IsFinite":return[a.isFinite(ka(e.inputNames[0],t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function gs(e,t,n=""){if(!(typeof e=="number"||typeof t=="number")){E.assert(e.length===t.length,()=>n+` Shapes ${e} and ${t} must match`);for(let a=0;a<e.length;a++){let r=e[a],s=t[a];E.assert(r<0||s<0||r===s,()=>n+` Shapes ${e} and ${t} must match`)}}}function pR(e){return!(typeof e=="number"||e.some(t=>t<0))}function Nm(e,t,n){let a=pk(e,n),r=!pR(a);if(r&&t.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${a}`);if(r&&t.forEach(s=>{a=pk(s.shape,a)}),!pR(a))throw new Error(`Non-fully-defined elementShape: ${a}`);return a}function pk(e,t){if(typeof e=="number")return t;if(typeof t=="number")return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);let n=[];for(let a=0;a<e.length;++a){let r=e[a],s=t[a];if(r>=0&&s>=0&&r!==s)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);n[a]=r>=0?r:s}return n}var gre=class{constructor(e,t,n,a,r,s,i){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=a,this.identicalElementShapes=r,this.dynamicSize=s,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=He(0),Zn(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);let t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);let n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),gs(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,Zn(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((n,a)=>this.write(n,t[a]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let a=0;a<this.size();a++)e.push(a)}if(e.length===0)return qa([],[0].concat(this.elementShape));let n=this.readMany(e);return gs(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),Un(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return qa([],[0].concat(this.elementShape));let t=[];for(let a=0;a<this.size();a++)t.push(a);let n=this.readMany(t);return gs(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),Yt(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);let n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,Nn(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0,a=e.map(o=>(n+=o,n));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);let r=n===0?0:t.size/n,s=[];ne(()=>{t=te(t,[1,n,r]);for(let o=0;o<e.length;++o){let u=[0,o===0?0:a[o-1],0],d=[1,e[o],r];s[o]=te(wt(t,u,d),this.elementShape)}return s});let i=[];for(let o=0;o<e.length;o++)i[o]=o;this.writeMany(i,s)}},Nx=class fk{get id(){return this.idTensor.id}constructor(t,n,a,r=-1){this.tensors=t,this.elementShape=n,this.elementDtype=a,t?.forEach(s=>{if(a!==s.dtype)throw new Error(`Invalid data types; op elements ${a}, but list elements ${s.dtype}`);gs(n,s.shape,"TensorList shape mismatch: "),Zn(s)}),this.idTensor=He(0),this.maxNumElements=r,Zn(this.idTensor)}copy(){return new fk([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(t){this.tensors.forEach(n=>{(t==null||!t.has(n.id))&&n.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(t,n,a=-1){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(a!==-1&&this.tensors.length!==a)throw new Error(`Operation expected a list with ${a} elements but got a list with ${this.tensors.length} elements.`);gs(t,this.elementShape,"TensorList shape mismatch: ");let r=Nm(this.elementShape,this.tensors,t);return ne(()=>{let s=this.tensors.map(i=>te(i,r));return Un(s,0)})}popBack(t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");let a=Nm(this.elementShape,this.tensors,t),r=this.tensors.pop();return r.kept=!1,gs(r.shape,t,"TensorList shape mismatch: "),te(r,a)}pushBack(t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(gs(t.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Zn(t),this.tensors.push(t)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(this.maxNumElements!==-1&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);let n=new fk([],this.elementShape,this.elementDtype,this.maxNumElements);n.tensors.length=t;for(let a=0;a<Math.min(this.tensors.length,t);++a)n.tensors[a]=this.tensors[a];return n}getItem(t,n,a){if(a!==this.elementDtype)throw new Error(`Invalid data types; op elements ${a}, but list elements ${this.elementDtype}`);if(t<0||t>this.tensors.length)throw new Error(`Trying to access element ${t} in a list with ${this.tensors.length} elements.`);if(this.tensors[t]==null)throw new Error(`element at index ${t} is null.`);gs(this.tensors[t].shape,n,"TensorList shape mismatch: ");let r=Nm(this.elementShape,this.tensors,n);return te(this.tensors[t],r)}setItem(t,n){if(n.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${this.elementDtype}`);if(t<0||this.maxNumElements!==-1&&t>=this.maxNumElements)throw new Error(`Trying to set element ${t} in a list with max ${this.maxNumElements} elements.`);gs(this.elementShape,n.shape,"TensorList shape mismatch: "),Zn(n),this.tensors[t]!=null&&(this.tensors[t].kept=!1),this.tensors[t]=n}gather(t,n,a){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);gs(this.elementShape,a,"TensorList shape mismatch: "),t=t.slice(0,this.size());let r=Nm(this.elementShape,this.tensors,a);return t.length===0?qa([],[0].concat(r)):ne(()=>{let s=t.map(i=>te(this.tensors[i],r));return Un(s,0)})}concat(t,n){if(t&&t!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${t}`);gs(this.elementShape,n,"TensorList shape mismatch: ");let a=Nm(this.elementShape,this.tensors,n);return this.size()===0?qa([],[0].concat(a)):ne(()=>{let r=this.tensors.map(s=>te(s,a));return Yt(r,0)})}};function yre(e,t,n){let a=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==n)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);let r=e.shape.slice(1);gs(r,t,"TensorList shape mismatch: ");let s=Nn(e);return new Nx(s,t,a)}function bre(e,t,n,a){return new Nx([],e,t,a)}function vre(e,t,n,a){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);let r=Math.max(...t);if(a!=null&&a!==-1&&r>=a)throw new Error(`Max index must be < array size (${r}  vs. ${a})`);let s=new Nx([],n,e.dtype,a),i=Nn(e,0);return t.forEach((o,u)=>{s.setItem(o,i[u])}),s}function xre(e,t,n){let a=0,r=t.map(c=>(a+=c,a));if(a!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${a}, and tensor's shape is: ${e.shape}`);let s=e.shape.slice(1),i=pk(s,n),o=a===0?0:e.size/a,u=ne(()=>{let c=[];e=te(e,[1,a,o]);for(let p=0;p<t.length;++p){let m=[0,p===0?0:r[p-1],0],g=[1,t[p],o];c[p]=te(wt(e,m,g),i)}return e.dispose(),c}),d=new Nx([],n,e.dtype,t.length);for(let c=0;c<u.length;c++)d.setItem(c,u[c]);return d}var wre=async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{let a=C("thenBranch",e,t,n),r=C("elseBranch",e,t,n),s=C("cond",e,t,n),i=C("args",e,t,n);return(await s.data())[0]?n.functionMap[a].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap):n.functionMap[r].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{let a=C("body",e,t,n),r=C("cond",e,t,n),s=C("args",e,t,n),i=await n.functionMap[r].executeFunctionAsync(s,n.tensorArrayMap,n.tensorListMap),o=s.map(c=>c.id),u=await i[0].data();i.forEach(c=>{!c.kept&&o.indexOf(c.id)===-1&&c.dispose()});let d=s;for(;u[0];){let c=d;d=await n.functionMap[a].executeFunctionAsync(d,n.tensorArrayMap,n.tensorListMap);let p=d.map(g=>g.id);c.forEach(g=>{!g.kept&&o.indexOf(g.id)===-1&&p.indexOf(g.id)===-1&&g.dispose()});let m=await n.functionMap[r].executeFunctionAsync(d,n.tensorArrayMap,n.tensorListMap);u=await m[0].data(),m.forEach(g=>{!g.kept&&o.indexOf(g.id)===-1&&p.indexOf(g.id)===-1&&g.dispose()})}return d}case"LoopCond":{let a=C("pred",e,t,n);return[ji(a)]}case"Switch":{let a=C("pred",e,t,n),r=C("data",e,t,n);return r.kept||(r=ji(r)),(await a.data())[0]?[void 0,r]:[r,void 0]}case"Merge":{let a=e.inputNames.find(r=>ka(r,t,n)!==void 0);if(a){let r=ka(a,t,n);return[ji(r)]}return}case"Enter":{let a=C("frameName",e,t,n),r=C("tensor",e,t,n);return n.enterFrame(a),[ji(r)]}case"Exit":{let a=C("tensor",e,t,n);return n.exitFrame(),[ji(a)]}case"NextIteration":{let a=C("tensor",e,t,n);return n.nextIteration(),[ji(a)]}case"TensorArrayV3":{let a=C("size",e,t,n),r=C("dtype",e,t,n),s=C("elementShape",e,t,n),i=C("dynamicSize",e,t,n),o=C("clearAfterRead",e,t,n),u=C("identicalElementShapes",e,t,n),d=C("name",e,t,n),c=new gre(d,r,a,s,u,i,o);return n.addTensorArray(c),[c.idTensor,He(1)]}case"TensorArrayWriteV3":{let a=C("tensorArrayId",e,t,n),r=C("index",e,t,n),s=C("tensor",e,t,n),i=n.getTensorArray(a.id);return i.write(r,s),[i.idTensor]}case"TensorArrayReadV3":{let a=C("tensorArrayId",e,t,n),r=C("index",e,t,n);return[n.getTensorArray(a.id).read(r)]}case"TensorArrayGatherV3":{let a=C("tensorArrayId",e,t,n),r=C("indices",e,t,n),s=C("dtype",e,t,n);return[n.getTensorArray(a.id).gather(r,s)]}case"TensorArrayScatterV3":{let a=C("tensorArrayId",e,t,n),r=C("indices",e,t,n),s=C("tensor",e,t,n),i=n.getTensorArray(a.id);return i.scatter(r,s),[i.idTensor]}case"TensorArrayConcatV3":{let a=C("tensorArrayId",e,t,n),r=n.getTensorArray(a.id),s=C("dtype",e,t,n);return[r.concat(s)]}case"TensorArraySplitV3":{let a=C("tensorArrayId",e,t,n),r=C("tensor",e,t,n),s=C("lengths",e,t,n),i=n.getTensorArray(a.id);return i.split(s,r),[i.idTensor]}case"TensorArraySizeV3":{let a=C("tensorArrayId",e,t,n),r=n.getTensorArray(a.id);return[He(r.size(),"int32")]}case"TensorArrayCloseV3":{let a=C("tensorArrayId",e,t,n),r=n.getTensorArray(a.id);return r.clearAndClose(),[r.idTensor]}case"TensorListSetItem":{let a=C("tensorListId",e,t,n),r=C("index",e,t,n),s=C("tensor",e,t,n),i=n.getTensorList(a.id);return i.setItem(r,s),[i.idTensor]}case"TensorListGetItem":{let a=C("tensorListId",e,t,n),r=C("index",e,t,n),s=C("elementShape",e,t,n),i=C("elementDType",e,t,n);return[n.getTensorList(a.id).getItem(r,s,i)]}case"TensorListScatterV2":case"TensorListScatter":{let a=C("indices",e,t,n),r=C("tensor",e,t,n),s=C("elementShape",e,t,n),i=C("numElements",e,t,n),o=vre(r,a,s,i);return n.addTensorList(o),[o.idTensor]}case"TensorListReserve":case"EmptyTensorList":{let a=C("elementShape",e,t,n),r=C("elementDType",e,t,n),s;e.op==="TensorListReserve"?s="numElements":s="maxNumElements";let i=C(s,e,t,n),o=e.op==="TensorListReserve"?-1:i,u=bre(a,r,i,o);return n.addTensorList(u),[u.idTensor]}case"TensorListGather":{let a=C("tensorListId",e,t,n),r=C("indices",e,t,n),s=C("elementShape",e,t,n),i=C("elementDType",e,t,n);return[n.getTensorList(a.id).gather(r,i,s)]}case"TensorListStack":{let a=C("tensorListId",e,t,n),r=C("elementShape",e,t,n),s=C("elementDType",e,t,n),i=C("numElements",e,t,n);return[n.getTensorList(a.id).stack(r,s,i)]}case"TensorListFromTensor":{let a=C("tensor",e,t,n),r=C("elementShape",e,t,n),s=C("elementDType",e,t,n),i=yre(a,r,s);return n.addTensorList(i),[i.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{let a=C("tensorListId",e,t,n),r=n.getTensorList(a.id),s=C("dtype",e,t,n),i=C("elementShape",e,t,n);return[r.concat(s,i)]}case"TensorListPushBack":{let a=C("tensorListId",e,t,n),r=C("tensor",e,t,n),s=n.getTensorList(a.id);return s.pushBack(r),[s.idTensor]}case"TensorListPopBack":{let a=C("tensorListId",e,t,n),r=C("elementShape",e,t,n),s=C("elementDType",e,t,n);return[n.getTensorList(a.id).popBack(r,s)]}case"TensorListSplit":{let a=C("tensor",e,t,n),r=C("elementShape",e,t,n),s=C("lengths",e,t,n),i=xre(a,s,r);return n.addTensorList(i),[i.idTensor]}case"TensorListLength":{let a=C("tensorListId",e,t,n),r=n.getTensorList(a.id);return[He(r.size(),"int32")]}case"TensorListResize":{let a=C("tensorListId",e,t,n),r=C("size",e,t,n),s=n.getTensorList(a.id).resize(r);return n.addTensorList(s),[s.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};function fR(e,t,n){let[a,r]=C("fusedOps",e,t,n),s=a==="biasadd",i=!s,o=r==="prelu",u=a==="fusedbatchnorm",d=C("numArgs",e,t,n);if(s){if(o&&d!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&s&&d!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(u)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");let c=C("strides",e,t,n),p=pv(e,t,n),m=C("dataFormat",e,t,n).toUpperCase(),g=C("dilations",e,t,n),[b,v]=C("args",e,t,n);i&&(v=b,b=void 0);let x=C("leakyreluAlpha",e,t,n);return{stride:c,pad:p,dataFormat:m,dilations:g,biasArg:b,preluArg:v,activationFunc:r,leakyreluAlpha:x}}var Sre=(e,t,n,a=ga)=>{switch(e.op){case"Conv1D":{let r=C("stride",e,t,n),s=C("pad",e,t,n),i=C("dataFormat",e,t,n).toUpperCase(),o=C("dilation",e,t,n);return[a.conv1d(C("x",e,t,n),C("filter",e,t,n),r,s,i,o)]}case"Conv2D":{let r=C("strides",e,t,n),s=pv(e,t,n),i=C("dataFormat",e,t,n).toUpperCase(),o=C("dilations",e,t,n);return[a.conv2d(C("x",e,t,n),C("filter",e,t,n),[r[1],r[2]],s,i,[o[1],o[2]])]}case"_FusedConv2D":{let{stride:r,pad:s,dataFormat:i,dilations:o,biasArg:u,preluArg:d,activationFunc:c,leakyreluAlpha:p}=fR(e,t,n);return[a.fused.conv2d({x:C("x",e,t,n),filter:C("filter",e,t,n),strides:[r[1],r[2]],pad:s,dataFormat:i,dilations:[o[1],o[2]],bias:u,activation:c,preluActivationWeights:d,leakyreluAlpha:p})]}case"FusedDepthwiseConv2dNative":{let{stride:r,pad:s,dataFormat:i,dilations:o,biasArg:u,preluArg:d,activationFunc:c,leakyreluAlpha:p}=fR(e,t,n);return[a.fused.depthwiseConv2d({x:C("x",e,t,n),filter:C("filter",e,t,n),strides:[r[1],r[2]],pad:s,dataFormat:i,dilations:[o[1],o[2]],bias:u,activation:c,preluActivationWeights:d,leakyreluAlpha:p})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{let r=C("outputShape",e,t,n),s=C("strides",e,t,n),i=pv(e,t,n);return[a.conv2dTranspose(C("x",e,t,n),C("filter",e,t,n),r,[s[1],s[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{let r=C("strides",e,t,n),s=pv(e,t,n),i=C("dilations",e,t,n),o=C("dataFormat",e,t,n).toUpperCase();return[a.depthwiseConv2d(C("input",e,t,n),C("filter",e,t,n),[r[1],r[2]],s,o,[i[1],i[2]])]}case"Conv3D":{let r=C("strides",e,t,n),s=C("pad",e,t,n),i=C("dataFormat",e,t,n).toUpperCase(),o=C("dilations",e,t,n);return[a.conv3d(C("x",e,t,n),C("filter",e,t,n),[r[1],r[2],r[3]],s,i,[o[1],o[2],o[3]])]}case"AvgPool":{let r=C("strides",e,t,n),s=C("pad",e,t,n),i=C("kernelSize",e,t,n);return[a.avgPool(C("x",e,t,n),[i[1],i[2]],[r[1],r[2]],s)]}case"MaxPool":{let r=C("strides",e,t,n),s=C("pad",e,t,n),i=C("kernelSize",e,t,n);return[a.maxPool(C("x",e,t,n),[i[1],i[2]],[r[1],r[2]],s)]}case"MaxPoolWithArgmax":{let r=C("strides",e,t,n),s=C("pad",e,t,n),i=C("kernelSize",e,t,n),o=C("includeBatchInIndex",e,t,n),{result:u,indexes:d}=a.maxPoolWithArgmax(C("x",e,t,n),[i[1],i[2]],[r[1],r[2]],s,o);return[u,d]}case"AvgPool3D":{let r=C("strides",e,t,n),s=C("pad",e,t,n),i=C("kernelSize",e,t,n);return[a.avgPool3d(C("x",e,t,n),[i[1],i[2],i[3]],[r[1],r[2],r[3]],s)]}case"MaxPool3D":{let r=C("strides",e,t,n),s=C("pad",e,t,n),i=C("kernelSize",e,t,n);return[a.maxPool3d(C("x",e,t,n),[i[1],i[2],i[3]],[r[1],r[2],r[3]],s)]}case"Dilation2D":{let r=C("strides",e,t,n),s=C("pad",e,t,n),i=C("dilations",e,t,n),o=r[1],u=r[2],d=i[1],c=i[2];return[a.dilation2d(C("x",e,t,n),C("filter",e,t,n),[o,u],s,[d,c],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},kre=(e,t,n,a=ga)=>{switch(e.op){case"Fill":{let r=C("shape",e,t,n),s=C("dtype",e,t,n),i=C("value",e,t,n);return[a.fill(r,i,s)]}case"LinSpace":{let r=C("start",e,t,n),s=C("stop",e,t,n),i=C("num",e,t,n);return[a.linspace(r,s,i)]}case"Multinomial":{let r=C("logits",e,t,n),s=C("numSamples",e,t,n),i=C("seed",e,t,n);return[a.multinomial(r,s,i)]}case"OneHot":{let r=C("indices",e,t,n),s=C("depth",e,t,n),i=C("onValue",e,t,n),o=C("offValue",e,t,n),u=C("dtype",e,t,n);return[a.oneHot(r,s,i,o,u)]}case"Ones":return[a.ones(C("shape",e,t,n),C("dtype",e,t,n))];case"OnesLike":return[a.onesLike(C("x",e,t,n))];case"RandomStandardNormal":return[a.randomStandardNormal(C("shape",e,t,n),C("dtype",e,t,n),C("seed",e,t,n))];case"RandomUniform":return[a.randomUniform(C("shape",e,t,n),C("minval",e,t,n),C("maxval",e,t,n),C("dtype",e,t,n))];case"RandomUniformInt":return[a.randomUniformInt(C("shape",e,t,n),C("minval",e,t,n),C("maxval",e,t,n),C("seed",e,t,n))];case"Range":{let r=C("start",e,t,n),s=C("stop",e,t,n),i=C("step",e,t,n);return[a.range(r,s,i,C("dtype",e,t,n))]}case"TruncatedNormal":{let r=C("shape",e,t,n),s=C("mean",e,t,n),i=C("stdDev",e,t,n),o=C("seed",e,t,n);return[a.truncatedNormal(r,s,i,C("dtype",e,t,n),o)]}case"Zeros":return[a.zeros(C("shape",e,t,n),C("dtype",e,t,n))];case"ZerosLike":return[a.zerosLike(C("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function iS(e,t,n){let a=C("boxes",e,t,n),r=C("scores",e,t,n),s=C("maxOutputSize",e,t,n),i=C("iouThreshold",e,t,n),o=C("scoreThreshold",e,t,n),u=C("softNmsSigma",e,t,n);return{boxes:a,scores:r,maxOutputSize:s,iouThreshold:i,scoreThreshold:o,softNmsSigma:u}}var _re=async(e,t,n,a,r=ga)=>{switch(e.op){case"NonMaxSuppressionV5":{let{boxes:s,scores:i,maxOutputSize:o,iouThreshold:u,scoreThreshold:d,softNmsSigma:c}=iS(e,t,n),p=await r.image.nonMaxSuppressionWithScoreAsync(s,i,o,u,d,c);return[p.selectedIndices,p.selectedScores]}case"NonMaxSuppressionV4":{let{boxes:s,scores:i,maxOutputSize:o,iouThreshold:u,scoreThreshold:d}=iS(e,t,n),c=C("padToMaxOutputSize",e,t,n),p=await r.image.nonMaxSuppressionPaddedAsync(s,i,o,u,d,c);return[p.selectedIndices,p.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{let{boxes:s,scores:i,maxOutputSize:o,iouThreshold:u,scoreThreshold:d}=iS(e,t,n);return[await r.image.nonMaxSuppressionAsync(s,i,o,u,d)]}case"Where":{let s=r.cast(C("condition",e,t,n),"bool"),i=[await r.whereAsync(s)];return s.dispose(),i}case"ListDiff":return r.setdiff1dAsync(C("x",e,t,n),C("y",e,t,n));default:throw TypeError(`Node type ${e.op} is not implemented`)}},Nre=(e,t,n,a=ga)=>{switch(e.op){case"LowerBound":{let r=C("sortedSequence",e,t,n),s=C("values",e,t,n);return[a.lowerBound(r,s)]}case"TopKV2":{let r=C("x",e,t,n),s=C("k",e,t,n),i=C("sorted",e,t,n),o=a.topk(r,s,i);return[o.values,o.indices]}case"UpperBound":{let r=C("sortedSequence",e,t,n),s=C("values",e,t,n);return[a.upperBound(r,s)]}case"Unique":{let r=C("x",e,t,n),s=a.unique(r);return[s.values,s.indices]}case"UniqueV2":{let r=C("x",e,t,n),s=C("axis",e,t,n),i=a.unique(r,s);return[i.values,i.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},Ire=(e,t,n,a=ga)=>{switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":let r=C("default",e,t,n);return[ka(e.name,t,n)||r];case"Placeholder":return[ka(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{let c=C("x",e,t,n);return[ji(c)]}case"IdentityN":return C("x",e,t,n).map(c=>ji(c));case"Snapshot":let s=C("x",e,t,n);return[ji(s)];case"Shape":return[a.tensor1d(C("x",e,t,n).shape,"int32")];case"ShapeN":return C("x",e,t,n).map(c=>a.tensor1d(c.shape));case"Size":return[a.scalar(C("x",e,t,n).size,"int32")];case"Rank":return[a.scalar(C("x",e,t,n).rank,"int32")];case"NoOp":return[a.scalar(1)];case"Print":let i=C("x",e,t,n),o=C("data",e,t,n),u=C("message",e,t,n),d=C("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(u);for(let c=0;c<o.length;c++)console.log(Array.prototype.slice.call(o[c].dataSync()).slice(0,d));return[i];default:throw TypeError(`Node type ${e.op} is not implemented`)}},Tre=class{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=He(0),this.tensorMap=new Map,Zn(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return He(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return this.tensorMap.forEach(a=>a.dispose()),this.tensorMap.clear(),ne(()=>{let a=Nn(t),r=n.length,s=a.length;E.assert(r===s,()=>`The number of elements doesn't match, keys has ${r} elements, the values has ${s} elements.`);for(let i=0;i<r;i++){let o=n[i],u=a[i];Zn(u),this.tensorMap.set(o,u)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return ne(()=>{let a=[];for(let r=0;r<n.length;r++){let s=n[r],i=this.findWithDefault(s,t);a.push(i)}return Un(a)})}findWithDefault(e,t){let n=this.tensorMap.get(e);return n??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}},Ere=async(e,t,n,a)=>{switch(e.op){case"HashTable":case"HashTableV2":{let r=a.getHashTableHandleByName(e.name);if(r!=null)return[r];{let s=C("keyDType",e,t,n),i=C("valueDType",e,t,n),o=new Tre(s,i);return a.addHashTable(e.name,o),[o.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{let r=C("tableHandle",e,t,n,a),s=C("keys",e,t,n),i=C("values",e,t,n);return[await a.getHashTableById(r.id).import(s,i)]}case"LookupTableFind":case"LookupTableFindV2":{let r=C("tableHandle",e,t,n,a),s=C("keys",e,t,n),i=C("defaultValue",e,t,n);return[await a.getHashTableById(r.id).find(s,i)]}case"LookupTableSize":case"LookupTableSizeV2":{let r=C("tableHandle",e,t,n,a);return[a.getHashTableById(r.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},Cre=(e,t,n,a=ga)=>{switch(e.op){case"ResizeBilinear":{let r=C("images",e,t,n),s=C("size",e,t,n),i=C("alignCorners",e,t,n),o=C("halfPixelCenters",e,t,n);return[a.image.resizeBilinear(r,[s[0],s[1]],i,o)]}case"ResizeNearestNeighbor":{let r=C("images",e,t,n),s=C("size",e,t,n),i=C("alignCorners",e,t,n),o=C("halfPixelCenters",e,t,n);return[a.image.resizeNearestNeighbor(r,[s[0],s[1]],i,o)]}case"CropAndResize":{let r=C("image",e,t,n),s=C("boxes",e,t,n),i=C("boxInd",e,t,n),o=C("cropSize",e,t,n),u=C("method",e,t,n),d=C("extrapolationValue",e,t,n);return[a.image.cropAndResize(r,s,i,o,u,d)]}case"ImageProjectiveTransformV3":{let r=C("images",e,t,n),s=C("transforms",e,t,n),i=C("outputShape",e,t,n),o=C("fillValue",e,t,n),u=C("interpolation",e,t,n),d=C("fillMode",e,t,n);return[a.image.transform(r,s,u.toLowerCase(),d.toLowerCase(),o,i)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},Are=(e,t,n,a=ga)=>{switch(e.op){case"Equal":return[a.equal(C("a",e,t,n),C("b",e,t,n))];case"NotEqual":return[a.notEqual(C("a",e,t,n),C("b",e,t,n))];case"Greater":return[a.greater(C("a",e,t,n),C("b",e,t,n))];case"GreaterEqual":return[a.greaterEqual(C("a",e,t,n),C("b",e,t,n))];case"Less":return[a.less(C("a",e,t,n),C("b",e,t,n))];case"LessEqual":return[a.lessEqual(C("a",e,t,n),C("b",e,t,n))];case"LogicalAnd":return[a.logicalAnd(C("a",e,t,n),C("b",e,t,n))];case"LogicalNot":return[a.logicalNot(C("a",e,t,n))];case"LogicalOr":return[a.logicalOr(C("a",e,t,n),C("b",e,t,n))];case"Select":case"SelectV2":return[a.where(C("condition",e,t,n),C("a",e,t,n),C("b",e,t,n))];case"BitwiseAnd":return[a.bitwiseAnd(C("a",e,t,n),C("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},$re=(e,t,n,a=ga)=>{switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[a.matMul(C("a",e,t,n),C("b",e,t,n),C("transposeA",e,t,n),C("transposeB",e,t,n))];case"Einsum":return[a.einsum(C("equation",e,t,n),...C("tensors",e,t,n))];case"Transpose":return[a.transpose(C("x",e,t,n),C("perm",e,t,n))];case"_FusedMatMul":let[r,s]=C("fusedOps",e,t,n),i=r==="biasadd",o=s==="prelu",u=C("numArgs",e,t,n),d=C("leakyreluAlpha",e,t,n);if(i){if(o&&u!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&u!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}let[c,p]=C("args",e,t,n);return[a.fused.matMul({a:C("a",e,t,n),b:C("b",e,t,n),transposeA:C("transposeA",e,t,n),transposeB:C("transposeB",e,t,n),bias:c,activation:s,preluActivationWeights:p,leakyreluAlpha:d})];case"MatrixBandPart":return[a.linalg.bandPart(C("a",e,t,n),C("numLower",e,t,n),C("numUpper",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},Rre=(e,t,n,a=ga)=>{switch(e.op){case"EuclideanNorm":return[a.euclideanNorm(C("x",e,t,n),C("axis",e,t,n),C("keepDims",e,t,n))];case"FusedBatchNorm":case"FusedBatchNormV2":return[a.batchNorm(C("x",e,t,n),C("mean",e,t,n),C("variance",e,t,n),C("offset",e,t,n),C("scale",e,t,n),C("epsilon",e,t,n))];case"FusedBatchNormV3":return[a.batchNorm(C("x",e,t,n),C("mean",e,t,n),C("variance",e,t,n),C("offset",e,t,n),C("scale",e,t,n),C("epsilon",e,t,n))];case"LRN":return[a.localResponseNormalization(C("x",e,t,n),C("radius",e,t,n),C("bias",e,t,n),C("alpha",e,t,n),C("beta",e,t,n))];case"Softmax":return[a.softmax(C("x",e,t,n))];case"LogSoftmax":return[a.logSoftmax(C("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},Dre=(e,t,n,a=ga)=>{switch(e.op){case"RaggedGather":{let{outputNestedSplits:r,outputDenseValues:s}=a.raggedGather(C("paramsNestedSplits",e,t,n),C("paramsDenseValues",e,t,n),C("indices",e,t,n),C("outputRaggedRank",e,t,n));return r.concat(s)}case"RaggedRange":{let{rtNestedSplits:r,rtDenseValues:s}=a.raggedRange(C("starts",e,t,n),C("limits",e,t,n),C("splits",e,t,n));return[r,s]}case"RaggedTensorToTensor":return[a.raggedTensorToTensor(C("shape",e,t,n),C("values",e,t,n),C("defaultValue",e,t,n),C("rowPartitionTensors",e,t,n),C("rowPartitionTypes",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},Ore=(e,t,n,a=ga)=>{switch(e.op){case"Max":{let o=C("axis",e,t,n),u=C("keepDims",e,t,n);return[a.max(C("x",e,t,n),o,u)]}case"Mean":{let o=C("axis",e,t,n),u=C("keepDims",e,t,n);return[a.mean(C("x",e,t,n),o,u)]}case"Min":{let o=C("axis",e,t,n),u=C("keepDims",e,t,n);return[a.min(C("x",e,t,n),o,u)]}case"Sum":{let o=C("axis",e,t,n),u=C("keepDims",e,t,n);return[a.sum(C("x",e,t,n),o,u)]}case"All":{let o=C("axis",e,t,n),u=C("keepDims",e,t,n);return[a.all(C("x",e,t,n),o,u)]}case"Any":{let o=C("axis",e,t,n),u=C("keepDims",e,t,n);return[a.any(C("x",e,t,n),o,u)]}case"ArgMax":{let o=C("axis",e,t,n);return[a.argMax(C("x",e,t,n),o)]}case"ArgMin":{let o=C("axis",e,t,n);return[a.argMin(C("x",e,t,n),o)]}case"Prod":{let o=C("axis",e,t,n),u=C("keepDims",e,t,n);return[a.prod(C("x",e,t,n),o,u)]}case"Cumprod":{let o=C("axis",e,t,n),u=C("exclusive",e,t,n),d=C("reverse",e,t,n);return[a.cumprod(C("x",e,t,n),o,u,d)]}case"Cumsum":{let o=C("axis",e,t,n),u=C("exclusive",e,t,n),d=C("reverse",e,t,n);return[a.cumsum(C("x",e,t,n),o,u,d)]}case"Bincount":let r=C("x",e,t,n),s=C("weights",e,t,n),i=C("size",e,t,n);return[a.bincount(r,s,i)];case"DenseBincount":{let o=C("x",e,t,n),u=C("weights",e,t,n),d=C("size",e,t,n),c=C("binaryOutput",e,t,n);return[a.denseBincount(o,u,d,c)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},Mre=(e,t,n,a=ga)=>{switch(e.op){case"ConcatV2":case"Concat":{let r=C("n",e,t,n),s=C("axis",e,t,n),i=C("tensors",e,t,n);return i=i.slice(0,r),[a.concat(i,s)]}case"Gather":{let r=C("x",e,t,n),s=C("indices",e,t,n);return[a.gather(r,a.cast(s,"int32"),0)]}case"GatherV2":{let r=C("axis",e,t,n),s=C("batchDims",e,t,n),i=C("x",e,t,n),o=C("indices",e,t,n);return[a.gather(i,a.cast(o,"int32"),r,s)]}case"Reverse":{let r=C("dims",e,t,n),s=[];for(let o=0;o<r.length;o++)r[o]&&s.push(o);let i=C("x",e,t,n);return[a.reverse(i,s)]}case"ReverseV2":{let r=C("axis",e,t,n),s=C("x",e,t,n);return[a.reverse(s,r)]}case"Slice":{let r=C("begin",e,t,n),s=C("size",e,t,n);return[a.slice(C("x",e,t,n),r,s)]}case"StridedSlice":{let r=C("begin",e,t,n),s=C("end",e,t,n),i=C("strides",e,t,n),o=C("beginMask",e,t,n),u=C("endMask",e,t,n),d=C("ellipsisMask",e,t,n),c=C("newAxisMask",e,t,n),p=C("shrinkAxisMask",e,t,n),m=C("x",e,t,n);return[a.stridedSlice(m,r,s,i,o,u,d,c,p)]}case"Pack":return ne(()=>{let r=C("axis",e,t,n),s=C("tensors",e,t,n),i=s[0].shape,o=a.squeeze(s[0]).shape,u=s.map(d=>{let c=E.arraysEqual(d.shape,i);if(!c&&!E.arraysEqual(a.squeeze(d).shape,o))throw new Error("the input tensors shape does not match");return c?d:a.reshape(d,i)});return[a.stack(u,r)]});case"Unpack":{let r=C("axis",e,t,n),s=C("tensor",e,t,n);return a.unstack(s,r)}case"Tile":{let r=C("reps",e,t,n);return[a.tile(C("x",e,t,n),r)]}case"Split":case"SplitV":{let r=C("axis",e,t,n),s=C("numOrSizeSplits",e,t,n),i=C("x",e,t,n);return a.split(i,s,r)}case"ScatterNd":{let r=C("indices",e,t,n),s=C("values",e,t,n),i=C("shape",e,t,n);return[a.scatterND(r,s,i)]}case"GatherNd":{let r=C("x",e,t,n),s=C("indices",e,t,n);return[a.gatherND(r,s)]}case"SparseToDense":{let r=C("sparseIndices",e,t,n),s=C("outputShape",e,t,n),i=C("sparseValues",e,t,n),o=C("defaultValue",e,t,n);return[a.sparseToDense(r,i,s,i.dtype===o.dtype?o:a.cast(o,i.dtype))]}case"TensorScatterUpdate":{let r=C("indices",e,t,n),s=C("values",e,t,n),i=C("tensor",e,t,n);return[a.tensorScatterUpdate(i,r,s)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},Fre=(e,t,n,a=ga)=>{switch(e.op){case"SparseFillEmptyRows":{let{outputIndices:r,outputValues:s,emptyRowIndicator:i,reverseIndexMap:o}=a.sparse.sparseFillEmptyRows(C("indices",e,t,n),C("values",e,t,n),C("denseShape",e,t,n),C("defaultValue",e,t,n));return[r,s,i,o]}case"SparseReshape":{let{outputIndices:r,outputShape:s}=a.sparse.sparseReshape(C("inputIndices",e,t,n),C("inputShape",e,t,n),C("newShape",e,t,n));return[r,s]}case"SparseSegmentMean":return[a.sparse.sparseSegmentMean(C("data",e,t,n),C("indices",e,t,n),C("segmentIds",e,t,n))];case"SparseSegmentSum":return[a.sparse.sparseSegmentSum(C("data",e,t,n),C("indices",e,t,n),C("segmentIds",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},zre=(e,t,n,a=ga)=>{switch(e.op){case"FFT":return[a.fft(C("x",e,t,n))];case"IFFT":return[a.ifft(C("x",e,t,n))];case"RFFT":return[a.rfft(C("x",e,t,n))];case"IRFFT":return[a.irfft(C("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},Lre=(e,t,n,a=ga)=>{switch(e.op){case"StaticRegexReplace":return[a.string.staticRegexReplace(C("input",e,t,n),C("pattern",e,t,n),C("rewrite",e,t,n),C("replaceGlobal",e,t,n))];case"StringNGrams":{let{nGrams:r,nGramsSplits:s}=a.string.stringNGrams(C("data",e,t,n),C("dataSplits",e,t,n),C("separator",e,t,n),C("nGramWidths",e,t,n),C("leftPad",e,t,n),C("rightPad",e,t,n),C("padWidth",e,t,n),C("preserveShortSequences",e,t,n));return[r,s]}case"StringSplit":{let{indices:r,values:s,shape:i}=a.string.stringSplit(C("input",e,t,n),C("delimiter",e,t,n),C("skipEmpty",e,t,n));return[r,s,i]}case"StringToHashBucketFast":return[a.string.stringToHashBucketFast(C("input",e,t,n),C("numBuckets",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},Bre=(e,t,n,a=ga)=>{switch(e.op){case"Cast":return[a.cast(C("x",e,t,n),C("dtype",e,t,n))];case"ExpandDims":{let r=C("axis",e,t,n);return[a.expandDims(C("x",e,t,n),r)]}case"Squeeze":{let r=C("axis",e,t,n);return[a.squeeze(C("x",e,t,n),r)]}case"Reshape":return[a.reshape(C("x",e,t,n),C("shape",e,t,n))];case"EnsureShape":return[a.ensureShape(C("x",e,t,n),C("shape",e,t,n))];case"MirrorPad":return[a.mirrorPad(C("x",e,t,n),C("padding",e,t,n),C("mode",e,t,n))];case"PadV2":case"Pad":return[a.pad(C("x",e,t,n),C("padding",e,t,n),C("constantValue",e,t,n))];case"SpaceToBatchND":{let r=C("blockShape",e,t,n),s=C("paddings",e,t,n);return[a.spaceToBatchND(C("x",e,t,n),r,s)]}case"BatchToSpaceND":{let r=C("blockShape",e,t,n),s=C("crops",e,t,n);return[a.batchToSpaceND(C("x",e,t,n),r,s)]}case"DepthToSpace":{let r=C("blockSize",e,t,n),s=C("dataFormat",e,t,n).toUpperCase();return[a.depthToSpace(C("x",e,t,n),r,s)]}case"BroadcastTo":return[a.broadcastTo(C("x",e,t,n),C("shape",e,t,n))];case"BroadcastArgs":return[a.broadcastArgs(C("s0",e,t,n),C("s1",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function mR(e,t,n,a,r=ne){let s=((i,o,u)=>{switch(i.category){case"arithmetic":return r(()=>fre(i,o,u));case"basic_math":return r(()=>mre(i,o,u));case"control":return wre(i,o,u);case"convolution":return r(()=>Sre(i,o,u));case"creation":return r(()=>kre(i,o,u));case"dynamic":return _re(i,o,u);case"evaluation":return r(()=>Nre(i,o,u));case"image":return r(()=>Cre(i,o,u));case"graph":return r(()=>Ire(i,o,u));case"logical":return r(()=>Are(i,o,u));case"matrices":return r(()=>$re(i,o,u));case"normalization":return r(()=>Rre(i,o,u));case"ragged":return r(()=>Dre(i,o,u));case"reduction":return r(()=>Ore(i,o,u));case"slice_join":return r(()=>Mre(i,o,u));case"sparse":return r(()=>Fre(i,o,u));case"spectral":return r(()=>zre(i,o,u));case"string":return r(()=>Lre(i,o,u));case"transformation":return r(()=>Bre(i,o,u));case"hash_table":return Ere(i,o,u,a);case"custom":let d=lz(i.op);if(d&&d.customExecutor)return d.customExecutor(new pre(i,o,u));throw TypeError(`Custom op ${i.op} is not registered.`);default:throw TypeError(`Unknown op '${i.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,n);return E.isPromise(s)?s.then(i=>[].concat(i)):[].concat(s)}var gR=class{constructor(e={},t={},n={},a={},r){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=a,this.parseNodeNameCache=r,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){let e=[];for(let t=0;t<this.contexts.length-1;t++){let n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;let e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(let t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(let t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}};function yR(e,t,n,a){let r=new Set,s=[],i=null,o=null,u=new Set,d=new Set(Object.keys(e).map(m=>Ir(m)[0]));a=a||[];let c=new Set(a.map(m=>Ir(m.name)[0])),p=[...t];for(;p.length>0;){let m=p.pop();if((pu(m)||qre(m)||Kre(m))&&i==null&&(i=m,o=i.children.map(g=>g.name).filter(g=>r.has(g))),r.add(m.name),n[m.name]==null&&!d.has(m.name)&&!c.has(m.name)){if(m.inputs.length===0){s.push(m.name);continue}m.inputs.forEach(g=>{u.has(g.name)||(u.add(g.name),p.push(g))})}}return{inputs:e,outputs:t,usedNodes:r,missingInputs:s,dynamicNode:i,syncInputs:o}}function Pre(e,t){let{usedNodes:n,inputs:a}=t,r=Object.keys(a).map(x=>Ir(x)[0]).map(x=>e.nodes[x]),s=e.initNodes||[],i=x=>n.has(typeof x=="string"?x:x.name);function o(x){return[...new Map(x.map(w=>[w.name,w])).values()]}let u=o([...r,...e.weights,...s]).filter(i),d=o([...u,...Object.values(e.nodes)]).filter(i),c=new Map(d.map(x=>[x.name,x])),p={};for(let x of d){p[x.name]=p[x.name]||0;for(let w of x.children)i(w)||(p[w.name]=Number.POSITIVE_INFINITY),p[w.name]=(p[w.name]||0)+1}let m=Object.entries(p).filter(([,x])=>x===0).map(([x])=>x),g=[...m];for(;m.length>0;){let x=m.pop(),w=c.get(x);for(let k of w.children.filter(i))--p[k.name]===0&&(g.push(k.name),m.push(k.name))}let b=g.map(x=>c.get(x)),v=Ure(b,u);return jre(v,u),v}function Ure(e,t){let n=new Map(e.map(s=>[s.name,s])),a=t.map(s=>s.name),r=new Set(a);for(;a.length>0;){let s=a.pop(),i=n.get(s);for(let o of i.children)!n.has(o.name)||r.has(o.name)||(r.add(o.name),a.push(o.name))}return e.filter(s=>r.has(s.name))}var Xb=class extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}};function jre(e,t){let n=new Map(e.map((o,u)=>[o.name,u])),a=new Set(t.map(o=>o.name)),r=o=>a.has(typeof o=="string"?o:o.name),s=new Set(e.map(o=>o.name)),i=o=>s.has(typeof o=="string"?o:o.name);for(let o of e){for(let u of o.children.filter(i)){if(!n.has(u.name))throw new Xb(`Child ${u.name} of node ${o.name} is unreachable.`);if(n.get(o.name)>n.get(u.name))throw new Xb(`Node ${o.name} is scheduled to run after its child ${u.name}.`)}if(!r(o))for(let u of o.inputs){if(!n.has(u.name))throw new Xb(`Input ${u.name} of node ${o.name} is unreachable.`);if(n.get(u.name)>n.get(o.name))throw new Xb(`Node ${o.name} is scheduled to run before its input ${u.name}.`)}}}function Wre(e){let t=new Map(e.map((o,u)=>[o.name,u])),n=Number.MAX_SAFE_INTEGER,a=e.map((o,u)=>pu(o)?n:u),r=o=>{let u=a[t.get(o.name)];return u??-1},s=e.map((o,u)=>o.children.map(r).reduce((d,c)=>Math.max(d,c),a[u])),i=new Map;for(let o=0;o<e.length;++o){let u=s[o];if(u===n)continue;let d=e[o],c=e[u];i.has(c.name)||i.set(c.name,[]),i.get(c.name).push(d)}return i}var Vre=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),Hre=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),Gre=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function pu(e){return Vre.has(e.op)}function qre(e){return Hre.has(e.op)}function Kre(e){return Gre.has(e.op)}var bR=class Az{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){let n=Object.keys(t).map(a=>t[a].map(r=>r.id));this._weightIds=[].concat(...n),this._weightMap=t}set resourceManager(t){this._resourceManager=t}get inputs(){return this._inputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(t=>t.signatureKey||t.name)}get outputNodes(){return this._outputs.map(t=>{let n=t.signatureKey||t.name;return t.defaultOutput?`${n}:${t.defaultOutput}`:n})}get functions(){return Object.keys(this._functions).reduce((t,n)=>(t[n]=this._functions[n].signature,t),{})}constructor(t,n){this.graph=t,this.parent=n,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,t.functions!=null&&Object.keys(t.functions).forEach(a=>{this._functionExecutorMap[a]=new Az(t.functions[a],this)})}getCompilationKey(t,n){let a=t.map(s=>s.name).sort(),r=n.map(s=>s.name).sort();return a.join(this.SEPARATOR)+"--"+r.join(this.SEPARATOR)}compile(t,n){let a=yR(t,n,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:s,syncInputs:i}=a;if(s!=null)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${i}]`);if(r.length>0){let d=n.map(p=>p.name),c=Object.keys(t);throw new Error(`Cannot compute the outputs [${d}] from the provided inputs [${c}]. Missing the following inputs: [${r}]`)}let o=Pre(this.graph,a),u=Wre(o);return{orderedNodes:o,nodeLiveUntilMap:u}}cloneAndKeepTensor(t){if(t==null)return null;let n=t.clone();return Zn(n),n}cloneTensorList(t){return t?t.map(n=>this.cloneAndKeepTensor(n)):null}cloneTensorMap(t){return Object.fromEntries(Object.entries(t).map(([n,a])=>[n,this.cloneTensorList(a)]))}execute(t,n){this.disposeIntermediateTensors(),t=this.mapInputs(t);let a=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),n=this.mapOutputs(n),this.checkOutputs(n);let r=a.map(m=>this.graph.nodes[Ir(m)[0]]),s=n.map(m=>Ir(m)[0]),i=new Set(s),o=s.map(m=>this.graph.nodes[m]);o.length===0&&(o=this._outputs);let u=this.getCompilationKey(r,o),d=this.compiledMap.get(u);d==null&&(d=this.compile(t,o),this.compiledMap.set(u,d));try{this.keepIntermediateTensors=oe().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(m){this.keepIntermediateTensors=!1,console.warn(m.message)}let c={},p={};return ne(()=>{let m=new gR(this.weightMap,c,p,this.functionExecutorMap,this.parseNodeNameCache),g=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(t).forEach(w=>{let[k,N]=Ir(w,m),I=[];I[N]=t[w],g[k]=I,this.keepIntermediateTensors&&(this.clonedTensorsMap[k]=this.cloneTensorList(I))});let b=this.getFrozenTensorIds(g),{orderedNodes:v,nodeLiveUntilMap:x}=d;for(let w of v){if(g[w.name])continue;let k=mR(w,g,m,this._resourceManager);if(E.isPromise(k))throw new Error(`The execution of the op '${w.op}' returned a promise. Please use model.executeAsync() instead.`);g[w.name]=k,this.keepIntermediateTensors&&(this.clonedTensorsMap[w.name]=this.cloneTensorList(k)),this.checkTensorForDisposalWithNodeLiveUntilInfo(w,g,m,b,i,x.get(w.name))}return this.parent==null&&m.dispose(b),n.map(w=>ka(w,g,m))})}getFrozenTensorIds(t){let n=[].concat.apply([],Object.keys(t).map(a=>t[a]).map(a=>a.map(r=>r.id)));return new Set(n)}checkTensorForDisposal(t,n,a,r,s,i,o){if(!(pu(n)||i.has(t))){for(let u of a[t])u!=null&&(o[u.id]=(o[u.id]||0)+n.children.length);for(let u of n.inputs){if(pu(u))continue;let d=cR(u.name,a,r);if(d!=null)for(let c of d){if(!c||c.kept||s.has(c.id))continue;let p=o[c.id];p===1?(c.dispose(),delete o[c.id]):p!=null&&o[c.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(t,n,a,r,s,i){function o(u){return pu(u)||s.has(u.name)}if(!(pu(t)||i==null))for(let u of i){if(o(u))continue;let d=cR(u.name,n,a);for(let c of d)!c||c.kept||r.has(c.id)||c.dispose()}}async executeAsync(t,n){return this._executeAsync(t,n)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(t=>{for(let n of t)n&&!n.isDisposed&&n.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(t,n,a=!1,r={},s={}){this.disposeIntermediateTensors(),a||(t=this.mapInputs(t),this.checkInputs(t),this.checkInputShapeAndType(t),n=this.mapOutputs(n),this.checkOutputs(n));try{this.keepIntermediateTensors=oe().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(m){this.keepIntermediateTensors=!1,console.warn(m.message)}let i=new gR(this.weightMap,r,s,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));let o=await this.executeWithControlFlow(t,i,n,a),u=n.map(m=>ka(m,o,i)),d=u.map(m=>m.id),c=Object.keys(t).map(m=>t[m].id),p=new Set([...d,...c,...this.weightIds]);return Object.values(o).forEach(m=>{m.forEach(g=>{g&&!g.isDisposed&&!p.has(g.id)&&g.dispose()})}),this.parent==null&&i.dispose(p),u}async executeFunctionAsync(t,n,a){let r=t.reduce((s,i,o)=>(s[this.inputs[o].name]=i,s),{});return this._executeAsync(r,this.outputNodes,!0,n,a)}async executeWithControlFlow(t,n,a,r){let s=Object.keys(t),i=s.map(I=>this.graph.nodes[Ir(I)[0]]),o=a.map(I=>Ir(I)[0]),u=new Set(o),d=o.map(I=>this.graph.nodes[I]);d.length===0&&(d=this._outputs);let{usedNodes:c,missingInputs:p,dynamicNode:m,syncInputs:g}=yR(t,d,this.weightMap,this._initNodes),b=[...i,...this.graph.weights,...this._initNodes||[]].map(I=>({node:I,contexts:n.currentContext})),v=Object.assign({},this.weightMap);Object.keys(t).forEach(I=>{let[T,$]=Ir(I),D=[];D[$]=t[I],v[T]=D});let x={},w=this.getFrozenTensorIds(v),k={};for(;b.length>0;){let I=this.processStack(i,b,n,v,k,w,u,x,c);await Promise.all(I)}m==null&&!r&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");let N=d.filter(I=>!pu(I)&&!ka(I.name,v,n)).map(I=>I.name);if(N.length>0){let I="";throw m!=null&&(I=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${g}]`),new Error(`Cannot compute the outputs [${N}] from the provided inputs [${s}]. Consider providing the following inputs: [${p}]. ${I}`)}return v}processStack(t,n,a,r,s,i,o,u,d){let c=[];for(;n.length>0;){let p=n.pop();a.currentContext=p.contexts;let m="";if(p.node.op==="Enter"&&C("isConstant",p.node,r,a)&&([m]=Ui(p.node.name,a)),r[p.node.name]==null){let g=mR(p.node,r,a,this._resourceManager);m||([m]=Ui(p.node.name,a));let b=a.currentContext;E.isPromise(g)?c.push(g.then(v=>(r[m]=v,this.keepIntermediateTensors&&(this.clonedTensorsMap[m]=this.cloneTensorList(v)),a.currentContext=b,this.checkTensorForDisposal(m,p.node,r,a,i,o,u),this.processChildNodes(p.node,n,a,r,s,d),v))):(r[m]=g,this.keepIntermediateTensors&&(this.clonedTensorsMap[m]=this.cloneTensorList(g)),this.checkTensorForDisposal(m,p.node,r,a,i,o,u),this.processChildNodes(p.node,n,a,r,s,d))}else this.processChildNodes(p.node,n,a,r,s,d)}return c}processChildNodes(t,n,a,r,s,i){t.children.forEach(o=>{let[u]=Ui(o.name,a);s[u]||!i.has(o.name)||(o.op==="Merge"?o.inputNames.some(d=>!!ka(d,r,a))&&(s[u]=!0,n.push({contexts:a.currentContext,node:o})):o.inputNames.every(d=>!!ka(d,r,a))&&(s[u]=!0,n.push({contexts:a.currentContext,node:o})))})}dispose(){Object.keys(this.weightMap).forEach(t=>this.weightMap[t].forEach(n=>n.dispose()))}checkInputShapeAndType(t){Object.keys(t).forEach(n=>{let a=t[n],[r]=Ir(n),s=this.graph.nodes[r];if(s.attrParams.shape&&s.attrParams.shape.value){let i=s.attrParams.shape.value,o=i.length===a.shape.length&&a.shape.every((u,d)=>i[d]===-1||i[d]===u);E.assert(o,()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${i}], but was [${a.shape}]`)}s.attrParams.dtype&&s.attrParams.dtype.value&&E.assert(a.dtype===s.attrParams.dtype.value,()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${a.dtype}`)})}mapInputs(t){var n,a;let r={};for(let s in t){let i=(a=(n=this._signature)===null||n===void 0?void 0:n.inputs)===null||a===void 0?void 0:a[s];i!=null?r[i.name]=t[s]:r[s]=t[s]}return r}checkInputs(t){let n=Object.keys(t).filter(a=>{let[r]=Ir(a);return this.graph.nodes[r]==null});if(n.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${n}] that are not part of graph`)}mapOutputs(t){return t.map(n=>{var a,r;let s=(r=(a=this._signature)===null||a===void 0?void 0:a.outputs)===null||r===void 0?void 0:r[n];return s!=null?s.name:n},{})}checkOutputs(t){t.forEach(n=>{let[a]=Ir(n);if(!this.graph.nodes[a])throw new Error(`The output '${n}' is not found in the graph`)})}},Xre=class{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(let e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(let e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}},Yre="?tfjs-format=file",Jre="model.json",iI=class{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},n=Na){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=n,t==null&&(this.loadOptions={}),this.resourceManager=new Xre}findIOHandler(){let e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{let t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let e=this.handler.load();return E.isPromise(e)?e.then(t=>t.getWeightStream==null?this.loadSync(t):this.loadStreaming(t)):this.loadSync(e)}loadSync(e){let t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(e.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");let t=await DO(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;let n=this.artifacts.modelTopology,a=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){let r=this.artifacts.userDefinedMetadata;r.signature!=null&&(a=r.signature),r.structuredOutputKeys!=null&&(this.structuredOutputKeys=r.structuredOutputKeys)}if(this.signature=a,this.version=`${n.versions.producer}.${n.versions.minConsumer}`,this.executor=new bR(dR.Instance.transformGraph(n,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){let r=dR.Instance.transformGraph(e.modelInitializer);this.initializer=new bR(r),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if(typeof e=="string"){let n=this.io.getSaveHandlers(e);if(n.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(n.length>1)throw new Error(`Found more than one (${n.length}) save handlers for URL '${e}'`);e=n[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){let t=e instanceof dt?[e]:e,n={};return t.forEach((a,r)=>n[this.structuredOutputKeys[r]]=a),n}return e}predict(e,t){let n=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(n)}async predictAsync(e,t){let n=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(n)}normalizeInputs(e){var t;if(!(e instanceof dt)&&!Array.isArray(e)){let r=(t=this.signature)===null||t===void 0?void 0:t.inputs;if(r!=null)for(let s in r){let i=r[s];i.resourceId!=null&&(e[s]=this.resourceIdToCapturedInput[i.resourceId])}return e}e=Array.isArray(e)?e:[e];let n=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+n!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-n} non-resource placeholders, while there are ${e.length} input tensors provided.`);let a=0;return this.inputNodes.reduce((r,s)=>{var i,o,u;let d=(u=(o=(i=this.signature)===null||i===void 0?void 0:i.inputs)===null||o===void 0?void 0:o[s])===null||u===void 0?void 0:u.resourceId;return d!=null?r[s]=this.resourceIdToCapturedInput[d]:r[s]=e[a++],r},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){let t=this.initializerSignature.outputs,n=Object.keys(t);for(let a=0;a<n.length;a++){let r=n[a],s=t[r];this.resourceIdToCapturedInput[s.resourceId]=e[a]}}}execute(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,n)=>(t[n]=[e[n]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&it(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}};async function Zre(e,t={},n=Na){if(e==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");t==null&&(t={}),t.fromTFHub&&typeof e=="string"&&(e=ese(e));let a=new iI(e,t,n);return await a.load(),a}function Qre(e){if(e==null)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let t;if(e instanceof Array){let[a,r]=e;if(!a)throw new Error("modelJSON must be the first element of the array");if(!r||!(r instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in a))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in a))throw new Error("Model JSON is missing 'weightsManifest'");let s=Na.getWeightSpecs(a.weightsManifest),i=Na.getModelArtifactsForJSONSync(a,s,r);t=Na.fromMemorySync(i)}else if("load"in e)t=e;else if("modelTopology"in e&&"weightSpecs"in e&&"weightData"in e)t=Na.fromMemorySync(e);else throw new Error("Unknown model format");let n=new iI(t);return n.load(),n}function ese(e){return e.endsWith("/")||(e=e+"/"),`${e}${Jre}${Yre}`}var tse="4.22.0",$z={};ot($z,{CSVDataset:()=>jz,Dataset:()=>ff,FileDataSource:()=>Xz,TextLineDataset:()=>Uz,URLDataSource:()=>Yz,array:()=>_se,csv:()=>zse,func:()=>Lse,generator:()=>Bse,microphone:()=>Use,version_data:()=>jse,webcam:()=>Pse,zip:()=>Nse});var nse=yl(r0()),ase=yl(r0());function rse(e,t){return Pv(e,t)}function Pv(e,t,n=new Map,a=new Set){if(e==null)return null;if(typeof Blob=="function"&&e instanceof Blob)return e.slice();if(a.has(e))throw new Error("Circular references are not supported.");if(n.has(e))return n.get(e);let r=t(e);if(r.recurse&&r.value!==null)throw new Error("A deep map function may not return both a value and recurse=true.");if(r.recurse)if(qh(e)){let s=Array.isArray(e)?[]:{};a.add(e);for(let i in e){let o=e[i],u=Pv(o,t,n,a);s[i]=u}return a.delete(e),e.__proto__&&(s.__proto__=e.__proto__),s}else throw new Error(`Can't recurse into non-iterable type: ${e}`);else return n.set(e,r.value),r.value}function sse(e,t=Dz){return Rz(e,t)}function Rz(e,t,n=new Set){let a=e[0];if(n.has(a))throw new Error("Circular references are not supported.");let r=t(e);if(r.recurse&&r.value!==null)throw new Error("A deep zip function may not return both a value and recurse=true.");if(r.recurse)if(qh(a)){let s=Array.isArray(a)?[]:{};n.add(a);for(let i in a){let o=e.map(d=>d[i]),u=Rz(o,t,n);s[i]=u}return n.delete(a),s}else throw new Error(`Can't recurse into non-iterable type: ${a}`);else return r.value}function Dz(e){return e===null?null:qh(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}async function Oz(e,t){let n=new Map;Pv(e,t,n);for(let a of Array.from(n.keys())){let r=n.get(a);if(E.isPromise(r)){let s=await r;n.set(a,s)}}return Pv(e,t,n)}function qh(e){let t=!1;if(oe().get("IS_BROWSER"))t=e instanceof TextDecoder;else{let{StringDecoder:n}=QD();t=e instanceof n}return e!=null&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||typeof e=="object"&&!(e instanceof dt)&&!(e instanceof Promise)&&!t)}function ise(e){return e==null||ose(e)||Array.isArray(e)||typeof e=="object"&&e instanceof dt||E.isTypedArray(e)}function ose(e){return e===null||typeof e!="object"&&typeof e!="function"}function lse(e){return rse(e,use)}function use(e){return e instanceof dt?{value:e.clone(),recurse:!1}:qh(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}var Mz=class{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,e==null)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return this.length()===0}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(let t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);let e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}},Fz=class zz extends Mz{constructor(){super(zz.INITIAL_CAPACITY)}isFull(){return!1}push(t){super.isFull()&&this.expand(),super.push(t)}unshift(t){super.isFull()&&this.expand(),super.unshift(t)}expand(){let t=this.capacity*2,n=new Array(t),a=this.length();for(let r=0;r<a;r++)n[r]=this.get(this.wrap(this.begin+r));this.data=n,this.capacity=t,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=a}};Fz.INITIAL_CAPACITY=32;function Lz(e){return new hse(e)}function oI(e){return new pse(e)}function cse(e,t){return new Bz(e,t)}function dse(e,t=Yo.FAIL){return new Sse(e,t)}var ma=class{async toArray(){let e=[],t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){let e=this.prefetch(100),t=[],n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new xse(this,e)}filter(e){return new bse(this,e)}map(e){return new vse(this,e)}mapAsync(e){return new vR(this,e)}serialMapAsync(e){return new vR(this,e).serial()}flatmap(e){return new wse(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile(t=>t===!0)}rowMajorBatch(e,t=!0){return new yse(this,e,t)}columnMajorBatch(e,t=!0,n=Dz){return this.rowMajorBatch(e,t).map(a=>sse(a,n))}concatenate(e,t){return new Bz(Lz([this,e]),t)}take(e){return e<0||e==null?this:new gse(this,e)}skip(e){return e<0||e==null?this:new mse(this,e)}prefetch(e){return new Pz(this,e)}shuffle(e,t){return new kse(this,e,t)}serial(){return new fse(this)}},hse=class extends ma{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};let e=this.items[this.trav];return this.trav++,{value:lse(e),done:!1}}},pse=class extends ma{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}}},fse=class extends ma{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}},mse=class extends ma{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){let e=await this.upstream.next();if(e.done)return e;it(e.value)}return this.upstream.next()}},gse=class extends ma{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}},yse=class extends ma{constructor(e,t,n=!0){super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){let e=[];for(;e.length<this.batchSize;){let t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}},bse=class extends ma{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){let e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;it(e.value)}}},vse=class extends ma{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=Fs.getTensorsInContainer(e.value),n=this.transform(e.value),a=Fs.getTensorsInContainer(n);for(let r of t)Fs.isTensorInList(r,a)||r.dispose();return{value:n,done:!1}}},xse=class extends ma{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}},vR=class extends ma{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=Fs.getTensorsInContainer(e.value),n=await this.transform(e.value),a=Fs.getTensorsInContainer(n);for(let r of t)Fs.isTensorInList(r,a)||r.dispose();return{value:n,done:!1}}},lI=class extends ma{constructor(){super(),this.outputQueue=new Fz,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.outputQueue.length()===0;)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}},wse=class extends lI{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){let e=await this.upstream.next();if(e.done)return!1;let t=Fs.getTensorsInContainer(e.value),n=this.transform(e.value),a=Fs.getTensorsInContainer(n);this.outputQueue.pushAll(n);for(let r of t)Fs.isTensorInList(r,a)||r.dispose();return!0}},Bz=class extends ma{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,this.iterator==null){let n=await this.moreIterators.next();if(n.done)return{value:null,done:!0};this.iterator=n.value,this.baseErrorHandler!=null&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}let t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}},Yo;(function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"})(Yo||(Yo={}));var Sse=class extends ma{constructor(e,t=Yo.FAIL){super(),this.iterators=e,this.mismatchMode=t,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(e){await e;let t=0,n=0;function a(s){return s instanceof ma?{value:s.next().then(i=>(t++,i.done&&n++,i.value)),recurse:!1}:{value:null,recurse:!0}}let r=await Oz(this.iterators,a);if(t===n)return{value:null,done:!0};if(n>0)switch(this.mismatchMode){case Yo.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case Yo.SHORTEST:return{value:null,done:!0};case Yo.LONGEST:}return this.count++,{value:r,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}},Pz=class extends ma{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new Mz(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){let e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}},kse=class extends Pz{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=ase.alea(n||E.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){let e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(t.done)this.upstreamExhausted=!0;else return this.refill(),t}return{value:null,done:!0}}},ff=class{constructor(){this.size=null}batch(e,t=!0){let n=this;E.assert(e>0,()=>`batchSize needs to be positive, but it is
      ${e}`);let a;return this.size===1/0||this.size==null?a=this.size:t?a=Math.ceil(this.size/e):a=Math.floor(this.size/e),Nr(async()=>(await n.iterator()).columnMajorBatch(e,t,Ise),a)}concatenate(e){let t=this,n;return this.size===1/0||e.size===1/0?n=1/0:this.size!=null&&e.size!=null?n=this.size+e.size:n=null,Nr(async()=>(await t.iterator()).concatenate(await e.iterator()),n)}filter(e){let t=this,n;return this.size===1/0?n=1/0:n=null,Nr(async()=>(await t.iterator()).filter(a=>ne(()=>e(a))),n)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){let t=this;return Nr(async()=>(await t.iterator()).map(n=>ne(()=>e(n))),this.size)}mapAsync(e){let t=this;return Nr(async()=>(await t.iterator()).mapAsync(e),this.size)}prefetch(e){if(e==null)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");let t=this;return Nr(async()=>(await t.iterator()).prefetch(e),this.size)}repeat(e){let t=this,n;return this.size!=null&&e>0?n=this.size*e:e===0?n=0:this.size!=null&&(e===void 0||e<0)?n=1/0:n=null,Nr(async()=>{let a=oI(async()=>({value:await t.iterator(),done:!1}));return cse(a.take(e))},n)}skip(e){let t=this,n;return this.size!=null&&e>=0&&this.size>=e?n=this.size-e:this.size!=null&&(this.size<e||e===void 0||e<0)?n=0:n=null,Nr(async()=>(await t.iterator()).skip(e),n)}shuffle(e,t,n=!0){if(e==null||e<0)throw this.size==null?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);let a=this,r=nse.alea(t||E.now().toString());return Nr(async()=>{let s=r.int32();return n&&(s+=r.int32()),(await a.iterator()).shuffle(e,s.toString())},this.size)}take(e){let t=this,n;return this.size!=null&&this.size>e?n=e:this.size!=null&&this.size<=e?n=this.size:n=null,Nr(async()=>(await t.iterator()).take(e),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}};ff.MAX_BUFFER_SIZE=1e4;function Nr(e,t=null){return new class extends ff{constructor(){super(...arguments),this.size=t}async iterator(){return e()}}}function _se(e){return Nr(async()=>Lz(e),e.length)}function Nse(e){if(!qh(e))throw new Error("The argument to zip() must be an object or array.");let t;if(Array.isArray(e))for(let n=0;n<e.length;n++)t=t==null?e[n].size:Math.min(t,e[n].size);else if(e instanceof Object)for(let n in e)t=t==null?e[n].size:Math.min(t,e[n].size);return Nr(async()=>{let n=await Oz(e,a=>{if(a instanceof ff)return{value:a.iterator(),recurse:!1};if(qh(a))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")});return dse(n,Yo.SHORTEST)},t)}function Ise(e){if(e===null)return null;let t=e[0];return ise(t)?{value:Tse(e),recurse:!1}:{value:null,recurse:!0}}function Tse(e){if(e.length===0)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof dt?Un(e):qa(e)}var Uz=class extends ff{constructor(e){super(),this.input=e}async iterator(){return(await this.input.iterator()).decodeUTF8().split(`
`).map(e=>(e.endsWith("\r")&&(e=e.slice(0,-1)),e))}},Yb='"',Im=Symbol("out"),xR=Symbol("field"),Jb=Symbol("quote"),oS=Symbol("quoteafterquote"),wR=Symbol("quoteinquote"),jz=class extends ff{async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){let e=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!e)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&e&&E.assert(e.length===this.fullColumnNames.length,()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+e.length.toString()+")."),this.fullColumnNames||(this.fullColumnNames=e);let t=this.fullColumnNames.reduce((a,r)=>(a[r]=a[r]+1||1,a),{}),n=Object.keys(t).filter(a=>t[a]>1);if(E.assert(n.length===0,()=>"Duplicate column names found: "+n.toString()),this.columnConfigs){for(let a of Object.keys(this.columnConfigs))if(this.fullColumnNames.indexOf(a)===-1)throw new Error('The key "'+a+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").")}this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){let e=await(await this.base.iterator()).next();if(e.done)throw new Error("No data was found for CSV parsing.");let t=e.value;return this.parseRow(t,!1)}else return null}constructor(e,t){super(),this.input=e,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new Uz(e),t||(t={}),this.hasHeader=t.hasHeader!==!1,this.fullColumnNames=t.columnNames,this.columnConfigs=t.columnConfigs,this.configuredColumnsOnly=t.configuredColumnsOnly,t.delimWhitespace?(E.assert(t.delimiter==null,()=>"Delimiter should not be provided when delimWhitespace is true."),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=t.delimiter?t.delimiter:","}async iterator(){this.columnNamesValidated||await this.setColumnNames();let e=await this.base.iterator();return this.hasHeader&&(e=e.skip(1)),e.map(t=>this.makeDataElement(t))}makeDataElement(e){let t=this.parseRow(e),n={},a={};for(let r=0;r<this.fullColumnNames.length;r++){let s=this.fullColumnNames[r],i=this.columnConfigs?this.columnConfigs[s]:null;if(!(this.configuredColumnsOnly&&!i)){let o=t[r],u=null;if(o==="")if(i&&i.default!==void 0)u=i.default;else{if(i&&(i.required||i.isLabel))throw new Error(`Required column ${s} is empty in this line: ${e}`);u=void 0}else{let d=Number(o);if(isNaN(d))i&&i.dtype==="bool"?u=this.getBoolean(o):u=o;else if(!i||!i.dtype)u=d;else switch(i.dtype){case"float32":u=d;break;case"int32":u=Math.floor(d);break;case"bool":u=this.getBoolean(o);break;default:u=d}}i&&i.isLabel?a[s]=u:n[s]=u}}return Object.keys(a).length===0?n:{xs:n,ys:a}}getBoolean(e){return e==="1"||e.toLowerCase()==="true"?1:0}parseRow(e,t=!0){let n=[],a=0,r=e.length,s=Im;for(let i=0;i<r;i++)switch(s){case Im:switch(e.charAt(i)){case Yb:a=i+1,s=Jb;break;case this.delimiter:if(a=i+1,this.delimiter===" "&&this.delimWhitespace)break;n.push(""),s=Im;break;default:s=xR,a=i;break}break;case xR:e.charAt(i)===this.delimiter&&(n.push(e.substring(a,i)),s=Im,a=i+1);break;case Jb:e.charAt(i)===Yb&&(s=oS);break;case oS:switch(e.charAt(i)){case this.delimiter:n.push(e.substring(a,i-1)),s=Im,a=i+1;break;case Yb:s=Jb;break;default:s=wR;break}break;case wR:e.charAt(i)===Yb&&(s=Jb);break}if(s===oS?n.push(e.substring(a,r-1)):n.push(e.substring(a)),t&&n.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${n}`);return n}},Ese=class Wz extends ma{constructor(t){super(),this.microphoneConfig=t,this.isClosed=!1,this.fftSize=t.fftSize||1024;let n=Math.log2(this.fftSize);if(this.fftSize<0||n<4||n>14||!Number.isInteger(n))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=t.numFramesPerSpectrogram||43,this.sampleRateHz=t.sampleRateHz,this.columnTruncateLength=t.columnTruncateLength||this.fftSize,this.audioTrackConstraints=t.audioTrackConstraints,this.smoothingTimeConstant=t.smoothingTimeConstant||0,this.includeSpectrogram=t.includeSpectrogram!==!1,this.includeWaveform=t.includeWaveform===!0,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(t={}){if(!oe().get("IS_BROWSER"))throw new Error("microphone API is only supported in browser environment.");let n=new Wz(t);return await n.start(),n}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:this.audioTrackConstraints==null?!0:this.audioTrackConstraints,video:!1})}catch(a){throw new Error(`Error thrown while initializing video stream: ${a.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");let t=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new t,!this.sampleRateHz)this.sampleRateHz=this.audioContext.sampleRate;else if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`);let n=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=this.fftSize*2,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,n.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let t,n,a=await this.getAudioData();if(this.includeSpectrogram){let r=this.flattenQueue(a.freqDataQueue);t=this.getTensorFromAudioDataArray(r,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){let r=this.flattenQueue(a.timeDataQueue);n=this.getTensorFromAudioDataArray(r,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:t,waveform:n},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){let t=[],n=[],a=0;return new Promise(r=>{let s=setInterval(()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&r({freqDataQueue:t,timeDataQueue:n}),t.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),n.push(this.timeData.slice())),++a===this.numFrames&&(clearInterval(s),r({freqDataQueue:t,timeDataQueue:n}))},this.fftSize/this.sampleRateHz*1e3)})}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),this.stream!=null&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(t){let n=t[0].length,a=new Float32Array(t.length*n);return t.forEach((r,s)=>a.set(r,s*n)),a}getTensorFromAudioDataArray(t,n){let a=new Float32Array(E.sizeFromShape(n));return a.set(t,a.length-t.length),qa(a,n)}},Cse=class Vz extends ma{constructor(t,n){if(super(),this.webcamVideoElement=t,this.webcamConfig=n,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=Lt([0],"int32"),this.webcamConfig.centerCrop){let a=this.webcamConfig.resizeWidth*1/this.webcamVideoElement.width,r=this.webcamConfig.resizeHeight*1/this.webcamVideoElement.height,s=(1-a)/2,i=(1-r)/2,o=s+a,u=r+i;this.cropBox=ui([i,s,u,o],[1,4])}else this.cropBox=ui([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(t,n={}){if(!oe().get("IS_BROWSER"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!t){if(t=document.createElement("video"),!n.resizeWidth||!n.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");t.width=n.resizeWidth,t.height=n.resizeHeight}let a=new Vz(t,n);return await a.start(),a}async start(){this.webcamConfig.facingMode&&E.assert(this.webcamConfig.facingMode==="user"||this.webcamConfig.facingMode==="environment",()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(t){throw t.message=`Error thrown while initializing video stream: ${t.message}`,t}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(t){console.log(t),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise(t=>{this.webcamVideoElement.onloadedmetadata=()=>{t()}})}async next(){if(this.isClosed)return{value:null,done:!0};let t;try{t=hy.fromPixels(this.webcamVideoElement)}catch(n){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(n)}`)}if(this.resize)try{return{value:this.cropAndResizeFrame(t),done:!1}}catch(n){throw new Error(`Error thrown cropping the video: ${n.message}`)}finally{t.dispose()}else return{value:t,done:!1}}needToResize(){return!!(this.webcamConfig.resizeWidth&&this.webcamConfig.resizeHeight&&(this.webcamVideoElement.width!==this.webcamConfig.resizeWidth||this.webcamVideoElement.height!==this.webcamConfig.resizeHeight))}cropAndResizeFrame(t){return ne(()=>{let n=da(Te(t,"float32"),0),a;a=Gr.cropAndResize(n,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");let r=a.shape;return te(a,r.slice(1))})}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach(t=>t.stop());try{this.webcamVideoElement.srcObject=null}catch(t){console.log(t),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}},Hz=class{},Gz=class extends ma{split(e){return new Ase(this,e)}},Ase=class extends Gz{constructor(e,t){super(),this.upstream=e,this.impl=new $se(e,t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},$se=class extends lI{constructor(e,t){super(),this.upstream=e,this.separator=t,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){let e=await this.upstream.next();if(e.done)return this.carryover===""?!1:(this.outputQueue.push(this.carryover),this.carryover="",!0);let t=e.value.split(this.separator);t[0]=this.carryover+t[0];for(let n of t.slice(0,-1))this.outputQueue.push(n);return this.carryover=t[t.length-1],!0}},Rse=class extends ma{decodeUTF8(){return new Dse(this)}},Dse=class extends Gz{constructor(e){super(),this.upstream=e,this.impl=new Ose(e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},Ose=class extends lI{constructor(e){if(super(),this.upstream=e,oe().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{let{StringDecoder:t}=QD();this.decoder=new t("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){let e=await this.upstream.next(),t;if(e.done)return!1;t=e.value;let n;return oe().get("IS_BROWSER")?n=this.decoder.decode(t,{stream:!0}):n=this.decoder.write(Buffer.from(t.buffer)),this.outputQueue.push(n),!0}},qz=class extends Rse{constructor(e,t={}){super(),this.file=e,this.options=t,E.assert(e instanceof Uint8Array||(oe().get("IS_BROWSER")?e instanceof File||e instanceof Blob:!1),()=>"FileChunkIterator only supports File, Blob and Uint8Array right now."),this.offset=t.offset||0,this.chunkSize=t.chunkSize||1024*1024}summary(){return`FileChunks ${this.file}`}async next(){return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?{value:null,done:!0}:{value:await new Promise((e,t)=>{let n=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)e(new Uint8Array(this.file.slice(this.offset,n)));else{let a=new FileReader;a.onload=s=>{let i=a.result;if(i instanceof ArrayBuffer&&(i=new Uint8Array(i)),!(i instanceof Uint8Array))return t(new TypeError("FileReader returned unknown type."));e(i)},a.onabort=s=>t(new Error("Aborted")),a.onerror=s=>t(new Error(s.type));let r=this.file.slice(this.offset,n);a.readAsArrayBuffer(r)}this.offset=n}),done:!1}}};async function Mse(e,t={},n){let a,r;typeof e=="string"?a=e:(a=e.url,r=Fse(e));let s=await(0,E.fetch)(a,r);if(s.ok){let i=new Uint8Array(await s.arrayBuffer());return new qz(i,t)}else throw new Error(s.statusText)}var Fse=e=>({method:e.method,headers:e.headers,body:e.body,mode:e.mode,credentials:e.credentials,cache:e.cache,redirect:e.redirect,referrer:e.referrer,integrity:e.integrity});function Kz(e){return typeof e=="string"&&e.slice(0,7)==="file://"}var Xz=class extends Hz{constructor(e,t={}){super(),this.input=e,this.options=t}async iterator(){if(Kz(this.input)&&oe().get("IS_NODE")){let e=Qk();this.input=e.readFileSync(this.input.slice(7))}return new qz(this.input,this.options)}},Yz=class extends Hz{constructor(e,t={}){super(),this.url=e,this.fileOptions=t}async iterator(){return Kz(this.url)?new Xz(this.url,this.fileOptions).iterator():Mse(this.url,this.fileOptions)}};function zse(e,t={}){return new jz(new Yz(e),t)}function Lse(e){let t=oI(e);return Nr(async()=>t)}function Bse(e){return Nr(async()=>{let t=await e();return oI(()=>t.next())})}async function Pse(e,t){return Cse.create(e,t)}async function Use(e){return Ese.create(e)}var jse="4.22.0";function Ue(e,t){Array.isArray(e)||(e=[e]),e.forEach(n=>{n!=null&&E.assert(n.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the CPU backend.`)})}var Wse=yi.whereImpl,uI=class Jz extends _g{nextDataId(){return Jz.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new s0(this,ms())}write(t,n,a){this.firstUse&&(this.firstUse=!1,oe().get("IS_NODE")&&O.warn(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));let r={id:this.nextDataId()};return this.data.set(r,{values:t,dtype:a,refCount:1}),r}makeTensorInfo(t,n,a){let r;if(n==="string"&&a!=null&&a.length>0&&E.isString(a[0])){let s=a.map(i=>E.encodeString(i));r=this.write(s,t,n)}else r=this.write(a,t,n);return{dataId:r,shape:t,dtype:n}}refCount(t){return this.data.has(t)?this.data.get(t).refCount:0}incRef(t){let n=this.data.get(t);n.refCount++}decRef(t){if(this.data.has(t)){let n=this.data.get(t);n.refCount--}}move(t,n,a,r,s){this.data.set(t,{values:n,dtype:r,refCount:s})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){let{dtype:n,complexTensorInfos:a}=this.data.get(t);if(n==="complex64"){let r=this.readSync(a.real.dataId),s=this.readSync(a.imag.dataId);return O.mergeRealAndImagArrays(r,s)}return E.convertBackendValuesAndArrayBuffer(this.data.get(t).values,n)}bufferSync(t){let n=this.readSync(t.dataId);if(t.dtype==="string")try{let a=n.map(r=>E.decodeString(r));return mt(t.shape,t.dtype,a)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return mt(t.shape,t.dtype,n)}makeOutput(t,n,a){return ms().makeTensorFromTensorInfo(this.makeTensorInfo(n,a,t),this)}disposeData(t,n=!1){if(this.data.has(t)){if(this.data.get(t).refCount--,!n&&this.data.get(t).refCount>0)return!1;let{complexTensorInfos:a}=this.data.get(t);a!=null&&(this.disposeData(a.real.dataId,!0),this.disposeData(a.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}async time(t){let n=E.now();return t(),{kernelMs:E.now()-n}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){Ue([t],"where");let n=this.readSync(t.dataId);return Wse(t.shape,n)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}};uI.nextDataId=0;var cI={};ot(cI,{addImpl:()=>eL,bincountImpl:()=>hI,bincountReduceImpl:()=>tL,bitwiseAndImpl:()=>nL,castImpl:()=>Qz,ceilImpl:()=>aL,concatImpl:()=>pI,equalImpl:()=>rL,expImpl:()=>iL,expm1Impl:()=>lL,floorDivImpl:()=>cL,floorImpl:()=>uL,gatherNdImpl:()=>dL,gatherV2Impl:()=>hL,greaterEqualImpl:()=>fL,greaterImpl:()=>pL,lessEqualImpl:()=>gL,lessImpl:()=>mL,linSpaceImpl:()=>yL,logImpl:()=>bL,maxImpl:()=>vL,maximumImpl:()=>xL,minimumImpl:()=>wL,multiplyImpl:()=>fI,negImpl:()=>SL,notEqualImpl:()=>kL,prodImpl:()=>_L,raggedGatherImpl:()=>NL,raggedRangeImpl:()=>IL,raggedTensorToTensorImpl:()=>TL,rangeImpl:()=>gI,rsqrtImpl:()=>EL,scatterImpl:()=>bu,sigmoidImpl:()=>jie,simpleAbsImpl:()=>Zz,sliceImpl:()=>jv,sparseFillEmptyRowsImpl:()=>AL,sparseReshapeImpl:()=>$L,sparseSegmentReductionImpl:()=>yI,sqrtImpl:()=>Hie,squaredDifferenceImpl:()=>RL,staticRegexReplaceImpl:()=>DL,stridedSliceImpl:()=>OL,stringNGramsImpl:()=>bI,stringSplitImpl:()=>vI,stringToHashBucketFastImpl:()=>xI,subImpl:()=>ML,tileImpl:()=>FL,topKImpl:()=>LL,transposeImpl:()=>mI,uniqueImpl:()=>SI});function Zz(e){let t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}var Vse=e=>{let{x:t}=e.inputs,n=e.backend;Ue(t,"abs");let a=new Float32Array(E.sizeFromShape(t.shape)),r=n.data.get(t.dataId).values;return a=Zz(r),n.makeOutput(a,t.shape,t.dtype)},Hse={kernelName:tp,backendName:"cpu",kernelFunc:Vse};function On(e){return(t,n,a,r,s)=>{let i=O.assertAndGetBroadcastShape(t,n),o=i.length,u=E.computeStrides(i),d=E.sizeFromShape(i),c=E.getTypedArrayFromDType(s,d),p=t.length,m=n.length,g=E.computeStrides(t),b=E.computeStrides(n),v=O.getBroadcastDims(t,i),x=O.getBroadcastDims(n,i);if(v.length+x.length===0)for(let w=0;w<c.length;++w)c[w]=e(a[w%a.length],r[w%r.length]);else for(let w=0;w<c.length;++w){let k=E.indexToLoc(w,o,u),N=k.slice(-p);v.forEach(D=>N[D]=0);let I=E.locToIndex(N,p,g),T=k.slice(-m);x.forEach(D=>T[D]=0);let $=E.locToIndex(T,m,b);c[w]=e(a[I],r[$])}return[c,i]}}function Tr(e){let{inputs:t,backend:n}=e,{real:a,imag:r}=t,s=n.data.get(a.dataId).values,i=n.data.get(r.dataId).values,o=n.makeTensorInfo(a.shape,"complex64"),u=n.data.get(o.dataId);return u.complexTensorInfos={real:n.makeTensorInfo(a.shape,"float32",s),imag:n.makeTensorInfo(r.shape,"float32",i)},o}var Gse={kernelName:l0,backendName:"cpu",kernelFunc:Tr};function Uv(e,t,n="float32"){if(n==="complex64"){let r=Uv(e,t,"float32"),s=Uv(e,t,"float32");return Tr({inputs:{real:r,imag:s},backend:e})}let a=E.makeZerosTypedArray(E.sizeFromShape(t),n);return e.makeTensorInfo(t,n,a)}function fi(e){let{inputs:t,backend:n}=e,{x:a}=t;return n.incRef(a.dataId),{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}var qse={kernelName:wc,backendName:"cpu",kernelFunc:fi};function Lu(e){let{inputs:t,backend:n}=e,{input:a}=t,r=n.data.get(a.dataId).complexTensorInfos.real,s=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,s)}var Kse={kernelName:x0,backendName:"cpu",kernelFunc:Lu};function Qz(e,t,n,a){if(a==="int32"){let r=Int32Array.from(e);return[t,"int32",r]}if(a==="bool"){let r=E.toTypedArray([0],n),[s,i]=On((o,u)=>o!==u?1:0)(t,[],e,r,"bool");return[i,"bool",s]}throw new Error(`Error in Cast: failed to cast ${n} to ${a}`)}function pl(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dtype:s}=a;if(s==="complex64"){if(r.dtype==="complex64")return fi({inputs:{x:r},backend:n});let c=Uv(n,r.shape,r.dtype),p=pl({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),m=Tr({inputs:{real:p,imag:c},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(p),m}if(r.dtype==="complex64"){let c=Lu({inputs:{input:r},backend:n}),p=pl({inputs:{x:c},backend:n,attrs:{dtype:s}});return n.disposeIntermediateTensorInfo(c),p}if(!E.hasEncodingLoss(r.dtype,s)){let c=fi({inputs:{x:r},backend:n});return{dataId:c.dataId,shape:c.shape,dtype:s}}let i=n.data.get(r.dataId).values,[o,u,d]=Qz(i,r.shape,r.dtype,s);return n.makeTensorInfo(o,u,d)}var Xse={kernelName:nc,backendName:"cpu",kernelFunc:pl};function aa(e,t,n,a){return n==null?({inputs:r,backend:s})=>{let{a:i,b:o}=r,u=s;Ue([i,o],e);let d=u.data.get(i.dataId).values,c=u.data.get(o.dataId).values,p=i.dtype==="string"?O.fromUint8ToStringArray(d):d,m=i.dtype==="string"?O.fromUint8ToStringArray(c):c,g=a||i.dtype,[b,v]=t(i.shape,o.shape,p,m,g);return u.makeTensorInfo(v,g,b)}:({inputs:r,backend:s})=>{let{a:i,b:o}=r,u=s;if(i.dtype==="complex64"||o.dtype==="complex64"){let d=pl({inputs:{x:i},backend:u,attrs:{dtype:"complex64"}}),c=u.data.get(d.dataId),p=c.complexTensorInfos.real,m=c.complexTensorInfos.imag,g=u.data.get(p.dataId).values,b=u.data.get(m.dataId).values,v=pl({inputs:{x:o},backend:u,attrs:{dtype:"complex64"}}),x=u.data.get(v.dataId),w=x.complexTensorInfos.real,k=x.complexTensorInfos.imag,N=u.data.get(w.dataId).values,I=u.data.get(k.dataId).values,[T,$,D]=n(i.shape,o.shape,g,b,N,I),M=u.makeTensorInfo(D,"float32",T),B=u.makeTensorInfo(D,"float32",$),V=Tr({inputs:{real:M,imag:B},backend:u});return u.disposeIntermediateTensorInfo(d),u.disposeIntermediateTensorInfo(v),u.disposeIntermediateTensorInfo(M),u.disposeIntermediateTensorInfo(B),V}else{let d=u.data.get(i.dataId).values,c=u.data.get(o.dataId).values,p=a||i.dtype,[m,g]=t(i.shape,o.shape,d,c,p);return u.makeTensorInfo(g,p,m)}}}function dI(e){return(t,n,a,r,s,i)=>{let o=O.assertAndGetBroadcastShape(t,n),u=E.sizeFromShape(o),d=o.length,c=E.computeStrides(o),p=E.getTypedArrayFromDType("float32",u),m=E.getTypedArrayFromDType("float32",u),g=O.getBroadcastDims(t,o),b=O.getBroadcastDims(n,o),v=O.mergeRealAndImagArrays(a,r),x=O.mergeRealAndImagArrays(s,i),w=t.length,k=E.computeStrides(t),N=n.length,I=E.computeStrides(n);if(g.length+b.length===0)for(let T=0;T<p.length;T++){let $=T%v.length,D=T%x.length,M=e(v[$*2],v[$*2+1],x[D*2],x[D*2+1]);p[T]=M.real,m[T]=M.imag}else for(let T=0;T<p.length;T++){let $=E.indexToLoc(T,d,c),D=$.slice(-w);g.forEach(R=>D[R]=0);let M=E.locToIndex(D,w,k),B=$.slice(-N);b.forEach(R=>B[R]=0);let V=E.locToIndex(B,N,I),W=e(v[M*2],v[M*2+1],x[V*2],x[V*2+1]);p[T]=W.real,m[T]=W.imag}return[p,m,o]}}var eL=On((e,t)=>e+t),Yse=dI((e,t,n,a)=>({real:e+n,imag:t+a})),Kh=aa(bl,eL,Yse),Jse={kernelName:bl,backendName:"cpu",kernelFunc:Kh};function hI(e,t,n,a,r){let s=E.sizeFromShape(a),i=E.makeZerosTypedArray(r,n);for(let o=0;o<e.length;o++){let u=e[o];if(u<0)throw new Error("Input x must be non-negative!");u>=r||(s>0?i[u]+=t[o]:i[u]+=1)}return i}function tL(e,t,n,a=!1){let r=e.shape[0],s=e.shape[1],i=mt([r,n],t.dtype);for(let o=0;o<r;o++)for(let u=0;u<s;u++){let d=e.get(o,u);if(d<0)throw new Error("Input x must be non-negative!");d>=n||(a?i.set(1,o,d):t.size>0?i.set(i.get(o,d)+t.get(o,u),o,d):i.set(i.get(o,d)+1,o,d))}return i}var nL=On((e,t)=>e&t),Zse=aa(up,nL),Qse={kernelName:up,backendName:"cpu",kernelFunc:Zse};function bi(e){return(t,n,a)=>{let r=E.getArrayFromDType(n,t.length);for(let s=0;s<t.length;++s)r[s]=e(t[s],a);return r}}function Vt(e,t,n){let a=bi(t);return Tl(e,a,n)}function Tl(e,t,n){return({inputs:a,attrs:r,backend:s})=>{let{x:i}=a;Ue(i,e);let o=s,u=o.data.get(i.dataId).values,d;if(i.dtype==="string"){if(!Array.isArray(u))throw new Error("String tensor's value was not an instance of Array");d=O.fromUint8ToStringArray(u)}else d=u;let c=n||i.dtype,p=t(d,c,r);return o.makeTensorInfo(i.shape,c,p)}}var aL=bi(e=>Math.ceil(e)),eie=Tl(ac,aL),tie={kernelName:ac,backendName:"cpu",kernelFunc:eie};function pI(e,t,n,a){let r=E.getArrayFromDType(n,E.sizeFromShape(t));if(a&&n!=="string"){let s=0;e.forEach(i=>{let o=E.sizeFromShape(i.shape);r.set(i.vals,s),s+=o})}else{let s=0;e.forEach(i=>{let o=n==="string"?O.fromUint8ToStringArray(i.vals):i.vals,u=0;for(let d=0;d<i.shape[0];++d){let c=d*t[1]+s;for(let p=0;p<i.shape[1];++p)r[c+p]=o[u++]}s+=i.shape[1]})}return r}var rL=On((e,t)=>e===t?1:0),sL=aa(yp,rL,null,"bool"),nie={kernelName:yp,backendName:"cpu",kernelFunc:sL},iL=bi(e=>Math.exp(e)),oL=Tl(mc,iL,"float32"),aie={kernelName:mc,backendName:"cpu",kernelFunc:oL},lL=bi(e=>Math.expm1(e)),rie=Tl(gc,lL),sie={kernelName:gc,backendName:"cpu",kernelFunc:rie},uL=bi(e=>Math.floor(e)),iie=Tl(yc,uL),oie={kernelName:yc,backendName:"cpu",kernelFunc:iie},cL=On((e,t)=>Math.floor(e/t)),lie=aa(bc,cL,null,"int32"),uie={kernelName:bc,backendName:"cpu",kernelFunc:lie};function dL(e,t,n,a,r,s,i,o,u){let d=mt([a,s],n);for(let c=0;c<a;c++){let p=[],m=0;for(let g=0;g<r;g++){let b=e[c*r+g];m+=b*i[g],p.push(b)}if(m<0||m>=u/s)throw new Error(`Invalid indices: ${p} does not index into ${o}`);for(let g=0;g<s;g++)d.values[c*s+g]=t.get(...t.indexToLoc(m*s+g))}return d}function hL(e,t,n){let a=mt(n,e.dtype);for(let r=0;r<a.size;++r){let s=a.indexToLoc(r).slice(),i=s[0],o=s[2],u=t.locToIndex([i,o]);s[2]=t.values[u];let d=e.locToIndex(s);0<=d&&d<e.values.length&&(a.values[r]=e.values[d])}return a}var pL=On((e,t)=>e>t?1:0),cie=aa(Sp,pL,null,"bool"),die={kernelName:Sp,backendName:"cpu",kernelFunc:cie},fL=On((e,t)=>e>=t?1:0),hie=aa(xc,fL,null,"bool"),pie={kernelName:xc,backendName:"cpu",kernelFunc:hie},mL=On((e,t)=>e<t?1:0),fie=aa(kp,mL,null,"bool"),mie={kernelName:kp,backendName:"cpu",kernelFunc:fie},gL=On((e,t)=>e<=t?1:0),gie=aa(_p,gL,null,"bool"),yie={kernelName:_p,backendName:"cpu",kernelFunc:gie};function yL(e,t,n){let a=(t-e)/(n-1),r=E.makeZerosTypedArray(n,"float32");r[0]=e;for(let s=1;s<r.length;s++)r[s]=r[s-1]+a;return r}var bL=bi(e=>Math.log(e)),bie=Tl(Ic,bL),vie={kernelName:Ic,backendName:"cpu",kernelFunc:bie};function vL(e,t,n,a){let r=E.getTypedArrayFromDType(a,E.sizeFromShape(n));for(let s=0;s<r.length;++s){let i=s*t,o=e[i];for(let u=0;u<t;++u){let d=e[i+u];(Number.isNaN(d)||d>o)&&(o=d)}r[s]=o}return r}var xL=On((e,t)=>Math.max(e,t)),xie=aa(Ac,xL),wie={kernelName:Ac,backendName:"cpu",kernelFunc:xie},wL=On((e,t)=>Math.min(e,t)),Sie=aa(Oc,wL),kie={kernelName:Oc,backendName:"cpu",kernelFunc:Sie},fI=On((e,t)=>e*t),_ie=dI((e,t,n,a)=>({real:e*n-t*a,imag:e*a+t*n})),Ix=aa(zc,fI,_ie),Nie={kernelName:zc,backendName:"cpu",kernelFunc:Ix};function SL(e,t,n){let a=E.createScalarValue(-1,n);return fI([],t,a,e,n)}function Iie(e){let{inputs:t,backend:n}=e,{x:a}=t;Ue(a,"neg");let r=n.data.get(a.dataId).values,[s,i]=SL(r,a.shape,a.dtype);return n.makeTensorInfo(i,a.dtype,s)}var Tie={kernelName:Rp,backendName:"cpu",kernelFunc:Iie},kL=On((e,t)=>e!==t?1:0),Eie=aa(Dp,kL,null,"bool"),Cie={kernelName:Dp,backendName:"cpu",kernelFunc:Eie};function mI(e,t,n,a,r){let s=t.length,i=E.sizeFromShape(t),o=E.computeStrides(t),u=E.computeStrides(r),d=E.getTypedArrayFromDType(n,E.sizeFromShape(r));for(let c=0;c<i;++c){let p=E.indexToLoc(c,s,o),m=new Array(p.length);for(let b=0;b<m.length;b++)m[b]=p[a[b]];let g=E.locToIndex(m,s,u);d[g]=e[c]}return d}function hr(e){let{inputs:t,attrs:n,backend:a}=e,{x:r}=t,{perm:s}=n;Ue(r,"transpose");let i=r.shape.length,o=new Array(i);for(let c=0;c<o.length;c++)o[c]=r.shape[s[c]];let u=a.data.get(r.dataId).values,d=mI(u,r.shape,r.dtype,s,o);return{dataId:a.write(d,o,r.dtype),shape:o,dtype:r.dtype}}var Aie={kernelName:Hi,backendName:"cpu",kernelFunc:hr};function _L(e,t,n,a){let[r,s]=O.computeOutAndReduceShapes(e,a),i=Jr(t,"int32"),o=E.makeZerosTypedArray(E.sizeFromShape(r),i),u=E.sizeFromShape(s);for(let d=0;d<o.length;++d){let c=d*u,p=1;for(let m=0;m<u;++m)p*=n[c+m];o[d]=p}return{outVals:o,outShape:r,outDtype:i}}function $ie(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a;Ue(r,"prod");let o=r.shape.length,u=E.parseAxisParam(s,r.shape),d=O.getAxesPermutation(u,o),c=u,p=r,m=[];d!=null&&(p=hr({inputs:{x:r},backend:n,attrs:{perm:d}}),m.push(p),c=O.getInnerMostAxes(c.length,o));let g=n.data.get(p.dataId).values,{outVals:b,outShape:v,outDtype:x}=_L(p.shape,p.dtype,g,c),w=v;return i&&(w=O.expandShapeToKeepDim(v,u)),m.forEach(k=>n.disposeIntermediateTensorInfo(k)),n.makeTensorInfo(w,x,b)}var Rie={kernelName:jc,backendName:"cpu",kernelFunc:$ie};function Die(e,t,n){e.forEach((a,r)=>{if(a<0||a>=n){let s=E.indexToLoc(r,t.length,E.computeStrides(t)).join(",");throw new Error(`indices[${s}] = ${a} is not in [0, ${n})`)}})}function Oie(e,t){for(let n=0;n<e.length;++n){let a=e[n],r=n===e.length-1?t:e[n+1].length;if(a.length===0)throw new Error("Ragged splits may not be empty");if(a[0]<0)throw new Error("Ragged splits must be non-negative");if(a[a.length-1]>r)throw new Error("Ragged splits must not point past values");for(let s=1;s<a.length;++s)if(a[s-1]>a[s])throw new Error("Ragged splits must be sorted in ascending order")}}function Mie(e,t,n,a){let r=[],s=0,i=t.length-1+n.length,o=new Array(i).fill(null).map(()=>[0]);Oie(n,a);let u=1;for(let d=0;d<t.length-1;++d){u*=t[d];let c=t[d+1];for(let p=1;p<u+1;++p)o[d].push(p*c)}for(let d=0;d<e.length;++d){let c=e[d],p=e[d]+1;for(let m=0;m<n.length;++m){let g=n[m],b=m+t.length-1;if(b>=0){let v=o[b],x=v[v.length-1]-g[c];for(let w=c;w<p;++w)o[b].push(g[w+1]+x)}c=g[c],p=g[p]}p!==c&&(r.push([c,p]),s+=p-c)}return{outSplits:o,valueSlices:r,numValues:s}}function Fie(e){let t=[];for(let n=0;n<e.length;++n){let a=e[n].length,r=E.getArrayFromDType("int32",a);t.push(r),e[n].forEach((s,i)=>r[i]=s)}return t}function SR(e,t){let n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let a=t;a<e.length;a++)n[t-1]*=e[a];return n}function zie(e,t,n,a,r,s){let i=SR(t,2)[1],o=SR(s,2)[1],u=0;for(let d of n)for(let c=d[0];c<d[1];++c){for(let p=0;p<a;++p)r[u*o+p]=e[c*i+p];++u}}function Lie(e,t,n,a,r){let s=t.slice();s[0]=r;let i=E.getArrayFromDType(n,E.sizeFromShape(s)),o=e.length,u=o===0?0:o/t[0];return zie(e,t,a,u,i,s),[i,s]}function NL(e,t,n,a,r,s,i,o){if(e.length===0)throw new Error("paramsNestedSplits must be non empty");if(t[0].length===0)throw new Error("Split tensors must not be scalars");let u=t[0][0]-1;if(Die(s,i,u),a.length===0)throw new Error("params.rank must be nonzero");let d=a[0],{outSplits:c,valueSlices:p,numValues:m}=Mie(s,i,e,d),g=Fie(c),b=Lie(n,a,r,p,m);return[g,b[0],b[1]]}var kR=2147483647;function IL(e,t,n,a,r,s,i){if(t.length>1)throw new Error("starts must be a scalar or vector");if(r.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");let o=t.length===0,u=r.length===0,d=i.length===0,c=[];o||c.push(t[0]),u||c.push(r[0]),d||c.push(i[0]);for(let x=1;x<c.length;++x)if(c[x]!==c[x-1])throw new Error("starts, limits, and deltas must have the same shape");let p=c.length===0?1:c[0],m=E.getArrayFromDType("int32",p+1);m[0]=0;for(let x=0;x<p;++x){let w=o?e[0]:e[x],k=u?a[0]:a[x],N=d?s[0]:s[x];if(N===0)throw new Error("Requires delta != 0");let I;if(N>0&&k<w||N<0&&k>w)I=0;else if(I=Math.ceil(Math.abs((k-w)/N)),I>kR)throw new Error(`Requires ((limit - start) / delta) <= ${kR}`);m[x+1]=m[x]+I}let g=m[p],b=E.getArrayFromDType(n,g),v=0;for(let x=0;x<p;++x){let w=m[x+1]-m[x],k=o?e[0]:e[x],N=d?s[0]:s[x];for(let I=0;I<w;++I)b[v++]=k,k+=N}return[m,b]}var fs=O.RowPartitionType,Bie=class mk{constructor(t,n,a,r,s,i,o,u,d,c){this.shape=t,this.shapeShape=n,this.values=a,this.valuesShape=r,this.valuesDType=s,this.defaultValue=i,this.defaultValueShape=o,this.rowPartitionValues=u,this.rowPartitionValuesShapes=d,this.rowPartitionTypes=O.getRowPartitionTypesHelper(c),this.raggedRank=O.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===fs.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===fs.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){let n=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case fs.VALUE_ROWIDS:return mk.getMaxWidthValueRowID(n);case fs.ROW_SPLITS:return mk.getMaxWidthRowSplit(n);default:throw new Error(`Cannot handle partition type ${fs[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){let n=t.length;if(n===0||n===1)return 0;let a=0;for(let r=0;r<n-1;++r){let s=t[r+1]-t[r];s>a&&(a=s)}return a}static getMaxWidthValueRowID(t){let n=t.length;if(n===0)return 0;let a=0,r=t[0],s=0;for(let i=1;i<n;++i){let o=t[i];o!==r&&(r=o,s=Math.max(i-a,s),a=i)}return Math.max(n-a,s)}tensorShapeFromTensor(t,n,a=!0){if(n.length===0){if(t[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return NR(t,a)}calculateOutputSize(t){let n=this.valuesShape,a=this.defaultValueShape;O.validateDefaultValueShape(a,n);let r=this.tensorShapeFromTensor(this.shape,this.shapeShape),s=O.combineRaggedTensorToTensorShapes(this.raggedRank,r,n);s[0]<0&&(s[0]=t);for(let i=1;i<=this.raggedRank;++i)s[i]<0&&(s[i]=this.getMaxWidth(i));return s}calculateFirstParentOutputIndex(t,n,a){let r=Math.min(t,a),s=[],i=0;for(let o=0;o<r;++o,i+=n)s.push(i);for(let o=r;o<t;++o)s.push(-1);return E.assert(s.length===t,()=>"Final length of result must be equal to firstDimension."),s}calculateOutputIndexRowSplit(t,n,a,r){let s=t.length,i=[];for(let o=0;o<s-1;++o){let u=t[o+1]-t[o],d=Math.min(r,u),c=n[o];c===-1&&(d=0);for(let p=0;p<d;++p)i.push(c),c+=a;for(let p=0;p<u-d;++p)i.push(-1)}if(s>0&&i.length!==t[s-1])throw new Error("Invalid row split size.");return i}calculateOutputIndexValueRowID(t,n,a,r){let s=t.length,i=[];if(s===0)return[];let o=0,u=t[0];if(u>=n.length)throw new Error(`Got currentValueRowId=${u}, which is not less than ${n.length}`);let d=n[u];i.push(d);for(let c=1;c<s;++c){let p=t[c];if(p===u)d>=0&&(++o,o<r?d+=a:d=-1);else{if(o=0,u=p,p>=n.length)throw new Error(`Got nextValueRowId=${p} which is not less than ${n.length}`);d=n[p]}i.push(d)}if(i.length!==t.length)throw new Error("Invalid row ids.");return i}calculateOutputIndex(t,n,a,r){let s=this.getRowPartitionTensor(t),i=this.getRowPartitionTypeByDimension(t);switch(i){case fs.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(s,n,a,r);case fs.ROW_SPLITS:if(s.length-1>n.length)throw new Error(`Row partition size is greater than output size: ${s.length-1} > ${n.length}`);return this.calculateOutputIndexRowSplit(s,n,a,r);default:throw new Error(`Unsupported partition type: ${fs[i]}`)}}getFirstDimensionSize(){let t=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");let n=this.rowPartitionTypes[0];switch(n){case fs.FIRST_DIM_SIZE:return t[0];case fs.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case fs.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${fs[n]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");let t=this.getFirstDimensionSize(),n=this.calculateOutputSize(t),a=new Array(this.raggedRank+1);a[a.length-1]=1;for(let i=a.length-2;i>=0;--i)a[i]=a[i+1]*n[i+1];let r=NR(n,!1),s=E.getArrayFromDType(this.valuesDType,E.sizeFromShape(r));if(a[0]*n[0]>0){let i=this.calculateFirstParentOutputIndex(t,a[0],n[0]);for(let o=1;o<=this.raggedRank;++o)i=this.calculateOutputIndex(o-1,i,a[o],n[o]);this.setOutput(this.raggedRank,i,s,r)}return[r,s]}setOutput(t,n,a,r){if(a.length===0)return;let s=this.values,i=a,o=r.slice();o=o.slice(t+1);let u=E.sizeFromShape(o),d=n.length,c=this.defaultValue;if(c.length!==u&&c.length!==1){let b=this.defaultValueShape;ne(()=>{let v=te(c,b);c=xu(v,o).dataSync()})}let p=0,m=0,g=0;for(let b=0;b<=d;++b){let v=b<d?n[b]:-1;if(v===g){++g;continue}if(m<g){let x=s.subarray(p*u),w=i.subarray(m*u),k=(g-m)*u;_R(w,x,k)}if(b>=d){let x=a.length;v=Math.floor(x/u)}if(v>g)if(this.defaultValue.length===1)i.subarray(g*u,v*u).fill(this.defaultValue[0]),g=v;else for(;v>g;){let x=i.slice(g*u);_R(x,c,u),++g}v<0?(p=b+1,m=g):(p=b,m=g,g=m+1)}}};function _R(e,t,n){for(let a=0;a<n;a++)e[a]=t[a]}function NR(e,t){let n=[];for(let a of e){if(a<0){if(!t)throw new Error(`Dimension ${a} must be >= 0`);if(a<-1)throw new Error(`Dimension ${a} must be >= -1`);a=-1}n.push(a)}return n}function TL(e,t,n,a,r,s,i,o,u,d){return new Bie(e,t,n,a,r,s,i,o,u,d).compute()}function gI(e,t,n,a){let r=e===t,s=e<t&&n<0,i=t<e&&n>1;if(r||s||i)return E.makeZerosTypedArray(0,a);let o=Math.abs(Math.ceil((t-e)/n)),u=E.makeZerosTypedArray(o,a);t<e&&n===1&&(n=-1),u[0]=e;for(let d=1;d<u.length;d++)u[d]=u[d-1]+n;return u}var EL=bi(e=>1/Math.sqrt(e)),Pie=Tl(Yc,EL),Uie={kernelName:Yc,backendName:"cpu",kernelFunc:Pie};function bu(e,t,n,a,r,s,i,o,u,d){let c=[a/r,r],p=e.values,m=t.values;if(a===0)return mt(n,t.dtype);let g=u instanceof Pn?u:mt(c,t.dtype);typeof u=="string"||typeof u=="number"?g.values.fill(u):typeof u=="boolean"&&g.values.fill(+u);for(let b=0;b<s;b++){let v=[],x=0;for(let w=0;w<i;w++){let k=p[b*i+w];v.push(k),x+=k*o[w]}if(x<0||x>=a/r)throw new Error(`Invalid indices: ${v} does not index into ${n}`);for(let w=0;w<r;w++)d?g.values[x*r+w]+=m[b*r+w]:g.values[x*r+w]=t.rank===0?m[0]:m[b*r+w]}return g}var jie=bi(e=>1/(1+Math.exp(-e))),CL=Vt(td,e=>1/(1+Math.exp(-e))),Wie={kernelName:td,backendName:"cpu",kernelFunc:CL};function jv(e,t,n,a,r){let s=ea.isSliceContinous(a,t,n),i=E.sizeFromShape(n),o=E.computeStrides(a);if(s){let p=ea.computeFlatOffset(t,o);return r==="string"?e.slice(p,p+i):e.subarray(p,p+i)}let u=r==="string"?O.fromUint8ToStringArray(e):e,d=mt(a,r,u),c=mt(n,r);for(let p=0;p<c.size;++p){let m=c.indexToLoc(p),g=m.map((b,v)=>b+t[v]);c.set(d.get(...g),...m)}return r==="string"?O.fromStringArrayToUint8(c.values):c.values}function Bu(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:s,size:i}=a;Ue(r,"slice");let[o,u]=ea.parseSliceParams(r,s,i);ea.assertParamsValid(r,o,u);let d=n.data.get(r.dataId).values,c=jv(d,o,u,r.shape,r.dtype);return n.makeTensorInfo(u,r.dtype,c)}var Vie={kernelName:Gp,backendName:"cpu",kernelFunc:Bu};function AL(e,t,n,a,r,s,i){let o=t[0],u=s[0],d=new Array(u),c=new Array(o),p=t[1];if(u===0){if(o!==0)throw new Error(O.getSparseFillEmptyRowsIndicesDenseShapeMismatch(o));let x=E.getArrayFromDType(n,0),w=E.getArrayFromDType(r,0);return[x,[0,p],w,d,c]}let m=!0,g=0,b=new Array(u).fill(0);for(let x=0;x<o;++x){let w=e[x*p];if(w<0)throw new Error(O.getSparseFillEmptyRowsNegativeIndexErrorMessage(x,w));if(w>=u)throw new Error(O.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(x,w,u));++b[w],m=m&&w>=g,g=w}let v=!0;for(let x=0;x<u;++x){let w=b[x]===0;d[x]=w,v=v&&!w,b[x]=Math.max(b[x],1),x>0&&(b[x]+=b[x-1])}if(v&&m){let x=e,w=a;for(let k=0;k<o;++k)c[k]=k;return[x,[o,p],w,d,c]}else{let x=b[u-1],w=E.getArrayFromDType(n,x*p),k=E.getArrayFromDType(r,x),N=new Array(u).fill(0);for(let I=0;I<o;++I){let T=e[I*p],$=N[T],D=(T===0?0:b[T-1])+$;N[T]++;for(let M=0;M<p;++M)w[D*p+M]=e[I*p+M];k[D]=a[I],c[I]=D}for(let I=0;I<u;++I)if(N[I]===0){let T=I===0?0:b[I-1];w[T*p+0]=I;for(let $=1;$<p;++$)w[T*p+$]=0;k[T]=i}return[w,[x,p],k,d,c]}}function $L(e,t,n,a,r){let s=E.sizeFromShape(a),i=t[0],o=r.length,u=[],d=1,c=-1;for(let v=0;v<o;++v){let x=r[v];if(x===-1){if(c!==-1)throw new Error(O.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(c,v));c=v,u.push(1)}else{if(x<0)throw new Error(O.getSparseReshapeNegativeOutputDimErrorMessage(v,x));d*=x,u.push(x)}}if(c!==-1){if(d<=0)throw new Error(O.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());let v=Math.trunc(s/d);if(d*v!==s)throw new Error(O.getSparseReshapeInputOutputMultipleErrorMessage(a,u));u[c]=v}if(E.sizeFromShape(u)!==s)throw new Error(O.getSparseReshapeInputOutputMismatchErrorMessage(a,u));let p=a.length,m=[];if(p>0){m[p-1]=1;for(let v=p-2;v>=0;--v)m[v]=m[v+1]*a[v+1]}let g=[];if(o>0){g[o-1]=1;for(let v=o-2;v>=0;--v)g[v]=g[v+1]*u[v+1]}let b=E.getArrayFromDType(n,i*o);for(let v=0;v<i;++v){let x=0;for(let w=0;w<p;++w)x+=e[v*p+w]*m[w];for(let w=0;w<o;++w)b[v*o+w]=Math.trunc(x/g[w]),x%=g[w]}return[b,[i,o],u]}function yI(e,t,n,a,r,s=!1,i=0){let o=a.length,u=[t[0],e.length/t[0]],d=u[1],c=o>0?r[o-1]+1:0;if(c<0)throw new Error(O.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let p=t.slice();p[0]=c;let m=p.reduce((k,N)=>k*N,1),g=E.getArrayFromDType(n,m);if(o===0)return c>0&&g.fill(i),[g,p];if(c<=0)throw new Error(O.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let b=0,v=1,x=0,w=r[b];for(;;){let k=0;if(v<o){if(k=r[v],w===k){++v;continue}if(w>=k)throw new Error(O.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(w<0||w>=c)throw new Error(O.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(w,c));w>x&&g.fill(i,x*d,w*d);for(let N=b;N<v;++N){let I=a[N];if(I<0||I>=u[0])throw new Error(O.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(N,a[N],u[0]));for(let T=0;T<d;T++)g[w*d+T]+=e[I*d+T]}if(s)for(let N=0;N<d;N++)g[w*d+N]/=v-b;if(b=v,++v,x=w+1,w=k,v>o)break}return x<c&&g.fill(i,x*d,c*d),[g,p]}var Hie=bi(e=>Math.sqrt(e)),Gie=Vt(ad,e=>Math.sqrt(e)),qie={kernelName:ad,backendName:"cpu",kernelFunc:Gie},RL=On((e,t)=>{let n=e-t;return n*n}),Kie=aa(id,RL),Xie={kernelName:id,backendName:"cpu",kernelFunc:Kie},DL=bi((e,t)=>{let{pattern:n,replaceGlobal:a,rewrite:r}=t;return e.replace(new RegExp(n,a?"g":""),r)}),Yie=Tl(Ug,DL),Jie={kernelName:Ug,backendName:"cpu",kernelFunc:Yie};function OL(e,t,n,a){let r=mt(e,t.dtype);for(let s=0;s<r.size;s++){let i=r.indexToLoc(s),o=new Array(i.length);for(let u=0;u<o.length;u++)o[u]=i[u]*n[u]+a[u];r.set(t.get(...o),...i)}return r}var Zie=class{constructor(e,t,n,a,r,s){this.separator=E.encodeString(e),this.nGramWidths=t,this.leftPad=E.encodeString(n),this.rightPad=E.encodeString(a),this.padWidth=r,this.preserveShort=s}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){let n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,a,r,s){for(let i=0;i<r;++i){let o=this.getPadWidth(s),u=Math.max(0,o-i),d=Math.max(0,o-(r-(i+1))),c=s-(u+d),p=t+(u>0?0:i-o),m=0;m+=u*this.leftPad.length;for(let w=0;w<c;++w)m+=e[p+w].length;m+=d*this.rightPad.length;let g=u+d+c-1;m+=g*this.separator.length,n[a+i]=new Uint8Array(m);let b=n[a+i],v=0,x=w=>w.forEach(k=>b[v++]=k);for(let w=0;w<u;++w)x(this.leftPad),x(this.separator);for(let w=0;w<c-1;++w)x(e[p+w]),x(this.separator);if(c>0){x(e[p+c-1]);for(let w=0;w<d;++w)x(this.separator),x(this.rightPad)}else{for(let w=0;w<d-1;++w)x(this.rightPad),x(this.separator);x(this.rightPad)}}}compute(e,t){let n=e.length,a=t.length;if(a>0){let o=t[0];if(o!==0)throw new Error(`First split value must be 0, got ${o}`);for(let u=1;u<a;++u){let d=t[u]>=o;if(d=d&&t[u]<=n,!d)throw new Error(`Invalid split value ${t[u]}, must be in [${o}, ${n}]`);o=t[u]}if(o!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${o}`)}let r=a-1,s=E.getArrayFromDType("int32",a);if(n===0||a===0){let o=new Array(n);for(let u=0;u<=r;++u)s[u]=0;return[o,s]}s[0]=0;for(let o=1;o<=r;++o){let u=t[o]-t[o-1],d=0;this.nGramWidths.forEach(c=>{d+=this.getNumNGrams(u,c)}),this.preserveShort&&u>0&&d===0&&(d=1),s[o]=s[o-1]+d}let i=new Array(s[r]);for(let o=0;o<r;++o){let u=t[o],d=s[o];if(this.nGramWidths.forEach(c=>{let p=t[o+1]-t[o],m=this.getNumNGrams(p,c);this.createNGrams(e,u,i,d,m,c),d+=m}),this.preserveShort&&d===s[o]){let c=t[o+1]-t[o];if(c===0)continue;let p=c+2*this.padWidth;this.createNGrams(e,u,i,d,1,p)}}return[i,s]}};function bI(e,t,n,a,r,s,i,o){return new Zie(n,a,r,s,i,o).compute(e,t)}function Qie(e,t,n,a){if(!e.length)return;if(t.length===0){for(let s=0;s<e.length;++s)a.push(e.subarray(s,s+1));return}if(t.length===1){let s=t[0],i=e.indexOf(s);for(;i!==-1;){let o=e.subarray(0,i);(!n||o.length!==0)&&a.push(o),e=e.subarray(i+1),i=e.indexOf(s)}(!n||e.length!==0)&&a.push(e);return}let r=0;for(let s=0;s<e.length+1;s++)if(s===e.length||t.indexOf(e[s])!==-1){let i=e.subarray(r,s);(!n||i.length!==0)&&a.push(i),r=s+1}}function vI(e,t,n){let a=e.length,r=[],s=0,i=0,o=new Array(a);for(let m=0;m<a;++m){let g=r.length;Qie(e[m],t,n,r);let b=r.length-g;o[m]=b,s+=b,i=Math.max(i,b)}let u=E.getArrayFromDType("int32",s*2),d=new Array(s),c=[a,i],p=0;for(let m=0;m<a;++m)for(let g=0;g<o[m];++g)u[p*2]=m,u[p*2+1]=g,d[p]=r[p],++p;return[u,d,c]}function xI(e,t){let n=E.getArrayFromDType("int32",e.length);for(let a=0;a<e.length;++a)n[a]=E.fingerPrint64(e[a]).modulo(t).getLowBitsUnsigned();return n}var ML=On((e,t)=>e-t),eoe=dI((e,t,n,a)=>({real:e-n,imag:t-a})),wI=aa(od,ML,eoe),toe={kernelName:od,backendName:"cpu",kernelFunc:wI};function FL(e,t){let n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=e.shape[r]*t[r];let a=mt(n,e.dtype);for(let r=0;r<a.values.length;++r){let s=a.indexToLoc(r),i=new Array(e.rank);for(let u=0;u<i.length;u++)i[u]=s[u]%e.shape[u];let o=e.locToIndex(i);a.values[r]=e.values[o]}return a}var $m=(e,t)=>{let n=t.value-e.value;return n===0?e.index-t.index:n};function zL(e,t,n=0,a=e.length-1){for(;a>n;){if(a-n>600){let o=a-n+1,u=t-n+1,d=Math.log(o),c=.5*Math.exp(2*d/3),p=.5*Math.sqrt(d*c*(o-c)/o)*Math.sign(u-o/2),m=Math.max(n,Math.floor(t-u*c/o+p)),g=Math.min(a,Math.floor(t+(o-u)*c/o+p));zL(e,t,m,g)}let r=e[t],s=n,i=a;for(E.swap(e,n,t),$m(e[a],r)>0&&E.swap(e,n,a);s<i;){for(E.swap(e,s,i),s++,i--;$m(e[s],r)<0;)s=s+1;for(;$m(e[i],r)>0;)i=i-1}$m(e[n],r)===0?E.swap(e,n,i):(i=i+1,E.swap(e,i,a)),i<=t&&(n=i+1),t<=i&&(a=i-1)}}function LL(e,t,n,a,r){let s=t[t.length-1],[i,o]=[e.length/s,s],u=E.getTypedArrayFromDType(n,i*a),d=E.getTypedArrayFromDType("int32",i*a);for(let p=0;p<i;p++){let m=p*o,g=e.subarray(m,m+o),b=new Array(g.length);g.forEach((k,N)=>b[N]={value:k,index:N}),a<b.length&&(zL(b,a),b=b.slice(0,a)),r&&b.sort($m);let v=p*a,x=u.subarray(v,v+a),w=d.subarray(v,v+a);for(let k=0;k<a;k++)x[k]=b[k].value,w[k]=b[k].index}let c=t.slice();return c[c.length-1]=a,[mt(c,n,u),mt(c,"int32",d)]}function SI(e,t,n,a){let r=E.parseAxisParam(t,n)[0],s=[1,n[0],1];for(let b=0;b<r;b++)s[0]*=n[b];s[1]=n[r];for(let b=r+1;b<n.length;b++)s[2]*=n[b];let i=new Map,o=new Int32Array(n[r]),u=new Pn(s,a,e),d=[],c=s[0]===1&&s[2]===1;for(let b=0;b<n[r];b++){let v;if(c)v=e[b].toString();else{let w=[];for(let k=0;k<s[0];k++)for(let N=0;N<s[2];N++)w.push(u.get(k,b,N));v=w.join(",")}let x=i.get(v);if(x!=null)o[b]=x;else{let w=i.size;i.set(v,w),o[b]=w,d.push(b)}}let p=s.slice();p[1]=i.size;let m=new Pn(p,a);d.forEach((b,v)=>{for(let x=0;x<s[0];x++)for(let w=0;w<s[2];w++)m.set(u.get(x,b,w),x,v,w)});let g=n.slice();return g[r]=p[1],{outputValues:m.values,outputShape:g,indices:o}}var noe="4.22.0";k0("cpu",()=>new uI,1);var BL=Vt(pc,e=>e>=0?e:Math.exp(e)-1),aoe={kernelName:pc,backendName:"cpu",kernelFunc:BL};function PL(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{alpha:s}=a;Ue([r],"leakyRelu");let i=E.sizeFromShape(r.shape),o=n.data.get(r.dataId).values,u=E.getTypedArrayFromDType("float32",i);for(let d=0;d<o.length;d++)u[d]=o[d]<0?s*o[d]:o[d];return n.makeTensorInfo(r.shape,"float32",u)}var roe={kernelName:Nc,backendName:"cpu",kernelFunc:PL},soe=On((e,t)=>e<0?t*e:e);function UL(e){let{inputs:t,backend:n}=e,{x:a,alpha:r}=t;Ue([a,r],"prelu");let s=n.data.get(a.dataId).values,i=n.data.get(r.dataId).values,[o,u]=soe(a.shape,r.shape,s,i,"float32");return n.makeTensorInfo(u,"float32",o)}var ioe={kernelName:Uc,backendName:"cpu",kernelFunc:UL},jL=Vt(Vc,e=>Math.max(0,e)),ooe={kernelName:Vc,backendName:"cpu",kernelFunc:jL},WL=Vt(qc,e=>Math.min(Math.max(0,e),6)),loe={kernelName:qc,backendName:"cpu",kernelFunc:WL};function Wv(e,t,n,a,r){if(n==="linear")return fi({inputs:{x:t},backend:e});if(n==="relu")return jL({inputs:{x:t},backend:e});if(n==="elu")return BL({inputs:{x:t},backend:e});if(n==="relu6")return WL({inputs:{x:t},backend:e});if(n==="prelu")return UL({inputs:{x:t,alpha:a},backend:e});if(n==="leakyrelu")return PL({inputs:{x:t},backend:e,attrs:{alpha:r}});if(n==="sigmoid")return CL({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function cn(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{shape:s}=a,i=E.sizeFromShape(r.shape),o=E.inferFromImplicitShape(s,i),u=E.sizeFromShape(o);E.assert(i===u,()=>`The new shape (${o}) has ${u} elements and the old shape (${r.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),n.incRef(r.dataId);let d=n.data.get(r.dataId);if(d.complexTensorInfos!=null){let c=d.complexTensorInfos.real,p=d.complexTensorInfos.imag;c.shape=o,p.shape=o}return{dataId:r.dataId,shape:o,dtype:r.dtype}}var uoe={kernelName:Bp,backendName:"cpu",kernelFunc:cn};function VL(e){let{inputs:t,backend:n,attrs:a}=e,{a:r,b:s}=t,{transposeA:i,transposeB:o}=a;Ue([r,s],"matMul");let u=r.shape.length,d=s.shape.length,c=i?r.shape[u-2]:r.shape[u-1],p=o?s.shape[d-1]:s.shape[d-2],m=i?r.shape[u-1]:r.shape[u-2],g=o?s.shape[d-2]:s.shape[d-1],b=r.shape.slice(0,-2),v=s.shape.slice(0,-2),x=E.sizeFromShape(b),w=E.sizeFromShape(v),k=af.assertAndGetBroadcastShape(r.shape.slice(0,-2),s.shape.slice(0,-2)).concat([m,g]);E.assert(c===p,()=>`Error in matMul: inner shapes (${c}) and (${p}) of Tensors with shapes ${r.shape} and ${s.shape} and transposeA=${i} and transposeB=${o} must match.`);let N=i?[x,c,m]:[x,m,c],I=o?[w,g,p]:[w,p,g],T=cn({inputs:{x:r},backend:n,attrs:{shape:N}}),$=cn({inputs:{x:s},backend:n,attrs:{shape:I}}),D=i?T.shape[1]:T.shape[2],M=i?T.shape[2]:T.shape[1],B=o?$.shape[1]:$.shape[2],V=Math.max(x,w),W=n.data.get(T.dataId).values,R=n.data.get($.dataId).values,H=E.computeStrides(T.shape),Z=E.computeStrides($.shape),[ae,j,K]=i?[H[0],1,H[1]]:[H[0],H[1],1],[Q,ce,me]=o?[1,Z[1],Z[0]]:[Z[1],1,Z[0]],L=M*B,ee=mt([V,M,B],T.dtype),ie=ee.values,de=n.blockSize;for(let we=0;we<V;we++){let Ie=we%x,Ee=we%w;for(let Ce=0;Ce<M;Ce+=de){let ze=Math.min(Ce+de,M);for(let Ke=0;Ke<B;Ke+=de){let at=Math.min(Ke+de,B);for(let lt=0;lt<D;lt+=de){let Dt=Math.min(lt+de,D);for(let ut=Ce;ut<ze;ut++)for(let xt=Ke;xt<at;xt++){let tt=0;for(let At=lt;At<Dt;At++){let Bt=W[Ie*ae+ut*j+At*K],ya=R[At*Q+xt*ce+Ee*me];tt+=Bt*ya}ie[we*L+(ut*B+xt)]+=tt}}}}}return n.disposeIntermediateTensorInfo(T),n.disposeIntermediateTensorInfo($),n.makeTensorInfo(k,ee.dtype,ee.values)}var coe={kernelName:tc,backendName:"cpu",kernelFunc:VL};function doe(e){let{inputs:t,backend:n,attrs:a}=e,{a:r,b:s,bias:i,preluActivationWeights:o}=t,{transposeA:u,transposeB:d,activation:c,leakyreluAlpha:p}=a,m,g,b,v=[];m=VL({inputs:{a:r,b:s},attrs:{transposeA:u,transposeB:d},backend:n}),i&&(g=Kh({inputs:{a:m,b:i},backend:n}),v.push(m),m=g),c&&(b=Wv(n,m,c,o,p),v.push(m),m=b);for(let x of v)n.disposeIntermediateTensorInfo(x);return m}var hoe={kernelName:Nu,backendName:"cpu",kernelFunc:doe},poe=Vt(Gu,e=>Math.acos(e)),foe={kernelName:Gu,backendName:"cpu",kernelFunc:poe},moe=Vt(qu,e=>Math.acosh(e)),goe={kernelName:qu,backendName:"cpu",kernelFunc:moe};function yoe(e){let{inputs:t,backend:n}=e,a=t;Ue(t,"addN");let r=a.map(o=>n.data.get(o.dataId).values),s=mt(a[0].shape,a[0].dtype),i=s.values;for(let o=0;o<a.length;o++){let u=r[o];for(let d=0;d<i.length;d++)i[d]+=u[d]}return n.makeTensorInfo(s.shape,s.dtype,s.values)}var boe={kernelName:Ku,backendName:"cpu",kernelFunc:yoe};function voe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a;Ue(r,"all");let o=E.parseAxisParam(s,r.shape),u=o,d=O.getAxesPermutation(u,r.shape.length),c=r;d!=null&&(c=hr({inputs:{x:r},backend:n,attrs:{perm:d}}),u=O.getInnerMostAxes(u.length,r.shape.length)),O.assertAxesAreInnerMostDims("all",u,c.shape.length);let[p,m]=O.computeOutAndReduceShapes(c.shape,u),g=E.sizeFromShape(m),b=E.makeZerosTypedArray(E.sizeFromShape(p),c.dtype),v=n.data.get(c.dataId).values;for(let w=0;w<b.length;++w){let k=w*g,N=v[k];for(let I=0;I<g;++I){let T=v[k+I];N=N&&T}b[w]=N}d!=null&&n.disposeIntermediateTensorInfo(c);let x=n.makeTensorInfo(p,c.dtype,b);if(i){let w=O.expandShapeToKeepDim(p,o),k=cn({inputs:{x},backend:n,attrs:{shape:w}});return n.disposeIntermediateTensorInfo(x),k}return x}var xoe={kernelName:np,backendName:"cpu",kernelFunc:voe};function woe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a;Ue(r,"any");let o=E.parseAxisParam(s,r.shape),u=o,d=O.getAxesPermutation(u,r.shape.length),c=r;d!=null&&(c=hr({inputs:{x:r},backend:n,attrs:{perm:d}}),u=O.getInnerMostAxes(u.length,r.shape.length)),O.assertAxesAreInnerMostDims("any",u,c.shape.length);let[p,m]=O.computeOutAndReduceShapes(c.shape,u),g=E.sizeFromShape(m),b=E.makeZerosTypedArray(E.sizeFromShape(p),c.dtype),v=n.data.get(c.dataId).values;for(let w=0;w<b.length;++w){let k=w*g,N=v[k];for(let I=0;I<g;++I){let T=v[k+I];N=N||T}b[w]=N}d!=null&&n.disposeIntermediateTensorInfo(c);let x=n.makeTensorInfo(p,c.dtype,b);if(i){let w=O.expandShapeToKeepDim(p,o),k=cn({inputs:{x},backend:n,attrs:{shape:w}});return n.disposeIntermediateTensorInfo(x),k}return x}var Soe={kernelName:ap,backendName:"cpu",kernelFunc:woe};function koe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s}=a;Ue(r,"argMax");let i=E.parseAxisParam(s,r.shape),o=O.getAxesPermutation(i,r.shape.length),u=r,d=[];o!=null&&(u=hr({inputs:{x:r},backend:n,attrs:{perm:o}}),d.push(u),i=O.getInnerMostAxes(i.length,u.shape.length)),i=[i[0]],O.assertAxesAreInnerMostDims("argMax",i,u.shape.length);let[c,p]=O.computeOutAndReduceShapes(u.shape,i),m=E.sizeFromShape(c),g=E.makeZerosTypedArray(m,"int32"),b=E.sizeFromShape(p),v=n.data.get(u.dataId).values;for(let x=0;x<g.length;++x){let w=x*b,k=v[w],N=0;for(let I=0;I<b;++I){let T=v[w+I];T>k&&(k=T,N=I)}g[x]=N}return d.forEach(x=>n.disposeIntermediateTensorInfo(x)),n.makeTensorInfo(c,"int32",g)}var _oe={kernelName:rp,backendName:"cpu",kernelFunc:koe};function Noe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s}=a;Ue(r,"argMin");let i=E.parseAxisParam(s,r.shape),o=O.getAxesPermutation(i,r.shape.length),u=r,d=[];o!=null&&(u=hr({inputs:{x:r},backend:n,attrs:{perm:o}}),d.push(u),i=O.getInnerMostAxes(i.length,u.shape.length)),i=[i[0]],O.assertAxesAreInnerMostDims("argMin",i,u.shape.length);let[c,p]=O.computeOutAndReduceShapes(u.shape,i),m=E.sizeFromShape(c),g=E.makeZerosTypedArray(m,"int32"),b=E.sizeFromShape(p),v=n.data.get(u.dataId).values;for(let x=0;x<g.length;++x){let w=x*b,k=v[w],N=0;for(let I=0;I<b;++I){let T=v[w+I];T<k&&(k=T,N=I)}g[x]=N}return d.forEach(x=>n.disposeIntermediateTensorInfo(x)),n.makeTensorInfo(c,"int32",g)}var Ioe={kernelName:sp,backendName:"cpu",kernelFunc:Noe},Toe=Vt(Xu,e=>Math.asin(e)),Eoe={kernelName:Xu,backendName:"cpu",kernelFunc:Toe},Coe=Vt(Yu,e=>Math.asinh(e)),Aoe={kernelName:Yu,backendName:"cpu",kernelFunc:Coe},$oe=Vt(Ju,e=>Math.atan(e)),Roe={kernelName:Ju,backendName:"cpu",kernelFunc:$oe},Doe=On((e,t)=>Math.atan2(e,t)),Ooe=aa(Qu,Doe),Moe={kernelName:Qu,backendName:"cpu",kernelFunc:Ooe},Foe=Vt(Zu,e=>Math.atanh(e)),zoe={kernelName:Zu,backendName:"cpu",kernelFunc:Foe};function kI(e,t,n,a,r,s){let i=r.strideHeight,o=r.strideWidth,u=r.dilationHeight,d=r.dilationWidth,c=r.effectiveFilterHeight,p=r.effectiveFilterWidth,m=r.padInfo.top,g=r.padInfo.left,b=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,v=mt(r.outShape,n),x=v.values,w=r.outShape[1]*r.outShape[2]*r.outShape[3],k=r.outShape[2]*r.outShape[3],N=r.outShape[3];for(let I=0;I<r.batchSize;++I){let T=I*w,$=I*a[0];for(let D=0;D<r.inChannels;++D)for(let M=0;M<r.outHeight;++M){let B=M*i-m,V=Math.max(0,B),W=Math.min(r.inHeight,c+B),R=T+M*k;for(let H=0;H<r.outWidth;++H){let Z=H*o-g,ae=Math.max(0,Z),j=Math.min(r.inWidth,p+Z),K=b,Q=0,ce=0;for(let L=V;L<W;L+=u){let ee=$+L*a[1];for(let ie=ae;ie<j;ie+=d){let de=ee+ie*a[2],we=e[de+D];s==="max"&&we>K?K=we:s==="avg"&&(Q+=we,ce++)}if(isNaN(K))break}let me=R+H*N+D;x[me]=s==="avg"?Q/ce:K}}}return v}function HL(e,t,n,a,r=!1,s=!1){let i=mt(a.outShape,"int32"),o=a.strideHeight,u=a.strideWidth,d=a.dilationHeight,c=a.dilationWidth,p=a.effectiveFilterHeight,m=a.effectiveFilterWidth,g=a.padInfo.top,b=a.padInfo.left,v=mt(t,n,e);for(let x=0;x<a.batchSize;++x)for(let w=0;w<a.inChannels;++w)for(let k=0;k<a.outHeight;++k){let N=k*o-g,I=N;for(;I<0;)I+=d;let T=Math.min(a.inHeight,p+N);for(let $=0;$<a.outWidth;++$){let D=$*u-b,M=D;for(;M<0;)M+=c;let B=Math.min(a.inWidth,m+D),V=Number.NEGATIVE_INFINITY,W=-1;for(let R=I;R<T;R+=d){let H=R-N;for(let Z=M;Z<B;Z+=c){let ae=Z-D,j=v.get(x,R,Z,w);j>V&&(V=j,r?W=s?((x*a.inHeight+R)*a.inWidth+Z)*a.inChannels+w:(R*a.inWidth+Z)*a.inChannels+w:W=H*m+ae)}}i.set(W,x,k,$,w)}}return i}function GL(e,t,n,a,r,s){let i=r.strideDepth,o=r.strideHeight,u=r.strideWidth,d=r.dilationDepth,c=r.dilationHeight,p=r.dilationWidth,m=r.effectiveFilterDepth,g=r.effectiveFilterHeight,b=r.effectiveFilterWidth,v=r.padInfo.front,x=r.padInfo.top,w=r.padInfo.left,k=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,N=mt(r.outShape,n),I=N.values,T=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],$=r.outShape[2]*r.outShape[3]*r.outShape[4],D=r.outShape[3]*r.outShape[4],M=r.outShape[4];for(let B=0;B<r.batchSize;++B){let V=B*T,W=B*a[0];for(let R=0;R<r.inChannels;++R)for(let H=0;H<r.outDepth;++H){let Z=H*i-v,ae=Z;for(;ae<0;)ae+=d;let j=Math.min(r.inDepth,m+Z),K=V+H*$;for(let Q=0;Q<r.outHeight;++Q){let ce=Q*o-x,me=ce;for(;me<0;)me+=c;let L=Math.min(r.inHeight,g+ce),ee=K+Q*D;for(let ie=0;ie<r.outWidth;++ie){let de=ie*u-w,we=de;for(;we<0;)we+=p;let Ie=Math.min(r.inWidth,b+de),Ee=ee+ie*M,Ce=k,ze=0,Ke=0;for(let lt=ae;lt<j;lt+=d){let Dt=W+lt*a[1];for(let ut=me;ut<L;ut+=c){let xt=Dt+ut*a[2];for(let tt=we;tt<Ie;tt+=p){let At=xt+tt*a[3],Bt=e[At+R];if(s==="max"&&Bt>Ce?Ce=Bt:s==="avg"&&(ze+=Bt,Ke++),isNaN(Ce))break}if(isNaN(Ce))break}if(isNaN(Ce))break}let at=Ee+R;I[at]=s==="avg"?ze/Math.max(Ke,1):Ce}}}}return N}function Loe(e,t){let n=mt(t.outShape,"int32"),a=t.strideDepth,r=t.strideHeight,s=t.strideWidth,i=t.dilationDepth,o=t.dilationHeight,u=t.dilationWidth,d=t.effectiveFilterDepth,c=t.effectiveFilterHeight,p=t.effectiveFilterWidth,m=t.padInfo.front,g=t.padInfo.top,b=t.padInfo.left;for(let v=0;v<t.batchSize;++v)for(let x=0;x<t.inChannels;++x)for(let w=0;w<t.outDepth;++w){let k=w*a-m,N=k;for(;N<0;)N+=i;let I=Math.min(t.inDepth,d+k);for(let T=0;T<t.outHeight;++T){let $=T*r-g,D=$;for(;D<0;)D+=o;let M=Math.min(t.inHeight,c+$);for(let B=0;B<t.outWidth;++B){let V=B*s-b,W=V;for(;W<0;)W+=u;let R=Math.min(t.inWidth,p+V),H=Number.NEGATIVE_INFINITY,Z=-1;for(let ae=N;ae<I;ae+=i){let j=ae-k;for(let K=D;K<M;K+=o){let Q=K-$;for(let ce=W;ce<R;ce+=u){let me=ce-V,L=e.get(v,ae,K,ce,x);L>=H&&(H=L,Z=j*c*p+Q*c+me)}}}n.set(Z,v,w,T,B,x)}}}return n}function Boe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t;Ue(r,"avgPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:u}=a,d=1;E.assert(O.eitherStridesOrDilationsAreOne(i,d),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${d}'`);let c=O.computePool2DInfo(r.shape,s,i,d,o,u),p;if(c.filterWidth===1&&c.filterHeight===1&&E.arraysEqual(c.inShape,c.outShape))p=fi({inputs:{x:r},backend:n});else{let m=n.data.get(r.dataId).values,g=E.computeStrides(r.shape),b=kI(m,r.shape,r.dtype,g,c,"avg");p=n.makeTensorInfo(c.outShape,r.dtype,b.values)}return p}var Poe={kernelName:ec,backendName:"cpu",kernelFunc:Boe};function Uoe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:u,dataFormat:d}=a;Ue(r,"avgPool3d");let c=O.computePool3DInfo(r.shape,s,i,1,o,u,d),p=n.data.get(r.dataId).values,m=GL(p,r.shape,r.dtype,E.computeStrides(r.shape),c,"avg");return n.makeTensorInfo(m.shape,"float32",m.values)}var joe={kernelName:ip,backendName:"cpu",kernelFunc:Uoe};function Woe(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,{filterSize:i,strides:o,pad:u,dimRoundingMode:d}=a;Ue([r,s],"avgPool3DGrad");let c=O.computePool3DInfo(s.shape,i,o,1,u,d),p=c.strideDepth,m=c.strideHeight,g=c.strideWidth,b=c.filterDepth,v=c.filterHeight,x=c.filterWidth,w=c.dilationDepth,k=c.dilationHeight,N=c.dilationWidth,I=c.effectiveFilterDepth,T=c.effectiveFilterHeight,$=c.effectiveFilterWidth,D=I-1-c.padInfo.front,M=$-1-c.padInfo.left,B=T-1-c.padInfo.top,V=mt(s.shape,"float32"),W=1/(b*v*x),R=n.bufferSync(r);for(let H=0;H<c.batchSize;++H)for(let Z=0;Z<c.inChannels;++Z)for(let ae=0;ae<c.inDepth;++ae)for(let j=0;j<c.inHeight;++j)for(let K=0;K<c.inWidth;++K){let Q=ae-D,ce=j-B,me=K-M,L=0;for(let ee=0;ee<I;ee+=w){let ie=(Q+ee)/p;if(!(ie<0||ie>=c.outDepth||Math.floor(ie)!==ie))for(let de=0;de<T;de+=k){let we=(ce+de)/m;if(!(we<0||we>=c.outHeight||Math.floor(we)!==we))for(let Ie=0;Ie<$;Ie+=N){let Ee=(me+Ie)/g;if(Ee<0||Ee>=c.outWidth||Math.floor(Ee)!==Ee)continue;let Ce=R.get(H,ie,we,Ee,Z);L+=Ce}}}V.set(L*W,H,ae,j,K,Z)}return n.makeTensorInfo(V.shape,V.dtype,V.values)}var Voe={kernelName:Tg,backendName:"cpu",kernelFunc:Woe};function Hoe(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,i=s;Ue([r,s],"avgPoolGrad");let{filterSize:o,strides:u,pad:d}=a,c=O.computePool2DInfo(i.shape,o,u,1,d),p=c.strideHeight,m=c.strideWidth,g=c.filterHeight,b=c.filterWidth,v=c.dilationHeight,x=c.dilationWidth,w=c.effectiveFilterHeight,k=c.effectiveFilterWidth,N=k-1-c.padInfo.left,I=w-1-c.padInfo.top,T=mt(i.shape,"float32"),$=1/(g*b),D=n.data.get(r.dataId).values,M=mt(r.shape,"float32",D);for(let B=0;B<c.batchSize;++B)for(let V=0;V<c.inChannels;++V)for(let W=0;W<c.inHeight;++W)for(let R=0;R<c.inWidth;++R){let H=W-I,Z=R-N,ae=0;for(let j=0;j<w;j+=v){let K=(H+j)/p;if(!(K<0||K>=c.outHeight||Math.floor(K)!==K))for(let Q=0;Q<k;Q+=x){let ce=(Z+Q)/m;if(ce<0||ce>=c.outWidth||Math.floor(ce)!==ce)continue;let me=M.get(B,K,ce,V);ae+=me}}T.set(ae*$,B,W,R,V)}return n.makeTensorInfo(T.shape,T.dtype,T.values)}var Goe={kernelName:Ig,backendName:"cpu",kernelFunc:Hoe};function qoe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,scale:s,offset:i,mean:o,variance:u}=t;E.assert(o.shape.length===u.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),E.assert(i==null||o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),E.assert(s==null||o.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),Ue([r,o,u,s,i],"batchNorm");let{varianceEpsilon:d}=a;d==null&&(d=.001);let c=n.data.get(r.dataId).values,p=n.data.get(o.dataId).values,m=n.data.get(u.dataId).values,g=s?n.data.get(s.dataId).values:new Float32Array([1]),b=i?n.data.get(i.dataId).values:new Float32Array([0]),v=new Float32Array(c.length),x=b.length,w=g.length,k=m.length,N=p.length,I=0,T=0,$=0,D=0;for(let M=0;M<c.length;++M)v[M]=b[I++]+(c[M]-p[T++])*g[$++]/Math.sqrt(m[D++]+d),I>=x&&(I=0),T>=N&&(T=0),$>=w&&($=0),D>=k&&(D=0);return n.makeTensorInfo(r.shape,r.dtype,v)}var Koe={kernelName:vc,backendName:"cpu",kernelFunc:qoe};function Xoe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,crops:i}=a;Ue([r],"batchToSpaceND");let o=s.reduce((w,k)=>w*k),u=O.getReshaped(r.shape,s,o),d=O.getPermuted(u.length,s.length),c=O.getReshapedPermuted(r.shape,s,o),p=O.getSliceBeginCoords(i,s.length),m=O.getSliceSize(c,i,s.length),g=cn({inputs:{x:r},backend:n,attrs:{shape:u}}),b=hr({inputs:{x:g},backend:n,attrs:{perm:d}}),v=cn({inputs:{x:b},backend:n,attrs:{shape:c}}),x=Bu({inputs:{x:v},backend:n,attrs:{begin:p,size:m}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(v),x}var Yoe={kernelName:op,backendName:"cpu",kernelFunc:Xoe};function Joe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,weights:s}=t,{size:i}=a,o=n.data.get(r.dataId).values,u=n.data.get(s.dataId).values,d=hI(o,u,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,d)}var Zoe={kernelName:lp,backendName:"cpu",kernelFunc:Joe};function Qoe(e){let{inputs:t,backend:n}=e,{s0:a,s1:r}=t,s=n.data.get(a.dataId).values,i=n.data.get(r.dataId).values,o=O.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}var ele={kernelName:Eg,backendName:"cpu",kernelFunc:Qoe},tle=Vt(vl,(e,t)=>{let n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e}),nle={kernelName:vl,backendName:"cpu",kernelFunc:tle},ale=e=>{let{x:t}=e.inputs,n=e.backend,a=new Float32Array(E.sizeFromShape(t.shape)),r=n.data.get(t.dataId),s=r.complexTensorInfos.real,i=r.complexTensorInfos.imag,o=n.data.get(s.dataId).values,u=n.data.get(i.dataId).values;for(let d=0;d<o.length;d++){let c=o[d],p=u[d];a[d]=Math.hypot(c,p)}return n.makeOutput(a,t.shape,"float32")},rle={kernelName:Cg,backendName:"cpu",kernelFunc:ale};function Xh(e){let{inputs:t,backend:n}=e,{input:a}=t,r=n.data.get(a.dataId).complexTensorInfos.imag,s=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,s)}var sle={kernelName:g0,backendName:"cpu",kernelFunc:Xh};function Yh(e){let{inputs:t,backend:n,attrs:a}=e,{axis:r}=a,s=E.parseAxisParam(r,t[0].shape)[0],i=t.map(v=>v.shape);O.assertParamsConsistent(i,s);let o=O.computeOutShape(t.map(v=>v.shape),s);if(E.sizeFromShape(o)===0)return n.makeTensorInfo(o,t[0].dtype,[]);let u=t.filter(v=>E.sizeFromShape(v.shape)>0);if(u.length===1)return fi({inputs:{x:u[0]},backend:n});if(u[0].dtype==="complex64"){let v=u.map(I=>Lu({inputs:{input:I},backend:n})),x=u.map(I=>Xh({inputs:{input:I},backend:n})),w=Yh({inputs:v,backend:n,attrs:{axis:s}}),k=Yh({inputs:x,backend:n,attrs:{axis:s}}),N=Tr({inputs:{real:w,imag:k},backend:n});return v.forEach(I=>n.disposeIntermediateTensorInfo(I)),x.forEach(I=>n.disposeIntermediateTensorInfo(I)),n.disposeIntermediateTensorInfo(w),n.disposeIntermediateTensorInfo(k),N}let d=u.map(v=>{let x=[-1,E.sizeFromShape(v.shape.slice(s))];return cn({inputs:{x:v},backend:n,attrs:{shape:x}})}),c=d.map(v=>({vals:n.data.get(v.dataId).values,shape:v.shape}));o=O.computeOutShape(d.map(v=>v.shape),1);let p=d[0].shape[0]===1,m=pI(c,o,t[0].dtype,p),g=O.computeOutShape(u.map(v=>v.shape),s),b=n.makeTensorInfo(g,t[0].dtype,m);return d.forEach(v=>n.disposeIntermediateTensorInfo(v)),b}var ile={kernelName:cp,backendName:"cpu",kernelFunc:Yh};function qL(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dataFormat:u,dilations:d,dimRoundingMode:c}=a;Ue([r,s],"conv2d");let p=O.convertConv2DDataFormat(u),m=O.computeConv2DInfo(r.shape,s.shape,i,d,o,c,!1,p),g=m.filterHeight,b=m.filterWidth,v=m.dilationHeight,x=m.dilationWidth,w=m.padInfo.left,k=m.padInfo.top,N=m.dataFormat==="channelsLast",I=new Pn(m.outShape,r.dtype),T=E.computeStrides(r.shape),$=E.computeStrides(s.shape),D=T[0],M=N?T[1]:T[2],B=N?T[2]:1,V=N?1:T[1],W=I.strides[0],R=N?I.strides[1]:I.strides[2],H=N?I.strides[2]:1,Z=N?1:I.strides[1],ae=n.data.get(r.dataId).values,j=n.data.get(s.dataId).values,K=I.values;for(let Q=0;Q<m.batchSize;++Q){let ce=Q*D,me=Q*W;for(let L=0;L<m.outHeight;++L){let ee=me+L*R,ie=L*m.strideHeight-k;for(let de=0;de<g;++de){let we=ie+de*v;if(we<0||we>=m.inHeight)continue;let Ie=de*$[0],Ee=ce+we*M;for(let Ce=0;Ce<m.outWidth;++Ce){let ze=ee+Ce*H,Ke=Ce*m.strideWidth-w;for(let at=0;at<b;++at){let lt=Ke+at*x;if(lt<0||lt>=m.inWidth)continue;let Dt=Ie+at*$[1],ut=Ee+lt*B,xt=Dt;for(let tt=0;tt<m.inChannels;++tt){let At=ae[ut+tt*V];for(let Bt=0;Bt<m.outChannels;++Bt)K[ze+Bt*Z]+=At*j[xt+Bt];xt+=m.outChannels}}}}}}return n.makeTensorInfo(I.shape,I.dtype,K)}var ole={kernelName:rc,backendName:"cpu",kernelFunc:qL};function lle(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:i,pad:o,dataFormat:u,dimRoundingMode:d,filterShape:c}=a;Ue([r,s],"conv2dBackpropFilter");let p=O.convertConv2DDataFormat(u),m=O.computeConv2DInfo(r.shape,c,i,1,o,d,!1,p),{strideHeight:g,strideWidth:b,filterHeight:v,filterWidth:x}=m,w=m.dataFormat==="channelsLast",k=new Pn(m.filterShape,"float32"),N=m.padInfo.left,I=m.padInfo.top,T=n.data.get(r.dataId).values,$=n.data.get(s.dataId).values,D=new Pn(r.shape,r.dtype,T),M=new Pn(s.shape,s.dtype,$);for(let B=0;B<v;++B){let V=Math.max(0,Math.ceil((I-B)/g)),W=Math.min(m.outHeight,(m.inHeight+I-B)/g);for(let R=0;R<x;++R){let H=Math.max(0,Math.ceil((N-R)/b)),Z=Math.min(m.outWidth,(m.inWidth+N-R)/b);for(let ae=0;ae<m.inChannels;++ae)for(let j=0;j<m.outChannels;++j){let K=0;for(let Q=0;Q<m.batchSize;++Q)for(let ce=V;ce<W;++ce){let me=B+ce*g-I;for(let L=H;L<Z;++L){let ee=R+L*b-N;w?K+=D.get(Q,me,ee,ae)*M.get(Q,ce,L,j):K+=D.get(Q,ae,me,ee)*M.get(Q,j,ce,L)}}k.set(K,B,R,ae,j)}}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}var ule={kernelName:u0,backendName:"cpu",kernelFunc:lle};function cle(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{inputShape:i,strides:o,pad:u,dataFormat:d,dimRoundingMode:c}=a;Ue([r,s],"conv2dBackpropInput");let p=E.computeStrides(s.shape),m=E.computeStrides(r.shape),g=O.convertConv2DDataFormat(d),b=O.computeConv2DInfo(i,s.shape,o,1,u,c,!1,g),v=new Pn(b.inShape,"float32"),x=v.values,w=n.data.get(r.dataId).values,k=n.data.get(s.dataId).values,[N,I,T]=p,{batchSize:$,filterHeight:D,filterWidth:M,inChannels:B,inHeight:V,inWidth:W,outChannels:R,outHeight:H,outWidth:Z,strideHeight:ae,strideWidth:j}=b;g=b.dataFormat;let K=D-1-b.padInfo.top,Q=M-1-b.padInfo.left,ce=g==="channelsLast",me=v.strides[0],L=ce?v.strides[1]:v.strides[2],ee=ce?v.strides[2]:1,ie=ce?1:v.strides[1],de=m[0],we=ce?m[1]:m[2],Ie=ce?m[2]:1,Ee=ce?1:m[1];for(let Ce=0;Ce<$;++Ce)for(let ze=0;ze<B;++ze)for(let Ke=0;Ke<V;++Ke){let at=Ke-K,lt=Math.max(0,Math.ceil(at/ae)),Dt=Math.min(H,(D+at)/ae);for(let ut=0;ut<W;++ut){let xt=ut-Q,tt=Math.max(0,Math.ceil(xt/j)),At=Math.min(Z,(M+xt)/j),Bt=0;for(let rn=lt;rn<Dt;++rn){let ra=rn*ae-at;for(let Hn=tt;Hn<At;++Hn){let Ta=Hn*j-xt,dn=de*Ce+we*rn+Ie*Hn,Ua=N*(D-1-ra)+I*(M-1-Ta)+T*ze;for(let ba=0;ba<R;++ba){let Mn=w[dn+Ee*ba],va=k[Ua+ba];Bt+=Mn*va}}}let ya=me*Ce+L*Ke+ee*ut+ie*ze;x[ya]=Bt}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}var dle={kernelName:sc,backendName:"cpu",kernelFunc:cle};function hle(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dilations:u}=a;Ue([r,s],"conv3d");let d=O.computeConv3DInfo(r.shape,s.shape,i,u,o),{filterDepth:c,filterHeight:p,filterWidth:m,dilationDepth:g,dilationHeight:b,dilationWidth:v,padInfo:x}=d,w=x.front,k=x.left,N=x.top,I=new Pn(d.outShape,r.dtype),T=n.data.get(r.dataId).values,$=n.data.get(s.dataId).values,D=I.values,M=E.computeStrides(r.shape),B=E.computeStrides(s.shape);for(let V=0;V<d.batchSize;++V){let W=V*M[0],R=V*I.strides[0];for(let H=0;H<d.outDepth;++H){let Z=R+H*I.strides[1],ae=H*d.strideDepth-w;for(let j=0;j<c;++j){let K=ae+j*g;if(K<0||K>=d.inDepth)continue;let Q=j*B[0],ce=W+K*M[1];for(let me=0;me<d.outHeight;++me){let L=Z+me*I.strides[2],ee=me*d.strideHeight-N;for(let ie=0;ie<p;++ie){let de=ee+ie*b;if(de<0||de>=d.inHeight)continue;let we=Q+ie*B[1],Ie=ce+de*M[2];for(let Ee=0;Ee<d.outWidth;++Ee){let Ce=L+Ee*d.outChannels,ze=Ee*d.strideWidth-k;for(let Ke=0;Ke<m;++Ke){let at=ze+Ke*v;if(at<0||at>=d.inWidth)continue;let lt=we+Ke*B[2],Dt=Ie+at*d.inChannels,ut=lt;for(let xt=0;xt<d.inChannels;++xt){let tt=T[Dt+xt];for(let At=0;At<d.outChannels;++At)D[Ce+At]+=tt*$[ut+At];ut+=d.outChannels}}}}}}}}return n.makeTensorInfo(I.shape,I.dtype,I.values)}var ple={kernelName:ic,backendName:"cpu",kernelFunc:hle};function fle(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:i,pad:o,filterShape:u}=a;Ue([r,s],"conv3dBackpropFilterV2");let d=E.computeStrides(r.shape),c=E.computeStrides(s.shape),p=O.computeConv3DInfo(r.shape,u,i,1,o),m=p.strideDepth,g=p.strideHeight,b=p.strideWidth,v=p.filterDepth,x=p.filterHeight,w=p.filterWidth,k=new Pn(p.filterShape,"float32"),N=k.values,[I,T,$,D]=k.strides,M=n.data.get(s.dataId).values,[B,V,W,R]=c,H=n.data.get(r.dataId).values,[Z,ae,j,K]=d,Q=p.padInfo.front,ce=p.padInfo.left,me=p.padInfo.top;for(let L=0;L<v;++L){let ee=Math.max(0,Math.ceil((Q-L)/m)),ie=Math.min(p.outDepth,(p.inDepth+Q-L)/m),de=L*I;for(let we=0;we<x;++we){let Ie=Math.max(0,Math.ceil((me-we)/g)),Ee=Math.min(p.outHeight,(p.inHeight+me-we)/g),Ce=we*T+de;for(let ze=0;ze<w;++ze){let Ke=Math.max(0,Math.ceil((ce-ze)/b)),at=Math.min(p.outWidth,(p.inWidth+ce-ze)/b),lt=ze*$+Ce;for(let Dt=0;Dt<p.inChannels;++Dt){let ut=Dt*D+lt;for(let xt=0;xt<p.outChannels;++xt){let tt=0;for(let At=0;At<p.batchSize;++At){let Bt=At*Z,ya=At*B;for(let rn=ee;rn<ie;++rn){let ra=(L+rn*m-Q)*ae+Bt,Hn=rn*V+ya;for(let Ta=Ie;Ta<Ee;++Ta){let dn=(we+Ta*g-me)*j+ra,Ua=Ta*W+Hn;for(let ba=Ke;ba<at;++ba){let Mn=(ze+ba*b-ce)*K+dn,va=ba*R+Ua;tt+=H[Mn+Dt]*M[va+xt]}}}}N[ut+xt]=tt}}}}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}var mle={kernelName:dp,backendName:"cpu",kernelFunc:fle};function gle(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{pad:i,strides:o,inputShape:u}=a;Ue([r],"conv3dBackpropInputV2");let d=E.computeStrides(r.shape),c=E.computeStrides(s.shape),p=O.computeConv3DInfo(u,s.shape,o,1,i),m=new Pn(p.inShape,"float32"),g=m.values,[b,v,x,w]=m.strides,k=n.data.get(r.dataId).values,[N,I,T,$]=d,D=n.data.get(s.dataId).values,[M,B,V,W]=c,{batchSize:R,filterDepth:H,filterHeight:Z,filterWidth:ae,inChannels:j,inDepth:K,inHeight:Q,inWidth:ce,outChannels:me,outDepth:L,outHeight:ee,outWidth:ie,strideDepth:de,strideHeight:we,strideWidth:Ie}=p,Ee=H-1-p.padInfo.front,Ce=Z-1-p.padInfo.top,ze=ae-1-p.padInfo.left;for(let Ke=0;Ke<R;++Ke)for(let at=0;at<j;++at)for(let lt=0;lt<K;++lt){let Dt=lt-Ee,ut=Math.max(0,Math.ceil(Dt/de)),xt=Math.min(L,(H+Dt)/de);for(let tt=0;tt<Q;++tt){let At=tt-Ce,Bt=Math.max(0,Math.ceil(At/we)),ya=Math.min(ee,(Z+At)/we);for(let rn=0;rn<ce;++rn){let ra=rn-ze,Hn=Math.max(0,Math.ceil(ra/Ie)),Ta=Math.min(ie,(ae+ra)/Ie),dn=0;for(let Ua=ut;Ua<xt;++Ua){let ba=Ua*de-Dt;for(let Mn=Bt;Mn<ya;++Mn){let va=Mn*we-At;for(let Gs=Hn;Gs<Ta;++Gs){let oo=Gs*Ie-ra,_s=N*Ke+I*Ua+T*Mn+$*Gs,Ol=M*(H-1-ba)+B*(Z-1-va)+V*(ae-1-oo)+W*at;for(let ja=0;ja<me;++ja){let In=k[_s+ja],sn=D[Ol+ja];dn+=In*sn}}}}g[b*Ke+v*lt+x*tt+w*rn+at]=dn}}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}var yle={kernelName:hp,backendName:"cpu",kernelFunc:gle},ble=Vt(oc,e=>Math.cos(e)),vle={kernelName:oc,backendName:"cpu",kernelFunc:ble},xle=Vt(lc,e=>Math.cosh(e)),wle={kernelName:lc,backendName:"cpu",kernelFunc:xle};function Sle(e){let{inputs:t,backend:n,attrs:a}=e,{image:r,boxes:s,boxInd:i}=t,{cropSize:o,method:u,extrapolationValue:d}=a,[c,p,m,g]=r.shape,b=s.shape[0],[v,x]=o,w=mt([b,v,x,g],"float32"),k=n.data.get(s.dataId).values,N=n.data.get(i.dataId).values,I=n.data.get(r.dataId).values,T=E.computeStrides(r.shape),$=E.computeStrides(w.shape);for(let D=0;D<b;D++){let M=D*4,B=k[M],V=k[M+1],W=k[M+2],R=k[M+3],H=N[D];if(H>=c)continue;let Z=v>1?(W-B)*(p-1)/(v-1):0,ae=x>1?(R-V)*(m-1)/(x-1):0;for(let j=0;j<v;j++){let K=v>1?B*(p-1)+j*Z:.5*(B+W)*(p-1);if(K<0||K>p-1){for(let Q=0;Q<x;Q++)for(let ce=0;ce<g;ce++){let me=ce+Q*$[2]+j*$[1]+D*$[0];w.values[me]=d}continue}if(u==="bilinear"){let Q=Math.floor(K),ce=Math.ceil(K),me=K-Q;for(let L=0;L<x;L++){let ee=x>1?V*(m-1)+L*ae:.5*(V+R)*(m-1);if(ee<0||ee>m-1){for(let Ie=0;Ie<g;Ie++){let Ee=Ie+L*$[2]+j*$[1]+D*$[0];w.values[Ee]=d}continue}let ie=Math.floor(ee),de=Math.ceil(ee),we=ee-ie;for(let Ie=0;Ie<g;Ie++){let Ee=Ie+ie*T[2]+Q*T[1]+H*T[0],Ce=I[Ee];Ee=Ie+de*T[2]+Q*T[1]+H*T[0];let ze=I[Ee];Ee=Ie+ie*T[2]+ce*T[1]+H*T[0];let Ke=I[Ee];Ee=Ie+de*T[2]+ce*T[1]+H*T[0];let at=I[Ee],lt=Ce+(ze-Ce)*we,Dt=Ke+(at-Ke)*we;Ee=Ie+L*$[2]+j*$[1]+D*$[0],w.values[Ee]=lt+(Dt-lt)*me}}}else for(let Q=0;Q<x;++Q){let ce=x>1?V*(m-1)+Q*ae:.5*(V+R)*(m-1);if(ce<0||ce>m-1){for(let ee=0;ee<g;ee++){let ie=ee+Q*$[2]+j*$[1]+D*$[0];w.values[ie]=d}continue}let me=Math.round(ce),L=Math.round(K);for(let ee=0;ee<g;ee++){let ie=ee+me*T[2]+L*T[1]+H*T[0],de=ee+Q*$[2]+j*$[1]+D*$[0];w.values[de]=I[ie]}}}}return n.makeTensorInfo(w.shape,w.dtype,w.values)}var kle={kernelName:fp,backendName:"cpu",kernelFunc:Sle};function _le(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,exclusive:i,reverse:o}=a;Ue(r,"cumprod");let u=O.getAxesPermutation([s],r.shape.length),d=r;u!=null&&(d=hr({inputs:{x:r},backend:n,attrs:{perm:u}}));let c=O.getInnerMostAxes(1,r.shape.length)[0];if(c!==d.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${d.shape.length-1} but got axis=${c}`);let p=Jr(d.dtype,"int32"),m=E.makeOnesTypedArray(E.sizeFromShape(d.shape),p),g=n.data.get(d.dataId).values,b=d.shape[d.shape.length-1],v=o?(w,k)=>w+b-k-1:(w,k)=>w+k;for(let w=0;w<g.length;w+=b)for(let k=0;k<b;k++){let N=v(w,k);if(k===0)m[N]=i?1:g[N];else{let I=v(w,k-1);m[N]=i?g[I]*m[I]:g[N]*m[I]}}let x=n.makeTensorInfo(d.shape,p,m);if(u!=null){let w=O.getUndoAxesPermutation(u),k=hr({inputs:{x},backend:n,attrs:{perm:w}});return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(d),k}return x}var Nle={kernelName:pp,backendName:"cpu",kernelFunc:_le};function Ile(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,exclusive:i,reverse:o}=a;Ue(r,"cumsum");let u=O.getAxesPermutation([s],r.shape.length),d=r;u!=null&&(d=hr({inputs:{x:r},backend:n,attrs:{perm:u}}));let c=O.getInnerMostAxes(1,r.shape.length)[0];if(c!==d.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${d.shape.length-1} but got axis=${c}`);let p=Jr(d.dtype,"int32"),m=E.makeZerosTypedArray(E.sizeFromShape(d.shape),p),g=n.data.get(d.dataId).values,b=d.shape[d.shape.length-1],v=o?(w,k)=>w+b-k-1:(w,k)=>w+k;for(let w=0;w<g.length;w+=b)for(let k=0;k<b;k++){let N=v(w,k);if(k===0)m[N]=i?0:g[N];else{let I=v(w,k-1);m[N]=i?g[I]+m[I]:g[N]+m[I]}}let x=n.makeTensorInfo(d.shape,p,m);if(u!=null){let w=O.getUndoAxesPermutation(u),k=hr({inputs:{x},backend:n,attrs:{perm:w}});return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(d),k}return x}var Tle={kernelName:uc,backendName:"cpu",kernelFunc:Ile};function Ele(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,weights:s}=t,{size:i,binaryOutput:o}=a;if(r.shape.length===1){let u=n.data.get(r.dataId).values,d=n.data.get(s.dataId).values,c=hI(u,d,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,c)}else if(r.shape.length===2){let u=n.bufferSync(r),d=n.bufferSync(s),c=tL(u,d,i,o);return n.makeTensorInfo(c.shape,s.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}var Cle={kernelName:Ag,backendName:"cpu",kernelFunc:Ele};function Ale(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockSize:s,dataFormat:i}=a;E.assert(i==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`);let o=r.shape[0],u=r.shape[1],d=r.shape[2],c=r.shape[3],p=u*s,m=d*s,g=c/(s*s),b=n.data.get(r.dataId).values,v=new Float32Array(o*p*m*g),x=0;for(let w=0;w<o;++w)for(let k=0;k<p;++k){let N=Math.floor(k/s),I=k%s;for(let T=0;T<m;++T){let $=Math.floor(T/s),D=T%s,M=(I*s+D)*g;for(let B=0;B<g;++B){let V=B+M+c*($+d*(N+u*w));v[x++]=b[V]}}}return n.makeTensorInfo([o,p,m,g],r.dtype,v)}var $le={kernelName:mp,backendName:"cpu",kernelFunc:Ale};function KL(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dilations:u,dimRoundingMode:d}=a;Ue([r,s],"depthwiseConv2DNative");let c=E.computeStrides(r.shape),p=E.computeStrides(s.shape),m=u;m==null&&(m=[1,1]),E.assert(O.eitherStridesOrDilationsAreOne(i,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${m}'`);let g=O.computeConv2DInfo(r.shape,s.shape,i,m,o,d,!0),{filterHeight:b,filterWidth:v,dilationHeight:x,dilationWidth:w,padInfo:k}=g,N=k.left,I=k.top,T=g.outChannels/g.inChannels,$=new Pn(g.outShape,r.dtype),D=n.data.get(r.dataId).values,M=n.data.get(s.dataId).values,B=$.values;for(let V=0;V<g.batchSize;++V){let W=V*c[0],R=V*$.strides[0];for(let H=0;H<g.outHeight;++H){let Z=R+H*$.strides[1],ae=H*g.strideHeight-I;for(let j=0;j<b;++j){let K=ae+j*x;if(K<0||K>=g.inHeight)continue;let Q=j*p[0],ce=W+K*c[1];for(let me=0;me<g.outWidth;++me){let L=Z+me*$.strides[2],ee=me*g.strideWidth-N;for(let ie=0;ie<v;++ie){let de=ee+ie*w;if(de<0||de>=g.inWidth)continue;let we=Q+ie*p[1],Ie=ce+de*g.inChannels,Ee=L,Ce=we;for(let ze=0;ze<g.inChannels;++ze){let Ke=D[Ie+ze];for(let at=0;at<T;++at)B[Ee+at]+=Ke*M[Ce+at];Ee+=T,Ce+=T}}}}}}return n.makeTensorInfo($.shape,$.dtype,$.values)}var Rle={kernelName:cc,backendName:"cpu",kernelFunc:KL};function Dle(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:i,dilations:o,pad:u,dimRoundingMode:d,filterShape:c}=a;Ue([r,s],"depthwiseConv2dNativeBackpropFilter");let p=O.computeConv2DInfo(r.shape,c,i,o,u,d,!0),{strideHeight:m,strideWidth:g,filterHeight:b,filterWidth:v}=p,x=new Pn(p.filterShape,"float32"),w=p.padInfo.left,k=p.padInfo.top,N=p.outChannels/p.inChannels,I=n.data.get(r.dataId).values,T=new Pn(r.shape,r.dtype,I),$=n.data.get(s.dataId).values,D=new Pn(s.shape,s.dtype,$);for(let M=0;M<b;++M){let B=Math.max(0,Math.ceil((k-M)/m)),V=Math.min(p.outHeight,(p.inHeight+k-M)/m);for(let W=0;W<v;++W){let R=Math.max(0,Math.ceil((w-W)/g)),H=Math.min(p.outWidth,(p.inWidth+w-W)/g);for(let Z=0;Z<p.outChannels;++Z){let ae=Math.trunc(Z/N),j=Z%N,K=0;for(let Q=0;Q<p.batchSize;++Q)for(let ce=B;ce<V;++ce){let me=M+ce*m-k;for(let L=R;L<H;++L){let ee=W+L*g-w;K+=T.get(Q,me,ee,ae)*D.get(Q,ce,L,Z)}}x.set(K,M,W,ae,j)}}}return n.makeTensorInfo(x.shape,x.dtype,x.values)}var Ole={kernelName:c0,backendName:"cpu",kernelFunc:Dle};function Mle(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{strides:i,dilations:o,pad:u,dimRoundingMode:d,inputShape:c}=a;Ue([r,s],"depthwiseConv2DNativeBackpropInput");let p=E.computeStrides(r.shape),m=E.computeStrides(s.shape),g=O.computeConv2DInfo(c,s.shape,i,o,u,d,!0),b=new Pn(g.inShape,"float32"),v=b.values,[x,w,k]=b.strides,N=n.data.get(r.dataId).values,[I,T,$]=p,D=n.data.get(s.dataId).values,[M,B,V]=m,{batchSize:W,filterHeight:R,filterWidth:H,inChannels:Z,inHeight:ae,inWidth:j,outChannels:K,outHeight:Q,outWidth:ce,strideHeight:me,strideWidth:L}=g,ee=R-1-g.padInfo.top,ie=H-1-g.padInfo.left,de=K/Z;for(let we=0;we<W;++we)for(let Ie=0;Ie<Z;++Ie)for(let Ee=0;Ee<ae;++Ee){let Ce=Ee-ee,ze=Math.max(0,Math.ceil(Ce/me)),Ke=Math.min(Q,(R+Ce)/me);for(let at=0;at<j;++at){let lt=at-ie,Dt=Math.max(0,Math.ceil(lt/L)),ut=Math.min(ce,(H+lt)/L),xt=0;for(let tt=ze;tt<Ke;++tt){let At=tt*me-Ce;for(let Bt=Dt;Bt<ut;++Bt){let ya=Bt*L-lt,rn=I*we+T*tt+$*Bt,ra=M*(R-1-At)+B*(H-1-ya)+V*Ie;for(let Hn=0;Hn<de;++Hn){let Ta=Ie*de+Hn,dn=N[rn+Ta],Ua=D[ra+Hn];xt+=dn*Ua}}}v[x*we+w*Ee+k*at+Ie]=xt}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}var Fle={kernelName:d0,backendName:"cpu",kernelFunc:Mle};function zle(e){let{inputs:t,backend:n}=e,{x:a}=t,r=E.sizeFromShape(a.shape),s=n.data.get(a.dataId).values,i=mt([r,r],a.dtype),o=i.values;for(let d=0;d<s.length;d++)o[d*r+d]=s[d];let u=[...a.shape,...a.shape];return n.makeTensorInfo(u,i.dtype,i.values)}var Lle={kernelName:$g,backendName:"cpu",kernelFunc:zle},Ble={kernelName:dc,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:a,filter:r}=e,{strides:s,pad:i,dilations:o}=n,u=t,d=u.data.get(a.dataId).values,c=a.shape.length,p=u.data.get(r.dataId).values,m=r.shape.length,{batchSize:g,inHeight:b,inWidth:v,inChannels:x,outHeight:w,outWidth:k,padInfo:N,strideHeight:I,strideWidth:T,filterHeight:$,filterWidth:D,dilationHeight:M,dilationWidth:B,outShape:V}=O.computeDilation2DInfo(a.shape,r.shape,s,i,"NHWC",o),W=E.sizeFromShape(V),R=V.length,H=E.getArrayFromDType(a.dtype,W);for(let Z=0;Z<g;++Z)for(let ae=0;ae<w;++ae){let j=ae*I-N.top;for(let K=0;K<k;++K){let Q=K*T-N.left;for(let ce=0;ce<x;++ce){let me=Number.MIN_SAFE_INTEGER;for(let ee=0;ee<$;++ee){let ie=j+ee*M;if(ie>=0&&ie<b)for(let de=0;de<D;++de){let we=Q+de*B;if(we>=0&&we<v){let Ie=E.locToIndex([Z,ie,we,ce],c,E.computeStrides(a.shape)),Ee=E.locToIndex([ee,de,ce],m,E.computeStrides(r.shape)),Ce=d[Ie]+p[Ee];Ce>me&&(me=Ce)}}}let L=E.locToIndex([Z,ae,K,ce],R,E.computeStrides(V));H[L]=me}}}return{dataId:u.write(E.toTypedArray(H,a.dtype),V,a.dtype),shape:V,dtype:a.dtype}}},Ple={kernelName:Fh,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:a,filter:r,dy:s}=e,{strides:i,pad:o,dilations:u}=n,d=t,c=E.toNestedArray(a.shape,d.data.get(a.dataId).values),p=E.toNestedArray(r.shape,d.data.get(r.dataId).values),{batchSize:m,inHeight:g,inWidth:b,inChannels:v,outHeight:x,outWidth:w,padInfo:k,strideHeight:N,strideWidth:I,filterHeight:T,filterWidth:$,dilationHeight:D,dilationWidth:M,outShape:B}=O.computeDilation2DInfo(a.shape,r.shape,i,o,"NHWC",u);E.assert(s.rank===B.length,()=>`Error in ${Fh}, dy must have the same rank as output ${B.length}, but got ${s.rank}`);let V=E.toNestedArray(B,d.data.get(s.dataId).values),W=E.makeZerosNestedTypedArray(r.shape,r.dtype);for(let R=0;R<m;++R)for(let H=0;H<x;++H){let Z=H*N-k.top;for(let ae=0;ae<w;++ae){let j=ae*I-k.left;for(let K=0;K<v;++K){let Q=Number.MIN_SAFE_INTEGER,ce=0,me=0;for(let L=0;L<T;++L){let ee=Z+L*D;if(ee>=0&&ee<g)for(let ie=0;ie<$;++ie){let de=j+ie*M;if(de>=0&&de<b){let we=c[R][ee][de][K]+p[L][ie][K];we>Q&&(Q=we,ce=L,me=ie)}}}W[ce][me][K]+=V[R][H][ae][K]}}}return{dataId:d.write(E.toTypedArray(W,a.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},Ule={kernelName:Mh,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:a,filter:r,dy:s}=e,{strides:i,pad:o,dilations:u}=n,d=t,c=E.toNestedArray(a.shape,d.data.get(a.dataId).values),p=E.toNestedArray(r.shape,d.data.get(r.dataId).values),{batchSize:m,inHeight:g,inWidth:b,inChannels:v,outHeight:x,outWidth:w,padInfo:k,strideHeight:N,strideWidth:I,filterHeight:T,filterWidth:$,dilationHeight:D,dilationWidth:M,outShape:B}=O.computeDilation2DInfo(a.shape,r.shape,i,o,"NHWC",u);E.assert(s.rank===B.length,()=>`Error in ${Mh}, dy must have the same rank as output ${B.length}, but got ${s.rank}`);let V=E.toNestedArray(B,d.data.get(s.dataId).values),W=E.makeZerosNestedTypedArray(a.shape,a.dtype);for(let R=0;R<m;++R)for(let H=0;H<x;++H){let Z=H*N-k.top;for(let ae=0;ae<w;++ae){let j=ae*I-k.left;for(let K=0;K<v;++K){let Q=Number.MIN_SAFE_INTEGER,ce=Z<0?0:Z,me=j<0?0:j;for(let L=0;L<T;++L){let ee=Z+L*D;if(ee>=0&&ee<g)for(let ie=0;ie<$;++ie){let de=j+ie*M;if(de>=0&&de<b){let we=c[R][ee][de][K]+p[L][ie][K];we>Q&&(Q=we,ce=ee,me=de)}}}W[R][ce][me][K]+=V[R][H][ae][K]}}}return{dataId:d.write(E.toTypedArray(W,a.dtype),a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}};function jle(e){let{inputs:t,backend:n,attrs:a}=e,{image:r}=t,{canvas:s,options:i}=a,{contextOptions:o,imageOptions:u}=i||{},d=u?.alpha||1,c=o?.contextType||"2d";if(c!=="2d")throw new Error(`Context type ${o.contextType} is not supported by the CPU backend.`);let p=s.getContext(c,o?.contextAttributes||{});if(p==null)throw new Error(`Could not get the context with ${c} type.`);let[m,g]=r.shape.slice(0,2),b=r.shape.length===2?1:r.shape[2],v=n.data.get(r.dataId).values,x=r.dtype==="float32"?255:1,w=new Uint8ClampedArray(g*m*4);for(let N=0;N<m*g;++N){let I=[0,0,0,255*d];for(let $=0;$<b;$++){let D=v[N*b+$];if(r.dtype==="float32"){if(D<0||D>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${D}.`)}else if(r.dtype==="int32"&&(D<0||D>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${D}.`);b===1?(I[0]=D*x,I[1]=D*x,I[2]=D*x):I[$]=D*x}let T=N*4;w[T+0]=Math.round(I[0]),w[T+1]=Math.round(I[1]),w[T+2]=Math.round(I[2]),w[T+3]=Math.round(I[3])}s.width=g,s.height=m;let k=new ImageData(w,g,m);return p.putImageData(k,0,0),r}var Wle={kernelName:h0,backendName:"cpu",kernelFunc:jle};function wy(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a;Ue(r,"sum");let o;r.dtype==="bool"?o=pl({inputs:{x:r},backend:n,attrs:{dtype:"int32"}}):o=fi({inputs:{x:r},backend:n});let u=o.shape.length,d=E.parseAxisParam(s,o.shape),c=O.getAxesPermutation(d,u),p=d,m=o;c!=null&&(m=hr({inputs:{x:o},backend:n,attrs:{perm:c}}),p=O.getInnerMostAxes(p.length,u)),O.assertAxesAreInnerMostDims("sum",p,m.shape.length);let[g,b]=O.computeOutAndReduceShapes(m.shape,p),v=O.upcastType(m.dtype,"int32"),x=Uv(n,g,v),w=E.sizeFromShape(b),k=n.data.get(x.dataId).values,N=n.data.get(m.dataId).values;for(let I=0;I<k.length;++I){let T=I*w,$=0;for(let D=0;D<w;++D)$+=N[T+D];k[I]=$}if(i){let I=O.expandShapeToKeepDim(x.shape,d),T=x;x=cn({inputs:{x},backend:n,attrs:{shape:I}}),n.disposeIntermediateTensorInfo(T)}return n.disposeIntermediateTensorInfo(o),c!=null&&n.disposeIntermediateTensorInfo(m),x}var Vle={kernelName:rd,backendName:"cpu",kernelFunc:wy};function Hle(e){let{inputs:t,backend:n,attrs:a}=e,{equation:r}=a,s=t,{allDims:i,summedDims:o,idDims:u}=O.decodeEinsumEquation(r,s.length);O.checkEinsumDimSizes(i.length,u,s);let{path:d,steps:c}=O.getEinsumComputePath(o,u),p=c.length,m=null,g=i.length,b=[];for(let v=0;v<p;++v){for(let x of c[v]){let{permutationIndices:w,expandDims:k}=O.getEinsumPermutation(g,u[x]),N;O.isIdentityPermutation(w)?N=s[x]:(N=hr({inputs:{x:s[x]},backend:n,attrs:{perm:w}}),b.push(N));let I=N.shape.slice();for(let T=0;T<k.length;++T)I.splice(k[T],0,1);E.arraysEqual(N.shape,I)||(N=cn({inputs:{x:N},backend:n,attrs:{shape:I}}),b.push(N)),m===null?m=N:(m=Ix({inputs:{a:N,b:m},backend:n}),b.push(m))}v<p-1&&(d[v]>=0&&(m=wy({inputs:{x:m},backend:n,attrs:{axis:d[v]-(i.length-g),keepDims:!1}}),b.push(m)),g--)}for(let v of b)v!==m&&n.disposeIntermediateTensorInfo(v);return m}var Gle={kernelName:p0,backendName:"cpu",kernelFunc:Hle};function qle(e){let{inputs:t,backend:n}=e,{dy:a,y:r}=t;Ue([a,r],"eluGrad");let s=new Float32Array(E.sizeFromShape(r.shape)),i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values;for(let u=0;u<i.length;++u){let d=i[u];d>=0?s[u]=o[u]:s[u]=o[u]*(d+1)}return n.makeTensorInfo(r.shape,"float32",s)}var Kle={kernelName:gp,backendName:"cpu",kernelFunc:qle},Xle=O.ERF_P,Yle=O.ERF_A1,Jle=O.ERF_A2,Zle=O.ERF_A3,Qle=O.ERF_A4,eue=O.ERF_A5,tue=Vt(fc,e=>{let t=Math.sign(e),n=Math.abs(e),a=1/(1+Xle*n);return t*(1-((((eue*a+Qle)*a+Zle)*a+Jle)*a+Yle)*a*Math.exp(-n*n))}),nue={kernelName:fc,backendName:"cpu",kernelFunc:tue};function Vv(e){let{inputs:t,backend:n,attrs:a}=e,{input:r}=t,{dim:s}=a,i=r.shape.length,o=r.shape.slice(),u=s;return s<0&&(E.assert(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),u=i+s+1),o.splice(u,0,1),cn({inputs:{x:r},backend:n,attrs:{shape:o}})}var aue={kernelName:bp,backendName:"cpu",kernelFunc:Vv},rue=On((e,t)=>e/t),_I=aa(hc,rue),gk={kernelName:hc,backendName:"cpu",kernelFunc:_I};function XL(e,t,n){let a=e.shape,r=a[0],s=a[1],i=n.data.get(e.dataId),o=i.complexTensorInfos.real,u=i.complexTensorInfos.imag,d=[r,s],c=E.sizeFromShape(d),p=E.getTypedArrayFromDType("float32",c),m=E.getTypedArrayFromDType("float32",c);for(let x=0;x<r;x++){let w=Bu({inputs:{x:o},backend:n,attrs:{begin:[x,0],size:[1,s]}}),k=Bu({inputs:{x:u},backend:n,attrs:{begin:[x,0],size:[1,s]}}),N=Tr({inputs:{real:w,imag:k},backend:n}),{real:I,imag:T}=sue(N,t,n),$=O.mergeRealAndImagArrays(I,T);for(let D=0;D<s;D++){let M=O.getComplexWithIndex($,D);p[x*s+D]=M.real,m[x*s+D]=M.imag}n.disposeIntermediateTensorInfo(w),n.disposeIntermediateTensorInfo(k),n.disposeIntermediateTensorInfo(N)}let g=n.makeTensorInfo(d,"float32",p),b=n.makeTensorInfo(d,"float32",m),v=Tr({inputs:{real:g,imag:b},backend:n});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(b),v}function sue(e,t,n){let a=E.sizeFromShape(e.shape),r=n.data.get(e.dataId),s=n.data.get(r.complexTensorInfos.real.dataId).values,i=n.data.get(r.complexTensorInfos.imag.dataId).values;if(iue(a)){let o=yk(s,i,a,t,n),u=[e.shape[0],e.shape[1]];if(t){let d=n.makeTensorInfo(u,"float32",o.real),c=n.makeTensorInfo(u,"float32",o.imag),p=n.makeTensorInfo([],"float32",E.createScalarValue(a,"float32")),m=fi({inputs:{x:p},backend:n}),g=gk.kernelFunc({inputs:{a:d,b:p},backend:n}),b=gk.kernelFunc({inputs:{a:c,b:m},backend:n}),v=n.data.get(g.dataId).values,x=n.data.get(b.dataId).values;return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(b),{real:v,imag:x}}return o}else{let o=O.mergeRealAndImagArrays(s,i),u=oue(o,a,t);return O.splitRealAndImagArrays(u)}}function iue(e){return(e&e-1)===0}function yk(e,t,n,a,r){if(n===1)return{real:e,imag:t};let s=O.mergeRealAndImagArrays(e,t),i=n/2,o=O.complexWithEvenIndex(s),u=o.real,d=o.imag,c=[u.length],p=r.makeTensorInfo(c,"float32",u),m=r.makeTensorInfo(c,"float32",d),g=Tr({inputs:{real:p,imag:m},backend:r}),b=O.complexWithOddIndex(s),v=b.real,x=b.imag,w=[v.length],k=r.makeTensorInfo(w,"float32",v),N=r.makeTensorInfo(w,"float32",x),I=Tr({inputs:{real:k,imag:N},backend:r}),T=yk(u,d,i,a,r),$=T.real,D=T.imag,M=[$.length],B=r.makeTensorInfo(M,"float32",$),V=r.makeTensorInfo(M,"float32",D),W=Tr({inputs:{real:B,imag:V},backend:r}),R=yk(v,x,i,a,r),H=R.real,Z=R.imag,ae=[H.length],j=r.makeTensorInfo(ae,"float32",H),K=r.makeTensorInfo(ae,"float32",Z),Q=Tr({inputs:{real:j,imag:K},backend:r}),ce=O.exponents(n,a),me=[ce.real.length],L=r.makeTensorInfo(me,"float32",ce.real),ee=r.makeTensorInfo(me,"float32",ce.imag),ie=Tr({inputs:{real:L,imag:ee},backend:r}),de=Ix({inputs:{a:ie,b:Q},backend:r}),we=Kh({inputs:{a:W,b:de},backend:r}),Ie=wI({inputs:{a:W,b:de},backend:r}),Ee=Lu({inputs:{input:we},backend:r}),Ce=Lu({inputs:{input:Ie},backend:r}),ze=Xh({inputs:{input:we},backend:r}),Ke=Xh({inputs:{input:Ie},backend:r}),at=Yh({inputs:[Ee,Ce],backend:r,attrs:{axis:0}}),lt=Yh({inputs:[ze,Ke],backend:r,attrs:{axis:0}}),Dt=r.data.get(at.dataId).values,ut=r.data.get(lt.dataId).values;return r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(m),r.disposeIntermediateTensorInfo(g),r.disposeIntermediateTensorInfo(k),r.disposeIntermediateTensorInfo(N),r.disposeIntermediateTensorInfo(I),r.disposeIntermediateTensorInfo(B),r.disposeIntermediateTensorInfo(V),r.disposeIntermediateTensorInfo(W),r.disposeIntermediateTensorInfo(j),r.disposeIntermediateTensorInfo(K),r.disposeIntermediateTensorInfo(Q),r.disposeIntermediateTensorInfo(L),r.disposeIntermediateTensorInfo(ee),r.disposeIntermediateTensorInfo(ie),r.disposeIntermediateTensorInfo(de),r.disposeIntermediateTensorInfo(we),r.disposeIntermediateTensorInfo(Ie),r.disposeIntermediateTensorInfo(Ee),r.disposeIntermediateTensorInfo(ze),r.disposeIntermediateTensorInfo(Ce),r.disposeIntermediateTensorInfo(Ke),r.disposeIntermediateTensorInfo(at),r.disposeIntermediateTensorInfo(lt),{real:Dt,imag:ut}}function oue(e,t,n){let a=new Float32Array(t*2);for(let r=0;r<t;r++){let s=0,i=0;for(let o=0;o<t;o++){let u=O.exponent(r*o,t,n),d=O.getComplexWithIndex(e,o);s+=d.real*u.real-d.imag*u.imag,i+=d.real*u.imag+d.imag*u.real}n&&(s/=t,i/=t),O.assignToTypedArray(a,s,i,r)}return a}function lue(e){let{inputs:t,backend:n}=e,{input:a}=t,r=E.sizeFromShape(a.shape),s=a.shape[a.shape.length-1],i=r/s,o=cn({inputs:{x:a},backend:n,attrs:{shape:[i,s]}}),u=XL(o,!1,n),d=cn({inputs:{x:u},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),d}var uue={kernelName:f0,backendName:"cpu",kernelFunc:lue};function NI(e){let{backend:t,attrs:n}=e,{shape:a,value:r,dtype:s}=n,i=s||E.inferDtype(r),o=E.getArrayFromDType(i,E.sizeFromShape(a));return due(o,r),t.makeTensorInfo(a,i,o)}var cue={kernelName:Rg,backendName:"cpu",kernelFunc:NI};function due(e,t,n){e.fill(t)}var hue={kernelName:vp,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:a}=e,r=n,s=E.getTypedArrayFromDType(a.dtype,E.sizeFromShape(a.shape)),[i,o,u,d]=a.shape,c=r.data.get(a.dataId).values;for(let p=0;p<i;p++){let m=p*u*o*d;for(let g=0;g<o;g++){let b=g*(u*d);for(let v=0;v<u;v++){let x=v*d;for(let w=0;w<d;w++){let k=Math.round(u-v-1),N=m+b+x+w,I=c[N];if(k>=0&&k<u){let T=k*d,$=m+b+T+w;I=c[$]}s[N]=I}}}}return{dataId:r.write(s,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}};function pue(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,bias:i,preluActivationWeights:o}=t,{strides:u,pad:d,dataFormat:c,dilations:p,dimRoundingMode:m,activation:g,leakyreluAlpha:b}=a,v=qL({inputs:{x:r,filter:s},backend:n,attrs:{strides:u,pad:d,dataFormat:c,dilations:p,dimRoundingMode:m}});if(i){let x=v;if(c==="NCHW"&&i.shape.length===1&&i.shape[0]!==1){let w=cn({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});v=Kh({inputs:{a:v,b:w},backend:n}),n.disposeIntermediateTensorInfo(w)}else v=Kh({inputs:{a:v,b:i},backend:n});n.disposeIntermediateTensorInfo(x)}if(g){let x=v;if(c==="NCHW"&&g==="prelu"&&o.shape.length===1&&o.shape[0]!==1){let w=cn({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});v=Wv(n,v,g,w,b),n.disposeIntermediateTensorInfo(w)}else v=Wv(n,v,g,o,b);n.disposeIntermediateTensorInfo(x)}return v}var fue={kernelName:Iu,backendName:"cpu",kernelFunc:pue};function mue(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,bias:i,preluActivationWeights:o}=t,{strides:u,pad:d,dataFormat:c,dilations:p,dimRoundingMode:m,activation:g,leakyreluAlpha:b}=a,v=KL({inputs:{x:r,filter:s},backend:n,attrs:{strides:u,pad:d,dataFormat:c,dilations:p,dimRoundingMode:m}});if(i){let x=v;v=Kh({inputs:{a:v,b:i},backend:n}),n.disposeIntermediateTensorInfo(x)}if(g){let x=v;v=Wv(n,v,g,o,b),n.disposeIntermediateTensorInfo(x)}return v}var gue={kernelName:Tu,backendName:"cpu",kernelFunc:mue};function yue(e){let{inputs:t,backend:n}=e,{params:a,indices:r}=t,s=E.sizeFromShape(a.shape),i=r.shape,o=i[i.length-1],[u,d,c,p]=O.prepareAndValidate(a,r);if(d===0)return n.makeTensorInfo(u,a.dtype,[]);let m=n.data.get(r.dataId).values,g=n.bufferSync(a),b=dL(m,g,a.dtype,d,o,c,p,a.shape,s);return n.makeTensorInfo(u,a.dtype,b.values)}var bue={kernelName:wp,backendName:"cpu",kernelFunc:yue};function vue(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,indices:s}=t,{axis:i,batchDims:o}=a;Ue([r,s],"gatherV2");let u=E.parseAxisParam(i,r.shape)[0],d=n.data.get(s.dataId).values,c=r.shape[u];for(let I=0;I<d.length;++I){let T=d[I];E.assert(T<=c-1&&T>=0,()=>`GatherV2: the index value ${T} is not in [0, ${c-1}]`)}let p=o;o==null&&(p=0);let m=E.sizeFromShape(s.shape),g=O.segment_util.collectGatherOpShapeInfo(r,s,u,p),b=cn({inputs:{x:r},backend:n,attrs:{shape:[g.batchSize,g.outerSize,g.dimSize,g.sliceSize]}}),v=cn({inputs:{x:s},backend:n,attrs:{shape:[g.batchSize,m/g.batchSize]}}),x=[g.batchSize,g.outerSize,m/g.batchSize,g.sliceSize],w=n.bufferSync(v),k=n.bufferSync(b),N=hL(k,w,x);return n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(v),n.makeTensorInfo(g.outputShape,N.dtype,N.values)}var xue={kernelName:xp,backendName:"cpu",kernelFunc:vue};function wue(e){let{inputs:t,backend:n}=e,{input:a}=t,r=E.sizeFromShape(a.shape),s=a.shape[a.shape.length-1],i=r/s,o=cn({inputs:{x:a},backend:n,attrs:{shape:[i,s]}}),u=XL(o,!0,n),d=cn({inputs:{x:u},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),d}var Sue={kernelName:m0,backendName:"cpu",kernelFunc:wue},kue=Vt(Sc,e=>Number.isFinite(e)?1:0,"bool"),_ue={kernelName:Sc,backendName:"cpu",kernelFunc:kue},Nue=Vt(kc,e=>Math.abs(e)===1/0?1:0,"bool"),Iue={kernelName:kc,backendName:"cpu",kernelFunc:Nue},Tue=Vt(_c,e=>Number.isNaN(e)?1:0,"bool"),Eue={kernelName:_c,backendName:"cpu",kernelFunc:Tue};function Cue(e){let{backend:t,attrs:n}=e,{start:a,stop:r,num:s}=n,i=yL(a,r,s);return t.makeTensorInfo([i.length],"float32",i)}var Aue={kernelName:Np,backendName:"cpu",kernelFunc:Cue},$ue=Vt(Tc,e=>Math.log1p(e)),Rue={kernelName:Tc,backendName:"cpu",kernelFunc:$ue},Due=On((e,t)=>e&&t),Oue=aa(Ip,Due,null,"bool"),Mue={kernelName:Ip,backendName:"cpu",kernelFunc:Oue},Fue=Vt(Tp,e=>e?0:1,"bool"),zue={kernelName:Tp,backendName:"cpu",kernelFunc:Fue},Lue=On((e,t)=>e||t),Bue=aa(Ep,Lue,null,"bool"),Pue={kernelName:Ep,backendName:"cpu",kernelFunc:Bue};function Uue(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{depthRadius:s,bias:i,alpha:o,beta:u}=a;Ue(r,"LRN");let d=r.shape[3],c=d-1,p=n.data.get(r.dataId).values,m=E.sizeFromShape(r.shape),g=new Float32Array(m);function b(v){let x=v%d,w=v-x+Math.max(0,x-s),k=v-x+Math.min(x+s,c),N=0;for(;w<=k;w++){let I=p[w];N+=I*I}return N}for(let v=0;v<m;v++){let x=b(v),w=p[v]*Math.pow(i+o*x,-u);g[v]=w}return n.makeTensorInfo(r.shape,r.dtype,g)}var jue={kernelName:Ec,backendName:"cpu",kernelFunc:Uue};function Wue(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,y:s,dy:i}=t,{depthRadius:o,bias:u,alpha:d,beta:c}=a;Ue(i,"LRNGrad");let p=E.sizeFromShape(i.shape),m=i.shape[3],g=n.data.get(i.dataId).values,b=n.data.get(r.dataId).values,v=n.data.get(s.dataId).values,x=new Float32Array(p),w=p;for(let k=0;k<w;k++){let N=k%m,I=k-N+Math.max(0,N-o),T=k-N+Math.min(m,N+o+1),$=0;for(let D=I;D<T;D++)$+=Math.pow(b[D],2);$=d*$+u;for(let D=I;D<T;D++){let M=-2*d*c*b[D]*v[k]/$;k===D&&(M+=Math.pow($,-c)),M*=g[k],x[D]+=M}}return n.makeTensorInfo(i.shape,r.dtype,x)}var Vue={kernelName:Cp,backendName:"cpu",kernelFunc:Wue};function YL(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reductionIndices:s,keepDims:i}=a,o=n,u=r.shape,d=u.length,c=E.parseAxisParam(s,u),p=c,m=O.getAxesPermutation(p,d),g=o.data.get(r.dataId).values;if(m!=null){let I=new Array(d);for(let T=0;T<I.length;T++)I[T]=u[m[T]];g=mI(g,u,r.dtype,m,I),p=O.getInnerMostAxes(p.length,d),u=I}Ue(r,"max"),O.assertAxesAreInnerMostDims("max",p,d);let[b,v]=O.computeOutAndReduceShapes(u,p),x=E.sizeFromShape(v),w=vL(g,x,b,r.dtype),k=o.write(w,b,r.dtype),N=b;return i&&(N=O.expandShapeToKeepDim(b,c)),{dataId:k,shape:N,dtype:r.dtype}}var Hue={kernelName:Cc,backendName:"cpu",kernelFunc:YL};function Gue(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t;Ue(r,"maxPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:u}=a,d=1;E.assert(O.eitherStridesOrDilationsAreOne(i,d),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${d}'`);let c=O.computePool2DInfo(r.shape,s,i,d,o,u),p;if(c.filterWidth===1&&c.filterHeight===1&&E.arraysEqual(c.inShape,c.outShape))p=fi({inputs:{x:r},backend:n});else{let m=n.data.get(r.dataId).values,g=E.computeStrides(r.shape),b=kI(m,r.shape,r.dtype,g,c,"max");p=n.makeTensorInfo(c.outShape,r.dtype,b.values)}return p}var que={kernelName:$c,backendName:"cpu",kernelFunc:Gue};function Kue(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:u,dataFormat:d}=a;Ue(r,"maxPool3d");let c=O.computePool3DInfo(r.shape,s,i,1,o,u,d),p=n.data.get(r.dataId).values,m=GL(p,r.shape,r.dtype,E.computeStrides(r.shape),c,"max");return n.makeTensorInfo(m.shape,"float32",m.values)}var Xue={kernelName:Ap,backendName:"cpu",kernelFunc:Kue};function Yue(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,{filterSize:i,strides:o,pad:u,dimRoundingMode:d}=a;Ue([r,s],"maxPool3DGrad");let c=O.computePool3DInfo(s.shape,i,o,1,u,d),p=n.bufferSync(s),m=Loe(p,c),g=c.strideDepth,b=c.strideHeight,v=c.strideWidth,x=c.dilationDepth,w=c.dilationHeight,k=c.dilationWidth,N=c.effectiveFilterDepth,I=c.effectiveFilterHeight,T=c.effectiveFilterWidth,$=N-1-c.padInfo.front,D=T-1-c.padInfo.left,M=I-1-c.padInfo.top,B=mt(s.shape,"float32"),V=n.bufferSync(r);for(let W=0;W<c.batchSize;++W)for(let R=0;R<c.inChannels;++R)for(let H=0;H<c.inDepth;++H)for(let Z=0;Z<c.inHeight;++Z)for(let ae=0;ae<c.inWidth;++ae){let j=H-$,K=Z-M,Q=ae-D,ce=0;for(let me=0;me<N;me+=x){let L=(j+me)/g;if(!(L<0||L>=c.outDepth||Math.floor(L)!==L))for(let ee=0;ee<I;ee+=w){let ie=(K+ee)/b;if(!(ie<0||ie>=c.outHeight||Math.floor(ie)!==ie))for(let de=0;de<T;de+=k){let we=(Q+de)/v;if(we<0||we>=c.outWidth||Math.floor(we)!==we)continue;let Ie=N*I*T-1-m.get(W,L,ie,we,R),Ee=me*I*T+ee*T+de,Ce=Ie===Ee?1:0;if(Ce===0)continue;let ze=V.get(W,L,ie,we,R);ce+=ze*Ce}}}B.set(ce,W,H,Z,ae,R)}return n.makeTensorInfo(B.shape,B.dtype,B.values)}var Jue={kernelName:Og,backendName:"cpu",kernelFunc:Yue};function Zue(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s,output:i}=t,o=s;Ue([s,i],"maxPoolGrad");let{filterSize:u,strides:d,pad:c,dimRoundingMode:p}=a,m=O.computePool2DInfo(o.shape,u,d,1,c,p),g=n.data.get(o.dataId).values,b=mt(m.outShape,o.dtype,HL(g,o.shape,o.dtype,m).values),v=m.strideHeight,x=m.strideWidth,w=m.dilationHeight,k=m.dilationWidth,N=m.effectiveFilterHeight,I=m.effectiveFilterWidth,T=I-1-m.padInfo.left,$=N-1-m.padInfo.top,D=mt(o.shape,"float32"),M=n.data.get(r.dataId).values,B=mt(r.shape,"float32",M);for(let V=0;V<m.batchSize;++V)for(let W=0;W<m.inChannels;++W)for(let R=0;R<m.inHeight;++R)for(let H=0;H<m.inWidth;++H){let Z=R-$,ae=H-T,j=0;for(let K=0;K<N;K+=w){let Q=(Z+K)/v;if(!(Q<0||Q>=m.outHeight||Math.floor(Q)!==Q))for(let ce=0;ce<I;ce+=k){let me=(ae+ce)/x;if(me<0||me>=m.outWidth||Math.floor(me)!==me)continue;let L=N*I-1-b.get(V,Q,me,W),ee=K*I+ce,ie=L===ee?1:0;if(ie===0)continue;let de=B.get(V,Q,me,W);j+=de*ie}}D.set(j,V,R,H,W)}return n.makeTensorInfo(D.shape,D.dtype,D.values)}var Que={kernelName:Dg,backendName:"cpu",kernelFunc:Zue};function ece(e,t,n,a,r){let s=E.computeStrides(t),i=kI(e,t,n,s,r,"max"),o=HL(e,t,n,r,!0,a);return[i.values,o.values]}var tce={kernelName:Mg,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:a}=e,{filterSize:r,strides:s,pad:i,includeBatchInIndex:o}=t,u=n;Ue(a,"MaxPoolWithArgmax");let d=u.data.get(a.dataId).values,c=O.computePool2DInfo(a.shape,r,s,[1,1],i),[p,m]=ece(d,a.shape,a.dtype,o,c),g=u.write(p,c.outShape,a.dtype),b=u.write(m,c.outShape,a.dtype);return[{dataId:g,shape:c.outShape,dtype:a.dtype},{dataId:b,shape:c.outShape,dtype:"int32"}]}};function nce(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a,o=E.parseAxisParam(s,r.shape),u=O.computeOutAndReduceShapes(r.shape,o)[1],d=E.sizeFromShape(u),c=[],p=n.makeTensorInfo([],"float32",new Float32Array([d]));c.push(p);let m=pl({inputs:{x:r},backend:n,attrs:{dtype:"float32"}});c.push(m);let g=_I({inputs:{a:m,b:p},backend:n});c.push(g);let b=wy({inputs:{x:g},backend:n,attrs:{axis:s,keepDims:i}});return c.forEach(v=>n.disposeIntermediateTensorInfo(v)),b}var ace={kernelName:Rc,backendName:"cpu",kernelFunc:nce};function rce(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a;Ue(r,"min");let o=E.parseAxisParam(s,r.shape),u=o,d=O.getAxesPermutation(u,r.shape.length),c=r;d!=null&&(c=hr({inputs:{x:r},backend:n,attrs:{perm:d}}),u=O.getInnerMostAxes(u.length,r.shape.length)),O.assertAxesAreInnerMostDims("min",u,c.shape.length);let[p,m]=O.computeOutAndReduceShapes(c.shape,u),g=E.sizeFromShape(m),b=E.makeZerosTypedArray(E.sizeFromShape(p),c.dtype),v=n.data.get(c.dataId).values;for(let w=0;w<b.length;++w){let k=w*g,N=v[k];for(let I=0;I<g;++I){let T=v[k+I];(Number.isNaN(T)||T<N)&&(N=T)}b[w]=N}d!=null&&n.disposeIntermediateTensorInfo(c);let x=n.makeTensorInfo(p,c.dtype,b);if(i){let w=O.expandShapeToKeepDim(p,o),k=cn({inputs:{x},backend:n,attrs:{shape:w}});return n.disposeIntermediateTensorInfo(x),k}return x}var sce={kernelName:Dc,backendName:"cpu",kernelFunc:rce};function ice(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{paddings:s,mode:i}=a;Ue(r,"mirrorPad");let o=s.map((k,N)=>k[0]+r.shape[N]+k[1]),u=s.map(k=>k[0]),d=s.map((k,N)=>k[0]+r.shape[N]),c=i==="reflect"?0:1,p=n.data.get(r.dataId).values,m=r.shape.length,g=E.computeStrides(r.shape),b=E.sizeFromShape(o),v=o.length,x=E.computeStrides(o),w=E.getTypedArrayFromDType(r.dtype,b);for(let k=0;k<b;k++){let N=E.indexToLoc(k,v,x);for(let T=0;T<v;T++)N[T]<u[T]?N[T]=u[T]*2-N[T]-c:N[T]>=d[T]&&(N[T]=(d[T]-1)*2-N[T]+c);N=N.map((T,$)=>T-u[$]);let I=E.locToIndex(N,m,g);w[k]=p[I]}return{dataId:n.write(w,o,r.dtype),shape:o,dtype:r.dtype}}var oce={kernelName:Mc,backendName:"cpu",kernelFunc:ice},lce=On((e,t)=>{let n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t}),uce=aa(Fc,lce),cce={kernelName:Fc,backendName:"cpu",kernelFunc:uce},dce=yl(r0());function JL(e){let{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{dim:s}=a,i=r.shape.length,o=s;if(o===-1&&(o=i-1),o!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${o}`);let u=E.parseAxisParam([o],r.shape),d=YL({inputs:{x:r},backend:n,attrs:{reductionIndices:u,keepDims:!1}}),c=O.expandShapeToKeepDim(d.shape,u),p=cn({inputs:{x:d},backend:n,attrs:{shape:c}}),m=wI({inputs:{a:r,b:p},backend:n}),g=oL({inputs:{x:m},backend:n}),b=wy({inputs:{x:g},backend:n,attrs:{axis:u,keepDims:!1}}),v=cn({inputs:{x:b},backend:n,attrs:{shape:c}}),x=_I({inputs:{a:g,b:v},backend:n});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(v),x}var hce={kernelName:sd,backendName:"cpu",kernelFunc:JL};function pce(e){let{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{numSamples:s,seed:i,normalized:o}=a;Ue(r,"multinomial");let u=o?r:JL({inputs:{logits:r},backend:n,attrs:{dim:-1}}),d=u.shape[0],c=u.shape[1],p=n.data.get(u.dataId).values,m=[d,s],g=E.makeZerosTypedArray(E.sizeFromShape(m),"int32");for(let b=0;b<d;++b){let v=b*c,x=new Float32Array(c-1);x[0]=p[v];for(let N=1;N<x.length;++N)x[N]=x[N-1]+p[v+N];let w=dce.alea(i.toString()),k=b*s;for(let N=0;N<s;++N){let I=w();g[k+N]=x.length;for(let T=0;T<x.length;T++)if(I<x[T]){g[k+N]=T;break}}}return o||n.disposeIntermediateTensorInfo(u),n.makeTensorInfo(m,"int32",g)}var fce={kernelName:$p,backendName:"cpu",kernelFunc:pce},mce=yi.nonMaxSuppressionV3Impl;function gce(e){let{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u}=a;Ue(r,"NonMaxSuppression");let d=n.data.get(r.dataId).values,c=n.data.get(s.dataId).values,{selectedIndices:p}=mce(d,c,i,o,u);return n.makeTensorInfo([p.length],"int32",new Int32Array(p))}var yce={kernelName:Op,backendName:"cpu",kernelFunc:gce},bce=yi.nonMaxSuppressionV4Impl;function vce(e){let{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u,padToMaxOutputSize:d}=a;Ue(r,"NonMaxSuppressionPadded");let c=n.data.get(r.dataId).values,p=n.data.get(s.dataId).values,{selectedIndices:m,validOutputs:g}=bce(c,p,i,o,u,d);return[n.makeTensorInfo([m.length],"int32",new Int32Array(m)),n.makeTensorInfo([],"int32",new Int32Array([g]))]}var xce={kernelName:Mp,backendName:"cpu",kernelFunc:vce},wce=yi.nonMaxSuppressionV5Impl;function Sce(e){let{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u,softNmsSigma:d}=a;Ue(r,"NonMaxSuppressionWithScore");let c=n.data.get(r.dataId).values,p=n.data.get(s.dataId).values,m=i,g=o,b=u,v=d,{selectedIndices:x,selectedScores:w}=wce(c,p,m,g,b,v);return[n.makeTensorInfo([x.length],"int32",new Int32Array(x)),n.makeTensorInfo([w.length],"float32",new Float32Array(w))]}var kce={kernelName:Fp,backendName:"cpu",kernelFunc:Sce};function _ce(e){let{inputs:t,backend:n,attrs:a}=e,{indices:r}=t,{dtype:s,depth:i,onValue:o,offValue:u}=a;Ue(r,"oneHot");let d=E.sizeFromShape(r.shape),c=new Float32Array(d*i);c.fill(u);let p=n.data.get(r.dataId).values;for(let m=0;m<d;++m)p[m]>=0&&p[m]<i&&(c[m*i+p[m]]=o);return n.makeTensorInfo([...r.shape,i],s,c)}var Nce={kernelName:Lc,backendName:"cpu",kernelFunc:_ce};function Hv(e){let{inputs:t,backend:n}=e,{x:a}=t;if(a.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(a.dtype==="complex64"){let r=Lu({inputs:{input:a},backend:n}),s=Hv({inputs:{x:r},backend:n}),i=Xh({inputs:{input:a},backend:n}),o=Hv({inputs:{x:i},backend:n}),u=Tr({inputs:{real:s,imag:o},backend:n});return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),u}else return NI({backend:n,attrs:{shape:a.shape,value:0,dtype:a.dtype}})}var Ice={kernelName:tf,backendName:"cpu",kernelFunc:Hv};function ZL(e){let{inputs:t,backend:n}=e,{x:a}=t;if(a.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(a.dtype==="complex64"){let r=Lu({inputs:{input:a},backend:n}),s=ZL({inputs:{x:r},backend:n}),i=Xh({inputs:{input:a},backend:n}),o=Hv({inputs:{x:i},backend:n}),u=Tr({inputs:{real:s,imag:o},backend:n});return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),u}else return NI({backend:n,attrs:{shape:a.shape,value:1,dtype:a.dtype}})}var Tce={kernelName:zp,backendName:"cpu",kernelFunc:ZL};function QL(e){let{inputs:t,backend:n,attrs:a}=e,{axis:r}=a;if(t.length===1)return Vv({inputs:{input:t[0]},backend:n,attrs:{dim:r}});let s=t[0].shape,i=t[0].dtype;t.forEach(c=>{E.assertShapesMatch(s,c.shape,"All tensors passed to stack must have matching shapes"),E.assert(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let o=[],u=t.map(c=>{let p=Vv({inputs:{input:c},backend:n,attrs:{dim:r}});return o.push(p),p}),d=Yh({inputs:u,backend:n,attrs:{axis:r}});return o.forEach(c=>n.disposeIntermediateTensorInfo(c)),d}var Ece={kernelName:Lp,backendName:"cpu",kernelFunc:QL};function Cce(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{paddings:s,constantValue:i}=a;Ue(r,"pad");let o=s.map((w,k)=>w[0]+r.shape[k]+w[1]),u=s.map(w=>w[0]),d=n.data.get(r.dataId).values,c=E.sizeFromShape(r.shape),p=r.shape.length,m=E.computeStrides(r.shape),g=E.sizeFromShape(o),b=o.length,v=E.computeStrides(o),x=E.getTypedArrayFromDType(r.dtype,g);i!==0&&x.fill(i);for(let w=0;w<c;w++){let k=E.indexToLoc(w,p,m).map((I,T)=>I+u[T]),N=E.locToIndex(k,b,v);x[N]=d[w]}return{dataId:n.write(x,o,r.dtype),shape:o,dtype:r.dtype}}var eB={kernelName:Bc,backendName:"cpu",kernelFunc:Cce},Ace=On((e,t)=>Math.pow(e,t)),$ce=aa(Pc,Ace),Rce={kernelName:Pc,backendName:"cpu",kernelFunc:$ce};function Dce(e){let{inputs:t,backend:n,attrs:a}=e,{paramsNestedSplits:r,paramsDenseValues:s,indices:i}=t,{outputRaggedRank:o}=a,u=r.map(w=>n.data.get(w.dataId).values),d=r.map(w=>w.shape),c=n.data.get(s.dataId).values,p=n.data.get(i.dataId).values,[m,g,b]=NL(u,d,c,s.shape,s.dtype,p,i.shape),v=m.map(w=>n.makeTensorInfo([w.length],"int32",w)),x=n.makeTensorInfo(b,s.dtype,g);return v.concat([x])}var Oce={kernelName:y0,backendName:"cpu",kernelFunc:Dce};function Mce(e){let{inputs:t,backend:n}=e,{starts:a,limits:r,deltas:s}=t,i=n.data.get(a.dataId).values,o=n.data.get(r.dataId).values,u=n.data.get(s.dataId).values,[d,c]=IL(i,a.shape,a.dtype,o,r.shape,u,s.shape),p=n.makeTensorInfo([d.length],"int32",d),m=n.makeTensorInfo([c.length],a.dtype,c);return[p,m]}var Fce={kernelName:b0,backendName:"cpu",kernelFunc:Mce};function zce(e){let{inputs:t,backend:n,attrs:a}=e,{shape:r,values:s,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:u}=a,d=n.data.get(r.dataId).values,c=n.data.get(s.dataId).values,p=n.data.get(i.dataId).values,m=o.map(x=>n.data.get(x.dataId).values),g=o.map(x=>x.shape),[b,v]=TL(d,r.shape,c,s.shape,s.dtype,p,i.shape,m,g,u);return n.makeTensorInfo(b,s.dtype,v)}var Lce={kernelName:v0,backendName:"cpu",kernelFunc:zce};function Bce(e){let{backend:t,attrs:n}=e,{start:a,stop:r,dtype:s,step:i}=n,o=gI(a,r,i,s);return t.makeTensorInfo([o.length],s,o)}var Pce={kernelName:Fg,backendName:"cpu",kernelFunc:Bce},Uce=Vt(Wc,e=>1/e),jce={kernelName:Wc,backendName:"cpu",kernelFunc:Uce};function Wce(e){let{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:s,halfPixelCenters:i,size:o}=a;Ue(r,"resizeBilinear");let u=E.computeStrides(r.shape),[d,c]=o,[p,m,g,b]=r.shape,v=n.data.get(r.dataId).values,x=new Float32Array(E.sizeFromShape([p,d,c,b])),w=[s&&d>1?m-1:m,s&&c>1?g-1:g],k=[s&&d>1?d-1:d,s&&c>1?c-1:c],N=0,I=w[0]/k[0],T=w[1]/k[1];for(let $=0;$<p;$++)for(let D=0;D<d;D++){let M;i?M=I*(D+.5)-.5:M=I*D;let B=Math.max(0,Math.floor(M)),V=M-B,W=Math.min(m-1,Math.ceil(M)),R=$*u[0]+B*u[1],H=$*u[0]+W*u[1];for(let Z=0;Z<c;Z++){let ae;i?ae=T*(Z+.5)-.5:ae=T*Z;let j=Math.max(0,Math.floor(ae)),K=ae-j,Q=Math.min(g-1,Math.ceil(ae)),ce=R+j*u[2],me=H+j*u[2],L=R+Q*u[2],ee=H+Q*u[2];for(let ie=0;ie<b;ie++){let de=v[ce+ie],we=v[me+ie],Ie=v[L+ie],Ee=v[ee+ie],Ce=de+(Ie-de)*K,ze=we+(Ee-we)*K,Ke=Ce+(ze-Ce)*V;x[N++]=Ke}}}return n.makeTensorInfo([p,d,c,b],"float32",x)}var Vce={kernelName:Gc,backendName:"cpu",kernelFunc:Wce};function Hce(e){let{inputs:t,backend:n,attrs:a}=e,{images:r,dy:s}=t,{alignCorners:i}=a;Ue([s,r],"resizeBilinearGrad");let o=E.computeStrides(r.shape),[u,d,c,p]=r.shape,[,m,g]=s.shape,b=new Float32Array(u*d*c*p),v=[i&&m>1?d-1:d,i&&g>1?c-1:c],x=[i&&m>1?m-1:m,i&&g>1?g-1:g],w=v[0]/x[0],k=v[1]/x[1],N=n.data.get(s.dataId).values,I=0;for(let T=0;T<u;T++){let $=T*o[0];for(let D=0;D<m;D++){let M=D*w,B=Math.floor(M),V=Math.min(Math.ceil(M),d-1),W=$+B*o[1],R=$+V*o[1],H=M-B,Z=1-H;for(let ae=0;ae<g;ae++){let j=ae*k,K=Math.floor(j),Q=Math.min(Math.ceil(j),c-1),ce=j-K,me=1-ce,L=W+K*o[2],ee=W+Q*o[2],ie=R+K*o[2],de=R+Q*o[2],we=Z*me,Ie=Z*ce,Ee=H*me,Ce=H*ce;for(let ze=0;ze<p;ze++){let Ke=N[I++];b[L+ze]+=Ke*we,b[ee+ze]+=Ke*Ie,b[ie+ze]+=Ke*Ee,b[de+ze]+=Ke*Ce}}}}return n.makeTensorInfo([u,c,d,p],"float32",b)}var Gce={kernelName:Up,backendName:"cpu",kernelFunc:Hce};function qce(e){let{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:s,halfPixelCenters:i,size:o}=a;Ue(r,"resizeNearestNeighbor");let u=E.computeStrides(r.shape),[d,c]=o,[p,m,g,b]=r.shape,v=n.data.get(r.dataId).values,x=new Float32Array(p*d*c*b),w=[s&&d>1?m-1:m,s&&c>1?g-1:g],k=[s&&d>1?d-1:d,s&&c>1?c-1:c],N=w[0]/k[0],I=w[1]/k[1],T=0;for(let $=0;$<p;$++){let D=$*u[0];for(let M=0;M<d;M++){let B=i?N*(M+.5):N*M,V=Math.min(m-1,s?Math.round(B):Math.floor(B));i&&(V=Math.max(0,V));let W=D+V*u[1];for(let R=0;R<c;R++){let H=i?I*(R+.5):I*R,Z=Math.min(g-1,s?Math.round(H):Math.floor(H));i&&(Z=Math.max(0,Z));let ae=W+Z*u[2];for(let j=0;j<b;j++){let K=v[ae+j];x[T++]=K}}}}return n.makeTensorInfo([p,d,c,b],r.dtype,x)}var Kce={kernelName:Hc,backendName:"cpu",kernelFunc:qce};function Xce(e){let{inputs:t,backend:n,attrs:a}=e,{images:r,dy:s}=t,{alignCorners:i}=a;Ue([s,r],"resizeNearestNeighborGrad");let o=E.computeStrides(r.shape),u=E.computeStrides(s.shape),[d,c,p,m]=r.shape,[,g,b]=s.shape,v=new Float32Array(d*c*p*m),x=n.data.get(s.dataId).values,w=[i&&g>1?c-1:c,i&&b>1?p-1:p],k=[i&&g>1?g-1:g,i&&b>1?b-1:b],N=w[0]/k[0],I=w[1]/k[1],T=1/N,$=1/I,D=Math.ceil(T)*2+2,M=Math.ceil($)*2+2;for(let B=0;B<d;B++){let V=B*o[0];for(let W=0;W<c;W++){let R=V+W*o[1],H=Math.floor(W*T),Z=Math.floor(H-D/2);for(let ae=0;ae<p;ae++){let j=R+ae*o[2],K=Math.floor(ae*$),Q=Math.floor(K-M/2);for(let ce=0;ce<m;ce++){let me=0;for(let L=0;L<D;L++){let ee=L+Z;if(ee<0||ee>=g)continue;let ie=V+ee*u[1],de=ee*N,we=Math.min(c-1,i?Math.round(de):Math.floor(de));if(W===we)for(let Ie=0;Ie<M;Ie++){let Ee=Ie+Q;if(Ee<0||Ee>=b)continue;let Ce=ie+Ee*u[2],ze=Ee*I,Ke=Math.min(p-1,i?Math.round(ze):Math.floor(ze));ae===Ke&&(me+=x[Ce+ce])}}v[j+ce]=me}}}}return n.makeTensorInfo(r.shape,r.dtype,v)}var Yce={kernelName:Pp,backendName:"cpu",kernelFunc:Xce};function Jce(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dims:s}=a;Ue(r,"reverse");let i=r.shape.length,o=E.parseAxisParam(s,r.shape);if(i===0)return fi({inputs:{x:r},backend:n});let u=new Pn(r.shape,r.dtype),d=n.bufferSync(r);for(let c=0;c<u.size;c++){let p=u.indexToLoc(c),m=p.slice();o.forEach(g=>m[g]=r.shape[g]-1-m[g]),u.set(d.get(...m),...p)}return n.makeTensorInfo(u.shape,u.dtype,u.values)}var Zce={kernelName:Kc,backendName:"cpu",kernelFunc:Jce},Qce={kernelName:nf,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:a}=e,{radians:r,fillValue:s,center:i}=t,o=n,u=E.getTypedArrayFromDType(a.dtype,E.sizeFromShape(a.shape)),[d,c,p,m]=a.shape,[g,b]=O.getImageCenter(i,c,p),v=255,x=Math.sin(r),w=Math.cos(r),k=o.data.get(a.dataId).values;for(let N=0;N<d;N++){let I=N*p*c*m;for(let T=0;T<c;T++){let $=T*(p*m);for(let D=0;D<p;D++){let M=D*m;for(let B=0;B<m;B++){let V=[d,T,D,B],W=V[2],R=V[1],H=(W-g)*w-(R-b)*x,Z=(W-g)*x+(R-b)*w;H=Math.round(H+g),Z=Math.round(Z+b);let ae=s;if(typeof s!="number"&&(B===3?ae=v:ae=s[B]),H>=0&&H<p&&Z>=0&&Z<c){let K=Z*(p*m),Q=H*m,ce=I+K+Q+B;ae=k[ce]}let j=I+$+M+B;u[j]=ae}}}}return{dataId:o.write(u,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},ede=Vt(Xc,e=>{let t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2===0?t:t+1}),tde={kernelName:Xc,backendName:"cpu",kernelFunc:ede};function nde(e){let{inputs:t,backend:n,attrs:a}=e,{indices:r,updates:s}=t,{shape:i}=a,{sliceRank:o,numUpdates:u,sliceSize:d,strides:c,outputSize:p}=O.calculateShapes(s,r,i),m=!0,g=n.bufferSync(r),b=n.bufferSync(s),v=bu(g,b,i,p,d,u,o,c,0,m);return n.makeTensorInfo(i,v.dtype,v.values)}var ade={kernelName:jp,backendName:"cpu",kernelFunc:nde};function rde(e,t){let n=0,a=e.length,r=0;for(;n<a;)r=Math.floor((n+a)/2),e[r]<t?n=r+1:a=r;return a}function sde(e,t){let n=0,a=e.length,r=0;for(;n<a;)r=Math.floor((n+a)/2),e[r]<=t?n=r+1:a=r;return a}function ide(e,t,n,a,r,s){let i=E.getArrayFromDType("int32",n*r);for(let o=0;o<n;++o){let u=e.slice(o*a,(o+1)*a),d=o*r;for(let c=0;c<r;++c)i[d+c]=s==="left"?rde(u,t[c+d]):sde(u,t[c+d])}return i}function ode(e){let{inputs:t,backend:n,attrs:a}=e,{sortedSequence:r,values:s}=t,{side:i}=a,o=n.data.get(r.dataId).values,u=n.data.get(s.dataId).values,d=ide(o,u,r.shape[0],r.shape[1],s.shape[1],i);return n.makeTensorInfo(s.shape,"int32",d)}var lde={kernelName:Vp,backendName:"cpu",kernelFunc:ode};function ude(e){let{inputs:t,backend:n}=e,{condition:a,t:r,e:s}=t;Ue([a,r,s],"select");let i=a.shape.length,o=n.data.get(a.dataId).values,u=n.data.get(r.dataId).values,d=n.data.get(s.dataId).values,c=Jr(r.dtype,s.dtype),p=E.makeZerosTypedArray(E.sizeFromShape(r.shape),c),m=0,g=i===0||i>1||r.shape.length===1?1:E.sizeFromShape(r.shape.slice(1));for(let b=0;b<o.length;b++)for(let v=0;v<g;v++)o[b]===1?p[m++]=u[b]:p[m++]=d[b];return n.makeTensorInfo(r.shape,c,p)}var cde={kernelName:Hp,backendName:"cpu",kernelFunc:ude},dde=O.SELU_SCALEALPHA,hde=O.SELU_SCALE,pde=Vt(Jc,e=>e>=0?hde*e:dde*(Math.exp(e)-1)),fde={kernelName:Jc,backendName:"cpu",kernelFunc:pde},mde=Vt(ed,e=>e<0?-1:e>0?1:0),gde={kernelName:ed,backendName:"cpu",kernelFunc:mde},yde=Vt(Zc,e=>Math.sin(e)),bde={kernelName:Zc,backendName:"cpu",kernelFunc:yde},vde=Vt(Qc,e=>Math.sinh(e)),xde={kernelName:Qc,backendName:"cpu",kernelFunc:vde},wde=11920928955078125e-23,IR=Math.log(wde)+2,Sde=Vt(nd,e=>{let t=e>-IR,n=e<IR,a=Math.exp(e),r;return n?r=a:t?r=e:r=Math.log(1+a),r}),kde={kernelName:nd,backendName:"cpu",kernelFunc:Sde};function _de(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,paddings:i}=a;Ue([r],"spaceToBatchND");let o=E.sizeFromShape(s),u=[[0,0]];u.push(...i);for(let x=1+s.length;x<r.shape.length;++x)u.push([0,0]);let d=eB.kernelFunc({inputs:{x:r},backend:n,attrs:{paddings:u,constantValue:0}}),c=O.getReshaped(d.shape,s,o,!1),p=O.getPermuted(c.length,s.length,!1),m=O.getReshapedPermuted(d.shape,s,o,!1),g=cn({inputs:{x:d},backend:n,attrs:{shape:c}}),b=hr({inputs:{x:g},backend:n,attrs:{perm:p}}),v=cn({inputs:{x:b},backend:n,attrs:{shape:m}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(b),v}var Nde={kernelName:qp,backendName:"cpu",kernelFunc:_de};function Ide(e){let{inputs:t,backend:n}=e,{indices:a,values:r,denseShape:s,defaultValue:i}=t;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${s.shape}`);if(a.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${a.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${r.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);let o=n.data.get(a.dataId).values,u=n.data.get(r.dataId).values,d=n.data.get(s.dataId).values,c=n.data.get(i.dataId).values[0],[p,m,g,b,v]=AL(o,a.shape,a.dtype,u,r.dtype,d,c);return[n.makeTensorInfo(m,a.dtype,p),n.makeTensorInfo([m[0]],r.dtype,g),n.makeTensorInfo([b.length],"bool",new Uint8Array(b.map(x=>Number(x)))),n.makeTensorInfo([v.length],a.dtype,new Int32Array(v))]}var Tde={kernelName:zg,backendName:"cpu",kernelFunc:Ide};function Ede(e){let{inputs:t,backend:n}=e,{inputIndices:a,inputShape:r,newShape:s}=t;if(a.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${a.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(n.data.get(r.dataId).values),o=n.data.get(a.dataId).values,u=Array.from(n.data.get(s.dataId).values),[d,c,p]=$L(o,a.shape,a.dtype,i,u);return[n.makeTensorInfo(c,a.dtype,d),n.makeTensorInfo([p.length],s.dtype,new Int32Array(p))]}var Cde={kernelName:Xp,backendName:"cpu",kernelFunc:Ede};function Ade(e){let{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:s}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${r.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${s.shape}`);if(r.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=n.data.get(a.dataId).values,o=n.data.get(r.dataId).values,u=n.data.get(s.dataId).values,[d,c]=yI(i,a.shape,a.dtype,o,u,!0);return n.makeTensorInfo(c,a.dtype,d)}var $de={kernelName:Lg,backendName:"cpu",kernelFunc:Ade};function Rde(e){let{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:s}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${r.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${s.shape}`);if(r.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=n.data.get(a.dataId).values,o=n.data.get(r.dataId).values,u=n.data.get(s.dataId).values,[d,c]=yI(i,a.shape,a.dtype,o,u);return n.makeTensorInfo(c,a.dtype,d)}var Dde={kernelName:Bg,backendName:"cpu",kernelFunc:Rde};function Ode(e){let{inputs:t,backend:n,attrs:a}=e,{sparseIndices:r,sparseValues:s,defaultValue:i}=t,{outputShape:o}=a,{sliceRank:u,numUpdates:d,sliceSize:c,strides:p,outputSize:m}=O.calculateShapes(s,r,o),g=!1,b=n.bufferSync(r),v;switch(s.dtype){case"bool":{let x=n.bufferSync(s),w=!!n.data.get(i.dataId).values[0];v=bu(b,x,o,m,c,d,u,p,w,g);break}case"float32":{let x=n.bufferSync(s),w=n.data.get(i.dataId).values[0];v=bu(b,x,o,m,c,d,u,p,w,g);break}case"int32":{let x=n.bufferSync(s),w=n.data.get(i.dataId).values[0];v=bu(b,x,o,m,c,d,u,p,w,g);break}case"string":{let x=n.bufferSync(s),w=E.decodeString(n.data.get(i.dataId).values[0]);v=bu(b,x,o,m,c,d,u,p,w,g);break}default:throw new Error(`Unsupported type ${s.dtype}`)}return n.makeTensorInfo(o,v.dtype,v.values)}var Mde={kernelName:Yp,backendName:"cpu",kernelFunc:Ode};function Fde(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{numOrSizeSplits:s,axis:i}=a,o=E.parseAxisParam(i,r.shape)[0],u=O.prepareSplitSize(r,s,o),d=new Array(r.shape.length).fill(0),c=r.shape.slice();return u.map(p=>{let m=[...c];m[o]=p;let g=Bu({inputs:{x:r},backend:n,attrs:{begin:d,size:m}});return d[o]+=p,g})}var zde={kernelName:Kp,backendName:"cpu",kernelFunc:Fde},Lde={kernelName:Pg,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{let{x:n}=e,a=t;Ue(n,"square");let r=a.data.get(n.dataId).values,s=new Float32Array(r.length);for(let i=0;i<r.length;++i){let o=r[i];s[i]=o*o}return{dataId:a.write(s,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},Bde=Vt(wl,(e,t)=>{let n=t;return isNaN(e)?NaN:e>0?1:n.alpha}),Pde={kernelName:wl,backendName:"cpu",kernelFunc:Bde};function Ude(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:s,end:i,strides:o,beginMask:u,endMask:d,ellipsisMask:c,newAxisMask:p,shrinkAxisMask:m}=a;Ue(r,"stridedSlice");let{finalShapeSparse:g,finalShape:b,isIdentity:v,sliceDim0:x,isSimpleSlice:w,begin:k,end:N,strides:I}=ea.sliceInfo(r.shape,s,i,o,u,d,c,p,m),T;if(v)T=cn({inputs:{x:r},backend:n,attrs:{shape:b}});else if(x||w){E.assert(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);let $=ea.computeOutShape(k,N,I),D=Bu({inputs:{x:r},backend:n,attrs:{begin:k,size:$}});T=cn({inputs:{x:D},backend:n,attrs:{shape:b}}),n.disposeIntermediateTensorInfo(D)}else{let $=n.bufferSync(r),D=OL(g,$,I,k);T=n.makeTensorInfo(b,D.dtype,D.values)}return T}var jde={kernelName:Jp,backendName:"cpu",kernelFunc:Ude};function Wde(e){let{inputs:t,backend:n,attrs:a}=e,{separator:r,nGramWidths:s,leftPad:i,rightPad:o,padWidth:u,preserveShortSequences:d}=a,{data:c,dataSplits:p}=t,m=n.data.get(c.dataId).values,g=n.data.get(p.dataId).values,[b,v]=bI(m,g,r,s,i,o,u,d);return[n.makeTensorInfo([b.length],"string",b),n.makeTensorInfo(p.shape,"int32",v)]}var Vde={kernelName:jg,backendName:"cpu",kernelFunc:Wde};function Hde(e){let{inputs:t,backend:n,attrs:a}=e,{skipEmpty:r}=a,{input:s,delimiter:i}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let o=n.data.get(s.dataId).values,u=n.data.get(i.dataId).values[0],[d,c,p]=vI(o,u,r),m=c.length;return[n.makeTensorInfo([m,2],"int32",d),n.makeTensorInfo([m],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(p))]}var Gde={kernelName:Wg,backendName:"cpu",kernelFunc:Hde};function qde(e){let{inputs:t,backend:n,attrs:a}=e,{numBuckets:r}=a,{input:s}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");let i=n.data.get(s.dataId).values,o=xI(i,r);return n.makeTensorInfo(s.shape,"int32",o)}var Kde={kernelName:Vg,backendName:"cpu",kernelFunc:qde},Xde=Vt(ld,e=>Math.tan(e)),Yde={kernelName:ld,backendName:"cpu",kernelFunc:Xde},Jde=Vt(ud,e=>Math.tanh(e)),Zde={kernelName:ud,backendName:"cpu",kernelFunc:Jde};function Qde(e){let{inputs:t,backend:n}=e,{tensor:a,indices:r,updates:s}=t,{sliceRank:i,numUpdates:o,sliceSize:u,strides:d,outputSize:c}=O.calculateShapes(s,r,a.shape),p=!1,m=n.bufferSync(r),g=n.bufferSync(s),b=n.bufferSync(a),v=bu(m,g,a.shape,c,u,o,i,d,b,p);return n.makeTensorInfo(a.shape,v.dtype,v.values)}var ehe={kernelName:Wp,backendName:"cpu",kernelFunc:Qde};function the(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reps:s}=a;Ue(r,"tile");let i=FL(n.bufferSync(r),s);return n.makeTensorInfo(i.shape,i.dtype,i.values)}var nhe={kernelName:xl,backendName:"cpu",kernelFunc:the};function ahe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{k:s,sorted:i}=a;Ue(r,"topk");let o=n.data.get(r.dataId).values,[u,d]=LL(o,r.shape,r.dtype,s,i);return[n.makeTensorInfo(u.shape,u.dtype,u.values),n.makeTensorInfo(d.shape,d.dtype,d.values)]}var rhe={kernelName:Zp,backendName:"cpu",kernelFunc:ahe};function she(e){let{inputs:t,attrs:n,backend:a}=e,{image:r,transforms:s}=t,{interpolation:i,fillMode:o,fillValue:u,outputShape:d}=n,[c,p,m,g]=r.shape,[b,v]=d??[p,m],x=[c,b,v,g],w=E.computeStrides(r.shape),k=w[0],N=w[1],I=w[2],T=E.computeStrides(x),$=T[0],D=T[1],M=T[2],B=E.getTypedArrayFromDType(r.dtype,E.sizeFromShape(x));B.fill(u);let V=a.data.get(r.dataId).values,W=a.data.get(s.dataId).values;for(let R=0;R<c;++R){let H=s.shape[0]===1?W:W.subarray(R*8,R*8+8);for(let Z=0;Z<b;++Z)for(let ae=0;ae<v;++ae)for(let j=0;j<g;++j){let K,Q=H[6]*ae+H[7]*Z+1;if(Q===0)continue;let ce=(H[0]*ae+H[1]*Z+H[2])/Q,me=(H[3]*ae+H[4]*Z+H[5])/Q,L=TR(ce,m,o),ee=TR(me,p,o);switch(i){case"nearest":K=dhe(V,p,m,k,N,I,R,ee,L,j,u);break;case"bilinear":K=hhe(V,p,m,k,N,I,R,ee,L,j,u);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}let ie=R*$+Z*D+ae*M+j;B[ie]=K}return a.makeTensorInfo(x,r.dtype,B)}return{dataId:a.write(B,x,r.dtype),shape:r.shape,dtype:r.dtype}}var ihe={kernelName:Qp,backendName:"cpu",kernelFunc:she};function TR(e,t,n){switch(n){case"reflect":return ohe(e,t);case"wrap":return lhe(e,t);case"nearest":return che(e,t);default:return uhe(e)}}function ohe(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let a=2*t;n<a&&(n=a*Math.trunc(-n/a)+n),n=n<-t?n+a:-n-1}else if(n>t-1)if(t<=1)n=0;else{let a=2*t;n-=a*Math.trunc(n/a),n>=t&&(n=a-n-1)}return E.clamp(0,n,t-1)}function lhe(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let a=t-1;n+=t*(Math.trunc(-n/a)+1)}else if(n>t-1)if(t<=1)n=0;else{let a=t-1;n-=t*Math.trunc(n/a)}return E.clamp(0,n,t-1)}function uhe(e,t){return e}function che(e,t){return E.clamp(0,e,t-1)}function Rm(e,t,n,a,r,s,i,o,u,d,c){let p=i*a+o*r+u*s+d;return 0<=o&&o<t&&0<=u&&u<n?e[p]:c}function dhe(e,t,n,a,r,s,i,o,u,d,c){let p=Math.round(o),m=Math.round(u);return Rm(e,t,n,a,r,s,i,p,m,d,c)}function hhe(e,t,n,a,r,s,i,o,u,d,c){let p=Math.floor(o),m=Math.floor(u),g=p+1,b=m+1,v=(b-u)*Rm(e,t,n,a,r,s,i,p,m,d,c)+(u-m)*Rm(e,t,n,a,r,s,i,p,b,d,c),x=(b-u)*Rm(e,t,n,a,r,s,i,g,m,d,c)+(u-m)*Rm(e,t,n,a,r,s,i,g,b,d,c);return(g-o)*v+(o-p)*x}function phe(e){let{inputs:t,attrs:n,backend:a}=e,{axis:r}=n,{x:s}=t;Ue(s,"unique");let i=a.data.get(s.dataId).values,{outputValues:o,outputShape:u,indices:d}=SI(i,r,s.shape,s.dtype);return[a.makeTensorInfo(u,s.dtype,o),a.makeTensorInfo([d.length],"int32",d)]}var fhe={kernelName:Hg,backendName:"cpu",kernelFunc:phe};function mhe(e){let{inputs:t,backend:n,attrs:a}=e,{value:r}=t,{axis:s}=a;s<0&&(s+=r.shape.length);let i=r.shape.length,o=r.shape[s],u=new Array(i-1),d=0;for(let g=0;g<i;g++)g!==s&&(u[d++]=r.shape[g]);let c=new Array(i).fill(0),p=r.shape.slice();p[s]=1;let m=new Array(o);for(let g=0;g<m.length;g++){c[s]=g;let b=Bu({inputs:{x:r},backend:n,attrs:{begin:c,size:p}});m[g]=cn({inputs:{x:b},backend:n,attrs:{shape:u}}),n.disposeIntermediateTensorInfo(b)}return m}var ghe={kernelName:ef,backendName:"cpu",kernelFunc:mhe};function yhe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,segmentIds:s}=t,{numSegments:i}=a;Ue(r,"unsortedSegmentSum");let o=r.shape.length,u=s.shape.length,d=[],c=[],p=o-u,m=s;for(let b=0;b<p;++b){let v=Vv({inputs:{input:m},backend:n,attrs:{dim:b+1}});m=v,c.push(v)}for(let b=0;b<i;++b){let v=E.createScalarValue(b,"int32"),x=n.makeTensorInfo([],"int32",v),w=sL({inputs:{a:x,b:m},backend:n}),k=pl({inputs:{x:w},backend:n,attrs:{dtype:"float32"}}),N=Ix({inputs:{a:k,b:r},backend:n}),I=wy({inputs:{x:N},backend:n,attrs:{axis:0,keepDims:!1}});d.push(I),c.push(x),c.push(w),c.push(k),c.push(N),c.push(I)}let g=QL({inputs:d,backend:n,attrs:{axis:0}});return c.forEach(b=>n.disposeIntermediateTensorInfo(b)),g}var bhe={kernelName:Gg,backendName:"cpu",kernelFunc:yhe},vhe=[hoe,Hse,foe,goe,Jse,boe,xoe,Soe,_oe,Ioe,Eoe,Aoe,Roe,Moe,zoe,Poe,joe,Voe,Goe,coe,Koe,Yoe,Zoe,Qse,ele,Xse,tie,nle,Gse,rle,ile,ole,ule,dle,ple,mle,yle,vle,wle,kle,Nle,Tle,Cle,$le,Rle,Ole,Fle,Lle,Ble,Ple,Ule,Wle,Gle,aoe,Kle,nie,nue,aie,aue,sie,uue,cue,hue,oie,uie,fue,gue,bue,xue,die,pie,qse,Sue,sle,_ue,Iue,Eue,roe,mie,yie,Aue,vie,Rue,Mue,zue,Pue,jue,Vue,Hue,wie,que,Xue,Jue,Que,tce,ace,sce,kie,oce,cce,fce,Nie,Tie,yce,xce,kce,Cie,Nce,Tce,Ece,eB,Rce,ioe,Rie,Oce,Fce,Lce,Pce,Kse,gk,jce,ooe,loe,uoe,Vce,Gce,Kce,Yce,Zce,Qce,tde,Uie,ade,lde,cde,fde,Wie,gde,bde,xde,Vie,hce,kde,Nde,Tde,Cde,$de,Dde,Mde,zde,qie,Lde,Xie,Jie,Pde,jde,Vde,Gde,Kde,toe,Vle,Yde,Zde,ehe,nhe,rhe,ihe,Aie,fhe,ghe,bhe,Ice];for(let e of vhe)qg(e);var tB={};ot(tB,{assertNotComplex:()=>gf,bindCanvasToFramebuffer:()=>Ahe,bindColorTextureToFramebuffer:()=>mv,bindTextureToProgramUniformSampler:()=>yB,bindTextureUnit:()=>fB,bindVertexBufferToProgramAttribute:()=>bk,callAndCheck:()=>Me,canBeRepresented:()=>aB,createFragmentShader:()=>iB,createFramebuffer:()=>pB,createProgram:()=>oB,createStaticIndexBuffer:()=>cB,createStaticVertexBuffer:()=>uB,createTexture:()=>dB,createVertexShader:()=>sB,getBatchDim:()=>Pu,getExtensionOrThrow:()=>Dm,getFramebufferErrorMessage:()=>bB,getMaxTexturesInShader:()=>SB,getNumChannels:()=>Ehe,getProgramUniformLocation:()=>gB,getProgramUniformLocationOrThrow:()=>mB,getRowsCols:()=>Uu,getShapeAs3D:()=>Mm,getTextureShapeFromLogicalShape:()=>xB,getWebGLDisjointQueryTimerVersion:()=>kB,getWebGLErrorMessage:()=>rB,getWebGLMaxTextureSize:()=>wB,hasExtension:()=>Kr,isCapableOfRenderingToFloatTexture:()=>_B,isDownloadFloatTextureEnabled:()=>NB,isReshapeFree:()=>lg,isWebGLFenceEnabled:()=>IB,isWebGLVersionEnabled:()=>xk,linkProgram:()=>lB,logShaderSourceAndInfoLog:()=>TI,resetMaxTextureSize:()=>$he,resetMaxTexturesInShader:()=>Rhe,unbindColorTextureFromFramebuffer:()=>vk,unbindTextureUnit:()=>Che,validateFramebuffer:()=>Om,validateProgram:()=>fv,validateTextureSize:()=>hB});var fu={},Zb={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function nB(e,t){fu[e]=t}function Ws(e,t){if(!(e in fu)||t!=null){let a=whe(e,t);if(a!==null)fu[e]=a;else return console.log("Could not get context for WebGL version",e),null}let n=fu[e];return n==null||n.isContextLost()?(delete fu[e],Ws(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),fu[e])}function xhe(e){if(!oe().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&e===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function whe(e,t){if(e!==1&&e!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");let n=t??xhe(e);return n.addEventListener("webglcontextlost",a=>{a.preventDefault(),delete fu[e]},!1),oe().getBool("SOFTWARE_WEBGL_ENABLED")&&(Zb.failIfMajorPerformanceCaveat=!1),e===1?n.getContext("webgl",Zb)||n.getContext("experimental-webgl",Zb):n.getContext("webgl2",Zb)}var og;(function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"})(og||(og={}));var qr;(function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"})(qr||(qr={}));var _a;(function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(_a||(_a={}));function Sy(e,t){return[t,e]}function She(e,t){return e*t}function Qb(e){let t=E.sizeFromShape(e),n=Math.ceil(t/4);return E.sizeToSquarishShape(n)}function mf(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function khe(e,t){let[n,a]=mf(e,t);return n*a*4}function II(e,t){let n=e,a,r,s,i,o,u,d,c,p,m;return oe().getNumber("WEBGL_VERSION")===2?(a=n.R32F,r=n.R16F,s=n.RGBA16F,i=n.RGBA32F,o=n.RED,d=4,c=1,p=n.HALF_FLOAT,m=n.FLOAT,u=n.RGBA8):(a=e.RGBA,r=e.RGBA,s=e.RGBA,i=n.RGBA,o=e.RGBA,d=4,c=4,p=t!=null?t.HALF_FLOAT_OES:null,m=e.FLOAT,u=e.RGBA),{internalFormatFloat:a,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:i,textureFormatFloat:o,downloadTextureFormat:u,downloadUnpackNumChannels:d,defaultNumChannels:c,textureTypeHalfFloat:p,textureTypeFloat:m}}function Me(e,t){let n=t();return oe().getBool("DEBUG")&&_he(e),n}function _he(e){let t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+rB(e,t))}var Nhe=596e-10,Ihe=65504;function aB(e){return!!(oe().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||e===0||Nhe<Math.abs(e)&&Math.abs(e)<Ihe)}function rB(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function Dm(e,t){return so(e,()=>e.getExtension(t),'Extension "'+t+'" not supported on this browser.')}function sB(e,t){let n=so(e,()=>e.createShader(e.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(Me(e,()=>e.shaderSource(n,t)),Me(e,()=>e.compileShader(n)),e.getShaderParameter(n,e.COMPILE_STATUS)===!1)throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function iB(e,t){let n=so(e,()=>e.createShader(e.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(Me(e,()=>e.shaderSource(n,t)),Me(e,()=>e.compileShader(n)),oe().get("ENGINE_COMPILE_ONLY"))return n;if(e.getShaderParameter(n,e.COMPILE_STATUS)===!1)throw TI(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}var The=/ERROR: [0-9]+:([0-9]+):/g;function TI(e,t){let n=The.exec(t);if(n==null){console.log(`Couldn't parse line number in error: ${t}`),console.log(e);return}let a=+n[1],r=e.split(`
`),s=r.length.toString().length+2,i=r.map((p,m)=>E.rightPad((m+1).toString(),s)+p),o=0;for(let p=0;p<i.length;p++)o=Math.max(i[p].length,o);let u=i.slice(0,a-1),d=i.slice(a-1,a),c=i.slice(a);console.log(u.join(`
`)),console.log(t.split(`
`)[0]),console.log(`%c ${E.rightPad(d[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join(`
`))}function oB(e){return so(e,()=>e.createProgram(),"Unable to create WebGLProgram.")}function lB(e,t){if(Me(e,()=>e.linkProgram(t)),!oe().get("ENGINE_COMPILE_ONLY")&&e.getProgramParameter(t,e.LINK_STATUS)===!1)throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function fv(e,t){if(Me(e,()=>e.validateProgram(t)),e.getProgramParameter(t,e.VALIDATE_STATUS)===!1)throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function uB(e,t){let n=so(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return Me(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),Me(e,()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function cB(e,t){let n=so(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return Me(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n)),Me(e,()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function Ehe(){return oe().getNumber("WEBGL_VERSION")===2?1:4}function dB(e){return so(e,()=>e.createTexture(),"Unable to create WebGLTexture.")}function hB(e,t){let n=oe().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0){let a=`[${e}x${t}]`;throw new Error("Requested texture size "+a+" is invalid.")}if(e>n||t>n){let a=`[${e}x${t}]`,r=`[${n}x${n}]`;throw new Error("Requested texture size "+a+" greater than WebGL maximum on this browser / GPU "+r+".")}}function pB(e){return so(e,()=>e.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function bk(e,t,n,a,r,s,i){let o=e.getAttribLocation(t,n);return o===-1?!1:(Me(e,()=>e.bindBuffer(e.ARRAY_BUFFER,a)),Me(e,()=>e.vertexAttribPointer(o,r,e.FLOAT,!1,s,i)),Me(e,()=>e.enableVertexAttribArray(o)),!0)}function fB(e,t,n){vB(e,n),Me(e,()=>e.activeTexture(e.TEXTURE0+n)),Me(e,()=>e.bindTexture(e.TEXTURE_2D,t))}function Che(e,t){vB(e,t),Me(e,()=>e.activeTexture(e.TEXTURE0+t)),Me(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function mB(e,t,n){return so(e,()=>e.getUniformLocation(t,n),'uniform "'+n+'" not present in program.')}function gB(e,t,n){return e.getUniformLocation(t,n)}function yB(e,t,n,a){Me(e,()=>fB(e,t,a)),Me(e,()=>e.uniform1i(n,a))}function Ahe(e){Me(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),Me(e,()=>e.viewport(0,0,e.canvas.width,e.canvas.height)),Me(e,()=>e.scissor(0,0,e.canvas.width,e.canvas.height))}function mv(e,t,n){Me(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,n)),Me(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0))}function vk(e,t){Me(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,t)),Me(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0))}function Om(e){let t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+bB(e,t))}function bB(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function so(e,t,n){let a=Me(e,()=>t());if(a==null)throw new Error(n);return a}function vB(e,t){let n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,a=t+e.TEXTURE0;if(a<e.TEXTURE0||a>n){let r=`[gl.TEXTURE0, gl.TEXTURE${n}]`;throw new Error(`textureUnit must be in ${r}.`)}}function Pu(e,t=2){return E.sizeFromShape(e.slice(0,e.length-t))}function Uu(e){if(e.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function Mm(e){let t=[1,1,1];return e.length===0||e.length===1&&e[0]===1||(t=[Pu(e),...Uu(e)]),t}function xB(e,t=!1){let n=oe().getNumber("WEBGL_MAX_TEXTURE_SIZE"),a=oe().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");a===1/0&&oe().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(a=n/2),t&&(n=n*2,a=a*2,e=e.map((o,u)=>u>=e.length-2?E.nearestLargerEven(e[u]):e[u]),e.length===1&&(e=[2,e[0]])),e.length!==2&&(e=E.squeezeShape(e).newShape);let r=E.sizeFromShape(e),s=null;e.length<=1&&r<=n?s=[1,r]:e.length===2&&e[0]<=n&&e[1]<=n?s=e:e.length===3&&e[0]*e[1]<=n&&e[2]<=n?s=[e[0]*e[1],e[2]]:e.length===3&&e[0]<=n&&e[1]*e[2]<=n?s=[e[0],e[1]*e[2]]:e.length===4&&e[0]*e[1]*e[2]<=n&&e[3]<=n?s=[e[0]*e[1]*e[2],e[3]]:e.length===4&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(s=[e[0],e[1]*e[2]*e[3]]);let i=s!=null&&Math.max(...s)>a&&Math.min(...s)<=(t?2:1)&&Math.min(...s)>0;if(s==null||i)if(t){let o=Pu(e),u=2,d=2;e.length&&([u,d]=Uu(e)),r=o*(u/2)*(d/2),s=E.sizeToSquarishShape(r).map(c=>c*2)}else s=E.sizeToSquarishShape(r);return s}function ev(e){return e%2===0}function lg(e,t){if(e=e.slice(-2),t=t.slice(-2),E.arraysEqual(e,t)||!e.length||!t.length||e[0]===0||e[1]===0||t[0]===0||t[1]===0)return!0;if(e.length!==t.length){let n=e[e.length-1],a=t[t.length-1];if(n===a||ev(n)&&ev(a)&&(e[0]===1||t[0]===1))return!0}return e[1]===t[1]&&ev(e[0])&&ev(t[0])}var gv,yv;function wB(e){if(gv==null){let t=Ws(e);gv=t.getParameter(t.MAX_TEXTURE_SIZE)}return gv}function $he(){gv=null}function Rhe(){yv=null}function SB(e){if(yv==null){let t=Ws(e);yv=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,yv)}function kB(e){if(e===0)return 0;let t,n=Ws(e);return Kr(n,"EXT_disjoint_timer_query_webgl2")&&e===2?t=2:Kr(n,"EXT_disjoint_timer_query")?t=1:t=0,t}function Kr(e,t){return e.getExtension(t)!=null}function xk(e){try{if(Ws(e)!=null)return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function _B(e){if(e===0)return!1;let t=Ws(e);if(e===1){if(!Kr(t,"OES_texture_float"))return!1}else if(!Kr(t,"EXT_color_buffer_float"))return!1;return wk(t)}function NB(e){if(e===0)return!1;let t=Ws(e);if(e===1){if(!Kr(t,"OES_texture_float")||!Kr(t,"WEBGL_color_buffer_float"))return!1}else{if(Kr(t,"EXT_color_buffer_float"))return wk(t);let n="EXT_color_buffer_half_float";if(Kr(t,n)){let a=t.getExtension(n);return Dhe(t,a)}return!1}return wk(t)}function wk(e){let t=II(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n),e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);let a=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,a),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);let r=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(a),r}function Dhe(e,t){let n=II(e,t),a=e.createTexture();e.bindTexture(e.TEXTURE_2D,a),e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);let r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,a,0);let s=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(a),e.deleteFramebuffer(r),s}function IB(e){return e!==2?!1:Ws(e).fenceSync!=null}function gf(e,t){Array.isArray(e)||(e=[e]),e.forEach(n=>{n!=null&&E.assert(n.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}var je=oe();je.registerFlag("HAS_WEBGL",()=>je.getNumber("WEBGL_VERSION")>0);je.registerFlag("WEBGL_VERSION",()=>xk(2)?2:xk(1)?1:0);je.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);je.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>je.get("WEBGL_VERSION")===2);je.registerFlag("WEBGL_CPU_FORWARD",()=>!0);je.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);je.registerFlag("WEBGL_PACK",()=>je.getBool("HAS_WEBGL"));je.registerFlag("WEBGL_PACK_NORMALIZATION",()=>je.getBool("WEBGL_PACK"));je.registerFlag("WEBGL_PACK_CLIP",()=>je.getBool("WEBGL_PACK"));je.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>je.getBool("WEBGL_PACK"));je.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>je.getBool("WEBGL_PACK"));je.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>je.getBool("WEBGL_PACK"));je.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>je.getBool("WEBGL_PACK"));je.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>je.getBool("WEBGL_PACK"));je.registerFlag("WEBGL_PACK_REDUCE",()=>je.getBool("WEBGL_PACK"));je.registerFlag("WEBGL_LAZILY_UNPACK",()=>je.getBool("WEBGL_PACK"));je.registerFlag("WEBGL_CONV_IM2COL",()=>je.getBool("WEBGL_PACK"));je.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>je.getBool("WEBGL_PACK"));je.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>wB(je.getNumber("WEBGL_VERSION")));je.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>SB(je.getNumber("WEBGL_VERSION")));je.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{let e=je.getNumber("WEBGL_VERSION");return e===0?0:kB(e)});je.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>je.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Yg.isMobile());je.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>_B(je.getNumber("WEBGL_VERSION")));je.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>je.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:je.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));je.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>NB(je.getNumber("WEBGL_VERSION")));je.registerFlag("WEBGL_FENCE_API_ENABLED",()=>IB(je.getNumber("WEBGL_VERSION")));je.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>je.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);je.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,e=>{if(typeof e!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${e}.`);if(e<0&&e!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)});je.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>Yg.isMobile()?1:-1,e=>{if(typeof e!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${e}.`);if(e<0&&e!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)});je.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);je.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);je.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);je.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);je.registerFlag("WEBGL_EXP_CONV",()=>!1);je.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>je.getBool("IS_TEST"));je.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);je.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);je.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);je.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);function er(){let e,t,n,a,r,s,i,o,u,d;return oe().getNumber("WEBGL_VERSION")===2?(e="#version 300 es",t="in",n="out",a="in",r="texture",s="outputColor",i="out vec4 outputColor;",o=oe().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",u="",d=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(e="",t="attribute",n="varying",a="varying",r="texture2D",s="gl_FragColor",i="",o=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,u=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,d=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:e,attribute:t,varyingVs:n,varyingFs:a,texture2D:r,output:s,defineOutput:i,defineSpecialNaN:o,defineSpecialInf:u,defineRound:d}}function yd(e,t,n="index"){let a=E.computeStrides(t);return a.map((r,s)=>{let i=`int ${e[s]} = ${n} / ${r}`,o=s===a.length-1?`int ${e[s+1]} = ${n} - ${e[s]} * ${r}`:`index -= ${e[s]} * ${r}`;return`${i}; ${o};`}).join("")}function Tx(e,t,n="index"){let a=E.computeStrides(t);return a.map((r,s)=>{let i=`int ${e[s]} = ${n} / outShapeStrides[${s}]`,o=s===a.length-1?`int ${e[s+1]} = ${n} - ${e[s]} * outShapeStrides[${s}]`:`index -= ${e[s]} * outShapeStrides[${s}]`;return`${i}; ${o};`}).join("")}function Ohe(e,t){let n=e.length,a=e.map(s=>`${t}[${s}]`),r=new Array(n-1);r[n-2]=a[n-1];for(let s=n-3;s>=0;--s)r[s]=`(${r[s+1]} * ${a[s+1]})`;return r}function Mhe(e,t,n="index"){let a=e.map((s,i)=>i),r=Ohe(a,t);return r.map((s,i)=>{let o=`int ${e[i]} = ${n} / ${r[i]}`,u=i===r.length-1?`int ${e[i+1]} = ${n} - ${e[i]} * ${r[i]}`:`index -= ${e[i]} * ${r[i]}`;return`${o}; ${u};`}).join("")}function EI(e){let t=E.computeStrides(e).map(n=>n.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;
  }
`}function CI(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}var TB=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`,{getBroadcastDims:EB}=O;function Fhe(e,t,n){let a=[];if(e.forEach(m=>{let g=E.sizeFromShape(m.shapeInfo.logicalShape);if(m.shapeInfo.isUniform?a.push(`uniform float ${m.name}${g>1?`[${g}]`:""};`):(a.push(`uniform sampler2D ${m.name};`),a.push(`uniform int offset${m.name};`)),n.enableShapeUniforms){let{uniformShape:b}=AI(n.packedInputs,m.shapeInfo.logicalShape,m.shapeInfo.texShape);switch(b.length){case 1:a.push(`uniform int ${m.name}Shape;`);break;case 2:a.push(`uniform ivec2 ${m.name}Shape;`);break;case 3:a.push(`uniform ivec3 ${m.name}Shape;`);break;case 4:a.push(`uniform ivec4 ${m.name}Shape;`);break}a.push(`uniform ivec2 ${m.name}TexShape;`)}}),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:a.push("uniform int outShape;");break;case 2:a.push("uniform ivec2 outShape;"),a.push("uniform int outShapeStrides;");break;case 3:a.push("uniform ivec3 outShape;"),a.push("uniform ivec2 outShapeStrides;");break;case 4:a.push("uniform ivec4 outShape;"),a.push("uniform ivec3 outShapeStrides;");break}a.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach(m=>{a.push(`uniform ${m.type} ${m.name}${m.arrayIndex?`[${m.arrayIndex}]`:""};`)});let r=a.join(`
`),s=e.map(m=>zhe(m,t,n.packedInputs,n.enableShapeUniforms)).join(`
`),i=t.texShape,o=er(),u=Phe(o),d,c,p=Whe(o);return t.isPacked?(d=Lhe(t.logicalShape,i,n.enableShapeUniforms),c=jhe(o)):(d=Bhe(t.logicalShape,i,n.enableShapeUniforms),c=Uhe(o)),n.packedInputs&&(p+=qhe),[p,u,c,r,d,s,n.userCode].join(`
`)}function yf(e,t=!1){let n=e.shapeInfo.logicalShape;switch(n.length){case 0:return spe(e,t);case 1:return ope(e,t);case 2:return upe(e,t);case 3:return dpe(e,t);case 4:return ppe(e,t);case 5:return fpe(e);case 6:return mpe(e);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function CB(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return rpe(e);case 1:return ipe(e,t);case 2:return lpe(e,t);case 3:return cpe(e,t);default:return hpe(e,t)}}function zhe(e,t,n=!1,a){let r="";n?r+=CB(e,a):r+=yf(e,a);let s=e.shapeInfo.logicalShape,i=t.logicalShape;return s.length<=i.length&&(n?r+=gpe(e,t):r+=ype(e,t)),r}function Lhe(e,t,n){switch(e.length){case 0:return AB();case 1:return Khe(e,t,n);case 2:return npe(e,t,n);case 3:return Yhe(e,t,n);default:return Zhe(e,t,n)}}function Bhe(e,t,n){switch(e.length){case 0:return AB();case 1:return Xhe(e,t,n);case 2:return ape(e,t,n);case 3:return Jhe(e,t,n);case 4:return Qhe(e,t,n);case 5:return epe(e,t);case 6:return tpe(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}function Phe(e){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${e.texture2D}(textureSampler, uv).r;
    }
  `}function Uhe(e){return`
    void setOutput(float val) {
      ${e.output} = vec4(val, 0, 0, 0);
    }
  `}function jhe(e){return`
    void setOutput(vec4 val) {
      ${e.output} = val;
    }
  `}function Whe(e){return`${e.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${e.varyingFs} vec2 resultUV;
    ${e.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${e.defineSpecialNaN}
    ${e.defineSpecialInf}
    ${e.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${Vhe}
    ${Hhe}
    ${Ghe}
  `}var Vhe=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Hhe=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Ghe=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,qhe=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function AB(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function Khe(e,t,n){let a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return a[0]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${a[1]}.0);
      }
    `:a[1]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${a[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${a[0]}, ${a[1]}));
      return 2 * (resTexRC.x * ${a[1]} + resTexRC.y);
    }
  `}function Xhe(e,t,n){return t[0]===1?n?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${t[1]}.0);
      }
    `:t[1]===1?n?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${t[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      return resTexRC.x * ${t[1]} + resTexRC.y;
    }
  `}function Yhe(e,t,n){if(n)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;let a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[2]/2),s=r*Math.ceil(e[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${a[0]}, ${a[1]}));
      int index = resTexRC.x * ${a[1]} + resTexRC.y;

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec3(b, r, c);
    }
  `}function Jhe(e,t,n){if(n)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${Tx(["r","c","d"],e)}
    return ivec3(r, c, d);
  }
`;let a=yd(["r","c","d"],e);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${a}
      return ivec3(r, c, d);
    }
  `}function Zhe(e,t,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;let a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[e.length-1]/2),s=r*Math.ceil(e[e.length-2]/2),i=s,o="",u="b, r, c";for(let d=2;d<e.length-1;d++)i*=e[e.length-d-1],o=`
      int b${d} = index / ${i};
      index -= b${d} * ${i};
    `+o,u=`b${d}, `+u;return`
    ivec${e.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${a[0]}, ${a[1]}));
      int index = resTexRC.x * ${a[1]} + resTexRC.y;

      ${o}

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec${e.length}(${u});
    }
  `}function Qhe(e,t,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${Tx(["r","c","d","d2"],e)}
      return ivec4(r, c, d, d2);
    }
  `;let a=yd(["r","c","d","d2"],e);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${a}
      return ivec4(r, c, d, d2);
    }
  `}function epe(e,t){let n=yd(["r","c","d","d2","d3"],e);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},
                             ${t[1]}));

      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${n}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function tpe(e,t){let n=yd(["r","c","d","d2","d3","d4"],e);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${n}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function npe(e,t,n){let a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(E.arraysEqual(e,t))return n?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${a[0]}, ${a[1]}));
      }
    `;let r=Math.ceil(e[1]/2);return n?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${a[0]}, ${a[1]}));

      int index = resTexRC.x * ${a[1]} + resTexRC.y;
      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec2(r, c);
    }
  `}function ape(e,t,n){return E.arraysEqual(e,t)?n?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));
      }
    `:e[1]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:e[0]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:n?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      int r = index / ${e[1]};
      int c = index - r * ${e[1]};
      return ivec2(r, c);
    }
  `}function bd(e){return`offset${e}`}function rpe(e){let t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),a=er();return`
    vec4 ${n}() {
      return ${a.texture2D}(${t}, halfCR);
    }
  `}function spe(e,t){let n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${a}() {return ${n};}`;let[r,s]=e.shapeInfo.texShape;if(r===1&&s===1)return`
      float ${a}() {
        return sampleTexture(${n}, halfCR);
      }
    `;let i=bd(n);if(t)return`
    float ${a}() {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${i});
      return sampleTexture(${n}, uv);
    }
  `;let[o,u]=e.shapeInfo.texShape;return`
    float ${a}() {
      vec2 uv = uvFromFlat(${o}, ${u}, ${i});
      return sampleTexture(${n}, uv);
    }
  `}function ipe(e,t){let n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),r=e.shapeInfo.texShape,s=er();if(t)return`
    vec4 ${a}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${s.texture2D}(${n}, uv);
    }
  `;let i=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return`
    vec4 ${a}(int index) {
      vec2 uv = packedUVfrom1D(
        ${i[0]}, ${i[1]}, index);
      return ${s.texture2D}(${n}, uv);
    }
  `}function ope(e,t){let n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`
      float ${a}(int index) {
        ${bf(e)}
      }
    `;let r=e.shapeInfo.texShape,s=r[0],i=r[1];if(i===1&&s===1)return`
      float ${a}(int index) {
        return sampleTexture(${n}, halfCR);
      }
    `;let o=bd(n);return i===1?t?`
      float ${a}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${a}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${s}.0);
        return sampleTexture(${n}, uv);
      }
    `:s===1?t?`
      float ${a}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${a}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${i}.0, 0.5);
        return sampleTexture(${n}, uv);
      }
    `:t?`
    float ${a}(int index) {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${o});
      return sampleTexture(${n}, uv);
    }
  `:`
    float ${a}(int index) {
      vec2 uv = uvFromFlat(${s}, ${i}, index + ${o});
      return sampleTexture(${n}, uv);
    }
  `}function lpe(e,t){let n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),s=e.shapeInfo.texShape,i=s[0],o=s[1],u=er();if(s!=null&&E.arraysEqual(n,s))return t?`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}TexShape[1], ${a}TexShape[0]);

        return ${u.texture2D}(${a}, uv);
      }
    `:`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${i}.0);

        return ${u.texture2D}(${a}, uv);
      }
    `;if(t)return`
    vec4 ${r}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${a}TexShape[0]) / 2.0), ceil(float(${a}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${a}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${u.texture2D}(${a}, uv);
    }
  `;let d=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],c=Math.ceil(n[1]/2);return`
    vec4 ${r}(int row, int col) {
      vec2 uv = packedUVfrom2D(${c}, ${d[0]}, ${d[1]}, row, col);
      return ${u.texture2D}(${a}, uv);
    }
  `}function upe(e,t){let n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),s=e.shapeInfo.texShape;if(s!=null&&E.arraysEqual(n,s)){if(t)return`
      float ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}TexShape[1], ${a}TexShape[0]);
        return sampleTexture(${a}, uv);
      }
    `;let m=s[0],g=s[1];return`
    float ${r}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${g}.0, ${m}.0);
      return sampleTexture(${a}, uv);
    }
  `}let{newShape:i,keptDims:o}=E.squeezeShape(n),u=i;if(u.length<n.length){let m=vf(e,u),g=["row","col"];return`
      ${yf(m,t)}
      float ${r}(int row, int col) {
        return ${r}(${xf(g,o)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${r}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));
        ${bf(e)}
      }
    `;let d=s[0],c=s[1],p=bd(a);return c===1?t?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${a}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${a}TexShape[0]));
        return sampleTexture(${a}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${d}.0);
      return sampleTexture(${a}, uv);
    }
  `:d===1?t?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${a}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${a}TexShape[1]), 0.5);
        return sampleTexture(${a}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);
      return sampleTexture(${a}, uv);
    }
  `:t?`
      float ${r}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${a}Shape[1] + col + ${p};
        vec2 uv = uvFromFlat(${a}TexShape[0], ${a}TexShape[1], index);
        return sampleTexture(${a}, uv);
      }
    `:`
  float ${r}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${n[1]} + col + ${p};
    vec2 uv = uvFromFlat(${d}, ${c}, index);
    return sampleTexture(${a}, uv);
  }
`}function cpe(e,t){let n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),s=e.shapeInfo.texShape,i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(n[0]===1){let m=n.slice(1),g=[1,2],b=vf(e,m),v=["b","row","col"];return`
        ${CB(b,t)}
        vec4 ${r}(int b, int row, int col) {
          return ${r}(${xf(v,g)});
        }
      `}let o=er();if(t)return`
    vec4 ${r}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${a}TexShape[0]) / 2.0), ceil(float(${a}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${a}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${a}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${o.texture2D}(${a}, uv);
    }
  `;let u=i[0],d=i[1],c=Math.ceil(n[2]/2),p=c*Math.ceil(n[1]/2);return`
    vec4 ${r}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${u}, ${d}, ${p}, ${c}, b, row, col);
      return ${o.texture2D}(${a}, uv);
    }
  `}function dpe(e,t){let n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),s=n[1]*n[2],i=n[2],{newShape:o,keptDims:u}=E.squeezeShape(n),d=o;if(d.length<n.length){let v=vf(e,d),x=["row","col","depth"];return`
        ${yf(v,t)}
        float ${r}(int row, int col, int depth) {
          return ${r}(${xf(x,u)});
        }
      `}if(e.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${s}, ${i}, 1)));
        ${bf(e)}
      }
    `;let c=e.shapeInfo.texShape,p=c[0],m=c[1],g=e.shapeInfo.flatOffset;if(m===s&&g==null)return t?`
      float ${r}(int row, int col, int depth) {
        int stride1 = ${a}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${a}TexShape[1], ${a}TexShape[0]);
        return sampleTexture(${a}, uv);
      }
    `:`
        float ${r}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${i}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${m}.0, ${p}.0);
          return sampleTexture(${a}, uv);
        }
      `;if(m===i&&g==null)return t?`
      float ${r}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${a}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${a}TexShape[1], ${a}TexShape[0]);
        return sampleTexture(${a}, uv);
      }
    `:`
    float ${r}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${m}.0, ${p}.0);
      return sampleTexture(${a}, uv);
    }
  `;let b=bd(a);return t?`
    float ${r}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${a}Shape[1] * ${a}Shape[2];
      int stride1 = ${a}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${b};
      vec2 uv = uvFromFlat(${a}TexShape[0], ${a}TexShape[1], index);
      return sampleTexture(${a}, uv);
    }
    `:`
      float ${r}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s} + col * ${i} + depth + ${b};
        vec2 uv = uvFromFlat(${p}, ${m}, index);
        return sampleTexture(${a}, uv);
      }
  `}function hpe(e,t){let n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),r=er();if(t)return`
    vec4 ${a}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${n}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${r.texture2D}(${n}, uv);
    }
  `;let s=e.shapeInfo.logicalShape,i=s.length,o=e.shapeInfo.texShape,u=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],d=u[0],c=u[1],p=Math.ceil(s[i-1]/2),m=p*Math.ceil(s[i-2]/2),g="int b, int row, int col",b=`b * ${m} + (row / 2) * ${p} + (col / 2)`;for(let v=2;v<i-1;v++)g=`int b${v}, `+g,m*=s[i-v-1],b=`b${v} * ${m} + `+b;return`
    vec4 ${a}(${g}) {
      int index = ${b};
      int texR = index / ${c};
      int texC = index - texR * ${c};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${d});
      return ${r.texture2D}(${n}, uv);
    }
  `}function ppe(e,t){let n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),s=n[3],i=n[2]*s,o=n[1]*i,{newShape:u,keptDims:d}=E.squeezeShape(n);if(u.length<n.length){let k=vf(e,u),N=["row","col","depth","depth2"];return`
      ${yf(k,t)}
      float ${r}(int row, int col, int depth, int depth2) {
        return ${r}(${xf(N,d)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${o}, ${i}, ${s}, 1)));
        ${bf(e)}
      }
    `;let c=e.shapeInfo.flatOffset,p=e.shapeInfo.texShape,m=p[0],g=p[1],b=`int stride2 = ${a}Shape[3];`,v=`int stride1 = ${a}Shape[2] * stride2;`,x=`int stride0 = ${a}Shape[1] * stride1;`;if(g===o&&c==null)return t?`
      float ${r}(int row, int col, int depth, int depth2) {
        ${b}
        ${v}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${a}TexShape[1], ${a}TexShape[0]);
        return sampleTexture(${a}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${i}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${g}.0, ${m}.0);
        return sampleTexture(${a}, uv);
      }
    `;if(g===s&&c==null)return t?`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${a}Shape[1] * ${a}Shape[2], ${a}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${a}TexShape[1], ${a}TexShape[0]);
        return sampleTexture(${a}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n[1]*n[2]}, ${n[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${g}.0, ${m}.0);
        return sampleTexture(${a}, uv);
      }
    `;let w=bd(a);return t?`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${b}
      ${v}
      ${x}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${a}TexShape[0], ${a}TexShape[1], index + ${w});
      return sampleTexture(${a}, uv);
    }
  `:`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${i} +
          depth * ${s} + depth2;
      vec2 uv = uvFromFlat(${m}, ${g}, index + ${w});
      return sampleTexture(${a}, uv);
    }
  `}function fpe(e){let t=e.shapeInfo.logicalShape,n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),r=t[4],s=t[3]*r,i=t[2]*s,o=t[1]*i,{newShape:u,keptDims:d}=E.squeezeShape(t);if(u.length<t.length){let v=vf(e,u),x=["row","col","depth","depth2","depth3"];return`
      ${yf(v)}
      float ${a}(int row, int col, int depth, int depth2, int depth3) {
        return ${a}(${xf(x,d)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${a}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${o}, ${i}, ${s}, ${r})) +
          depth3;
        ${bf(e)}
      }
    `;let c=e.shapeInfo.flatOffset,p=e.shapeInfo.texShape,m=p[0],g=p[1];if(g===o&&c==null)return`
      float ${a}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${i}, ${s}, ${r}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${g}.0, ${m}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(g===r&&c==null)return`
      float ${a}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]},
               ${t[2]*t[3]}, ${t[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${g}.0, ${m}.0);
        return sampleTexture(${n}, uv);
      }
    `;let b=bd(n);return`
    float ${a}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${i} + depth * ${s} +
          depth2 * ${r} + depth3 + ${b};
      vec2 uv = uvFromFlat(${m}, ${g}, index);
      return sampleTexture(${n}, uv);
    }
  `}function mpe(e){let t=e.shapeInfo.logicalShape,n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:r,keptDims:s}=E.squeezeShape(t);if(r.length<t.length){let x=vf(e,r),w=["row","col","depth","depth2","depth3","depth4"];return`
      ${yf(x)}
      float ${a}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${a}(${xf(w,s)});
      }
    `}let i=t[5],o=t[4]*i,u=t[3]*o,d=t[2]*u,c=t[1]*d;if(e.shapeInfo.isUniform)return`
      float ${a}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${c}, ${d}, ${u}, ${o})) +
          dot(
            vec2(depth3, depth4),
            vec2(${i}, 1)));
        ${bf(e)}
      }
    `;let p=e.shapeInfo.flatOffset,m=e.shapeInfo.texShape,g=m[0],b=m[1];if(b===c&&p==null)return`
      float ${a}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${d}, ${u}, ${o}, ${i})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${b}.0, ${g}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(b===i&&p==null)return`
      float ${a}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]*t[4]},
               ${t[2]*t[3]*t[4]},
               ${t[3]*t[4]},
               ${t[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${b}.0, ${g}.0);
        return sampleTexture(${n}, uv);
      }
    `;let v=bd(n);return`
    float ${a}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${c} + col * ${d} + depth * ${u} +
          depth2 * ${o} + depth3 * ${i} + depth4 + ${v};
      vec2 uv = uvFromFlat(${g}, ${b}, index);
      return sampleTexture(${n}, uv);
    }
  `}function bf(e){let t=e.name,n=E.sizeFromShape(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`
    for (int i = 0; i < ${n}; i++) {
      if (i == index) {
        return ${t}[i];
      }
    }
  `}function gpe(e,t){let n=e.name,a=n.charAt(0).toUpperCase()+n.slice(1),r="get"+a+"AtOutCoords",s=e.shapeInfo.logicalShape.length,i=t.logicalShape.length,o=EB(e.shapeInfo.logicalShape,t.logicalShape),u=Zt(i),d=i-s,c,p=["x","y","z","w","u","v"];s===0?c="":i<2&&o.length>=1?c="coords = 0;":c=o.map(x=>`coords.${p[x+d]} = 0;`).join(`
`);let m="";i<2&&s>0?m="coords":m=e.shapeInfo.logicalShape.map((x,w)=>`coords.${p[w+d]}`).join(", ");let g="return outputValue;",b=E.sizeFromShape(e.shapeInfo.logicalShape)===1,v=E.sizeFromShape(t.logicalShape)===1;if(s===1&&!b&&!v)g=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(b&&!v)i===1?g=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:g=`
        return vec4(outputValue.x);
      `;else if(o.length){let x=s-2,w=s-1;o.indexOf(x)>-1&&o.indexOf(w)>-1?g="return vec4(outputValue.x);":o.indexOf(x)>-1?g="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(w)>-1&&(g="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${r}() {
      ${u} coords = getOutputCoords();
      ${c}
      vec4 outputValue = get${a}(${m});
      ${g}
    }
  `}function ype(e,t){let n=e.name,a=n.charAt(0).toUpperCase()+n.slice(1),r="get"+a+"AtOutCoords",s=t.texShape,i=e.shapeInfo.texShape,o=e.shapeInfo.logicalShape.length,u=t.logicalShape.length;if(!e.shapeInfo.isUniform&&o===u&&e.shapeInfo.flatOffset==null&&E.arraysEqual(i,s))return`
      float ${r}() {
        return sampleTexture(${n}, resultUV);
      }
    `;let d=Zt(u),c=EB(e.shapeInfo.logicalShape,t.logicalShape),p=u-o,m,g=["x","y","z","w","u","v"];o===0?m="":u<2&&c.length>=1?m="coords = 0;":m=c.map(v=>`coords.${g[v+p]} = 0;`).join(`
`);let b="";return u<2&&o>0?b="coords":b=e.shapeInfo.logicalShape.map((v,x)=>`coords.${g[x+p]}`).join(", "),`
    float ${r}() {
      ${d} coords = getOutputCoords();
      ${m}
      return get${a}(${b});
    }
  `}function Zt(e){if(e<=1)return"int";if(e===2)return"ivec2";if(e===3)return"ivec3";if(e===4)return"ivec4";if(e===5)return"ivec5";if(e===6)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function AI(e,t,n){let{newShape:a,keptDims:r}=E.squeezeShape(t),s=t.length,i=e&&s===3&&t[0]===1,o=i?t.slice(1):a,u=!e&&s>1&&!E.arraysEqual(t,n)&&a.length<s||i;return{useSqueezeShape:u,uniformShape:u?o:t,keptDims:r}}function vf(e,t){let n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function xf(e,t){return t.map(n=>e[n]).join(", ")}function bpe(e,t,n,a){let r=n.map((c,p)=>{let m={logicalShape:c.shape,texShape:c.isUniform?null:c.texData.texShape,isUniform:c.isUniform,isPacked:c.isUniform?!1:c.texData.isPacked,flatOffset:null};return c.texData!=null&&c.texData.slice!=null&&c.texData.slice.flatOffset>0&&(m.flatOffset=c.texData.slice.flatOffset),{name:t.variableNames[p],shapeInfo:m}}),s=r.map(c=>c.shapeInfo),i={logicalShape:a.shape,texShape:a.texData.texShape,isUniform:!1,isPacked:a.texData.isPacked,flatOffset:null},o=Fhe(r,i,t),u=iB(e.gl,o),d=e.createProgram(u);return oe().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:u,source:o,webGLProgram:d,inShapeInfos:s,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(d),Object.assign({program:t,fragmentShader:u,source:o,webGLProgram:d,inShapeInfos:s,outShapeInfo:i},$B(e,t,d)))}function $B(e,t,n){let a=[],r=[],s,i,o,u=null,d=null;d=e.getUniformLocation(n,"NAN",!1),oe().getNumber("WEBGL_VERSION")===1&&(u=e.getUniformLocation(n,"INFINITY",!1));let c=!1;for(let p of t.variableNames){let m={name:p,uniform:e.getUniformLocation(n,p,c),offset:e.getUniformLocation(n,`offset${p}`,c)};t.enableShapeUniforms&&(m.shape=e.getUniformLocation(n,`${p}Shape`,c),m.texShape=e.getUniformLocation(n,`${p}TexShape`,c)),a.push(m)}if(t.enableShapeUniforms&&(s=e.getUniformLocation(n,"outShape",c),o=e.getUniformLocation(n,"outShapeStrides",c),i=e.getUniformLocation(n,"outTexShape",c)),t.customUniforms)for(let p of t.customUniforms)r.push(e.getUniformLocation(n,p.name,c));return{variablesLocations:a,customUniformLocations:r,infLoc:u,nanLoc:d,outShapeLocation:s,outShapeStridesLocation:o,outTexShapeLocation:i}}function ER(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach((n,a)=>{let r=n.logicalShape,s=t[a],i=s.shape;if(!E.arraysEqual(r,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${i} must match`);if(n.isUniform&&s.isUniform)return;let o=n.texShape,u=s.isUniform?null:s.texData.texShape;if(!E.arraysEqual(o,u))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${o} and ${u} must match`)})}function vpe(e,t,n,a,r){t.program.enableShapeUniforms||(ER(t.inShapeInfos,n),ER([t.outShapeInfo],[a]));let s=a.texData.texture,i=a.texData.texShape;a.texData.isPacked?e.setOutputPackedMatrixTexture(s.texture,i[0],i[1]):e.setOutputMatrixTexture(s.texture,i[0],i[1]),e.setProgram(t.webGLProgram),e.bindVertexArray(t.webGLProgram.vao),oe().getNumber("WEBGL_VERSION")===1&&t.infLoc!==null&&e.gl.uniform1f(t.infLoc,1/0),t.nanLoc!==null&&e.gl.uniform1f(t.nanLoc,NaN);for(let u=0;u<n.length;++u){let d=n[u],{uniform:c,offset:p,shape:m,texShape:g}=t.variablesLocations[u];if(m){let{uniformShape:b}=AI(t.program.packedInputs,d.shape,d.texData.texShape);switch(b.length){case 1:e.gl.uniform1iv(m,new Int32Array(b));break;case 2:e.gl.uniform2iv(m,new Int32Array(b));break;case 3:e.gl.uniform3iv(m,new Int32Array(b));break;case 4:e.gl.uniform4iv(m,new Int32Array(b));break}}if(g&&e.gl.uniform2i(g,d.texData.texShape[0],d.texData.texShape[1]),c!=null){if(d.isUniform){if(E.sizeFromShape(d.shape)<2)e.gl.uniform1f(c,d.uniformValues[0]);else{let b=d.uniformValues;b instanceof Float32Array||(b=new Float32Array(b)),e.gl.uniform1fv(c,b)}continue}d.texData.slice!=null&&p!=null&&e.gl.uniform1i(p,d.texData.slice.flatOffset),e.setInputMatrixTexture(d.texData.texture.texture,c,u)}}let o=t.outShapeLocation;if(o)switch(a.shape.length){case 1:e.gl.uniform1iv(o,new Int32Array(a.shape));break;case 2:e.gl.uniform2iv(o,new Int32Array(a.shape));break;case 3:e.gl.uniform3iv(o,new Int32Array(a.shape));break;case 4:e.gl.uniform4iv(o,new Int32Array(a.shape));break}if(t.outShapeStridesLocation){let u=E.computeStrides(a.shape);switch(a.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(u));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(u));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(u));break}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,a.texData.texShape[0],a.texData.texShape[1]),t.program.customUniforms&&r)for(let u=0;u<t.program.customUniforms.length;++u){let d=t.program.customUniforms[u],c=t.customUniformLocations[u],p=r[u];if(d.type==="float")e.gl.uniform1fv(c,p);else if(d.type==="vec2")e.gl.uniform2fv(c,p);else if(d.type==="vec3")e.gl.uniform3fv(c,p);else if(d.type==="vec4")e.gl.uniform4fv(c,p);else if(d.type==="int")e.gl.uniform1iv(c,p);else if(d.type==="ivec2")e.gl.uniform2iv(c,p);else if(d.type==="ivec3")e.gl.uniform3iv(c,p);else if(d.type==="ivec4")e.gl.uniform4iv(c,p);else throw Error(`uniform type ${d.type} is not supported yet.`)}e.executeProgram()}function xpe(e,t,n){let a="";t.concat(n).forEach(i=>{let o=i.texData!=null&&i.texData.slice!=null&&i.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!i.isUniform){let u=i.texData.texShape,{useSqueezeShape:d,uniformShape:c,keptDims:p}=AI(e.packedInputs,i.shape,u),m="",g="",b="";if(c.length===1&&e.packedInputs){let T=[Math.ceil(u[0]/2),Math.ceil(u[1]/2)];m=`${T[0]>1}_${T[1]>1}`}else if(c.length===2&&!e.packedInputs)g=`${c[0]>1}_${c[1]>1}`;else if(c.length>2&&!e.packedInputs){let T=E.computeStrides(c);b=`${T[0]===u[1]}_${T[T.length-1]===u[1]}`}let v=i.shape.length,x=c.length===2&&E.arraysEqual(i.shape,u),w=E.sizeFromShape(i.shape)===1,k=O.getBroadcastDims(i.shape,n.shape),N=!e.packedInputs&&v===n.shape.length&&E.arraysEqual(u,n.texData.texShape),I=e.packedInputs||c.length>2?"":`${u[0]>1}_${u[1]>1}`;a+=`${v}_${N}_${d?p:""}_${c.length}_${w}_${k}_${x}_${m}_${g}_${b}_${I}_${o}`}else{let u=i.isUniform?"uniform":i.texData.texShape;a+=`${i.shape}_${u}_${o}`}});let r=e.userCode,s=e.constructor.name;return s+="_"+a+"_"+r+`${oe().getNumber("WEBGL_VERSION")}`,s}function Pa(e){return oe().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}var wpe=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=og.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=er();this.outputShape=e,this.enableShapeUniforms=Pa(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Tx(["r","c","d"],e):yd(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}},Spe=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=og.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=er();this.outputShape=e,this.enableShapeUniforms=Pa(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Tx(["r","c","d"],e):yd(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}},kpe=class{constructor(e){this.variableNames=["A"],this.outTexUsage=qr.DOWNLOAD;let t=er();this.outputShape=e,this.userCode=`
      ${TB}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}},_pe=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=qr.DOWNLOAD;let t=er();this.outputShape=e,this.userCode=`
      ${TB}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}},Npe={R:0,G:1,B:2,A:3},CR=class{constructor(e,t=!1,n="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];let a=er();this.outputShape=e,this.enableShapeUniforms=Pa(this.outputShape.length);let r="result";t&&(r="floor(result * 255. + 0.5)");let s="";for(let i=0;i<n.length;i++){let o=n[i];s+=`
          if(offset == ${i}) {
            result = values[${Npe[o]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?CI():EI(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${n.length});

        flatIndex = idiv(flatIndex, ${n.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${a.texture2D}(A, uv);
          ${s}
        }
        ${a.output} = vec4(${r}, 0., 0., 0.);
      }
    `}},Ipe=class{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];let n=er();this.outputShape=e,this.enableShapeUniforms=Pa(this.outputShape.length);let a="",r="result";t&&(r="floor(result * 255. + 0.5)");for(let s=0;s<=1;s++)for(let i=0;i<=1;i++){let o=s*2+i;a+=`
          localCoords = coords;
          if(localCoords[2] + ${i} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${i};
          if (localCoords[1] + ${s} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${s};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${n.texture2D}(A, uv);

            if (offset == 0) {
              result[${o}] = values[0];
            } else if (offset == 1) {
              result[${o}] = values[1];
            } else if (offset == 2) {
              result[${o}] = values[2];
            } else {
              result[${o}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?CI():EI(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${a}

          ${n.output} = ${r};
        }
    `}},RB={};ot(RB,{bindVertexProgramAttributeStreams:()=>UB,createBufferFromOutputTexture:()=>VB,createFloat16MatrixTexture:()=>zB,createFloat16PackedMatrixTexture:()=>PB,createFloat32MatrixTexture:()=>FB,createIndexBuffer:()=>MB,createPackedMatrixTexture:()=>BB,createUnsignedBytesMatrixTexture:()=>LB,createVertexBuffer:()=>OB,createVertexShader:()=>DB,downloadByteEncodedFloatMatrixFromOutputTexture:()=>GB,downloadFloat32MatrixFromBuffer:()=>HB,downloadMatrixFromPackedOutputTexture:()=>KB,downloadPackedMatrixFromBuffer:()=>qB,getInternalFormatForFloat16MatrixTexture:()=>RI,getInternalFormatForFloat16PackedMatrixTexture:()=>MI,getInternalFormatForFloat32MatrixTexture:()=>$I,getInternalFormatForPackedMatrixTexture:()=>OI,getInternalFormatForUnsignedBytesMatrixTexture:()=>DI,uploadDenseMatrixToTexture:()=>jB,uploadPixelDataToTexture:()=>WB});function DB(e){let t=er(),n=`${t.version}
    precision highp float;
    ${t.attribute} vec3 clipSpacePos;
    ${t.attribute} vec2 uv;
    ${t.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return sB(e,n)}function OB(e){let t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return uB(e,t)}function MB(e){let t=new Uint16Array([0,1,2,2,1,3]);return cB(e,t)}function ky(e,t,n,a,r,s){hB(t,n);let i=dB(e),o=e.TEXTURE_2D;return Me(e,()=>e.bindTexture(o,i)),Me(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE)),Me(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)),Me(e,()=>e.texParameteri(o,e.TEXTURE_MIN_FILTER,e.NEAREST)),Me(e,()=>e.texParameteri(o,e.TEXTURE_MAG_FILTER,e.NEAREST)),oe().getNumber("WEBGL_VERSION")===1?Me(e,()=>e.texImage2D(o,0,a,t,n,0,r,s,null)):Me(e,()=>e.texStorage2D(o,1,a,t,n)),Me(e,()=>e.bindTexture(e.TEXTURE_2D,null)),{texture:i,texShape:[n,t]}}function $I(e){return e.internalFormatFloat}function FB(e,t,n,a){let[r,s]=Sy(t,n);return ky(e,r,s,$I(a),a.textureFormatFloat,e.FLOAT)}function RI(e){return e.internalFormatHalfFloat}function zB(e,t,n,a){let[r,s]=Sy(t,n);return ky(e,r,s,RI(a),a.textureFormatFloat,a.textureTypeHalfFloat)}function DI(e){return e.downloadTextureFormat}function LB(e,t,n,a){let[r,s]=Sy(t,n);return ky(e,r,s,DI(a),e.RGBA,e.UNSIGNED_BYTE)}function OI(e){return e.internalFormatPackedFloat}function BB(e,t,n,a){let[r,s]=mf(t,n);return ky(e,r,s,OI(a),e.RGBA,e.FLOAT)}function MI(e){return e.internalFormatPackedHalfFloat}function PB(e,t,n,a){let[r,s]=mf(t,n);return ky(e,r,s,MI(a),e.RGBA,a.textureTypeHalfFloat)}function UB(e,t,n){return Me(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),bk(e,t,"clipSpacePos",n,3,20,0)&&bk(e,t,"uv",n,2,20,12)}function jB(e,t,n,a,r,s){Me(e,()=>e.bindTexture(e.TEXTURE_2D,t));let i,o,u;r instanceof Uint8Array?(i=new Uint8Array(n*a*4),o=e.UNSIGNED_BYTE,u=e.RGBA):(i=new Float32Array(n*a*4),o=e.FLOAT,u=s.internalFormatPackedFloat),i.set(r),oe().getNumber("WEBGL_VERSION")===2?Me(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,a,e.RGBA,o,i)):Me(e,()=>e.texImage2D(e.TEXTURE_2D,0,u,n,a,0,e.RGBA,o,i)),Me(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function WB(e,t,n){Me(e,()=>e.bindTexture(e.TEXTURE_2D,t)),n.data instanceof Uint8Array?oe().getNumber("WEBGL_VERSION")===2?Me(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data)):Me(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data)):oe().getNumber("WEBGL_VERSION")===2?Me(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n)):Me(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n)),Me(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function VB(e,t,n,a){let r=e.createBuffer();Me(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,r));let s=16*t*n;return Me(e,()=>e.bufferData(e.PIXEL_PACK_BUFFER,s,e.STREAM_READ)),Me(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0)),Me(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null)),r}function HB(e,t,n){let a=e,r=new Float32Array(n);return a.bindBuffer(a.PIXEL_PACK_BUFFER,t),a.getBufferSubData(a.PIXEL_PACK_BUFFER,0,r),a.bindBuffer(a.PIXEL_PACK_BUFFER,null),r}function GB(e,t,n,a){let[r,s]=Sy(t,n),i=4,o=new Uint8Array(She(t*n,i));return Me(e,()=>e.readPixels(0,0,r,s,a.downloadTextureFormat,e.UNSIGNED_BYTE,o)),new Float32Array(o.buffer)}function qB(e,t,n,a,r,s,i,o){let u=e,d=new Float32Array(khe(s,i));return u.bindBuffer(u.PIXEL_PACK_BUFFER,t),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,d),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),d}function KB(e,t,n){let a=new Float32Array(t*n*4);return Me(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,a)),a}var bv=class{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];let t=oe().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,nB(t,e)):this.gl=Ws(t),e=this.gl,oe().getNumber("WEBGL_VERSION")===2){let r=e;this.createVertexArray=()=>Me(r,()=>r.createVertexArray()),this.bindVertexArray=s=>Me(r,()=>r.bindVertexArray(s)),this.deleteVertexArray=s=>Me(r,()=>r.deleteVertexArray(s)),this.getVertexArray=()=>Me(r,()=>r.getParameter(r.VERTEX_ARRAY_BINDING))}else if(e!=null){let r=e.getExtension("OES_vertex_array_object");if(r==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>Me(e,()=>r.createVertexArrayOES()),this.bindVertexArray=s=>Me(e,()=>r.bindVertexArrayOES(s)),this.deleteVertexArray=s=>Me(e,()=>r.deleteVertexArrayOES(s)),this.getVertexArray=()=>Me(e,()=>e.getParameter(r.VERTEX_ARRAY_BINDING_OES))}let n="WEBGL_color_buffer_float",a="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),oe().getNumber("WEBGL_VERSION")===1){let r="OES_texture_float",s="OES_texture_half_float";if(this.textureFloatExtension=Dm(this.gl,r),Kr(this.gl,s))this.textureHalfFloatExtension=Dm(this.gl,s);else if(oe().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),Kr(this.gl,a))this.colorBufferHalfFloatExtension=Dm(this.gl,a);else if(oe().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",Kr(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else if(Kr(this.gl,a))this.colorBufferHalfFloatExtension=this.gl.getExtension(a);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=OB(this.gl),this.indexBuffer=MB(this.gl),this.framebuffer=pB(this.gl),this.textureConfig=II(this.gl,this.textureHalfFloatExtension)}get debug(){return oe().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let e=this.gl;Me(e,()=>e.finish()),Me(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),Me(e,()=>e.deleteFramebuffer(this.framebuffer)),Me(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),Me(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),Me(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),FB(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),zB(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),LB(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),WB(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,a){this.throwIfDisposed(),jB(this.gl,e,t,n,a,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),PB(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),BB(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(vk(this.gl,this.framebuffer),this.outputTexture=null),Me(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,()=>GB(this.gl,t,n,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,n,a,r,s){return qB(this.gl,e,t,n,a,r,s,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return HB(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);let a=VB(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),a}createAndWaitForFence(){let e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(oe().getBool("WEBGL_FENCE_API_ENABLED")){let a=e,r=a.fenceSync(a.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{let s=a.clientWaitSync(r,0,0);return s===a.ALREADY_SIGNALED||s===a.CONDITION_SATISFIED},t=r}else oe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,oe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,()=>KB(this.gl,t,n))}createProgram(e){this.throwIfDisposed();let t=this.gl;this.vertexShader==null&&(this.vertexShader=DB(t));let n=oB(t);Me(t,()=>t.attachShader(n,this.vertexShader)),Me(t,()=>t.attachShader(n,e)),lB(t,n);let a=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&fv(t,a),a}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);let t=this.gl;Me(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),UB(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(Me(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&fv(this.gl,this.program),Me(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?mB(this.gl,e,t):gB(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),Me(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),yB(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();let[a,r]=mf(t,n);this.setOutputMatrixTextureDriver(e,a,r)}setOutputMatrixWriteRegion(e,t,n,a){this.setOutputMatrixWriteRegionDriver(n,e,a,t)}setOutputPackedMatrixWriteRegion(e,t,n,a){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&fv(this.gl,this.program),Om(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let e=this.gl;if(this.debug){let t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}Me(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Me(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=Dm(this.gl,oe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(oe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let n=this.gl,a=this.getQueryTimerExtensionWebGL2(),r=n.createQuery();return n.beginQuery(a.TIME_ELAPSED_EXT,r),r}let e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(oe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let t=this.gl,n=this.getQueryTimerExtensionWebGL2();t.endQuery(n.TIME_ELAPSED_EXT);return}let e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await E.repeatedTry(()=>this.disposed||this.isQueryAvailable(e,oe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,oe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){let n=this.gl;return n.getQueryParameter(e,n.QUERY_RESULT)/1e6}else{let n=this.getQueryTimerExtensionWebGL1();return n.getQueryObjectEXT(e,n.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){let n=this.gl,a=this.getQueryTimerExtensionWebGL2(),r=n.getQueryParameter(e,n.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(a.GPU_DISJOINT_EXT)),r&&!this.disjoint}else{let n=this.getQueryTimerExtensionWebGL1(),a=n.getQueryObjectEXT(e,n.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),a&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){let e=Tpe(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){let{resolveFn:n}=this.itemsToPoll[t];n()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in oe().platform&&(n=oe().platform.setTimeoutCustom.bind(oe().platform)),E.repeatedTry(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),mv(this.gl,e,this.framebuffer),this.debug&&Om(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(mv(this.gl,this.outputTexture,this.framebuffer),this.debug&&Om(this.gl)):vk(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);let n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();let a=this.gl;mv(a,e,this.framebuffer),this.debug&&Om(a),this.outputTexture=e,Me(a,()=>a.viewport(0,0,t,n)),Me(a,()=>a.scissor(0,0,t,n))}setOutputMatrixWriteRegionDriver(e,t,n,a){this.throwIfDisposed(),Me(this.gl,()=>this.gl.scissor(e,t,n,a))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}};function Tpe(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}var{addImpl:Epe,bincountImpl:XB,bincountReduceImpl:Cpe,bitwiseAndImpl:Ape,castImpl:$pe,ceilImpl:Rpe,concatImpl:Dpe,equalImpl:Ope,expImpl:Mpe,expm1Impl:Fpe,floorImpl:zpe,gatherNdImpl:Lpe,gatherV2Impl:Bpe,greaterImpl:Ppe,greaterEqualImpl:Upe,lessImpl:jpe,lessEqualImpl:Wpe,linSpaceImpl:Vpe,logImpl:Hpe,maxImpl:Gpe,maximumImpl:qpe,minimumImpl:Kpe,multiplyImpl:Xpe,negImpl:Ype,notEqualImpl:Jpe,prodImpl:Zpe,raggedGatherImpl:Qpe,raggedRangeImpl:efe,raggedTensorToTensorImpl:tfe,rangeImpl:nfe,rsqrtImpl:afe,scatterImpl:rfe,sigmoidImpl:sfe,simpleAbsImpl:YB,sliceImpl:ife,sparseFillEmptyRowsImpl:ofe,sparseReshapeImpl:lfe,sparseSegmentReductionImpl:JB,sqrtImpl:ufe,staticRegexReplaceImpl:cfe,stridedSliceImpl:dfe,stringNGramsImpl:hfe,stringSplitImpl:pfe,stringToHashBucketFastImpl:ffe,subImpl:mfe,tileImpl:gfe,topKImpl:yfe,transposeImpl:FI,uniqueImpl:bfe}=cI;function ZB(e,t){return["x","y","z","w","u","v"].slice(0,t).map(n=>`${e}.${n}`)}function Ga(e,t){return t===1?[e]:ZB(e,t)}function vfe(e,t){if(e===1)return"rc";let n="";for(let a=0;a<e;a++)n+=t[a],a<e-1&&(n+=",");return n}var xfe=class{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=Pa(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{let t=Ga("rc",this.rank),n=Zt(this.rank),a=this.getOutOfBoundsCondition(t),r=this.getSetup(t),s=this.getOutput(t);this.userCode=`
        void main() {
          ${n} rc = getOutputCoords();

          if(${a}) {
            setOutput(vec4(0));
          } else {
            ${r}

            setOutput(vec4(${s}));
          }
        }
      `}}getSourceCoordsArr(e){let t=[];for(let n=0;n<=1;n++)for(let a=0;a<=1;a++){let r=`${n===0?"r":"rp1"}, ${a===0?"c":"cp1"}`;for(let s=2;s<this.rank;s++)r=`${e[e.length-1-s]},`+r;t.push(r)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let n=this.rank-2;n<this.rank;n++)t+=`${e[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";let t=e.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],a=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${n};
      bool rEdge = rp1 >= ${a};
    `}getOutput(e){let t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}},QB=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=Pa(this.outputShape.length);let n="";for(let a=0;a<4;a++){let r="thisRC = rc;";a%2===1&&(r+="thisRC.z += 1;"),a>1&&(r+="thisRC.y += 1;"),n+=`
        ${r}
        ${a>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${a}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${a>0?"}":""}
      `}this.userCode=`
      ${wfe(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?CI():EI(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${n}

        setOutput(result);
      }
    `}};function wfe(e,t){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${t?Mhe(["r","c","d"],"inputShape"):yd(["r","c","d"],e)}
      return ivec3(r, c, d);
    }
  `}var Sfe=class{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,n){let a=$R(t,n),r=RR(e,a,n);r in this.freeTextures||(this.freeTextures[r]=[]),r in this.usedTextures||(this.usedTextures[r]=[]);let s=AR(e,a,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[r].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=s,this.log();let o=this.freeTextures[r].pop();return this.usedTextures[r].push(o),o}let i;return a===_a.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):a===_a.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):a===_a.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):a===_a.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):a===_a.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[r].push(i),this.numUsedTextures++,this._numBytesAllocated+=s,this.log(),i}releaseTexture(e,t,n,a){if(this.freeTextures==null)return;let r=$R(n,a),s=RR(t,r,a);s in this.freeTextures||(this.freeTextures[s]=[]);let i=AR(t,r,this.gpgpu.gl,this.gpgpu.textureConfig,a),o=oe().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");o!==-1&&this._numBytesAllocated>o?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=i):(this.freeTextures[s].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;let u=this.usedTextures[s],d=u&&u.indexOf(e);if(d==null||d<0)throw new Error("Cannot release a texture that was never provided by this texture manager");u[d]=u[u.length-1],u.pop(),this.log()}log(){if(!this.logEnabled)return;let e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);let t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(let e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(let e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function kfe(e,t){let n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F||t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}function AR(e,t,n,a,r){let s=_fe(t,a),i;if(r){let[u,d]=mf(e[0],e[1]);i=u*d}else{let[u,d]=Sy(e[0],e[1]);i=u*d}let o=kfe(n,s);return i*o}function _fe(e,t){switch(e){case _a.PACKED_2X2_FLOAT32:return OI(t);case _a.PACKED_2X2_FLOAT16:return MI(t);case _a.UNPACKED_FLOAT32:return $I(t);case _a.UNPACKED_FLOAT16:return RI(t);case _a.PACKED_4X1_UNSIGNED_BYTE:return DI(t);default:throw new Error(`Unknown physical texture type ${e}`)}}function Nfe(e){return oe().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?_a.PACKED_2X2_FLOAT32:_a.UNPACKED_FLOAT32:e?_a.PACKED_2X2_FLOAT16:_a.UNPACKED_FLOAT16}function $R(e,t){if(e===qr.UPLOAD)return _a.PACKED_2X2_FLOAT32;if(e===qr.RENDER||e==null)return Nfe(t);if(e===qr.DOWNLOAD||e===qr.PIXELS)return _a.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function RR(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}var oi=class{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=Pa(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}},ks="if (isnan(x)) return x;",Ife="return x;",DR="return abs(x);",Tfe="return (x >= 0.0) ? x : (exp(x) - 1.0);",Efe=ks+`
  return (x < 0.0) ? 0.0 : x;
`,Cfe=ks+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Vo="return x;",Afe="return 1.0 / (1.0 + exp(-1.0 * x));",$fe="return x;",Rfe=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,Dfe=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Ofe=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Mfe="return 1.0 / (1.0 + exp(-1.0 * x));",Jo=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=Pa(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}},Ffe=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=Pa(this.outputShape.length);let t=e.length,n=Ga("rc",t),a=Zt(t),r=vfe(t,n),s=n.slice(-2),i=t<=1?"rc":`vec2(${s.join(",")})`;this.userCode=`
      void main() {
        ${a} rc = getOutputCoords();
        vec4 packedInput = getA(${r});

        setOutput(getChannel(packedInput, ${i}));
      }
    `}},zfe=yi.whereImpl,Lfe=1e-7,Bfe=1e-4,lS={};function Pfe(e){return e in lS||(lS[e]={}),lS[e]}var Ufe=oe().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),jfe=600;function Wfe(){return oe().global.screen==null?1024:oe().global.screen.height*oe().global.screen.width*window.devicePixelRatio*jfe/1024/1024}var zI=class e4 extends _g{nextDataId(){return e4.nextDataId++}constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!oe().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let n;if(t!=null){if(t instanceof bv)n=t;else{let a=Ws(oe().getNumber("WEBGL_VERSION"),t);n=new bv(a)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{let a=Ws(oe().getNumber("WEBGL_VERSION"));n=new bv(a),this.binaryCache=Pfe(oe().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=n,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new Sfe(this.gpgpu),this.numMBBeforeWarning=Wfe(),this.texData=new s0(this,ms())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(t,n,a,r,s,i){let o=this.makeTensorInfo(n,a),u=this.texData.get(o.dataId);u.isPacked=!1,u.texture={texture:t,texShape:[r,s]},u.texShape=[r,s];let d=Mm(n),c=new CR(d,!1,i),p=this.runWebGLProgram(c,[o],a,[[r,s]]);return p.shape=n,u.texture=null,this.disposeIntermediateTensorInfo(o),p.dataId}write(t,n,a){if((oe().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||oe().getBool("DEBUG"))&&this.checkNumericalProblems(t),a==="complex64"&&t!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let r={id:this.nextDataId()};return this.texData.set(r,{shape:n,dtype:a,values:t,usage:qr.UPLOAD,refCount:1}),r}refCount(t){return this.texData.has(t)?this.texData.get(t).refCount:0}incRef(t){let n=this.texData.get(t);n.refCount++}decRef(t){if(this.texData.has(t)){let n=this.texData.get(t);n.refCount--}}move(t,n,a,r,s){if(oe().getBool("DEBUG")&&this.checkNumericalProblems(n),r==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:a,dtype:r,values:n,usage:qr.UPLOAD,refCount:s})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){let n=this.texData.get(t),{values:a,dtype:r,complexTensorInfos:s,slice:i,shape:o,isPacked:u}=n;if(i!=null){let m;u?m=new Jo(o,Vo):m=new oi(o,Vo);let g=this.runWebGLProgram(m,[{dataId:t,shape:o,dtype:r}],r),b=this.readSync(g.dataId);return this.disposeIntermediateTensorInfo(g),b}if(a!=null)return this.convertAndCacheOnCPU(t);if(r==="string")return a;let d=this.activeTimers!=null,c;d&&(c=E.now());let p;if(r==="complex64"){let m=this.readSync(s.real.dataId),g=this.readSync(s.imag.dataId);p=O.mergeRealAndImagArrays(m,g)}else p=this.getValuesFromTexture(t);return d&&(this.downloadWaitMs+=E.now()-c),this.convertAndCacheOnCPU(t,p)}async read(t){if(this.pendingRead.has(t)){let b=this.pendingRead.get(t);return new Promise(v=>b.push(v))}let n=this.texData.get(t),{values:a,shape:r,slice:s,dtype:i,complexTensorInfos:o,isPacked:u}=n;if(s!=null){let b;u?b=new Jo(r,Vo):b=new oi(r,Vo);let v=this.runWebGLProgram(b,[{dataId:t,shape:r,dtype:i}],i),x=this.read(v.dataId);return this.disposeIntermediateTensorInfo(v),x}if(a!=null)return this.convertAndCacheOnCPU(t);if(oe().getBool("DEBUG")&&!oe().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&oe().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let d=null,c;if(i!=="complex64"&&oe().get("WEBGL_BUFFER_SUPPORTED")){c=this.decode(t);let b=this.texData.get(c.dataId);d=this.gpgpu.createBufferFromTexture(b.texture.texture,...Qb(r))}this.pendingRead.set(t,[]),i!=="complex64"&&await this.gpgpu.createAndWaitForFence();let p;if(i==="complex64"){let b=await Promise.all([this.read(o.real.dataId),this.read(o.imag.dataId)]),v=b[0],x=b[1];p=O.mergeRealAndImagArrays(v,x)}else if(d==null)p=this.getValuesFromTexture(t);else{let b=E.sizeFromShape(r);p=this.gpgpu.downloadFloat32MatrixFromBuffer(d,b)}if(c!=null&&this.disposeIntermediateTensorInfo(c),d!=null){let b=this.gpgpu.gl;Me(b,()=>b.deleteBuffer(d))}let m=this.convertAndCacheOnCPU(t,p),g=this.pendingRead.get(t);return this.pendingRead.delete(t),g.forEach(b=>b(m)),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t)&&ms().removeDataId(t,this),this.pendingDeletes--),m}readToGPU(t,n={}){let a=this.texData.get(t),{values:r,shape:s,slice:i,dtype:o,isPacked:u,texture:d}=a;if(o==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(i!=null){let g;u?g=new Jo(s,Vo):g=new oi(s,Vo);let b=this.runWebGLProgram(g,[{dataId:t,shape:s,dtype:o}],o),v=this.readToGPU(b,n);return this.disposeIntermediateTensorInfo(b),v}if(d==null)throw r!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");let c=this.decode(t,n.customTexShape),p=ms().makeTensorFromTensorInfo(c),m=this.texData.get(c.dataId);return Object.assign({tensorRef:p},m.texture)}bufferSync(t){let n=this.readSync(t.dataId);if(t.dtype==="string")try{let a=n.map(r=>E.decodeString(r));return mt(t.shape,t.dtype,a)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return mt(t.shape,t.dtype,n)}checkNumericalProblems(t){if(t!=null)for(let n=0;n<t.length;n++){let a=t[n];if(!aB(a))throw oe().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${a} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${a} cannot be represented on this device.`)}}getValuesFromTexture(t){let{shape:n,dtype:a,isPacked:r}=this.texData.get(t),s=E.sizeFromShape(n);if(oe().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let m=this.decode(t),g=this.texData.get(m.dataId),b=this.gpgpu.downloadMatrixFromPackedTexture(g.texture.texture,...Qb(n)).subarray(0,s);return this.disposeIntermediateTensorInfo(m),b}let i=oe().getBool("WEBGL_PACK")&&r===!0,o=i?Mm(n):n,u=i?new _pe(o):new kpe(o),d=this.runWebGLProgram(u,[{shape:o,dtype:a,dataId:t}],"float32"),c=this.texData.get(d.dataId),p=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture.texture,c.texShape[0],c.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(d),p}timerAvailable(){return oe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(t){let n=this.activeTimers,a=[],r=!1;this.programTimersStack==null?(this.programTimersStack=a,r=!0):this.activeTimers.push(a),this.activeTimers=a,t();let s=E.flatten(this.activeTimers.map(u=>u.query)).filter(u=>u!=null),i=E.flatten(this.activeTimers.map(u=>u.name)).filter(u=>u!=null);this.activeTimers=n,r&&(this.programTimersStack=null);let o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(oe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let u=await Promise.all(s);o.kernelMs=E.sum(u),o.getExtraProfileInfo=()=>u.map((d,c)=>({name:i[c],ms:d})).map(d=>`${d.name}: ${d.ms}`).join(", ")}else o.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,o})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return oe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:E.now(),endMs:null}}endTimer(t){return oe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=E.now(),t)}async getQueryTime(t){if(oe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(t);let n=t;return n.endMs-n.startMs}disposeData(t,n=!1){if(this.pendingDisposal.has(t))return!1;if(!this.texData.has(t))return!0;if(n?this.texData.get(t).refCount=0:this.texData.get(t).refCount--,!n&&this.texData.get(t).refCount>0)return!1;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),this.pendingDeletes++,!1;this.releaseGPUData(t);let{complexTensorInfos:a}=this.texData.get(t);return a!=null&&(this.disposeData(a.real.dataId,n),this.disposeData(a.imag.dataId,n)),this.texData.delete(t),!0}releaseGPUData(t){let{texture:n,dtype:a,texShape:r,usage:s,isPacked:i,slice:o}=this.texData.get(t),u=o&&o.origDataId||t,d=this.dataRefCount.get(u);d>1?this.dataRefCount.set(u,d-1):(this.dataRefCount.delete(u),n!=null&&(this.numBytesInGPU-=this.computeBytes(r,a),this.textureManager.releaseTexture(n,r,s,i)));let c=this.texData.get(t);c.texture=null,c.texShape=null,c.isPacked=!1,c.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture.texture}getDataInfo(t){return this.texData.get(t)}shouldExecuteOnCPU(t,n=Ufe){return oe().getBool("WEBGL_CPU_FORWARD")&&t.every(a=>this.texData.get(a.dataId).texture==null&&E.sizeFromShape(a.shape)<n)}getGPGPUContext(){return this.gpgpu}where(t){O.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let n=t.dataSync();return zfe(t.shape,n)}packedUnaryOp(t,n,a){let r=new Jo(t.shape,n),s=this.compileAndRun(r,[t],a);return ms().makeTensorFromTensorInfo(s)}abs(t){if(this.shouldExecuteOnCPU([t])&&t.dtype!=="complex64"){let r=YB(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,r)}if(oe().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,DR,t.dtype);let n=new oi(t.shape,DR),a=this.compileAndRun(n,[t]);return ms().makeTensorFromTensorInfo(a)}makeTensorInfo(t,n,a){let r;if(n==="string"&&a!=null&&a.length>0&&E.isString(a[0])){let s=a.map(i=>E.encodeString(i));r=this.write(s,t,n)}else r=this.write(a,t,n);return this.texData.get(r).usage=null,{dataId:r,shape:t,dtype:n}}makeOutput(t,n,a){return ms().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,a),this)}unpackTensor(t){let n=new Ffe(t.shape);return this.runWebGLProgram(n,[t],t.dtype)}packTensor(t){let n=new xfe(t.shape);return this.runWebGLProgram(n,[t],t.dtype,null,!0)}packedReshape(t,n){let a=[Pu(t.shape),...Uu(t.shape)],r={dtype:t.dtype,shape:a,dataId:t.dataId},s=[Pu(n),...Uu(n)],i=new QB(s,a),o=!0,u=[a],d=this.runWebGLProgram(i,[r],t.dtype,u,o);return{dataId:d.dataId,shape:n,dtype:d.dtype}}decode(t,n){let a=this.texData.get(t),{isPacked:r,shape:s,dtype:i}=a;if(n!=null){let m=E.sizeFromShape(s),g=n[0]*n[1]*4;E.assert(m<=g,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}let o=Mm(s),u;r?u=new Spe(o):u=new wpe(o);let d=!0,c=[n??Qb(o)],p=this.runWebGLProgram(u,[{shape:o,dtype:i,dataId:t}],i,c,d,n);return{dtype:i,shape:s,dataId:p.dataId}}runWebGLProgram(t,n,a,r,s=!1,i){let o=this.makeTensorInfo(t.outputShape,a),u=this.texData.get(o.dataId);if(t.packedOutput&&(u.isPacked=!0),t.outPackingScheme===og.DENSE){let w=i??Qb(t.outputShape);u.texShape=w.map(k=>k*2)}if(t.outTexUsage!=null&&(u.usage=t.outTexUsage),E.sizeFromShape(o.shape)===0)return u.values=E.getTypedArrayFromDType(o.dtype,0),o;let d=[],c=n.map(w=>{if(w.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let k=this.texData.get(w.dataId);if(k.texture==null){if(!t.packedInputs&&E.sizeFromShape(w.shape)<=oe().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:w.shape,texData:null,isUniform:!0,uniformValues:k.values};t.packedInputs&&(k.isPacked=!0,k.shape=w.shape)}if(this.uploadToGPU(w.dataId),!!k.isPacked!=!!t.packedInputs)w=k.isPacked?this.unpackTensor(w):this.packTensor(w),d.push(w),k=this.texData.get(w.dataId);else if(k.isPacked&&!lg(k.shape,w.shape)){let N=w,I=w.shape;w.shape=k.shape,w=this.packedReshape(w,I),d.push(w),k=this.texData.get(w.dataId),N.shape=I}return{shape:w.shape,texData:k,isUniform:!1}});this.uploadToGPU(o.dataId);let p={shape:o.shape,texData:u,isUniform:!1},m=xpe(t,c,p),g=this.getAndSaveBinary(m,()=>bpe(this.gpgpu,t,c,p)),b=this.activeTimers!=null,v;b&&(v=this.startTimer()),oe().get("ENGINE_COMPILE_ONLY")||vpe(this.gpgpu,g,c,p,r),d.forEach(w=>this.disposeIntermediateTensorInfo(w)),b&&(v=this.endTimer(v),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(v)}));let x=oe().getNumber("WEBGL_FLUSH_THRESHOLD");if(x>0){let w=E.now();w-this.lastGlFlushTime>x&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=w)}if(!oe().getBool("WEBGL_LAZILY_UNPACK")&&u.isPacked&&s===!1){let w=this.unpackTensor(o);return this.disposeIntermediateTensorInfo(o),w}return o}compileAndRun(t,n,a,r,s=!1){return a=a||n[0].dtype,this.runWebGLProgram(t,n,a,r,s)}getAndSaveBinary(t,n){return t in this.binaryCache||(this.binaryCache[t]=n()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(oe().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=ne(()=>{if(!oe().get("WEBGL_RENDER_FLOAT32_ENABLED")){let t=oe().getBool("DEBUG");oe().set("DEBUG",!1);let n=this.abs(He(1e-8)).dataSync()[0];if(oe().set("DEBUG",t),n>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?Lfe:Bfe}uploadToGPU(t){let n=this.texData.get(t),{shape:a,dtype:r,values:s,texture:i,usage:o,isPacked:u}=n;if(i!=null)return;let d=this.activeTimers!=null,c;d&&(c=E.now());let p=n.texShape;if(p==null&&(p=xB(a,u),n.texShape=p),s!=null){let m=Mm(a),g,b=p[1],v=p[0],x=s instanceof Uint8Array||s instanceof Uint8ClampedArray;(u||!x)&&([b,v]=mf(p[0],p[1])),u?g=new Ipe(m,x):g=new CR(m,x);let w=x?[v,b]:p,k=this.makeTensorInfo(w,r),N=this.texData.get(k.dataId);x?N.usage=qr.PIXELS:N.usage=qr.UPLOAD,N.texShape=w,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(k.dataId),b,v,s);let I=[[v,b]],T=this.runWebGLProgram(g,[k],r,I,!0),$=this.texData.get(T.dataId);n.texShape=$.texShape,n.isPacked=$.isPacked,n.usage=$.usage,oe().get("ENGINE_COMPILE_ONLY")?this.disposeData(T.dataId):(n.texture=$.texture,n.values=null,this.texData.delete(T.dataId)),this.disposeIntermediateTensorInfo(k),d&&(this.uploadWaitMs+=E.now()-c)}else{let m=this.acquireTexture(p,o,r,u);n.texture=m}}convertAndCacheOnCPU(t,n){let a=this.texData.get(t),{dtype:r}=a;return n!=null&&(a.values=Vfe(n,r)),a.values}acquireTexture(t,n,a,r){if(this.numBytesInGPU+=this.computeBytes(t,a),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){let s=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${s} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,n,r)}computeBytes(t,n){return t[0]*t[1]*E.bytesPerElement(n)}checkCompileCompletion(){for(let[,t]of Object.entries(this.binaryCache))this.checkCompletion_(t)}async checkCompileCompletionAsync(){let t=[];if(this.gpgpu.parallelCompilationExtension){for(let[,n]of Object.entries(this.binaryCache))t.push(this.checkCompletionAsync_(n));return Promise.all(t)}else{for(let[,n]of Object.entries(this.binaryCache)){let a=new Promise(r=>{try{this.checkCompletion_(n),r(!0)}catch(s){throw s}});t.push(a)}return Promise.all(t)}}async checkCompletionAsync_(t){return this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(t):(await I2(),this.checkCompletionAsync_(t))}checkCompletion_(t){if(this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(t.webGLProgram)),this.gpgpu.gl.getShaderParameter(t.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(TI(t.source,this.gpgpu.gl.getShaderInfoLog(t.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(let t of Object.values(this.binaryCache)){this.gpgpu.buildVao(t.webGLProgram);let{variablesLocations:n,customUniformLocations:a,infLoc:r,nanLoc:s,outShapeLocation:i,outShapeStridesLocation:o,outTexShapeLocation:u}=$B(this.gpgpu,t.program,t.webGLProgram);t.variablesLocations=n,t.customUniformLocations=a,t.infLoc=r,t.nanLoc=s,t.outShapeLocation=i,t.outShapeStridesLocation=o,t.outTexShapeLocation=u}}createTensorFromGPUData(t,n,a){t.channels=t.channels||"RGBA";let{texture:r,height:s,width:i,channels:o}=t,u=ms().backend;if(!u.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");let d=u.writeTexture(r,n,a,s,i,o);return ms().makeTensorFromDataId(d,n,a,u)}};zI.nextDataId=0;function Vfe(e,t){if(t==="float32"||t==="complex64")return e;if(t==="int32"||t==="bool"){let n=t==="int32"?new Int32Array(e.length):new Uint8Array(e.length);for(let a=0;a<n.length;++a)n[a]=Math.round(e[a]);return n}else throw new Error(`Unknown dtype ${t}`)}var Hfe="4.22.0";function t4(){oe().set("WEBGL_FORCE_F16_TEXTURES",!0)}Yg.isBrowser()&&k0("webgl",()=>new zI,2);var Gfe={forceHalfFloat:t4},LI=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`,ju=class{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=O.assertAndGetBroadcastShape(t,n),this.enableShapeUniforms=Pa(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}},vd=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`,wf=class{constructor(e,t,n,a=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=O.assertAndGetBroadcastShape(t,n);let r=this.outputShape.length;this.enableShapeUniforms=Pa(r);let s="";if(a)if(r===0||E.sizeFromShape(this.outputShape)===1)s=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(s=`
          ${Zt(r)} coords = getOutputCoords();
        `,r===1)this.enableShapeUniforms?s+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:s+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{let i=Ga("coords",r);this.enableShapeUniforms?s+=`
            bool nextRowOutOfBounds =
              (${i[r-2]} + 1) >= outShape[${r} - 2];
            bool nextColOutOfBounds =
              (${i[r-1]} + 1) >= outShape[${r} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:s+=`
            bool nextRowOutOfBounds =
              (${i[r-2]} + 1) >= ${this.outputShape[r-2]};
            bool nextColOutOfBounds =
              (${i[r-1]} + 1) >= ${this.outputShape[r-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${s}

        setOutput(result);
      }
    `}};function Dr(e){let{inputs:t,backend:n}=e,{x:a}=t;return n.incRef(a.dataId),{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}var qfe={kernelName:wc,backendName:"webgl",kernelFunc:Dr};function El(e){let{inputs:t,backend:n}=e,{real:a,imag:r}=t,s=n.makeTensorInfo(a.shape,"complex64"),i=n.texData.get(s.dataId),o=Dr({inputs:{x:a},backend:n}),u=Dr({inputs:{x:r},backend:n});return i.complexTensorInfos={real:o,imag:u},s}var Kfe={kernelName:l0,backendName:"webgl",kernelFunc:El},n4="return (a < 0.) ? b * a : a;",a4=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function Xfe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{alpha:s}=a,i=n.makeTensorInfo([],"float32",E.createScalarValue(s,"float32")),o=oe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new wf(a4,r.shape,i.shape):new ju(n4,r.shape,i.shape),u=n.runWebGLProgram(o,[r,i],"float32");return n.disposeIntermediateTensorInfo(i),u}var Yfe={kernelName:Nc,backendName:"webgl",kernelFunc:Xfe},r4="return (a < 0.) ? b * a : a;",s4=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function Jfe(e){let{inputs:t,backend:n}=e,{x:a,alpha:r}=t,s=oe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new wf(s4,a.shape,r.shape):new ju(r4,a.shape,r.shape);return n.runWebGLProgram(s,[a,r],"float32")}var Zfe={kernelName:Uc,backendName:"webgl",kernelFunc:Jfe},Sf="if (isnan(x)) return x;";function Ct({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:a}){return({inputs:r,backend:s})=>{let{x:i}=r,o=s,u=a||i.dtype;if(o.shouldExecuteOnCPU([i])&&n!=null){let p=o.texData.get(i.dataId),m=n(p.values,u);return o.makeTensorInfo(i.shape,u,m)}let d=oe().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&t!=null,c;return d?c=new Jo(i.shape,t):c=new oi(i.shape,e),o.runWebGLProgram(c,[i],u)}}function Ia({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:a=!1,cpuKernelImpl:r,dtype:s}){return({inputs:i,backend:o})=>{let{a:u,b:d}=i,c=o;if(a&&u.dtype==="complex64"){let b=c.texData.get(u.dataId),v=c.texData.get(d.dataId),[x,w]=[[b.complexTensorInfos.real,v.complexTensorInfos.real],[b.complexTensorInfos.imag,v.complexTensorInfos.imag]].map(N=>{let[I,T]=N,$={dataId:I.dataId,dtype:I.dtype,shape:u.shape},D={dataId:T.dataId,dtype:T.dtype,shape:d.shape},M=new ju(e,u.shape,d.shape);return c.runWebGLProgram(M,[$,D],Jr(I.dtype,T.dtype))}),k=El({inputs:{real:x,imag:w},backend:c});return c.disposeIntermediateTensorInfo(x),c.disposeIntermediateTensorInfo(w),k}let p=s||Jr(u.dtype,d.dtype);if((u.dtype==="string"||d.dtype==="string"||c.shouldExecuteOnCPU([u,d]))&&r!=null){let b=c.texData.get(u.dataId).values,v=c.texData.get(d.dataId).values,x=u.dtype==="string"?O.fromUint8ToStringArray(b):b,w=u.dtype==="string"?O.fromUint8ToStringArray(v):v,[k,N]=r(u.shape,d.shape,x,w,p),I=c.makeTensorInfo(N,p),T=c.texData.get(I.dataId);return T.values=k,I}let m=oe().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&t!=null,g;return m?g=new wf(t,u.shape,d.shape,n):g=new ju(e,u.shape,d.shape),c.runWebGLProgram(g,[u,d],p)}}function ug(e,t=!1){if(e==="linear")return t?$fe:Ife;if(e==="relu")return t?Dfe:Efe;if(e==="elu")return t?Rfe:Tfe;if(e==="relu6")return t?Ofe:Cfe;if(e==="prelu")return t?s4:r4;if(e==="leakyrelu")return t?a4:n4;if(e==="sigmoid")return t?Mfe:Afe;throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}var i4=class{constructor(e,t,n,a=!1,r=!1,s=!1,i=null,o=!1,u=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=Pa(this.outputShape.length);let d=a?e[1]:e[2],c=Math.ceil(d/2),p=a?"i * 2, rc.y":"rc.y, i * 2",m=r?"rc.z, i * 2":"i * 2, rc.z",g=a?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],b=r?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],v="",x="";i&&(o?v=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${i}
        }`:u?v=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${i}
        }`:v=`vec4 activation(vec4 x) {
          ${i}
        }`,x="result = activation(result);");let w=s?"result += getBiasAtOutCoords();":"";s&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha");let k="rc.x",N="rc.x";e[0]<t[0]?k=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(N=`imod(rc.x, ${t[0]})`),this.userCode=`
      ${v}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${c}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${k};
        int batchB = ${N};
        for (int i = 0; i < ${c}; i++) {
          vec4 a = getMatrixA(batchA, ${p});
          vec4 b = getMatrixB(batchB, ${m});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${g[0]} * ${b[0]});
          result += (${g[1]} * ${b[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${w}

        ${x}

        setOutput(result);
      }
    `}},OR={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"},MR=class{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=O.assertAndGetBroadcastShape(t,n),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}},FR="return a * b;";function BI(e){let{inputs:t,backend:n}=e,{a,b:r}=t,s=O.upcastType(a.dtype,r.dtype);if(a.dtype==="complex64"){let o=n.texData.get(a.dataId),u=n.texData.get(r.dataId),d=new MR(OR.REAL,a.shape,r.shape),c=new MR(OR.IMAG,a.shape,r.shape),p=[{dataId:o.complexTensorInfos.real.dataId,dtype:o.complexTensorInfos.real.dtype,shape:a.shape},{dataId:o.complexTensorInfos.imag.dataId,dtype:o.complexTensorInfos.imag.dtype,shape:a.shape},{dataId:u.complexTensorInfos.real.dataId,dtype:u.complexTensorInfos.real.dtype,shape:r.shape},{dataId:u.complexTensorInfos.imag.dataId,dtype:u.complexTensorInfos.imag.dtype,shape:r.shape}],m=n.runWebGLProgram(d,p,"float32"),g=n.runWebGLProgram(c,p,"float32"),b=El({inputs:{real:m,imag:g},backend:n});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),b}if(n.shouldExecuteOnCPU([a,r])){let o=n.texData.get(a.dataId),u=n.texData.get(r.dataId),[d,c]=Xpe(a.shape,r.shape,o.values,u.values,s),p=n.makeTensorInfo(c,s),m=n.texData.get(p.dataId);return m.values=d,p}let i;return oe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?i=new wf(FR,a.shape,r.shape):i=new ju(FR,a.shape,r.shape),n.runWebGLProgram(i,[a,r],s)}var Qfe={kernelName:zc,backendName:"webgl",kernelFunc:BI};function eme(e,t,n){let a=[Pu(e.shape),...Uu(e.shape)],r={dtype:e.dtype,shape:a,dataId:e.dataId},s=[Pu(t),...Uu(t)],i=new QB(s,a),o=!0,u=[a],d=n.runWebGLProgram(i,[r],e.dtype,u,o);return{dataId:d.dataId,shape:t,dtype:d.dtype}}function Oe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{shape:s}=a,i=n,o=E.sizeFromShape(r.shape),u=E.inferFromImplicitShape(s,o),d=E.sizeFromShape(u);E.assert(o===d,()=>`The new shape (${u}) has ${d} elements and the old shape (${r.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`);let c=i.texData.get(r.dataId);return c.isPacked&&!lg(r.shape,u)&&!(c.texture!==null&&lg(c.shape,u))?eme(r,u,i):(i.incRef(r.dataId),{dataId:r.dataId,shape:u,dtype:r.dtype})}var tme={kernelName:Bp,backendName:"webgl",kernelFunc:Oe},zR=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:a,inSize:r,outSize:s}=e;this.outputShape=[a,s];let i=Math.floor(n/4)*4,o=n%4,u="sumValue += dot(values, ones);";if(t!=null){let c=1/t;u=`sumValue += dot(values * ${E.isInt(c)?c.toPrecision(2):c}, ones);`}let d="";r%n>0&&(d=`
        if (inIdx < 0 || inIdx >= ${r}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${d}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        float sumValue = 0.0;

        for (int i = 0; i < ${i}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${u}
        }

        int inIdx = inOffset + ${i};
        if (${o===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${u}
        } else if (${o===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${u}
        } else if (${o===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${u}
        }
        setOutput(sumValue);
      }
    `}},nme=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:a,inSize:r,outSize:s}=e;this.outputShape=[a,s];let i="0.0",o="";t==="prod"?i="1.0":t==="min"?(i="1.0 / 1e-20",o="min"):t==="max"&&(i="-1.0 / 1e-20",o="max");let u=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?u="sumValue":t==="prod"?u="prodValue":t==="all"?u="allValue":t==="any"&&(u="anyValue");let d=Math.floor(n/4)*4,c=n%4,p=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${o}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${o}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,m="vec4";t==="all"?(i="1.0",p=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,m="bvec4"):t==="any"&&(i="0.0",p=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,m="bvec4");let g="";r%n>0&&(g=`
        if (inIdx < 0 || inIdx >= ${r}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${i};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${g}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        vec4 minMaxValue = vec4(${i});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${d}; i += 4) {
          int inIdx = inOffset + i;
          ${m} values = ${m}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${p}
        }

        int inIdx = inOffset + ${d};
        if (${c===1}) {
          ${m} values = ${m}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${p}
        } else if (${c===2}) {
          ${m} values = ${m}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${p}
        } else if (${c===3}) {
          ${m} values = ${m}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${p}
        }
        setOutput(${u});
      }
    `}};function ame(e){let t=[];for(;t.length===0||t[t.length-1].outSize!==1;){let n=t.length?t[t.length-1].outSize:e[1],a=O.computeOptimalWindowSize(n);t.push({inSize:n,windowSize:a,outSize:Math.ceil(n/a)})}return t}function xd(e,t,n,a){let r=ame(e.shape),s=e;for(let i=0;i<r.length;i++){let{inSize:o,windowSize:u,outSize:d}=r[i],c,p;n==="mean"?c=i===0?new zR({windowSize:u,inSize:o,batchSize:e.shape[0],outSize:d},o):new zR({windowSize:u,inSize:o,batchSize:e.shape[0],outSize:d}):c=new nme({windowSize:u,inSize:o,batchSize:e.shape[0],outSize:d},n),p=s,s=a.runWebGLProgram(c,[s],t),p.dataId!==e.dataId&&a.disposeIntermediateTensorInfo(p)}return s}var rme=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let s=0;s<n.length;s++)n[s]=e[t[s]];this.outputShape=n,this.rank=n.length;let a=Zt(this.rank),r=sme(t);this.userCode=`
    void main() {
      ${a} resRC = getOutputCoords();
      setOutput(getA(${r}));
    }
    `}};function sme(e){let t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],a=new Array(t);for(let r=0;r<e.length;r++)a[e[r]]=n[r];return a.join()}var ime=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;let n=new Array(e.length);for(let d=0;d<n.length;d++)n[d]=e[t[d]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let a=Zt(this.rank),r=ZB("rc",this.rank),s=new Array(this.rank);for(let d=0;d<t.length;d++)s[t[d]]=r[d];let i=`vec2(${s.slice(-2).join()})`,o=`++${r[this.rank-1]} < ${n[this.rank-1]}`,u=`getChannel(getA(${s.join()}), ${i})`;this.userCode=`
    void main() {
      ${a} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${u};
      if(${o}) {
        result[1] = ${u};
      }
      --${r[this.rank-1]};
      if(++${r[this.rank-2]} < ${n[this.rank-2]}) {
        result[2] = ${u};
        if(${o}) {
          result[3] = ${u};
        }
      }
      setOutput(result);
    }
    `}};function Ex(e,t,n){let a=oe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new ime(e.shape,t):new rme(e.shape,t);return n.runWebGLProgram(a,[e],e.dtype)}function ome(e,t,n,a){let r=t,s=e.shape.length,i=E.parseAxisParam(r,e.shape),o=i,u=O.getAxesPermutation(o,s),d=u!=null,c=e;d&&(c=Ex(e,u,a),o=O.getInnerMostAxes(o.length,s)),O.assertAxesAreInnerMostDims("sum",o,s);let[p,m]=O.computeOutAndReduceShapes(c.shape,o),g=p;n&&(g=O.expandShapeToKeepDim(p,i));let b=E.sizeFromShape(m),v=E.sizeFromShape(e.shape)/b,x=Oe({inputs:{x:c},attrs:{shape:[v,b]},backend:a}),w=S0(e.dtype),k=xd(x,w,"sum",a),N=Oe({inputs:{x:k},attrs:{shape:g},backend:a});return a.disposeIntermediateTensorInfo(x),a.disposeIntermediateTensorInfo(k),d&&a.disposeIntermediateTensorInfo(c),N}function Cx(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a;return ome(r,s,i,n)}var lme={kernelName:rd,backendName:"webgl",kernelFunc:Cx};function Xa(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{perm:s}=a,i=n,o=r.shape.length,u=new Array(o);for(let c=0;c<u.length;c++)u[c]=r.shape[s[c]];let d;if(i.shouldExecuteOnCPU([r])){let c=i.texData.get(r.dataId).values,p=FI(c,r.shape,r.dtype,s,u);d=i.makeTensorInfo(u,r.dtype);let m=i.texData.get(d.dataId);m.values=p}else d=Ex(r,s,i);return d}var ume={kernelName:Hi,backendName:"webgl",kernelFunc:Xa},o4=1e3;function Gv({a:e,b:t,transposeA:n,transposeB:a,backend:r,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:u=null}){let d=e.shape.length,c=t.shape.length,p=n?e.shape[d-2]:e.shape[d-1],m=a?t.shape[c-1]:t.shape[c-2],g=n?e.shape[d-1]:e.shape[d-2],b=a?t.shape[c-2]:t.shape[c-1],v=e.shape.slice(0,-2),x=t.shape.slice(0,-2),w=E.sizeFromShape(v),k=E.sizeFromShape(x),N=af.assertAndGetBroadcastShape(e.shape.slice(0,-2),t.shape.slice(0,-2)).concat([g,b]);E.assert(p===m,()=>`Error in matMul: inner shapes (${p}) and (${m}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${a} must match.`);let I=n?[w,p,g]:[w,g,p],T=a?[k,b,m]:[k,m,b],$=Oe({inputs:{x:e},backend:r,attrs:{shape:I}}),D=Oe({inputs:{x:t},backend:r,attrs:{shape:T}}),M=[$,D],B=Math.max(w,k),V=n?$.shape[1]:$.shape[2],W=s!=null,R=i!=null,H=u==="leakyrelu",Z=u!=null?ug(u,!0):null,ae=W||R||H||Z!=null,j;if((g===1||b===1)&&V>o4&&ae===!1){let Q=$,ce=D;n&&(Q=Xa({inputs:{x:$},backend:r,attrs:{perm:[0,2,1]}}),M.push(Q)),a&&(ce=Xa({inputs:{x:D},backend:r,attrs:{perm:[0,2,1]}}),M.push(ce));let me=b!==1,L=b===1,ee=Q;me&&(ee=Oe({inputs:{x:Q},backend:r,attrs:{shape:[B,V,1]}}),M.push(ee));let ie=b===1?2:1,de=ce;L&&(de=Oe({inputs:{x:ce},backend:r,attrs:{shape:[B,1,V]}}),M.push(de));let we=BI({inputs:{a:ee,b:de},backend:r});j=Cx({inputs:{x:we},backend:r,attrs:{axis:ie,keepDims:!0}}),M.push(we)}else{let Q=Jr(e.dtype,t.dtype),ce=new i4(I,T,[B,g,b],n,a,W,Z,R,H),me=[$,D];if(s!=null&&me.push(s),R&&me.push(i),H){let L=r.makeTensorInfo([],"float32",E.createScalarValue(o,"float32"));me.push(L),M.push(L)}j=r.runWebGLProgram(ce,me,Q)}let K=Oe({inputs:{x:j},backend:r,attrs:{shape:N}});M.push(j);for(let Q of M)r.disposeIntermediateTensorInfo(Q);return K}function cme(e){let{inputs:t,backend:n,attrs:a}=e,{a:r,b:s,bias:i,preluActivationWeights:o}=t,{transposeA:u,transposeB:d,activation:c,leakyreluAlpha:p}=a;return Gv({a:r,b:s,transposeA:u,transposeB:d,backend:n,bias:i,preluActivationWeights:o,leakyreluAlpha:p,activation:c})}var dme={kernelName:Nu,backendName:"webgl",kernelFunc:cme},LR="return abs(x);";function hme(e){let{inputs:t,backend:n}=e,{x:a}=t;if(n.shouldExecuteOnCPU([a])&&a.dtype!=="complex64"){let s=n.texData.get(a.dataId),i=YB(s.values);return n.makeTensorInfo(a.shape,a.dtype,i)}let r;return oe().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new Jo(a.shape,LR):r=new oi(a.shape,LR),n.runWebGLProgram(r,[a],a.dtype)}var pme={kernelName:tp,backendName:"webgl",kernelFunc:hme},fme=ks+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,mme=Ct({opSnippet:fme}),gme={kernelName:Gu,backendName:"webgl",kernelFunc:mme},yme=ks+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,bme=Ct({opSnippet:yme}),vme={kernelName:qu,backendName:"webgl",kernelFunc:bme},BR="return a + b;",xme=Ia({opSnippet:BR,packedOpSnippet:BR,supportsComplex:!0,cpuKernelImpl:Epe}),wme={kernelName:bl,backendName:"webgl",kernelFunc:xme},Sme=class{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((r,s)=>`T${s}`);let n=[];this.variableNames.forEach(r=>{n.push(`float v${r} = get${r}AtOutCoords();`)});let a=this.variableNames.map(r=>`v${r}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        float result = ${a};
        setOutput(result);
      }
    `}},kme=class{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((r,s)=>`T${s}`);let n=[];this.variableNames.forEach(r=>{n.push(`vec4 v${r} = get${r}AtOutCoords();`)});let a=this.variableNames.map(r=>`v${r}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        vec4 result = ${a};
        setOutput(result);
      }
    `}};function vv(e){let{inputs:t,backend:n}=e,a=t;if(a.length===1)return Dr({inputs:{x:a[0]},backend:n});if(a.length>oe().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){let o=Math.floor(a.length/2),u=vv({inputs:a.slice(0,o),backend:n}),d=vv({inputs:a.slice(o),backend:n});return vv({inputs:[u,d],backend:n})}let r=a.map(o=>o.dtype).reduce((o,u)=>Jr(o,u)),s=a.map(o=>o.shape),i=oe().getBool("WEBGL_PACK")?new kme(a[0].shape,s):new Sme(a[0].shape,s);return n.runWebGLProgram(i,a,r)}var _me={kernelName:Ku,backendName:"webgl",kernelFunc:vv};function Nme(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a,o=r.shape.length,u=E.parseAxisParam(s,r.shape),d=u,c=O.getAxesPermutation(d,o),p=r;c!=null&&(p=Xa({inputs:{x:r},backend:n,attrs:{perm:c}}),d=O.getInnerMostAxes(d.length,o)),O.assertAxesAreInnerMostDims("all",d,o);let[m,g]=O.computeOutAndReduceShapes(p.shape,d),b=E.sizeFromShape(g),v=Oe({inputs:{x:p},backend:n,attrs:{shape:[-1,b]}}),x=xd(v,v.dtype,"all",n),w;if(i){let k=O.expandShapeToKeepDim(m,u);w=Oe({inputs:{x},backend:n,attrs:{shape:k}})}else w=Oe({inputs:{x},backend:n,attrs:{shape:m}});return n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(x),c!=null&&n.disposeIntermediateTensorInfo(p),w}var Ime={kernelName:np,backendName:"webgl",kernelFunc:Nme};function Tme(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a,o=r.shape.length,u=E.parseAxisParam(s,r.shape),d=u,c=O.getAxesPermutation(d,o),p=r;c!=null&&(p=Xa({inputs:{x:r},backend:n,attrs:{perm:c}}),d=O.getInnerMostAxes(d.length,o)),O.assertAxesAreInnerMostDims("any",d,o);let[m,g]=O.computeOutAndReduceShapes(p.shape,d),b=E.sizeFromShape(g),v=Oe({inputs:{x:p},backend:n,attrs:{shape:[-1,b]}}),x=xd(v,v.dtype,"any",n),w;if(i){let k=O.expandShapeToKeepDim(m,u);w=Oe({inputs:{x},backend:n,attrs:{shape:k}})}else w=Oe({inputs:{x},backend:n,attrs:{shape:m}});return n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(x),c!=null&&n.disposeIntermediateTensorInfo(p),w}var Eme={kernelName:ap,backendName:"webgl",kernelFunc:Tme},Cme=class{constructor(e,t,n){this.variableNames=["A"];let{windowSize:a,batchSize:r,outSize:s}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[r,s];let i=t==="max"?">":"<",o=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${a};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${a}; i++) {
          int inIdx = ${o};
          float candidate = getA(batch, inIdx);
          if (candidate ${i} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}},Ame=class{constructor(e,t,n,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,E.assert(e.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);let r=e[e.length-1],s=Math.ceil(r/t);this.outputShape=e.slice(0,-1),s>1&&this.outputShape.push(s),a||this.variableNames.push("bestIndicesA");let i=this.outputShape,o=i.length,u=Zt(o),d=Ga("coords",o),c,p;if(s===1){p=o+1;let D=Zt(p);c=`
        ${D} sourceLocR = ${D}(${d.join()}, 0);
        ++${d[o-1]};
        ${D} sourceLocG = ${D}(${d.join()}, 0);
        ++${d[o-2]};
        ${D} sourceLocA = ${D}(${d.join()}, 0);
        --${d[o-1]};
        ${D} sourceLocB = ${D}(${d.join()}, 0);
        --${d[o-2]};`}else p=o,c=`
        ${u} sourceLocR = coords;
        ++${d[o-1]};
        ${u} sourceLocG = coords;
        ++${d[o-2]};
        ${u} sourceLocA = coords;
        --${d[o-1]};
        ${u} sourceLocB = coords;
        --${d[o-2]};`;let m=["x","y","z","w","u","v"].slice(0,p),g="."+m[p-1],b=m.map(D=>"int "+D),v=Ga("sourceLocR",p-1).concat("inIdx.r"),x=Ga("sourceLocG",p-1).concat("inIdx.g"),w=Ga("sourceLocB",p-1).concat("inIdx.b"),k=Ga("sourceLocA",p-1).concat("inIdx.a"),N=n==="max"?"greaterThan":"lessThan",I=a?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${v.join()}),
                             getBestIndicesAChannel(${x.join()}),
                             getBestIndicesAChannel(${w.join()}),
                             getBestIndicesAChannel(${k.join()})));`,T=`vec4(
            getAChannel(${v.join()}),
            hasNextCol ? getAChannel(${x.join()}) : 0.,
            hasNextRow ? getAChannel(${w.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${k.join()}) : 0.)`,$=a?"":`
      float getBestIndicesAChannel(${b.join()}) {
        return getChannel(getBestIndicesA(${m.join()}),
                                          vec2(${m.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${b.join()}) {
        return getChannel(getA(${m.join()}),
                               vec2(${m.slice(-2).join()}));
      }
      ${$}
      void main() {
        ${u} coords = getOutputCoords();
        bool hasNextCol = ${d[o-1]} < ${i[o-1]-1};
        bool hasNextRow = ${d[o-2]} < ${i[o-2]-1};
        ${c}
        ivec4 srcIdx = ivec4(sourceLocR${g}, sourceLocG${g},
          sourceLocB${g}, sourceLocA${g}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${T};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${I}
          vec4 candidate = ${T};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${N}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}};function l4(e,t,n,a=null){let r=t.shape[0],s=t.shape[1];a!=null&&(r=a.shape[0],s=a.shape[1]);let i=O.computeOptimalWindowSize(s),o={windowSize:i,inSize:s,batchSize:r,outSize:Math.ceil(s/i)},u=new Cme(o,n,a==null),d=[t];a!=null&&d.push(a);let c=e.runWebGLProgram(u,d,"int32");if(c.shape[1]===1)return c;let p=l4(e,t,n,c);return e.disposeIntermediateTensorInfo(c),p}function u4(e,t,n,a=null){let r=a!=null?a.shape:t.shape,s=r[r.length-1],i=O.computeOptimalWindowSize(s),o=new Ame(r,i,n,a==null),u=a==null?[t]:[t,a],d=e.runWebGLProgram(o,u,"int32");if(d.shape.length===t.shape.length){let c=u4(e,t,n,d);return e.disposeIntermediateTensorInfo(d),c}return d}function c4(e,t,n,a){let r=[n];if(O.assertAxesAreInnerMostDims("arg"+a.charAt(0).toUpperCase()+a.slice(1),r,t.shape.length),!oe().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){let s=[],i=e.texData.get(t.dataId),o=i!==null&&i.isPacked,u=t;o&&(u=e.unpackTensor(t),s.push(u));let[d,c]=O.computeOutAndReduceShapes(u.shape,r),p=E.sizeFromShape(c),m=Oe({inputs:{x:u},backend:e,attrs:{shape:[-1,p]}});s.push(m);let g=l4(e,m,a);s.push(g);let b=Oe({inputs:{x:g},backend:e,attrs:{shape:d}});return s.forEach(v=>e.disposeIntermediateTensorInfo(v)),b}return u4(e,t,a)}function $me(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s}=a,i=E.parseAxisParam(s,r.shape),o=O.getAxesPermutation(i,r.shape.length),u=r,d=[];o!=null&&(u=Xa({inputs:{x:r},backend:n,attrs:{perm:o}}),d.push(u),i=O.getInnerMostAxes(i.length,u.shape.length)),O.assertAxesAreInnerMostDims("argMax",[i[0]],u.shape.length);let c=c4(n,u,i[0],"max");return d.forEach(p=>n.disposeIntermediateTensorInfo(p)),c}var Rme={kernelName:rp,backendName:"webgl",kernelFunc:$me};function Dme(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s}=a,i=E.parseAxisParam(s,r.shape),o=O.getAxesPermutation(i,r.shape.length),u=r,d=[];o!=null&&(u=Xa({inputs:{x:r},backend:n,attrs:{perm:o}}),d.push(u),i=O.getInnerMostAxes(i.length,u.shape.length)),O.assertAxesAreInnerMostDims("argMin",[i[0]],u.shape.length);let c=c4(n,u,i[0],"min");return d.forEach(p=>n.disposeIntermediateTensorInfo(p)),c}var Ome={kernelName:sp,backendName:"webgl",kernelFunc:Dme},Mme=ks+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,Fme=Ct({opSnippet:Mme}),zme={kernelName:Xu,backendName:"webgl",kernelFunc:Fme},Lme=ks+"return log(x + sqrt(x * x + 1.0));",Bme=Ct({opSnippet:Lme}),Pme={kernelName:Yu,backendName:"webgl",kernelFunc:Bme},Ume=ks+`
  return atan(x);
`,jme=Ct({opSnippet:Ume}),Wme={kernelName:Ju,backendName:"webgl",kernelFunc:jme},Vme=LI+`
  return atan(a, b);
`,Hme=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+vd+`
  return result;
`,Gme=Ia({opSnippet:Vme,packedOpSnippet:Hme}),qme={kernelName:Qu,backendName:"webgl",kernelFunc:Gme},Kme=ks+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,Xme=Ct({opSnippet:Kme}),Yme={kernelName:Zu,backendName:"webgl",kernelFunc:Xme},cg=class{constructor(e,t,n,a=!1,r=!1){if(this.variableNames=["x"],t==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let s=e.filterWidth,i=e.strideHeight,o=e.strideWidth,u=e.dilationHeight,d=e.dilationWidth,c=e.effectiveFilterHeight,p=e.effectiveFilterWidth,m=e.padInfo.top,g=e.padInfo.left;this.outputShape=e.outShape;let b=t==="avg",v=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,x=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`,w="0.0";if(b||(w="-1.0 / 1e-20"),n){let D=">=";this.userCode=`
        const ivec2 strides = ivec2(${i}, ${o});
        const ivec2 pads = ivec2(${m}, ${g});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${c};
              wR += ${u}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${p};
                wC += ${d}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${D} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${a?r?v:x:`wR * ${p} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let k="max",N=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(N="avgValue / max(count, 1.0)");let I=Math.floor(s/4)*4,T=s%4,$=`
      if (${b}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${k}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${o});
      const ivec2 pads = ivec2(${m}, ${g});
      const float initializationValue = ${w};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${w});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${c};
            wR += ${u}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${I}; wC += 4) {
            int xC = xCCorner + wC * ${d};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${d}, d),
              getValue(batch, xR, xC + 2 * ${d}, d),
              getValue(batch, xR, xC + 3 * ${d}, d)
            );

            ${$}
          }

          int xC = xCCorner + ${I};
          if (${T===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${$}
          } else if (${T===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${d}, d),
              initializationValue,
              initializationValue
            );

            ${$}
          } else if (${T===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${d}, d),
              getValue(batch, xR, xC + 2 * ${d}, d),
              initializationValue
            );

            ${$}
          }
        }
        setOutput(${N});
      }
    `}},PI=class{constructor(e,t,n,a=!1,r=!1){if(this.variableNames=["x"],t==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let s=e.filterWidth,i=e.strideDepth,o=e.strideHeight,u=e.strideWidth,d=e.dilationDepth,c=e.dilationHeight,p=e.dilationWidth,m=e.effectiveFilterDepth,g=e.effectiveFilterHeight,b=e.effectiveFilterWidth,v=e.padInfo.front,x=e.padInfo.top,w=e.padInfo.left;this.outputShape=e.outShape;let k=t==="avg",N="0.0";if(k||(N="-1.0 / 1e-20"),n){let B=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${i}, ${o}, ${u});
        const ivec3 pads = ivec3(${v}, ${x}, ${w});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${m};
              wD += ${d}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${g};
                wR += ${c}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${b};
                  wC += ${p}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${B} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${a?r?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${g} * ${b} +
                      wR * ${b} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let I="max",T=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(T="avgValue / max(count, 1.0)");let $=Math.floor(s/4)*4,D=s%4,M=`
      if (${k}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${I}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${i}, ${o}, ${u});
      const ivec3 pads = ivec3(${v}, ${x}, ${w});
      const float initializationValue = ${N};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${N});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${m};
            wD += ${d}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${g};
            wR += ${c}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${$}; wC += 4) {
              int xC = xCCorner + wC * ${p};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                getValue(batch, xD, xR, xC + 2 * ${p}, ch),
                getValue(batch, xD, xR, xC + 3 * ${p}, ch)
              );

              ${M}
            }

            int xC = xCCorner + ${$};
            if (${D===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${M}
            } else if (${D===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                initializationValue,
                initializationValue
              );

              ${M}
            } else if (${D===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                getValue(batch, xD, xR, xC + 2 * ${p}, ch),
                initializationValue
              );

              ${M}
            }
          }
        }
        setOutput(${T});
      }
    `}};function Jme(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t;gf(r,"avgPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:u}=a,d=1;E.assert(O.eitherStridesOrDilationsAreOne(i,d),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${d}'`);let c=O.computePool2DInfo(r.shape,s,i,d,o,u);if(c.filterWidth===1&&c.filterHeight===1&&E.arraysEqual(c.inShape,c.outShape))return Dr({inputs:{x:r},backend:n});let p=new cg(c,"avg",!1);return n.runWebGLProgram(p,[r],"float32")}var Zme={kernelName:ec,backendName:"webgl",kernelFunc:Jme};function Qme(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:u,dataFormat:d}=a,c=[1,1,1],p=O.computePool3DInfo(r.shape,s,i,c,o,u,d),m=new PI(p,"avg",!1);return n.runWebGLProgram(m,[r],"float32")}var ege={kernelName:ip,backendName:"webgl",kernelFunc:Qme},tge=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,r=e.strideWidth,s=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterHeight,u=e.effectiveFilterWidth,d=o-1-e.padInfo.top,c=u-1-e.padInfo.left,p=1/(t*n);this.userCode=`
      const ivec2 pads = ivec2(${d}, ${c});
      const float avgMultiplier = float(${p});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${o};
            wR += ${s}) {
          float dyR = float(dyRCorner + wR) / ${a}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${u};
            wC+= ${i}) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}},nge=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,a=e.filterWidth,r=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,u=e.dilationHeight,d=e.dilationWidth,c=e.effectiveFilterDepth,p=e.effectiveFilterHeight,m=e.effectiveFilterWidth,g=c-1-e.padInfo.front,b=p-1-e.padInfo.top,v=m-1-e.padInfo.left,x=1/(t*n*a);this.userCode=`
      const ivec3 pads = ivec3(${g}, ${b}, ${v});
      const float avgMultiplier = float(${x});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${c};
            wD += ${o}) {
          float dyD = float(dyDCorner + wD) / ${r}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${p};
              wR += ${u}) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${m};
                wC += ${d}) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function age(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,i=s,{filterSize:o,strides:u,pad:d,dimRoundingMode:c}=a,p=[1,1,1],m=O.computePool3DInfo(i.shape,o,u,p,d,c),g=new nge(m);return n.runWebGLProgram(g,[r],i.dtype)}var rge={kernelName:Tg,backendName:"webgl",kernelFunc:age};function sge(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,i=s;gf([r,s],"avgPoolGrad");let{filterSize:o,strides:u,pad:d}=a,c=O.computePool2DInfo(i.shape,o,u,1,d),p=new tge(c);return n.runWebGLProgram(p,[r],i.dtype)}var ige={kernelName:Ig,backendName:"webgl",kernelFunc:sge};function oge(e){let{inputs:t,backend:n,attrs:a}=e,{a:r,b:s}=t,{transposeA:i,transposeB:o}=a;return Gv({a:r,b:s,transposeA:i,transposeB:o,backend:n})}var lge={kernelName:tc,backendName:"webgl",kernelFunc:oge},uge=class{constructor(e,t,n,a,r,s){this.outputShape=[],this.variableNames=["x","mean","variance"],O.assertAndGetBroadcastShape(e,t),O.assertAndGetBroadcastShape(e,n);let i="0.0";a!=null&&(O.assertAndGetBroadcastShape(e,a),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="1.0";r!=null&&(O.assertAndGetBroadcastShape(e,r),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${i};
        float scale = ${o};
        float inv = scale * inversesqrt(variance + float(${s}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}},cge=class{constructor(e,t,n,a,r,s){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],O.assertAndGetBroadcastShape(e,t),O.assertAndGetBroadcastShape(e,n);let i="vec4(0.0)";a!=null&&(O.assertAndGetBroadcastShape(e,a),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="vec4(1.0)";r!=null&&(O.assertAndGetBroadcastShape(e,r),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${i};
        vec4 scale = ${o};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${s}));

        setOutput((x - mean) * inv + offset);
      }
    `}},dge=({inputs:e,backend:t,attrs:n})=>{let{x:a,mean:r,variance:s,offset:i,scale:o}=e;E.assert(r.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),E.assert(i==null||r.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),E.assert(o==null||r.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:u}=n;u==null&&(u=.001);let d=[a,r,s],c=null;i!=null&&(c=i.shape,d.push(i));let p=null;o!=null&&(p=o.shape,d.push(o));let m=oe().getBool("WEBGL_PACK_NORMALIZATION")?new cge(a.shape,r.shape,s.shape,c,p,u):new uge(a.shape,r.shape,s.shape,c,p,u);return t.runWebGLProgram(m,d,d[0].dtype)},hge={kernelName:vc,backendName:"webgl",kernelFunc:dge},pge=class{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;let t=Zt(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let n=fge(this.rank),a,r=e.map((s,i)=>`sourceLoc.${Sk[i]} = start[${i}] + coords.${Sk[i]};`);a=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${r.join(`
`)}
      `,this.userCode=`
      void main() {
        ${a}
        setOutput(getSource(${n}));
      }
    `}},Sk=["x","y","z","w","u","v"];function fge(e){if(e===1)return"sourceLoc";if(e<=6)return Sk.slice(0,e).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}var mge=class{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let t=Zt(this.rank),n=Ga("coords",this.rank),a=Ga("sourceLoc",this.rank),r=this.rank===1?"sourceLoc":`vec2(${a.slice(-2).join()})`,s=`getChannel(getSource(${a.join()}), ${r})`,i=`
      result.x = ${s};
      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {
        ++${a[this.rank-1]};
        result.y = ${s};
        --${a[this.rank-1]};
      }
    `,o=this.rank===1?"":`
      --${n[this.rank-1]};
      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {
        ++${a[this.rank-2]};
        result.z = ${s};
        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {
          ++${a[this.rank-1]};
          result.w = ${s};
        }
      }
    `,u=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((d,c)=>`start[${c}]`).join()});`:e.map((d,c)=>`${a[c]} = ${n[c]} + start[${c}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${u}
        vec4 result = vec4(0.);
        ${i}
        ${o}
        setOutput(result);
      }
    `}};function gge(e,t,n,a){let r=a.texData.get(e.dataId),s=a.makeTensorInfo(n,e.dtype),i=a.texData.get(s.dataId);Object.assign(i,r),i.refCount=1,i.shape=n,i.dtype=e.dtype;let o=ea.computeFlatOffset(t,E.computeStrides(e.shape));r.slice&&(o+=r.slice.flatOffset),i.slice={flatOffset:o,origDataId:r.slice&&r.slice.origDataId||e.dataId};let u=a.dataRefCount.get(i.slice.origDataId)||1;return a.dataRefCount.set(i.slice.origDataId,u+1),s}function kf(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:s,size:i}=a,[o,u]=ea.parseSliceParams(r,s,i);if(ea.assertParamsValid(r,o,u),E.sizeFromShape(u)===0)return n.makeTensorInfo(u,r.dtype,[]);if(n.shouldExecuteOnCPU([r])||r.dtype==="string"){let p=n.texData.get(r.dataId),m=ife(p.values,o,u,r.shape,r.dtype);return n.makeTensorInfo(u,r.dtype,m)}let{isPacked:d}=n.texData.get(r.dataId),c=ea.isSliceContinous(r.shape,o,u);if(d||!c){let p=oe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new mge(u):new pge(u),m=[o];return n.runWebGLProgram(p,[r],r.dtype,m)}return n.uploadToGPU(r.dataId),gge(r,o,u,n)}var yge={kernelName:Gp,backendName:"webgl",kernelFunc:kf},bge=e=>{let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,crops:i}=a;E.assert(r.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");let o=s.reduce((k,N)=>k*N),u=O.getReshaped(r.shape,s,o),d=O.getPermuted(u.length,s.length),c=O.getReshapedPermuted(r.shape,s,o),p=O.getSliceBeginCoords(i,s.length),m=O.getSliceSize(c,i,s.length),g=[],b=Oe({inputs:{x:r},backend:n,attrs:{shape:u}}),v=Xa({inputs:{x:b},backend:n,attrs:{perm:d}}),x=Oe({inputs:{x:v},backend:n,attrs:{shape:c}}),w=kf({inputs:{x},backend:n,attrs:{begin:p,size:m}});return g.push(b),g.push(v),g.push(x),g.forEach(k=>n.disposeIntermediateTensorInfo(k)),w},vge={kernelName:op,backendName:"webgl",kernelFunc:bge};function xge(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,weights:s}=t,{size:i}=a,o=n.readSync(r.dataId),u=n.readSync(s.dataId),d=XB(o,u,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,d)}var wge={kernelName:lp,backendName:"webgl",kernelFunc:xge},Sge=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,kge=`
  return float(int(a.r) & int(b.r));
`;function _ge(e){let{inputs:t,backend:n}=e,{a,b:r}=t,s=oe().getBool("WEBGL_PACK_BINARY_OPERATIONS"),i=oe().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([a,r])||i===1){let u=n.texData.get(a.dataId).values,d=n.texData.get(r.dataId).values,[c,p]=Ape(a.shape,r.shape,u,d,a.dtype),m=n.makeTensorInfo(p,a.dtype),g=n.texData.get(m.dataId);return g.values=c,m}let o;return s?o=new wf(Sge,a.shape,r.shape,!1):o=new ju(kge,a.shape,r.shape),n.runWebGLProgram(o,[a,r],a.dtype)}var Nge={kernelName:up,backendName:"webgl",kernelFunc:_ge};function Ige(e){let{inputs:t,backend:n}=e,{s0:a,s1:r}=t,s=n.readSync(a.dataId),i=n.readSync(r.dataId),o=O.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}var Tge={kernelName:Eg,backendName:"webgl",kernelFunc:Ige},Ege="return float(a != b);",d4=Ia({opSnippet:Ege,cpuKernelImpl:Jpe,dtype:"bool"}),Cge={kernelName:Dp,backendName:"webgl",kernelFunc:d4};function _y(e){let{inputs:t,backend:n}=e,{input:a}=t,r=n.texData.get(a.dataId);return Dr({inputs:{x:r.complexTensorInfos.real},backend:n})}var Age={kernelName:x0,backendName:"webgl",kernelFunc:_y},$ge="return float(int(x));";function Rge(e,t){let n=new oi(e.shape,$ge),a=t.runWebGLProgram(n,[e],"int32");return{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}function kk(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dtype:s}=a;if(s==="complex64"){if(r.dtype==="complex64")return Dr({inputs:{x:r},backend:n});let i=xn(r.shape),o=kk({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),u=El({inputs:{real:o,imag:i},backend:n});return i.dispose(),n.disposeIntermediateTensorInfo(o),u}if(r.dtype==="complex64"){let i=_y({inputs:{input:r},backend:n}),o=kk({inputs:{x:i},backend:n,attrs:{dtype:s}});return n.disposeIntermediateTensorInfo(i),o}if(!E.hasEncodingLoss(r.dtype,s)){let i=Dr({inputs:{x:r},backend:n});return{dataId:i.dataId,shape:i.shape,dtype:s}}if(n.shouldExecuteOnCPU([r])){let i=n.texData.get(r.dataId).values,[o,u,d]=$pe(i,r.shape,r.dtype,s);return n.makeTensorInfo(o,u,d)}if(s==="int32")return Rge(r,n);if(s==="bool"){let i=n.makeTensorInfo([],"bool",E.getTypedArrayFromDType("bool",1)),o=d4({inputs:{a:r,b:i},backend:n});return n.disposeIntermediateTensorInfo(i),o}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${s}`)}var Dge={kernelName:nc,backendName:"webgl",kernelFunc:kk},PR="return ceil(x);",Oge=Ct({opSnippet:PR,packedOpSnippet:PR,cpuKernelImpl:Rpe}),Mge={kernelName:ac,backendName:"webgl",kernelFunc:Oge},Fge=class{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}},zge=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}};function Lge(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{clipValueMin:s,clipValueMax:i}=a,o;oe().getBool("WEBGL_PACK_CLIP")?o=new zge(r.shape):o=new Fge(r.shape);let u=[[s],[i]];return n.runWebGLProgram(o,[r],r.dtype,u)}var Bge={kernelName:vl,backendName:"webgl",kernelFunc:Lge},Pge=class{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}};function UR(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}function Uge(e){let{inputs:t,backend:n}=e,{x:a}=t,r=n.texData.get(a.dataId),s=new Pge(a.shape),i=[UR(a,r.complexTensorInfos.real),UR(a,r.complexTensorInfos.imag)];return n.runWebGLProgram(s,i,i[0].dtype)}var jge={kernelName:Cg,backendName:"webgl",kernelFunc:Uge},Wge=class{constructor(e){this.outputShape=[],this.outputShape=O.computeOutShape(e,1),this.variableNames=e.map((s,i)=>`T${i}`);let t=new Array(e.length-1);t[0]=e[0][1];for(let s=1;s<t.length;s++)t[s]=t[s-1]+e[s][1];let n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let s=1;s<t.length;s++){let i=t[s-1];n.push(`else if (yC < ${t[s]}) setOutput(getT${s}(yR, yC-${i}));`)}let a=t.length,r=t[t.length-1];n.push(`else setOutput(getT${a}(yR, yC-${r}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${n.join(`
        `)}
      }
    `}},Vge=class{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=O.computeOutShape(e,t);let n=this.outputShape,a=n.length,r=Zt(a),s=Ga("coords",a),i=["x","y","z","w","u","v"].slice(0,a);this.variableNames=e.map((b,v)=>`T${v}`);let o=new Array(e.length-1);o[0]=e[0][t];for(let b=1;b<o.length;b++)o[b]=o[b-1]+e[b][t];let u=i[t],d=i.slice(-2),c=i.join(),p=`if (${u} < ${o[0]}) {
        return getChannel(
            getT0(${c}), vec2(${d.join()}));
        }`;for(let b=1;b<o.length;b++){let v=o[b-1];p+=`
        if (${u} < ${o[b]}  && ${u} >= ${o[b-1]}) {
          return getChannel(
            getT${b}(${tv(i,u,v)}),
            vec2(${tv(d,u,v)}));
        }`}let m=o.length,g=o[o.length-1];p+=`
        return getChannel(
          getT${m}(${tv(i,u,g)}),
          vec2(${tv(d,u,g)}));`,this.userCode=`
      float getValue(${i.map(b=>"int "+b)}) {
        ${p}
      }

      void main() {
        ${r} coords = getOutputCoords();
        vec4 result = vec4(getValue(${s}), 0., 0., 0.);

        ${s[a-1]} = ${s[a-1]} + 1;
        if (${s[a-1]} < ${n[a-1]}) {
          result.g = getValue(${s});
        }

        ${s[a-2]} = ${s[a-2]} + 1;
        if (${s[a-2]} < ${n[a-2]}) {
          result.a = getValue(${s});
        }

        ${s[a-1]} = ${s[a-1]} - 1;
        if (${s[a-2]} < ${n[a-2]} &&
            ${s[a-1]} < ${n[a-1]}) {
          result.b = getValue(${s});
        }
        setOutput(result);
      }
    `}};function tv(e,t,n){let a=e.indexOf(t);return e.map((r,s)=>s===a?`${r} - ${n}`:r).join()}function Ax(e){let{inputs:t,backend:n}=e,{input:a}=t,r=n.texData.get(a.dataId);return Dr({inputs:{x:r.complexTensorInfos.imag},backend:n})}var Hge={kernelName:g0,backendName:"webgl",kernelFunc:Ax};function Fm(e,t,n){let a=e[0].dtype;if(a==="complex64"){let g=e.map(k=>_y({inputs:{input:k},backend:n})),b=e.map(k=>Ax({inputs:{input:k},backend:n})),v=Fm(g,t,n),x=Fm(b,t,n),w=El({inputs:{real:v,imag:x},backend:n});return g.forEach(k=>n.disposeIntermediateTensorInfo(k)),b.forEach(k=>n.disposeIntermediateTensorInfo(k)),n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(x),w}let r=n.shouldExecuteOnCPU(e);if(a==="string"&&(r=!0),r){let g=e.map(I=>{let T=[-1,E.sizeFromShape(I.shape.slice(t))];return Oe({inputs:{x:I},backend:n,attrs:{shape:T}})}),b=g.map(I=>({vals:n.readSync(I.dataId),shape:I.shape})),v=O.computeOutShape(g.map(I=>I.shape),1),x=g[0].shape[0]===1,w=Dpe(b,v,a,x),k=O.computeOutShape(e.map(I=>I.shape),t),N=n.makeTensorInfo(k,a,w);return g.forEach(I=>n.disposeIntermediateTensorInfo(I)),N}let s=e.filter(g=>E.sizeFromShape(g.shape)>0),i=oe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&s[0].shape.length>1;if(s.length===1){let g=i?new oi(e[0].shape,Vo):new Jo(e[0].shape,Vo);return n.runWebGLProgram(g,e,a)}let o=oe().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(s.length>o){let g=[];for(let v=0;v<s.length;v+=o){let x=s.slice(v,v+o);g.push(Fm(x,t,n))}let b=Fm(g,t,n);for(let v of g)n.disposeIntermediateTensorInfo(v);return b}if(i){let g=new Vge(s.map(b=>b.shape),t);return n.runWebGLProgram(g,s,a)}let{tensors2D:u,outShape:d}=Gge(s,t,n),c=new Wge(u.map(g=>g.shape)),p=n.runWebGLProgram(c,u,a);u.forEach(g=>n.disposeIntermediateTensorInfo(g));let m=Oe({inputs:{x:p},attrs:{shape:d},backend:n});return n.disposeIntermediateTensorInfo(p),m}function Gge(e,t,n){let a=O.computeOutShape(e.map(r=>r.shape),t);return{tensors2D:e.map(r=>Oe({inputs:{x:r},attrs:{shape:[-1,E.sizeFromShape(r.shape.slice(t))]},backend:n})),outShape:a}}function h4(e){let{inputs:t,backend:n,attrs:a}=e,{axis:r}=a,s=E.parseAxisParam(r,t[0].shape)[0],i=t.map(d=>d.shape);O.assertParamsConsistent(i,s);let o=O.computeOutShape(t.map(d=>d.shape),s);if(E.sizeFromShape(o)===0)return n.makeTensorInfo(o,t[0].dtype,[]);let u=t.filter(d=>E.sizeFromShape(d.shape)>0);return u.length===1?Dr({inputs:{x:u[0]},backend:n}):Fm(u,s,n)}var qge={kernelName:cp,backendName:"webgl",kernelFunc:h4},p4=class{constructor(e,t=!1,n=null,a=!1,r=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;let s=e.padInfo.top,i=e.padInfo.left,o=e.strideHeight,u=e.strideWidth,d=e.dilationHeight,c=e.dilationWidth,p=e.filterHeight,m=e.filterWidth,g=Math.floor(e.inChannels/4)*4,b=e.inChannels%4,v=e.dataFormat==="channelsLast",x=v?1:2,w=v?2:3,k=v?3:1,N="",I="";n&&(a?N=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:r?N=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:N=`
          float activation(float x) {
            ${n}
          }
        `,I="result = activation(result);");let T=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${N}

      const ivec2 strides = ivec2(${o}, ${u});
      const ivec2 pads = ivec2(${s}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${k}];

        ivec2 xRCCorner =
            ivec2(coords[${x}], coords[${w}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${p}; wR++) {
          int xR = xRCorner + wR * ${d};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${m}; wC++) {
            int xC = xCCorner + wC * ${c};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${g}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${v}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${b===1}) {

              if (${v}) {
                dotProd +=
                    getX(batch, xR, xC, ${g}) *
                    getW(wR, wC, ${g}, d2);
              } else {
                dotProd +=
                    getX(batch, ${g}, xR, xC) *
                    getW(wR, wC, ${g}, d2);
              }

            } else if (${b===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${g}, d2),
                getW(wR, wC, ${g} + 1, d2)
              );

              if (${v}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${g}),
                  getX(batch, xR, xC, ${g} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${g}, xR, xC),
                  getX(batch, ${g} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${b===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${g}, d2),
                getW(wR, wC, ${g} + 1, d2),
                getW(wR, wC, ${g} + 2, d2)
              );

              if (${v}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${g}),
                  getX(batch, xR, xC, ${g} + 1),
                  getX(batch, xR, xC, ${g} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${g}, xR, xC),
                  getX(batch, ${g} + 1, xR, xC),
                  getX(batch, ${g} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${T}
        ${I}
        setOutput(result);
      }
    `}},Kge=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let t=e.padInfo.front,n=e.padInfo.top,a=e.padInfo.left,r=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,u=e.dilationHeight,d=e.dilationWidth,c=e.filterDepth,p=e.filterHeight,m=e.filterWidth,g=Math.floor(e.inChannels/4)*4,b=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${r}, ${s}, ${i});
      const ivec3 pads = ivec3(${t}, ${n}, ${a});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${c}; wF++) {
          int xF = xFCorner + wF * ${o};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${p}; wR++) {
            int xR = xRCorner + wR * ${u};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${m}; wC++) {
              int xC = xCCorner + wC * ${d};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${g}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${b===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${g}) *
                  getW(wF, wR, wC, ${g}, d2);
              } else if (${b===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${g}),
                  getX(batch, xF, xR, xC, ${g} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${g}, d2),
                  getW(wF, wR, wC, ${g} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${b===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${g}),
                  getX(batch, xF, xR, xC, ${g} + 1),
                  getX(batch, xF, xR, xC, ${g} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${g}, d2),
                  getW(wF, wR, wC, ${g} + 1, d2),
                  getW(wF, wR, wC, ${g} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},f4=class{constructor(e,t=!1,n=null,a=!1,r=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Pa(this.outputShape.length);let s=e.padInfo.left,i=e.strideWidth,o=e.dilationWidth,u=e.filterHeight,d=e.filterWidth,c=d,p=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let v=0;v<d;v++)p+=`
           vec4 xTexelC${v*2};
           int xTexelC${v*2}Ready;
           vec4 xTexelC${v*2+1};
           int xTexelC${v*2+1}Ready;
           vec4 xC${v};`;p+=`
     for (int r = 0; r < ${u}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let v=0;v<d;v++)p+=`
           xTexelC${v*2} = vec4(0.0);
           xTexelC${v*2}Ready = 0;
           xTexelC${v*2+1} = vec4(0.0);
           xTexelC${v*2+1}Ready = 0;
           xC${v} = vec4(0.0);`;p+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let v=0;v<(c+1)/2;v++){let x=v*2;if(p+=`
           xC = xCCorner + ${x*o};
           `,i===1){if(x<d&&(s%2===1?(p+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {
                   xTexelC${x} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${x}.zw = vec2(0.0);
                   }
                   xTexelC${x}Ready = 1;
                 }
               `,o===1&&x>0?p+=`
                 xC${x} = vec4(xTexelC${x-2}.zw, xTexelC${x}.xy);
                 `:p+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${x} = vec4(previous.zw, xTexelC${x}.xy);
                   } else {
                     xC${x} = vec4(0.0, 0.0, xTexelC${x}.xy);
                   }
                   `):p+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {
                   xTexelC${x} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${x}.zw = vec2(0.0);
                   }
                   xTexelC${x}Ready = 1;
                 }

                 xC${x} = xTexelC${x};
                 `,x+1<d)){let w=s%2===0?E.nearestLargerEven(o):o;o%2===0&&s%2===1||o%2!==0&&s%2!==1?(p+=`
                   xCOffset = xC + imod(pads[1], 2) + ${w};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                     xTexelC${x+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${x+1}.zw = vec2(0.0);
                     }
                     xTexelC${x+1}Ready = 1;
                   }
                   `,o>1?p+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${x+1} = vec4(previous.zw, xTexelC${x+1}.xy);
                     } else {
                      xC${x+1} = vec4(0.0, 0.0, xTexelC${x+1}.xy);
                     }
                     `:p+=`
                     xC${x+1} = vec4(xTexelC${x}.zw, xTexelC${x+1}.xy);
                     `):w===1?p+=`
                     xC${x+1} = xTexelC${x};
                     `:p+=`
                     xCOffset = xC + ${w};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                       xTexelC${x+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${x+1}.zw = vec2(0.0);
                       }
                       xTexelC${x+1}Ready = 1;
                     }

                     xC${x+1} = xTexelC${x+1};
                     `}}else x<d&&(s%2===1?(p+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {
                   xTexelC${x} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${x}.zw = vec2(0.0);
                   }
                   xTexelC${x}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${x+1}Ready == 0) {
                   xTexelC${x+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${x+1}.zw = vec2(0.0);
                   }
                   xTexelC${x+1}Ready = 1;
                 }

                 xC${x} = vec4(xTexelC${x}.zw, xTexelC${x+1}.zw);
               `,x+1<d&&(p+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${x+1} = vec4(xTexelC${x+1}.xy, final.xy);
                 `)):(p+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {
                   xTexelC${x} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${x}.zw = vec2(0.0);
                   }
                   xTexelC${x}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                   xTexelC${x+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${x+1}.zw = vec2(0.);
                   }
                   xTexelC${x+1}Ready = 1;
                 }

                 xC${x} = vec4(
                   xTexelC${x}.xy, xTexelC${x+1}.xy);
               `,x+1<d&&(p+=`
                   xC${x+1} = vec4(xTexelC${x}.zw, xTexelC${x+1}.zw);
                 `)));x<d&&(p+=`
             wTexel = getW(r, ${x}, d1, d2);
             dotProd += xC${x}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${x}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,x+1<d&&(p+=`
               wTexel = getW(r, ${x+1}, d1, d2);
               dotProd += xC${x+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${x+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}p+=`
     }
   `,p+=`
     }
   `,p+=`
     }
   `;let m="",g="";n&&(a?m=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${n}
         }`:r?m=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${n}
         }`:m=`vec4 activation(vec4 x) {
           ${n}
         }`,g="result = activation(result);");let b=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${m}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${p}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${b}
         ${g}
         setOutput(result);
       }
     `}},Xge=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=Pa(this.outputShape.length);let{dataFormat:n}=t,a=er(),r=n==="channelsLast",s=r?1:2,i=r?2:3,o=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`,u="";for(let d=0;d<=1;d++)for(let c=0;c<=1;c++)u+=`
          blockIndex = rc.z + ${c};
          pos = rc.y + ${d};

          ${o}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${s}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${i}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${r}) {
                  innerDims = vec2(d1, ch);
                  result[${d*2+c}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${d*2+c}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${u}

        ${a.output} = result;
      }
    `}};function qv(e,t){let n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&n===1&&e[0]>1?[e[0],1]:null}function m4({x:e,filter:t,convInfo:n,backend:a,bias:r=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:o=null}){let u=e.shape,d=a.texData.get(e.dataId),c=n.inChannels,p=u[0]*u[1]*u[2],m=n.outChannels,g=n.dataFormat==="channelsLast",b=!1,v=!1,x,w=[];if(s!=null){let k=qv(s.shape,g);k!=null&&(s=Oe({inputs:{x:s},backend:a,attrs:{shape:k}}),w.push(s))}if(r!=null){let k=qv(r.shape,g);k!=null&&(r=Oe({inputs:{x:r},backend:a,attrs:{shape:k}}),w.push(r))}if(!((p===1||m===1)&&c>o4)&&d.isPacked&&g&&d.texture!=null&&u[2]%2!==0&&E.arraysEqual(d.shape.slice(-3),u.slice(-3))){let k=u[0]*u[1]*(u[2]+1),N={dataId:e.dataId,shape:[1,k,n.inChannels],dtype:e.dtype},I=d.shape;d.shape=d.shape.slice(),d.shape[d.shape.length-2]++,E.assert(lg(d.shape,N.shape),()=>`packed reshape ${d.shape} to ${N.shape} isn't free`);let T=Oe({inputs:{x:t},backend:a,attrs:{shape:[1,n.inChannels,n.outChannels]}});w.push(T);let $=Gv({a:N,b:T,backend:a,transposeA:b,transposeB:v,bias:r,activation:o,preluActivationWeights:s,leakyreluAlpha:i}),D=a.texData.get($.dataId);E.assert(D.isPacked,()=>"batchMatMul result is expected to be packed"),d.shape=I,D.shape=n.outShape,x=Dr({inputs:{x:$},backend:a}),x.shape=n.outShape,w.push($)}else{let k=n.outHeight*n.outWidth,N=Oe({inputs:{x:e},backend:a,attrs:{shape:g?[n.batchSize,k,n.inChannels]:[n.batchSize,n.inChannels,k]}}),I=Oe({inputs:{x:t},backend:a,attrs:{shape:[1,n.inChannels,n.outChannels]}}),T=Gv({a:g?N:I,b:g?I:N,transposeA:!g,transposeB:v,backend:a,bias:r,activation:o,preluActivationWeights:s,leakyreluAlpha:i});x=Oe({inputs:{x:T},backend:a,attrs:{shape:n.outShape}}),w.push(N),w.push(I),w.push(T)}for(let k of w)a.disposeIntermediateTensorInfo(k);return x}function g4({x:e,filter:t,convInfo:n,backend:a,bias:r=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:o=null}){let{filterWidth:u,filterHeight:d,inChannels:c,outWidth:p,outHeight:m,dataFormat:g}=n,b=g==="channelsLast",v=u*d*c,x=m*p,w=[n.batchSize,v,x],k=!0,N=!1,I=[];if(s!=null){let Q=qv(s.shape,b);Q!=null&&(s=Oe({inputs:{x:s},backend:a,attrs:{shape:Q}}),I.push(s))}if(r!=null){let Q=qv(r.shape,b);Q!=null&&(r=Oe({inputs:{x:r},backend:a,attrs:{shape:Q}}),I.push(r))}let T=Oe({inputs:{x:t},backend:a,attrs:{shape:[1,v,E.sizeFromShape(t.shape)/v]}});I.push(T);let $=new Xge(w,n),D=[e.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],M=a.runWebGLProgram($,[e],"float32",D),B=Oe({inputs:{x:M},backend:a,attrs:{shape:w}});I.push(M),I.push(B);let V=r!=null,W=s!=null,R=o==="leakyrelu",H=o?ug(o,!0):null,Z=new i4(b?B.shape:T.shape,b?T.shape:B.shape,b?[n.batchSize,x,n.outChannels]:[n.batchSize,n.outChannels,x],k,N,V,H,W,R),ae=b?[B,T]:[T,B];if(r&&ae.push(r),W&&ae.push(s),R){let Q=a.makeTensorInfo([],"float32",E.createScalarValue(i,"float32"));ae.push(Q),I.push(Q)}let j=a.runWebGLProgram(Z,ae,"float32"),K=Oe({inputs:{x:j},backend:a,attrs:{shape:n.outShape}});I.push(j);for(let Q of I)a.disposeIntermediateTensorInfo(Q);return K}function Yge(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dataFormat:u,dilations:d,dimRoundingMode:c}=a,p=O.convertConv2DDataFormat(u),m=O.computeConv2DInfo(r.shape,s.shape,i,d,o,c,!1,p),g;if(m.filterHeight===1&&m.filterWidth===1&&m.dilationHeight===1&&m.dilationWidth===1&&m.strideHeight===1&&m.strideWidth===1&&(m.padInfo.type==="SAME"||m.padInfo.type==="VALID"))g=m4({x:r,filter:s,convInfo:m,backend:n});else if(m.strideWidth<=2&&p==="channelsLast"&&oe().getBool("WEBGL_EXP_CONV")){let v=new f4(m),x=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]];g=n.runWebGLProgram(v,[r,s],"float32",x)}else if(oe().getBool("WEBGL_CONV_IM2COL"))g=g4({x:r,filter:s,convInfo:m,backend:n});else{let v=new p4(m);g=n.runWebGLProgram(v,[r,s],"float32")}let b=Oe({inputs:{x:g},backend:n,attrs:{shape:m.outShape}});return n.disposeIntermediateTensorInfo(g),b}var Jge={kernelName:rc,backendName:"webgl",kernelFunc:Yge},Zge=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,a=e.padInfo.top,r=e.padInfo.left,s=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${a};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${r};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${s?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}},Qge=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,r=e.strideWidth,s=e.dataFormat==="channelsLast",i=t-1-e.padInfo.top,o=n-1-e.padInfo.left,u=s?1:2,d=s?2:3,c=s?3:1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${c}];

        ivec2 dyCorner = ivec2(coords[${u}], coords[${d}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${a}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${s}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},eye=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideDepth,n=e.strideHeight,a=e.strideWidth,r=e.padInfo.front,s=e.padInfo.top,i=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${r};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${n} - ${s};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${a} - ${i};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},tye=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,a=e.filterWidth,r=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=t-1-e.padInfo.front,u=n-1-e.padInfo.top,d=a-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${o}, ${u}, ${d});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${r}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${n}; wR++) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${n} - 1 - wR;

            for (int wC = 0; wC < ${a}; wC++) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${a} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function nye(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:i,pad:o,dataFormat:u,dimRoundingMode:d,filterShape:c}=a,p=O.convertConv2DDataFormat(u),m=O.computeConv2DInfo(r.shape,c,i,1,o,d,!1,p),g=new Zge(m);return n.runWebGLProgram(g,[r,s],"float32")}var aye={kernelName:u0,backendName:"webgl",kernelFunc:nye},rye=class{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=Pa(this.outputShape.length);let t=e.filterHeight,n=e.filterWidth,a=t-1-e.padInfo.top,r=n-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${r});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            int wCPerm = ${n} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}};function sye(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{inputShape:i,strides:o,pad:u,dataFormat:d,dimRoundingMode:c}=a,p=O.convertConv2DDataFormat(d),m=O.computeConv2DInfo(i,s.shape,o,1,u,c,!1,p);if(oe().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&p==="channelsLast"){let g=[[m.strideHeight,m.strideWidth]],b=new rye(m);return n.runWebGLProgram(b,[r,s],"float32",g)}else{let g=new Qge(m);return n.runWebGLProgram(g,[r,s],"float32")}}var iye={kernelName:sc,backendName:"webgl",kernelFunc:sye};function oye(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dilations:u}=a,d=O.computeConv3DInfo(r.shape,s.shape,i,u,o),c=new Kge(d);return n.runWebGLProgram(c,[r,s],"float32")}var lye={kernelName:ic,backendName:"webgl",kernelFunc:oye};function uye(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:i,pad:o,filterShape:u}=a,d=O.computeConv3DInfo(r.shape,u,i,1,o),c=new eye(d);return n.runWebGLProgram(c,[r,s],"float32")}var cye={kernelName:dp,backendName:"webgl",kernelFunc:uye};function dye(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{pad:i,strides:o,inputShape:u}=a,d=O.computeConv3DInfo(u,s.shape,o,1,i),c=new tye(d);return n.runWebGLProgram(c,[r,s],"float32")}var hye={kernelName:hp,backendName:"webgl",kernelFunc:dye},pye=Sf+`
  return cos(x);
`,fye=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${vd}
  return result;
`,mye=Ct({opSnippet:pye,packedOpSnippet:fye}),gye={kernelName:oc,backendName:"webgl",kernelFunc:mye},yye=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,bye=Ct({opSnippet:yye}),vye={kernelName:lc,backendName:"webgl",kernelFunc:bye},xye=class{constructor(e,t,n,a,r){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];let[s,i,o,u]=e,[d]=t,[c,p]=n;this.outputShape=[d,c,p,u];let m=a==="bilinear"?1:0,[g,b]=[`${i-1}.0`,`${o-1}.0`],[v,x,w]=c>1?[`${(i-1)/(c-1)}`,"(y2-y1) * height_ratio",`y1*${g} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${g}`],[k,N,I]=p>1?[`${(o-1)/(p-1)}`,"(x2-x1) * width_ratio",`x1*${b} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${b}`];this.userCode=`
      const float height_ratio = float(${v});
      const float width_ratio = float(${k});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${s}) {
          return;
        }

        float height_scale = ${x};
        float width_scale = ${N};

        float in_y = ${w};
        if( in_y < 0.0 || in_y > ${g} ) {
          setOutput(float(${r}));
          return;
        }
        float in_x = ${I};
        if( in_x < 0.0 || in_x > ${b} ) {
          setOutput(float(${r}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${m} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}},wye=e=>{let{inputs:t,backend:n,attrs:a}=e,{image:r,boxes:s,boxInd:i}=t,{cropSize:o,method:u,extrapolationValue:d}=a,c=new xye(r.shape,s.shape,o,u,d);return n.runWebGLProgram(c,[r,s,i],"float32")},Sye={kernelName:fp,backendName:"webgl",kernelFunc:wye},dg;(function(e){e.Prod="*",e.Sum="+"})(dg||(dg={}));var jR=class{constructor(e,t,n,a){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];let r=this.outputShape.length,s=this.op===dg.Prod?"1.0":"0.0",i=n?s:`getX(${WR(r,"coords",this.op)})`,o=this.outputShape[this.outputShape.length-1],u="",d="";n?(u=a?`end != ${o-1}`:"end != 0",d=a?"end + 1":"end - 1"):(u=a?`end + pow2 < ${o}`:"end >= pow2",d=a?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Zt(r)} coords = getOutputCoords();
        int end = ${VR(r,"coords",this.op)};
        float val = ${i};
        int pow2 = int(pow(2.0, index));
        if (${u}) {
          int idx = ${d};
          ${VR(r,"coords",this.op)} = idx;
          val ${this.op}= getX(${WR(r,"coords",this.op)});
        }
        setOutput(val);
      }
    `}};function WR(e,t,n){if(e===1)return`${t}`;if(e===2)return`${t}.x, ${t}.y`;if(e===3)return`${t}.x, ${t}.y, ${t}.z`;if(e===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function VR(e,t,n){if(e===1)return`${t}`;if(e===2)return`${t}.y`;if(e===3)return`${t}.z`;if(e===4)return`${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function y4(e,t,n,a,r,s){let i=t.shape.length,o=O.getAxesPermutation([a],i),u=t;o!=null&&(u=Xa({inputs:{x:t},backend:n,attrs:{perm:o}}));let d=O.getInnerMostAxes(1,i)[0];if(d!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${a}`);let c=u.shape[d],p=Dr({inputs:{x:u},backend:n});for(let m=0;m<=Math.ceil(Math.log2(c))-1;m++){let g=new jR(e,u.shape,!1,s),b=[[m]],v=p;p=n.runWebGLProgram(g,[p],p.dtype,b),n.disposeIntermediateTensorInfo(v)}if(r){let m=new jR(e,u.shape,r,s),g=p;p=n.runWebGLProgram(m,[p],p.dtype),n.disposeIntermediateTensorInfo(g)}if(o!=null){let m=O.getUndoAxesPermutation(o),g=Xa({inputs:{x:p},backend:n,attrs:{perm:m}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(u),g}return p}function kye(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,exclusive:i,reverse:o}=a;return y4(dg.Prod,r,n,s,i,o)}var _ye={kernelName:pp,backendName:"webgl",kernelFunc:kye};function Nye(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,exclusive:i,reverse:o}=a;return y4(dg.Sum,r,n,s,i,o)}var Iye={kernelName:uc,backendName:"webgl",kernelFunc:Nye};function Tye(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,weights:s}=t,{size:i,binaryOutput:o}=a;if(r.shape.length===1){let u=n.readSync(r.dataId),d=n.readSync(s.dataId),c=XB(u,d,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,c)}else if(r.shape.length===2){let u=n.bufferSync(r),d=n.bufferSync(s),c=Cpe(u,d,i,o);return n.makeTensorInfo(c.shape,s.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}var Eye={kernelName:Ag,backendName:"webgl",kernelFunc:Tye},Cye=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};function Aye(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockSize:s,dataFormat:i}=a,o=r.shape[0],u=i==="NHWC"?r.shape[1]:r.shape[2],d=i==="NHWC"?r.shape[2]:r.shape[3],c=i==="NHWC"?r.shape[3]:r.shape[1],p=u*s,m=d*s,g=c/(s*s),b=i==="NHWC"?[o,p,m,g]:[o,g,p,m],v=new Cye(b,s,i);return n.runWebGLProgram(v,[r],r.dtype)}var $ye={kernelName:mp,backendName:"webgl",kernelFunc:Aye},b4=class{constructor(e,t=!1,n=null,a=!1,r=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Pa(this.outputShape.length);let s=e.filterHeight,i=e.filterWidth,o=e.outChannels/e.inChannels,u="",d="";n&&(a?u=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:r?u=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:u=`
          float activation(float x) {
            ${n}
          }
        `,d="result = activation(result);");let c=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${u}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${o};
        int q = d2 - d1 * ${o};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${s}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${i}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${c}
        ${d}
        setOutput(result);
      }
    `}},v4=class{constructor(e,t=!1,n=null,a=!1,r=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Pa(this.outputShape.length);let s=e.outChannels/e.inChannels,i=e.padInfo.left,o=e.strideWidth,u=e.dilationWidth,d=e.filterHeight,c=e.filterWidth,p=c,m=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let x=0;x<c;x++)m+=`
          vec4 xTexelC${x*2};
          int xTexelC${x*2}Ready;
          vec4 xTexelC${x*2+1};
          int xTexelC${x*2+1}Ready;
          vec4 xC${x};`;m+=`
    for (int r = 0; r < ${d}; r++) {
      `;for(let x=0;x<c;x++)m+=`
          xTexelC${x*2} = vec4(0.0);
          xTexelC${x*2}Ready = 0;
          xTexelC${x*2+1} = vec4(0.0);
          xTexelC${x*2+1}Ready = 0;
          xC${x} = vec4(0.0);`;m+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let x=0;x<(p+1)/2;x++){let w=x*2;if(m+=`
          xC = xCCorner + ${w*u};
          `,o===1){if(w<c&&(i%2===1?(m+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w}Ready == 0) {
                  xTexelC${w} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${w}.zw = vec2(0.0);
                  }
                  xTexelC${w}Ready = 1;
                }
              `,u===1&&w>0?m+=`
                xC${w} = vec4(xTexelC${w-2}.zw, xTexelC${w}.xy);
                `:m+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${w} = vec4(previous.zw, xTexelC${w}.xy);
                  } else {
                    xC${w} = vec4(0.0, 0.0, xTexelC${w}.xy);
                  }
                  `):m+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${w}Ready == 0) {
                  xTexelC${w} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${w}.zw = vec2(0.0);
                  }
                  xTexelC${w}Ready = 1;
                }

                xC${w} = xTexelC${w};
                `,w+1<c)){let k=i%2===0?E.nearestLargerEven(u):u;u%2===0&&i%2===1||u%2!==0&&i%2!==1?(m+=`
                  xCOffset = xC + imod(pads[1], 2) + ${k};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w+1}Ready == 0) {
                    xTexelC${w+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${w+1}.zw = vec2(0.0);
                    }
                    xTexelC${w+1}Ready = 1;
                  }
                  `,u>1?m+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${w+1} = vec4(previous.zw, xTexelC${w+1}.xy);
                    } else {
                     xC${w+1} = vec4(0.0, 0.0, xTexelC${w+1}.xy);
                    }
                    `:m+=`
                    xC${w+1} = vec4(xTexelC${w}.zw, xTexelC${w+1}.xy);
                    `):k===1?m+=`
                    xC${w+1} = xTexelC${w};
                    `:m+=`
                    xCOffset = xC + ${k};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w+1}Ready == 0) {
                      xTexelC${w+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${w+1}.zw = vec2(0.0);
                      }
                      xTexelC${w+1}Ready = 1;
                    }

                    xC${w+1} = xTexelC${w+1};
                    `}}else w<c&&(i%2===1?(m+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w}Ready == 0) {
                  xTexelC${w} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${w}.zw = vec2(0.0);
                  }
                  xTexelC${w}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${w+1}Ready == 0) {
                  xTexelC${w+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${w+1}.zw = vec2(0.0);
                  }
                  xTexelC${w+1}Ready = 1;
                }

                xC${w} = vec4(xTexelC${w}.zw, xTexelC${w+1}.zw);
              `,w+1<c&&(m+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${w+1} = vec4(xTexelC${w+1}.xy, final.xy);
                `)):(m+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${w}Ready == 0) {
                  xTexelC${w} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${w}.zw = vec2(0.0);
                  }
                  xTexelC${w}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w+1}Ready == 0) {
                  xTexelC${w+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${w+1}.zw = vec2(0.);
                  }
                  xTexelC${w+1}Ready = 1;
                }

                xC${w} = vec4(
                  xTexelC${w}.xy, xTexelC${w+1}.xy);
              `,w+1<c&&(m+=`
                  xC${w+1} = vec4(xTexelC${w}.zw, xTexelC${w+1}.zw);
                `)));w<c&&(m+=`
            wTexel = getW(r, ${w}, d1, q);
            dotProd += xC${w} * vec4(wTexel.xz, wTexel.xz);
          `,w+1<c&&(m+=`
              wTexel = getW(r, ${w+1}, d1, q);
              dotProd += xC${w+1} * vec4(wTexel.xz, wTexel.xz);
            `))}m+=`
    }
  `,m+=`
      }
    `;let g="",b="";n&&(a?g=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:r?g=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:g=`vec4 activation(vec4 x) {
          ${n}
        }`,b="result = activation(result);");let v=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${g}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${s};
        int q = d2 - d1 * ${s};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${m}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${v}
        ${b}
        setOutput(result);
      }
    `}};function Rye(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dilations:u,dimRoundingMode:d}=a,c=u;c==null&&(c=[1,1]),E.assert(O.eitherStridesOrDilationsAreOne(i,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);let p=O.computeConv2DInfo(r.shape,s.shape,i,c,o,d,!0),m;oe().getBool("WEBGL_PACK_DEPTHWISECONV")&&p.strideWidth<=2&&p.outChannels/p.inChannels===1?m=new v4(p):m=new b4(p);let g=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];return n.runWebGLProgram(m,[r,s],"float32",g)}var Dye={kernelName:cc,backendName:"webgl",kernelFunc:Rye},Oye=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,a=e.padInfo.top,r=e.padInfo.left,s=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${s} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${a};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${r};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}},Mye=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,r=e.strideWidth,s=t-1-e.padInfo.top,i=n-1-e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${s}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${a}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${o}; dm++) {
              int d2 = d1 * ${o} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Fye(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:i,dilations:o,pad:u,dimRoundingMode:d,filterShape:c}=a,p=O.computeConv2DInfo(r.shape,c,i,o,u,d,!0),m=new Oye(p);return n.runWebGLProgram(m,[r,s],"float32")}var zye={kernelName:c0,backendName:"webgl",kernelFunc:Fye};function Lye(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{strides:i,dilations:o,pad:u,dimRoundingMode:d,inputShape:c}=a,p=O.computeConv2DInfo(c,s.shape,i,o,u,d,!0),m=new Mye(p);return n.runWebGLProgram(m,[r,s],"float32")}var Bye={kernelName:d0,backendName:"webgl",kernelFunc:Lye},Pye=class{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}};function Uye(e){let{inputs:t,backend:n}=e,{x:a}=t,r=[...a.shape,...a.shape],s=E.sizeFromShape(a.shape),i=Oe({inputs:{x:a},backend:n,attrs:{shape:[s]}}),o=new Pye(s),u=n.runWebGLProgram(o,[i],i.dtype),d=Oe({inputs:{x:u},backend:n,attrs:{shape:r}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(u),d}var jye={kernelName:$g,backendName:"webgl",kernelFunc:Uye},Wye=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let{inHeight:t,inWidth:n,padInfo:a,strideHeight:r,strideWidth:s,filterHeight:i,filterWidth:o,dilationHeight:u,dilationWidth:d}=e,{top:c,left:p}=a;this.userCode=`
      const ivec2 strides = ivec2(${r}, ${s});
      const ivec2 pads = ivec2(${c}, ${p});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${i}; h++) {
          int hIn = hBeg + h * ${u};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${o}; w++) {
              int wIn = wBeg + w * ${d};

              if (wIn >= 0 && wIn < ${n}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}};function Vye(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dilations:u}=a,d=O.computeDilation2DInfo(r.shape,s.shape,i,o,"NHWC",u),c,p=new Wye(d);c=n.runWebGLProgram(p,[r,s],"float32");let m=Oe({inputs:{x:c},backend:n,attrs:{shape:d.outShape}});return n.disposeIntermediateTensorInfo(c),m}var Hye={kernelName:dc,backendName:"webgl",kernelFunc:Vye};function Gye(e){let{inputs:t,backend:n,attrs:a}=e,{equation:r}=a,s=t,{allDims:i,summedDims:o,idDims:u}=O.decodeEinsumEquation(r,s.length);O.checkEinsumDimSizes(i.length,u,s);let{path:d,steps:c}=O.getEinsumComputePath(o,u),p=c.length,m=null,g=i.length,b=[];for(let v=0;v<p;++v){for(let x of c[v]){let{permutationIndices:w,expandDims:k}=O.getEinsumPermutation(g,u[x]),N;O.isIdentityPermutation(w)?N=s[x]:(N=Xa({inputs:{x:s[x]},backend:n,attrs:{perm:w}}),b.push(N));let I=N.shape.slice();for(let T=0;T<k.length;++T)I.splice(k[T],0,1);E.arraysEqual(N.shape,I)||(N=Oe({inputs:{x:N},backend:n,attrs:{shape:I}}),b.push(N)),m===null?m=N:(m=BI({inputs:{a:N,b:m},backend:n}),b.push(m))}v<p-1&&(d[v]>=0&&(m=Cx({inputs:{x:m},backend:n,attrs:{axis:d[v]-(i.length-g),keepDims:!1}}),b.push(m)),g--)}for(let v of b)v!==m&&n.disposeIntermediateTensorInfo(v);return m}var qye={kernelName:p0,backendName:"webgl",kernelFunc:Gye},Kye="return (x >= 0.0) ? x : (exp(x) - 1.0);",Xye=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,Yye=Ct({opSnippet:Kye,packedOpSnippet:Xye}),Jye={kernelName:pc,backendName:"webgl",kernelFunc:Yye},Zye="return (b >= 0.0) ? a : a * (b + 1.0);",Qye=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,ebe=e=>{let{inputs:t,backend:n}=e,{dy:a,y:r}=t,s=oe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new wf(Qye,a.shape,r.shape):new ju(Zye,a.shape,r.shape);return n.runWebGLProgram(s,[a,r],a.dtype)},tbe={kernelName:gp,backendName:"webgl",kernelFunc:ebe},nbe=`
  return vec4(equal(a, b));
`,abe="return float(a == b);",rbe=Ia({opSnippet:abe,packedOpSnippet:nbe,dtype:"bool",cpuKernelImpl:Ope}),sbe={kernelName:yp,backendName:"webgl",kernelFunc:rbe},ibe=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${O.ERF_P};
  float a1 = ${O.ERF_A1};
  float a2 = ${O.ERF_A2};
  float a3 = ${O.ERF_A3};
  float a4 = ${O.ERF_A4};
  float a5 = ${O.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,obe=Ct({opSnippet:ibe}),lbe={kernelName:fc,backendName:"webgl",kernelFunc:obe},ube=Sf+`
  return exp(x);
`,cbe=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,x4=Ct({opSnippet:ube,packedOpSnippet:cbe,cpuKernelImpl:Mpe,dtype:"float32"}),dbe={kernelName:mc,backendName:"webgl",kernelFunc:x4};function _k(e){let{inputs:t,attrs:n,backend:a}=e,{dim:r}=n,{input:s}=t,i=s.shape.length,o=s.shape.slice(),u=r;return r<0&&(E.assert(-(i+1)<=r,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),u=i+r+1),o.splice(u,0,1),Oe({inputs:{x:s},backend:a,attrs:{shape:o}})}var hbe={kernelName:bp,backendName:"webgl",kernelFunc:_k},HR="return exp(x) - 1.0;",pbe=Ct({opSnippet:HR,packedOpSnippet:HR,cpuKernelImpl:Fpe}),fbe={kernelName:gc,backendName:"webgl",kernelFunc:pbe},GR=class{constructor(e,t,n){this.variableNames=["real","imag"];let a=t[1];this.outputShape=t;let r=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,s=n?`${a}.0`:"1.0",i;if(e==="real")i="return real * expR - imag * expI;";else if(e==="imag")i="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${r};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${i}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${a});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${a}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${s};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};function w4(e,t,n){let a=n.texData.get(e.dataId),r=E.sizeFromShape(e.shape),s=e.shape[e.shape.length-1],i=r/s,o=Oe({inputs:{x:e},backend:n,attrs:{shape:[i,s]}}),u=o.shape,d=new GR("real",u,t),c=new GR("imag",u,t),p=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:u},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:u}],m=n.runWebGLProgram(d,p,"float32"),g=n.runWebGLProgram(c,p,"float32"),b=El({inputs:{real:m,imag:g},backend:n});n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g);let v=Oe({inputs:{x:b},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(b),v}function mbe(e){let{inputs:t,backend:n}=e,{input:a}=t;return w4(a,!1,n)}var gbe={kernelName:f0,backendName:"webgl",kernelFunc:mbe},ybe=class{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}};function Ny(e){let{backend:t,attrs:n}=e,{shape:a,value:r}=n,{dtype:s}=n;if(s=s||E.inferDtype(r),s==="string"){let i=E.getArrayFromDType(s,E.sizeFromShape(a));return i.fill(r),t.makeTensorInfo(a,s,i)}else{let i=new ybe(a,r),o=[[r]];return t.runWebGLProgram(i,[],s,o)}}var bbe={kernelName:Rg,backendName:"webgl",kernelFunc:Ny},vbe=class{constructor(e){this.variableNames=["Image"],this.outputShape=[];let t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}},xbe={kernelName:vp,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{let{image:n}=e,a=t,r=new vbe(n.shape);return a.runWebGLProgram(r,[n],n.dtype)}},qR="return floor(x);",wbe=Ct({opSnippet:qR,packedOpSnippet:qR,cpuKernelImpl:zpe}),Sbe={kernelName:yc,backendName:"webgl",kernelFunc:wbe},kbe=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,_be=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,Nbe=Ia({opSnippet:kbe,packedOpSnippet:_be,dtype:"int32"}),Ibe={kernelName:bc,backendName:"webgl",kernelFunc:Nbe},Tbe=class{constructor(e){this.variableNames=["A"];let t=er(),[n,a]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${a}.0, ${n}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}},Ebe=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;let t=er(),[n,a]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${a}.0, ${n}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}},Cbe={kernelName:Nv,backendName:"webgl",kernelFunc:Abe},hh,uS=oe().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function Abe(e){let{inputs:t,backend:n,attrs:a}=e,{pixels:r}=t,{numChannels:s}=a,i=typeof HTMLVideoElement<"u"&&r instanceof HTMLVideoElement,o=typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement,[u,d]=i?[r.videoWidth,r.videoHeight]:[r.width,r.height],c=[d,u],p=[d,u,s];if(o||i){let v=oe().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(hh==null||v!==uS)&&(uS=v,hh=document.createElement("canvas").getContext("2d",{willReadFrequently:uS})),hh.canvas.width=u,hh.canvas.height=d,hh.drawImage(r,0,0,u,d),r=hh.canvas}let m=n.makeTensorInfo(c,"int32");n.texData.get(m.dataId).usage=qr.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(m.dataId),r);let g=oe().getBool("WEBGL_PACK")?new Ebe(p):new Tbe(p),b=n.runWebGLProgram(g,[m],"int32");return n.disposeData(m.dataId),b}function $be(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,bias:i,preluActivationWeights:o}=t,{strides:u,pad:d,dataFormat:c,dilations:p,dimRoundingMode:m,activation:g,leakyreluAlpha:b}=a,v=O.convertConv2DDataFormat(c),x=O.computeConv2DInfo(r.shape,s.shape,u,p,d,m,!1,v),w,k=[],N=i!=null,I=o!=null,T=g==="leakyrelu",$=()=>{let M=[r,s],B=(V,W)=>{if(W==="NCHW"&&V.shape.length===1&&V.shape[0]!==1){let R=Oe({inputs:{x:V},backend:n,attrs:{shape:[V.shape[0],1,1]}});return k.push(R),R}return V};if(N&&M.push(B(i,c)),I&&M.push(B(o,c)),T){let V=n.makeTensorInfo([],"float32",E.createScalarValue(b,"float32"));M.push(V),k.push(V)}return M};if(x.filterHeight===1&&x.filterWidth===1&&x.dilationHeight===1&&x.dilationWidth===1&&x.strideHeight===1&&x.strideWidth===1&&(x.padInfo.type==="SAME"||x.padInfo.type==="VALID"))w=m4({x:r,filter:s,convInfo:x,backend:n,bias:i,activation:g,preluActivationWeights:o,leakyreluAlpha:b});else if(x.strideWidth<=2&&v==="channelsLast"&&oe().getBool("WEBGL_EXP_CONV")){let M=g?ug(g,!0):null,B=new f4(x,N,M,I,T),V=[[x.padInfo.top,x.padInfo.left],[x.strideHeight,x.strideWidth],[x.dilationHeight,x.dilationWidth],[x.inHeight,x.inWidth]],W=$();w=n.runWebGLProgram(B,W,"float32",V)}else if(oe().getBool("WEBGL_CONV_IM2COL"))w=g4({x:r,filter:s,convInfo:x,backend:n,bias:i,activation:g,preluActivationWeights:o,leakyreluAlpha:b});else{let M=g?ug(g,!1):null,B=new p4(x,N,M,I,T),V=$();w=n.runWebGLProgram(B,V,"float32")}let D=Oe({inputs:{x:w},backend:n,attrs:{shape:x.outShape}});return k.push(w),k.forEach(M=>n.disposeIntermediateTensorInfo(M)),D}var Rbe={kernelName:Iu,backendName:"webgl",kernelFunc:$be};function Dbe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,bias:i,preluActivationWeights:o}=t,{strides:u,pad:d,dilations:c,dimRoundingMode:p,activation:m,leakyreluAlpha:g}=a,b=[],v=c;v==null&&(v=[1,1]),E.assert(O.eitherStridesOrDilationsAreOne(u,v),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${v}'`);let x=O.computeConv2DInfo(r.shape,s.shape,u,v,d,p,!0),w=oe().getBool("WEBGL_PACK_DEPTHWISECONV")&&x.strideWidth<=2&&x.outChannels/x.inChannels===1,k=m?ug(m,w):null,N=[r,s],I=i!=null,T=o!=null,$=m==="leakyrelu";if(I&&N.push(i),T&&N.push(o),$){let V=n.makeTensorInfo([],"float32",E.createScalarValue(g,"float32"));N.push(V),b.push(V)}let D;w?D=new v4(x,I,k,T,$):D=new b4(x,I,k,T,$);let M=[[x.padInfo.top,x.padInfo.left],[x.strideHeight,x.strideWidth],[x.dilationHeight,x.dilationWidth],[x.inHeight,x.inWidth]],B=n.runWebGLProgram(D,N,"float32",M);return b.forEach(V=>n.disposeIntermediateTensorInfo(V)),B}var Obe={kernelName:Tu,backendName:"webgl",kernelFunc:Dbe},Mbe=class{constructor(e,t,n,a){this.sliceDim=e,this.strides=t,this.paramsShape=a,this.variableNames=["x","indices"],this.outputShape=n;let r=Zt(n.length),s=`
    int index;`;for(let i=0;i<this.sliceDim;i++)s+=`
          index = round(getIndices(coords[0], ${i}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[i]};
          flattenIndex += index * ${this.strides[i]};`;this.userCode=`
         void main() {
          ${r} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${s}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}};function Fbe(e){let{inputs:t,backend:n}=e,{params:a,indices:r}=t,s=r.shape,i=s[s.length-1],o=E.sizeFromShape(a.shape),[u,d,c,p]=O.prepareAndValidate(a,r),m=Oe({inputs:{x:r},backend:n,attrs:{shape:[d,i]}}),g=Oe({inputs:{x:a},backend:n,attrs:{shape:[E.sizeFromShape(a.shape)/c,c]}});if(n.shouldExecuteOnCPU([a,r])||a.dtype==="string"){let w=n.readSync(r.dataId),k=n.bufferSync(a),N=Lpe(w,k,a.dtype,d,i,c,p,a.shape,o);return n.makeTensorInfo(u,a.dtype,N.values)}let b=new Mbe(i,p,[d,c],a.shape),v=n.runWebGLProgram(b,[g,m],g.dtype),x=Oe({inputs:{x:v},backend:n,attrs:{shape:u}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(v),x}var zbe={kernelName:wp,backendName:"webgl",kernelFunc:Fbe},Lbe=class{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;let n=Zt(this.rank),a=Bbe(e);this.userCode=`
      void main() {
        ${n} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${a}));
      }
    `}};function Bbe(e,t){let n=["resRC.x","resRC.y","resRC.z","resRC.w"],a=[];for(let r=0;r<e.length;r++)r===2?a.push("index"):a.push(`${n[r]}`);return a.join()}function S4(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,indices:s}=t,{axis:i,batchDims:o}=a,u=E.parseAxisParam(i,r.shape)[0];if(oe().get("DEBUG")){let k=n.readSync(s.dataId),N=r.shape[u];for(let I=0;I<k.length;++I){let T=k[I];E.assert(T<=N-1&&T>=0,()=>`GatherV2: the index value ${T} is not in [0, ${N-1}]`)}}let d=O.segment_util.collectGatherOpShapeInfo(r,s,u,o),c=E.sizeFromShape(s.shape),p=[],m=Oe({inputs:{x:r},backend:n,attrs:{shape:[d.batchSize,d.outerSize,d.dimSize,d.sliceSize]}}),g=Oe({inputs:{x:s},backend:n,attrs:{shape:[d.batchSize,c/d.batchSize]}});p.push(m),p.push(g);let b=[d.batchSize,d.outerSize,c/d.batchSize,d.sliceSize];if(n.shouldExecuteOnCPU([r,s])||r.dtype==="string"){let k=n.bufferSync(g),N=n.bufferSync(m),I=Bpe(N,k,b);return p.forEach(T=>n.disposeIntermediateTensorInfo(T)),n.makeTensorInfo(d.outputShape,I.dtype,I.values)}let v=new Lbe(m.shape,b),x=n.runWebGLProgram(v,[m,g],m.dtype);p.push(x);let w=Oe({inputs:{x},backend:n,attrs:{shape:d.outputShape}});return p.forEach(k=>n.disposeIntermediateTensorInfo(k)),w}var Pbe={kernelName:xp,backendName:"webgl",kernelFunc:S4},Ube="return float(a > b);",jbe=`
  return vec4(greaterThan(a, b));
`,Wbe=Ia({opSnippet:Ube,packedOpSnippet:jbe,cpuKernelImpl:Ppe,dtype:"bool"}),Vbe={kernelName:Sp,backendName:"webgl",kernelFunc:Wbe},Hbe="return float(a >= b);",Gbe=`
  return vec4(greaterThanEqual(a, b));
`,qbe=Ia({opSnippet:Hbe,packedOpSnippet:Gbe,dtype:"bool",cpuKernelImpl:Upe}),Kbe={kernelName:xc,backendName:"webgl",kernelFunc:qbe};function Xbe(e){let{inputs:t,backend:n}=e,{input:a}=t;return w4(a,!0,n)}var Ybe={kernelName:m0,backendName:"webgl",kernelFunc:Xbe},Jbe="return float(!isnan(x) && !isinf(x));",Zbe=Ct({opSnippet:Jbe,dtype:"bool"}),Qbe={kernelName:Sc,backendName:"webgl",kernelFunc:Zbe},eve="return float(isinf(x));",tve=Ct({opSnippet:eve,dtype:"bool"}),nve={kernelName:kc,backendName:"webgl",kernelFunc:tve},ave="return float(isnan(x));",rve=Ct({opSnippet:ave,dtype:"bool"}),sve={kernelName:_c,backendName:"webgl",kernelFunc:rve},ive="return float(a < b);",ove=`
  return vec4(lessThan(a, b));
`,lve=Ia({opSnippet:ive,packedOpSnippet:ove,cpuKernelImpl:jpe,dtype:"bool"}),uve={kernelName:kp,backendName:"webgl",kernelFunc:lve},cve="return float(a <= b);",dve=`
  return vec4(lessThanEqual(a, b));
`,hve=Ia({opSnippet:cve,packedOpSnippet:dve,cpuKernelImpl:Wpe,dtype:"bool"}),pve={kernelName:_p,backendName:"webgl",kernelFunc:hve};function fve(e){let{backend:t,attrs:n}=e,{start:a,stop:r,num:s}=n,i=Vpe(a,r,s);return t.makeTensorInfo([i.length],"float32",i)}var mve={kernelName:Np,backendName:"webgl",kernelFunc:fve},gve=Sf+`
  return x < 0.0 ? 0./0. : log(x);
`,yve=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,bve=Ct({opSnippet:gve,packedOpSnippet:yve,cpuKernelImpl:Hpe}),vve={kernelName:Ic,backendName:"webgl",kernelFunc:bve},xve=Sf+`
  return log(1.0 + x);
`,wve=Ct({opSnippet:xve}),Sve={kernelName:Tc,backendName:"webgl",kernelFunc:wve},kve="return float(a >= 1.0 && b >= 1.0);",_ve=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,Nve=Ia({opSnippet:kve,packedOpSnippet:_ve,dtype:"bool"}),Ive={kernelName:Ip,backendName:"webgl",kernelFunc:Nve},Tve="return float(!(x >= 1.0));",Eve=Ct({opSnippet:Tve}),Cve={kernelName:Tp,backendName:"webgl",kernelFunc:Eve},Ave="return float(a >= 1.0 || b >= 1.0);",$ve=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,Rve=Ia({opSnippet:Ave,packedOpSnippet:$ve,dtype:"bool"}),Dve={kernelName:Ep,backendName:"webgl",kernelFunc:Rve},Ove=class{constructor(e,t,n,a,r){this.variableNames=["x"],this.outputShape=[];let s=t,i=e[3]-1;this.outputShape=e;let o,u=`float(${n}) + float(${a}) * sum`;r===.5?o=`inversesqrt(${u})`:r===1?o=`1.0/(${u})`:o=`exp(log(${u}) * float(-${r}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${s}; j <= ${s}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${i}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${o};
        setOutput(val);
      }
    `}},Mve=class{constructor(e,t,n,a,r){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;let s=t,i=e[3]-1;this.outputShape=e;let o,u=`float(${n}) + float(${a}) * sum`;r===.5?o=`inversesqrt(${u})`:r===1?o=`1.0/(${u})`:o=`exp(log(${u}) * float(-${r}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${s};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${s}; j <= ${s}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${o};
        setOutput(result);
      }
    `}},Fve=e=>{let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{depthRadius:s,bias:i,alpha:o,beta:u}=a,d=oe().getBool("WEBGL_PACK_NORMALIZATION")?new Mve(r.shape,s,i,o,u):new Ove(r.shape,s,i,o,u);return n.runWebGLProgram(d,[r],r.dtype)},zve={kernelName:Ec,backendName:"webgl",kernelFunc:Fve},Lve=class{constructor(e,t,n,a,r){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=a,this.beta=r,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${a}) * norm + float(${n});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${a})
                * float(${r})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${r});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}},Bve=e=>{let{inputs:t,backend:n,attrs:a}=e,{x:r,y:s,dy:i}=t,{depthRadius:o,bias:u,alpha:d,beta:c}=a,p=new Lve(r.shape,o,u,d,c);return n.runWebGLProgram(p,[r,s,i],r.dtype)},Pve={kernelName:Cp,backendName:"webgl",kernelFunc:Bve};function Uve(e,t,n,a){let r=E.sizeFromShape(t),s=E.sizeFromShape(e.shape)/r,i=Oe({inputs:{x:e},attrs:{shape:[s,r]},backend:a}),o=xd(i,e.dtype,"max",a),u=Oe({inputs:{x:o},attrs:{shape:n},backend:a});return a.disposeIntermediateTensorInfo(i),a.disposeIntermediateTensorInfo(o),u}function k4(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reductionIndices:s,keepDims:i}=a,o=r.shape.length,u=E.parseAxisParam(s,r.shape),d=u,c=O.getAxesPermutation(d,o),p=c!=null,m=n.shouldExecuteOnCPU([r]),g=r;if(p){if(m){let k=n.texData.get(g.dataId).values,N=new Array(o);for(let $=0;$<N.length;$++)N[$]=r.shape[c[$]];let I=FI(k,r.shape,r.dtype,c,N);g=n.makeTensorInfo(N,r.dtype);let T=n.texData.get(g.dataId);T.values=I}else g=Ex(r,c,n);d=O.getInnerMostAxes(d.length,o)}O.assertAxesAreInnerMostDims("max",d,o);let[b,v]=O.computeOutAndReduceShapes(g.shape,d),x=b;i&&(x=O.expandShapeToKeepDim(b,u));let w;if(m){let k=n.texData.get(g.dataId).values,N=Gpe(k,E.sizeFromShape(v),x,r.dtype);w=n.makeTensorInfo(x,r.dtype);let I=n.texData.get(w.dataId);I.values=N}else w=Uve(g,v,x,n);return p&&n.disposeIntermediateTensorInfo(g),w}var jve={kernelName:Cc,backendName:"webgl",kernelFunc:k4},Wve=LI+`
  return max(a, b);
`,Vve=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+vd+`
  return result;
`,Hve=Ia({opSnippet:Wve,packedOpSnippet:Vve,cpuKernelImpl:qpe}),Gve={kernelName:Ac,backendName:"webgl",kernelFunc:Hve};function qve(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t;gf(r,"maxPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:u}=a,d=1;E.assert(O.eitherStridesOrDilationsAreOne(i,d),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${d}'`);let c=O.computePool2DInfo(r.shape,s,i,d,o,u);if(c.filterWidth===1&&c.filterHeight===1&&E.arraysEqual(c.inShape,c.outShape))return Dr({inputs:{x:r},backend:n});let p=new cg(c,"max",!1);return n.runWebGLProgram(p,[r],r.dtype)}var Kve={kernelName:$c,backendName:"webgl",kernelFunc:qve};function Xve(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:i,pad:o,dataFormat:u,dimRoundingMode:d}=a,c=[1,1,1],p=O.computePool3DInfo(r.shape,s,i,c,o,d,u),m=new PI(p,"max",!1);return n.runWebGLProgram(m,[r],r.dtype)}var Yve={kernelName:Ap,backendName:"webgl",kernelFunc:Xve},Jve=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideHeight,n=e.strideWidth,a=e.dilationHeight,r=e.effectiveFilterHeight,s=e.effectiveFilterWidth,i=r-1-e.padInfo.top,o=s-1-e.padInfo.left,u=r*s-1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${r};
          wR += ${a}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${n}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${u} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${s} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}},Zve=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideDepth,n=e.strideHeight,a=e.strideWidth,r=e.dilationDepth,s=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterDepth,u=e.effectiveFilterHeight,d=e.effectiveFilterWidth,c=o-1-e.padInfo.front,p=u-1-e.padInfo.top,m=d-1-e.padInfo.left,g=o*u*d-1;this.userCode=`
      const ivec3 pads = ivec3(${c}, ${p}, ${m});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${o};
           wD += ${r}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${u};
              wR += ${s}) {
            float dyR = float(dyRCorner + wR) / ${n}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${d};
                wC += ${i}) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${g} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${u} * ${d} +
                  wR * ${d} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Qve(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,i=s,{filterSize:o,strides:u,pad:d,dimRoundingMode:c}=a,p=[1,1,1],m=O.computePool3DInfo(i.shape,o,u,p,d,c),g=new PI(m,"max",!0),b=n.runWebGLProgram(g,[i],i.dtype),v=new Zve(m),x=n.runWebGLProgram(v,[r,b],i.dtype);return n.disposeIntermediateTensorInfo(b),x}var e0e={kernelName:Og,backendName:"webgl",kernelFunc:Qve};function t0e(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s,output:i}=t,o=s;gf([s,i],"maxPoolGrad");let{filterSize:u,strides:d,pad:c,dimRoundingMode:p}=a,m=O.computePool2DInfo(o.shape,u,d,1,c,p),g=!0,b=new cg(m,"max",g),v=n.runWebGLProgram(b,[o],o.dtype),x=new Jve(m),w=n.runWebGLProgram(x,[r,v],o.dtype);return n.disposeIntermediateTensorInfo(v),w}var n0e={kernelName:Dg,backendName:"webgl",kernelFunc:t0e};function a0e(e,t,n,a){let r=new cg(n,"max",!1),s=a.runWebGLProgram(r,[e],"float32");r=new cg(n,"max",!0,!0,t);let i=a.runWebGLProgram(r,[e],"float32");return[s,i]}var r0e={kernelName:Mg,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:a}=e,{filterSize:r,strides:s,pad:i,includeBatchInIndex:o}=t,u=n;E.assert(a.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.shape.length}.`);let d=[1,1];E.assert(O.eitherStridesOrDilationsAreOne(s,d),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${d}'`);let c=O.computePool2DInfo(a.shape,r,s,d,i),[p,m]=a0e(a,o,c,u);return[p,m]}};function s0e(e,t,n,a){let r=E.sizeFromShape(t),s=E.sizeFromShape(e.shape)/r,i=Oe({inputs:{x:e},attrs:{shape:[s,r]},backend:a}),o=xd(i,"float32","mean",a),u=Oe({inputs:{x:o},attrs:{shape:n},backend:a});return a.disposeIntermediateTensorInfo(i),a.disposeIntermediateTensorInfo(o),u}var i0e={kernelName:Rc,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:a}=e,{keepDims:r,axis:s}=t,i=n,o=a.shape.length,u=E.parseAxisParam(s,a.shape),d=u,c=O.getAxesPermutation(d,o),p=c!=null,m=i.shouldExecuteOnCPU([a]),g=[],b=a;if(p){if(m){let N=i.texData.get(b.dataId).values,I=new Array(o);for(let D=0;D<I.length;D++)I[D]=a.shape[c[D]];let T=FI(N,a.shape,a.dtype,c,I);b=i.makeTensorInfo(I,a.dtype);let $=i.texData.get(b.dataId);$.values=T}else b=Ex(a,c,i);g.push(b),d=O.getInnerMostAxes(d.length,o)}O.assertAxesAreInnerMostDims("sum",d,o);let[v,x]=O.computeOutAndReduceShapes(b.shape,d),w=v;r&&(w=O.expandShapeToKeepDim(v,u));let k=s0e(b,x,w,i);for(let N of g)i.disposeIntermediateTensorInfo(N);return k}};function o0e(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a,o=r.shape.length,u=E.parseAxisParam(s,r.shape),d=u,c=O.getAxesPermutation(d,o),p=r;c!=null&&(p=Xa({inputs:{x:r},backend:n,attrs:{perm:c}}),d=O.getInnerMostAxes(d.length,r.shape.length)),O.assertAxesAreInnerMostDims("min",d,o);let[m,g]=O.computeOutAndReduceShapes(p.shape,d),b=E.sizeFromShape(g),v=Oe({inputs:{x:p},backend:n,attrs:{shape:[-1,b]}}),x=xd(v,v.dtype,"min",n),w;if(i){let k=O.expandShapeToKeepDim(m,u);w=Oe({inputs:{x},backend:n,attrs:{shape:k}})}else w=Oe({inputs:{x},backend:n,attrs:{shape:m}});return n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(x),c!=null&&n.disposeIntermediateTensorInfo(p),w}var l0e={kernelName:Dc,backendName:"webgl",kernelFunc:o0e},u0e=LI+`
  return min(a, b);
`,c0e=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+vd+`
  return result;
`,d0e=Ia({opSnippet:u0e,packedOpSnippet:c0e,cpuKernelImpl:Kpe}),h0e={kernelName:Oc,backendName:"webgl",kernelFunc:d0e},p0e=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map((d,c)=>d[0]+e[c]+d[1]);let a=e.length,r=Zt(a),s=t.map(d=>d[0]).join(","),i=t.map((d,c)=>d[0]+e[c]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,a),u=n==="reflect"?0:1;if(a===1){this.userCode=`
        int start = ${s};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${u};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${u};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${r} start = ${r}(${s});
      ${r} end = ${r}(${i});

      void main() {
        ${r} outC = getOutputCoords();
        for (int i = 0; i < ${a}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${u};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u};
          }
        }
        ${r} coords = outC - start;
        setOutput(getX(${o}));
      }
    `}},f0e=class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((g,b)=>g[0]+e[b]+g[1]);let a=e.length,r=Zt(a),s=t.map(g=>g[0]).join(","),i=t.map((g,b)=>g[0]+e[b]).join(","),o=Ga("rc",a),u=Ga("source",a),d=`${o[a-1]} < ${this.outputShape[a-1]}`,c=a===1?"source":`vec2(${u.slice(-2).join()})`,p=n==="reflect"?0:1,m="";if(a===1){let g=`
        ${r} source = rc;
        if (source < start) {
          source = start * 2 - source - ${p};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${p};
        }
        source -= start;
      `;m=`
        ${r} rc = outputLoc;
        ${g}
        result[0] = getChannel(getX(${u.join()}), ${c});
        ${o[a-1]} += 1;
        if(${d}) {
          ${g}
          result[1] = getChannel(getX(${u.join()}), ${c});
        }
      `}else{let g=`
        ${r} source = rc;
        ${r} lt = ${r}(lessThan(source, start));
        ${r} gte = ${r}(greaterThanEqual(source, end));
        ${r} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${p}) +
                gte * ((end - 1) * 2 - source + ${p});
        source -= start;
      `;m=`
        ${r} rc = outputLoc;
        ${g}
        result[0] = getChannel(getX(${u.join()}), ${c});
        ${o[a-1]} += 1;
        if(${d}) {
          ${g}
          result[1] = getChannel(getX(${u.join()}), ${c});
        }
        rc = outputLoc;
        ${o[a-2]} += 1;
        if(${o[a-2]} < ${this.outputShape[a-2]}) {
          ${g}
          result[2] = getChannel(getX(${u.join()}), ${c});
          ${o[a-1]} += 1;
          if(${d}) {
            ${g}
            result[3] = getChannel(getX(${u.join()}), ${c});
          }
        }
      `}this.userCode=`
      const ${r} start = ${r}(${s});
      const ${r} end = ${r}(${i});

      void main() {
        ${r} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${m}
        setOutput(result);
      }
    `}},m0e=({inputs:e,backend:t,attrs:n})=>{let{x:a}=e,{paddings:r,mode:s}=n,i=oe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new f0e(a.shape,r,s):new p0e(a.shape,r,s);return t.runWebGLProgram(i,[a],a.dtype)},g0e={kernelName:Mc,backendName:"webgl",kernelFunc:m0e},y0e=`if (b == 0.0) return NAN;
  return mod(a, b);`,b0e=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+vd+`
  return result;
`,v0e=Ia({opSnippet:y0e,packedOpSnippet:b0e}),x0e={kernelName:Fc,backendName:"webgl",kernelFunc:v0e},w0e=class{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}},S0e=`
if (a == b) {
  return 1.0;
};
return a / b;`,k0e=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,_4=Ia({opSnippet:S0e,packedOpSnippet:k0e,checkOutOfBounds:!0}),_0e={kernelName:hc,backendName:"webgl",kernelFunc:_4},KR="return a - b;",N4=Ia({opSnippet:KR,packedOpSnippet:KR,supportsComplex:!0,cpuKernelImpl:mfe}),N0e={kernelName:od,backendName:"webgl",kernelFunc:N4};function I4(e){let{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{dim:s}=a,i=E.parseAxisParam([s],r.shape),o=k4({inputs:{x:r},backend:n,attrs:{reductionIndices:i,keepDims:!1}}),u=O.expandShapeToKeepDim(o.shape,i),d=Oe({inputs:{x:o},backend:n,attrs:{shape:u}}),c=N4({inputs:{a:r,b:d},backend:n}),p=x4({inputs:{x:c},backend:n}),m=Cx({inputs:{x:p},backend:n,attrs:{axis:i,keepDims:!1}}),g=Oe({inputs:{x:m},backend:n,attrs:{shape:u}}),b=_4({inputs:{a:p,b:g},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),b}var I0e={kernelName:sd,backendName:"webgl",kernelFunc:I4};function T0e(e){let{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{numSamples:s,seed:i,normalized:o}=a,u=o?r:I4({inputs:{logits:r},backend:n,attrs:{dim:r.shape.length-1}}),d=u.shape[0],c=u.shape[1],p=new w0e(d,c,s),m=[[i]],g=n.runWebGLProgram(p,[u],"int32",m);return o||n.disposeIntermediateTensorInfo(u),g}var E0e={kernelName:$p,backendName:"webgl",kernelFunc:T0e},C0e=ks+`
  return -x;
`,A0e=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function $0e(e){let{inputs:t,backend:n}=e,{x:a}=t;if(n.shouldExecuteOnCPU([a])){let s=n.texData.get(a.dataId),[i,o]=Ype(s.values,a.shape,a.dtype);return n.makeTensorInfo(o,a.dtype,i)}let r;return oe().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new Jo(a.shape,A0e):r=new oi(a.shape,C0e),n.runWebGLProgram(r,[a],a.dtype)}var R0e={kernelName:Rp,backendName:"webgl",kernelFunc:$0e},D0e=yi.nonMaxSuppressionV3Impl;function O0e(e){O.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u}=a,d=n.readSync(r.dataId),c=n.readSync(s.dataId),{selectedIndices:p}=D0e(d,c,i,o,u);return n.makeTensorInfo([p.length],"int32",new Int32Array(p))}var M0e={kernelName:Op,backendName:"webgl",kernelFunc:O0e},F0e=yi.nonMaxSuppressionV4Impl;function z0e(e){O.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u,padToMaxOutputSize:d}=a,c=n.readSync(r.dataId),p=n.readSync(s.dataId),{selectedIndices:m,validOutputs:g}=F0e(c,p,i,o,u,d);return[n.makeTensorInfo([m.length],"int32",new Int32Array(m)),n.makeTensorInfo([],"int32",new Int32Array([g]))]}var L0e={kernelName:Mp,backendName:"webgl",kernelFunc:z0e},B0e=yi.nonMaxSuppressionV5Impl;function P0e(e){O.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u,softNmsSigma:d}=a,c=n.readSync(r.dataId),p=n.readSync(s.dataId),m=i,g=o,b=u,v=d,{selectedIndices:x,selectedScores:w}=B0e(c,p,m,g,b,v);return[n.makeTensorInfo([x.length],"int32",new Int32Array(x)),n.makeTensorInfo([w.length],"float32",new Float32Array(w))]}var U0e={kernelName:Fp,backendName:"webgl",kernelFunc:P0e},j0e=class{constructor(e,t,n,a){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${a}), float(${n}),
                      float(index == coords.y)));
      }
    `}},W0e=e=>{let{inputs:t,backend:n,attrs:a}=e,{indices:r}=t,{dtype:s,depth:i,onValue:o,offValue:u}=a,d=E.sizeFromShape(r.shape),c=new j0e(d,i,o,u),p=Oe({inputs:{x:r},backend:n,attrs:{shape:[d]}}),m=n.runWebGLProgram(c,[p],s);n.disposeIntermediateTensorInfo(p);let g=[...r.shape,i],b=Oe({inputs:{x:m},backend:n,attrs:{shape:g}});return n.disposeIntermediateTensorInfo(m),b},V0e={kernelName:Lc,backendName:"webgl",kernelFunc:W0e};function Kv(e){let{inputs:t,backend:n}=e,{x:a}=t;if(a.dtype==="complex64"){let r=_y({inputs:{input:a},backend:n}),s=Kv({inputs:{x:r},backend:n}),i=Ax({inputs:{input:a},backend:n}),o=Kv({inputs:{x:i},backend:n}),u=El({inputs:{real:s,imag:o},backend:n});return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),u}else return Ny({attrs:{shape:a.shape,dtype:a.dtype,value:a.dtype==="string"?"":0},backend:n})}var H0e={kernelName:tf,backendName:"webgl",kernelFunc:Kv};function T4(e){let{inputs:t,backend:n}=e,{x:a}=t;if(a.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(a.dtype==="complex64"){let r=_y({inputs:{input:a},backend:n}),s=T4({inputs:{x:r},backend:n}),i=Ax({inputs:{input:a},backend:n}),o=Kv({inputs:{x:i},backend:n}),u=El({inputs:{real:s,imag:o},backend:n});return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),u}else return Ny({attrs:{shape:a.shape,dtype:a.dtype,value:1},backend:n})}var G0e={kernelName:zp,backendName:"webgl",kernelFunc:T4};function q0e(e){let{inputs:t,backend:n,attrs:a}=e,{axis:r}=a;if(t.length===1)return _k({inputs:{input:t[0]},backend:n,attrs:{dim:r}});let s=t[0].shape,i=t[0].dtype;t.forEach(c=>{E.assertShapesMatch(s,c.shape,"All tensors passed to stack must have matching shapes"),E.assert(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let o=[],u=t.map(c=>{let p=_k({inputs:{input:c},backend:n,attrs:{dim:r}});return o.push(p),p}),d=h4({inputs:u,backend:n,attrs:{axis:r}});return o.forEach(c=>n.disposeIntermediateTensorInfo(c)),d}var K0e={kernelName:Lp,backendName:"webgl",kernelFunc:q0e},X0e=class{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((u,d)=>u[0]+e[d]+u[1]);let a=e.length,r=Zt(a),s=t.map(u=>u[0]).join(","),i=t.map((u,d)=>u[0]+e[d]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,a);if(a===1){this.userCode=`
        int start = ${s};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${r} start = ${r}(${s});
      ${r} end = ${r}(${i});

      void main() {
        ${r} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${r} coords = outC - start;
          setOutput(getX(${o}));
        }
      }
    `}},Y0e=class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((b,v)=>b[0]+e[v]+b[1]);let a=e.length,r=Zt(a),s=t.map(b=>b[0]).join(","),i=t.map((b,v)=>b[0]+e[v]).join(","),o=Ga("rc",a),u=Ga("source",a),d=`${o[a-1]} < ${this.outputShape[a-1]}`,c=a===1?"source":`vec2(${u.slice(-2).join()})`,p=[`${r} rc = outputLoc;`,`${o[a-1]} += 1;
       if(${d}) {
      `,a===1?"":`}
       rc = outputLoc;
       ${o[a-2]} += 1;
       if(${o[a-2]} < ${this.outputShape[a-2]}) {`,a===1?"":`  ${o[a-1]} += 1;
         if(${d}) {`],m=a===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",g="";for(let b=0,v=a===1?2:4;b<v;b++)g+=`
        ${p[b]}
        if (${m}) {
          result[${b}] = float(value);
        } else {
          ${r} source = rc - start;
          result[${b}] = getChannel(getX(${u.join()}), ${c});
        }
      `;g+=a===1?"} ":"}}",this.userCode=`
      const ${r} start = ${r}(${s});
      const ${r} end = ${r}(${i});

      void main() {
        ${r} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${g}
        setOutput(result);
      }
    `}},E4=e=>{let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{paddings:s,constantValue:i}=a;if(E.sizeFromShape(r.shape)===0){let d=s.map((c,p)=>c[0]+r.shape[p]+c[1]);return Ny({backend:n,attrs:{shape:d,value:i,dtype:r.dtype}})}let o=oe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Y0e(r.shape,s,i):new X0e(r.shape,s,i),u=[[i]];return n.runWebGLProgram(o,[r],r.dtype,u)},J0e={kernelName:Bc,backendName:"webgl",kernelFunc:E4},Z0e=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,Q0e=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+vd+`
  return result;
`,exe=Ia({opSnippet:Z0e,packedOpSnippet:Q0e}),txe={kernelName:Pc,backendName:"webgl",kernelFunc:exe};function nxe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a,o=r.shape.length,u=[],d=E.parseAxisParam(s,r.shape),c=d,p=O.getAxesPermutation(c,o),m=r;p!=null&&(m=Xa({inputs:{x:r},backend:n,attrs:{perm:p}}),c=O.getInnerMostAxes(c.length,o),u.push(m)),O.assertAxesAreInnerMostDims("prod",c,o);let g;if(n.shouldExecuteOnCPU([m])){let b=n.texData.get(m.dataId).values,{outVals:v,outShape:x,outDtype:w}=Zpe(m.shape,m.dtype,b,c);g=n.makeTensorInfo(x,w,v)}else{let[b,v]=O.computeOutAndReduceShapes(m.shape,c),x=E.sizeFromShape(v),w=Oe({inputs:{x:m},backend:n,attrs:{shape:[-1,x]}}),k=S0(r.dtype),N=xd(w,k,"prod",n);g=Oe({inputs:{x:N},backend:n,attrs:{shape:b}}),u.push(w),u.push(N)}if(i){u.push(g);let b=O.expandShapeToKeepDim(g.shape,d);g=Oe({inputs:{x:g},backend:n,attrs:{shape:b}})}return u.forEach(b=>n.disposeIntermediateTensorInfo(b)),g}var axe={kernelName:jc,backendName:"webgl",kernelFunc:nxe};function rxe(e){let{inputs:t,backend:n,attrs:a}=e,{paramsNestedSplits:r,paramsDenseValues:s,indices:i}=t,{outputRaggedRank:o}=a,u=r.map(w=>n.readSync(w.dataId)),d=r.map(w=>w.shape),c=n.readSync(s.dataId),p=n.readSync(i.dataId),[m,g,b]=Qpe(u,d,c,s.shape,s.dtype,p,i.shape,o),v=m.map(w=>n.makeTensorInfo([w.length],"int32",w)),x=n.makeTensorInfo(b,s.dtype,g);return v.concat([x])}var sxe={kernelName:y0,backendName:"webgl",kernelFunc:rxe};function ixe(e){let{inputs:t,backend:n}=e,{starts:a,limits:r,deltas:s}=t,i=n.readSync(a.dataId),o=n.readSync(r.dataId),u=n.readSync(s.dataId),[d,c]=efe(i,a.shape,a.dtype,o,r.shape,u,s.shape),p=n.makeTensorInfo([d.length],"int32",d),m=n.makeTensorInfo([c.length],a.dtype,c);return[p,m]}var oxe={kernelName:b0,backendName:"webgl",kernelFunc:ixe};function lxe(e){let{inputs:t,backend:n,attrs:a}=e,{shape:r,values:s,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:u}=a,d=n.readSync(r.dataId),c=n.readSync(s.dataId),p=n.readSync(i.dataId),m=o.map(x=>n.readSync(x.dataId)),g=o.map(x=>x.shape),[b,v]=tfe(d,r.shape,c,s.shape,s.dtype,p,i.shape,m,g,u);return n.makeTensorInfo(b,s.dtype,v)}var uxe={kernelName:v0,backendName:"webgl",kernelFunc:lxe},C4=e=>{let{backend:t,attrs:n}=e,{start:a,stop:r,step:s,dtype:i}=n,o=nfe(a,r,s,i);return t.makeTensorInfo([o.length],i,o)},cxe={kernelName:Fg,backendName:"webgl",kernelFunc:C4},dxe="return 1.0 / x;",hxe=Ct({opSnippet:dxe}),pxe={kernelName:Wc,backendName:"webgl",kernelFunc:hxe},fxe=ks+`
  return (x < 0.0) ? 0.0 : x;
`,mxe=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,gxe=Ct({opSnippet:fxe,packedOpSnippet:mxe}),yxe={kernelName:Vc,backendName:"webgl",kernelFunc:gxe},bxe=ks+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,vxe=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,xxe=Ct({opSnippet:bxe,packedOpSnippet:vxe}),wxe={kernelName:qc,backendName:"webgl",kernelFunc:xxe},Sxe=class{constructor(e,t,n,a,r){this.variableNames=["A"],this.outputShape=[];let[s,i,o,u]=e;this.outputShape=[s,t,n,u];let d=[a&&t>1?i-1:i,a&&n>1?o-1:o],c=[a&&t>1?t-1:t,a&&n>1?n-1:n],p;r?p="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":p="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${d[0]/c[0]},
          ${d[1]/c[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${p};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}},kxe=class{constructor(e,t,n,a,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[s,i,o,u]=e;this.outputShape=[s,t,n,u];let d=[a&&t>1?i-1:i,a&&n>1?o-1:o],c=[a&&t>1?t-1:t,a&&n>1?n-1:n],p;r?p="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":p="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${d[0]/c[0]},
          ${d[1]/c[1]},
          ${d[1]/c[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,
                                     ${o}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${p};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${n-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}};function _xe(e){let{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:s,halfPixelCenters:i,size:o}=a,[u,d]=o,c=oe().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new kxe(r.shape,u,d,s,i):new Sxe(r.shape,u,d,s,i);return n.runWebGLProgram(c,[r],"float32")}var Nxe={kernelName:Gc,backendName:"webgl",kernelFunc:_xe},Ixe=class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,a,r]=t,[,s,i]=e,o=[n&&s>1?a-1:a,n&&i>1?r-1:r],u=[n&&s>1?s-1:s,n&&i>1?i-1:i],d=o[0]/u[0],c=o[1]/u[1],p=1/d,m=1/c,g=Math.ceil(p)*2+2,b=Math.ceil(m)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${d});
        const float widthScale = float(${c});

        const float invHeightScale = float(${p});
        const float invWidthScale = float(${m});

        const int winHeight = int(${g});
        const int winWidth = int(${b});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${s}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${a-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${r-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function Txe(e){let{inputs:t,backend:n,attrs:a}=e,{images:r,dy:s}=t,{alignCorners:i}=a,o=new Ixe(s.shape,r.shape,i);return n.runWebGLProgram(o,[s],s.dtype)}var Exe={kernelName:Up,backendName:"webgl",kernelFunc:Txe},Cxe=class{constructor(e,t,n,a,r){this.variableNames=["A"],this.outputShape=[];let[s,i,o,u]=e;this.outputShape=[s,t,n,u];let d=[a&&t>1?i-1:i,a&&n>1?o-1:o],c=[a&&t>1?t-1:t,a&&n>1?n-1:n],p=a?"0.5":"0.0",m;r?m="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":m="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${d[0]/c[0]},
          ${d[1]/c[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${m};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${p})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}},Axe=class{constructor(e,t,n,a,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[s,i,o,u]=e;this.outputShape=[s,t,n,u];let d=[a&&t>1?i-1:i,a&&n>1?o-1:o],c=[a&&t>1?t-1:t,a&&n>1?n-1:n],p=a?"0.5":"0.0",m;r?m="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":m="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${d[0]/c[0]},
          ${d[1]/c[1]},
          ${d[1]/c[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,
                                     ${o}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${m};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${p})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${n-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}};function $xe(e){let{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:s,halfPixelCenters:i,size:o}=a,[u,d]=o,c=oe().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Axe(r.shape,u,d,s,i):new Cxe(r.shape,u,d,s,i);return n.runWebGLProgram(c,[r],r.dtype)}var Rxe={kernelName:Hc,backendName:"webgl",kernelFunc:$xe},Dxe=class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,a,r]=t,[,s,i]=e,o=[n&&s>1?a-1:a,n&&i>1?r-1:r],u=[n&&s>1?s-1:s,n&&i>1?i-1:i],d=o[0]/u[0],c=o[1]/u[1],p=1/d,m=1/c,g=Math.ceil(p)*2+2,b=Math.ceil(m)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${d});
        const float widthScale = float(${c});

        const float invHeightScale = float(${p});
        const float invWidthScale = float(${m});

        const int winHeight = int(${g});
        const int winWidth = int(${b});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${s}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float sourceFracRow =
              float(${o[0]}) *
                (float(dyR) / float(${u[0]}));

            float sourceFracCol =
                float(${o[1]}) *
                  (float(dyC) / float(${u[1]}));

            int sourceNearestRow = int(min(
                float(int(${a}) - 1),
                ${n} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${r}) - 1),
                ${n} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function Oxe(e){let{inputs:t,backend:n,attrs:a}=e,{images:r,dy:s}=t,{alignCorners:i}=a,o=new Dxe(s.shape,r.shape,i);return n.runWebGLProgram(o,[s],s.dtype)}var Mxe={kernelName:Pp,backendName:"webgl",kernelFunc:Oxe},Fxe=class{constructor(e,t){this.variableNames=["x"];let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,n===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}let a=i=>t.indexOf(i)!==-1&&e[i]!==1?`${e[i]} - coords[${i}] - 1`:`coords[${i}]`,r=e.map((i,o)=>a(o)).join(","),s=Zt(n);this.userCode=`
      void main() {
        ${s} coords = getOutputCoords();
        setOutput(getX(${r}));
      }
    `}},zxe=class{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;let a=Ga("rc",n),r=`${a[n-1]} + 1 < ${this.outputShape[n-1]}`,s=`${a[n-2]} + 1 < ${this.outputShape[n-2]}`,i=Zt(n);n===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${r}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${i} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${o(a.slice())};
          if(${r}){
            result.g = ${u(a.slice())};
          }
          if(${s}) {
            result.b = ${d(a.slice())};
            if(${r}) {
              result.a = ${c(a.slice())};
            }
          }
          setOutput(result);
        }
    `;function o(g){return p(g)}function u(g){return g[n-1]="("+g[n-1]+" + 1)",p(g)}function d(g){return g[n-2]="("+g[n-2]+" + 1)",p(g)}function c(g){return g[n-1]="("+g[n-1]+" + 1)",g[n-2]="("+g[n-2]+" + 1)",p(g)}function p(g){let b=e.map((w,k)=>m(k,g)),v=b.join(","),x=b.slice(-2).join(",");return`getChannel(getX(${v}), vec2(${x}))`}function m(g,b){return t.indexOf(g)!==-1&&e[g]!==1?`${e[g]} - ${b[g]} - 1`:`${b[g]}`}}};function Lxe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dims:s}=a,i=r.shape.length,o=E.parseAxisParam(s,r.shape);if(i===0)return Dr({inputs:{x:r},backend:n});let u=oe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new zxe(r.shape,o):new Fxe(r.shape,o);return n.runWebGLProgram(u,[r],r.dtype)}var Bxe={kernelName:Kc,backendName:"webgl",kernelFunc:Lxe},Pxe=class{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];let n=e[1],a=e[2];this.outputShape=e;let r="";typeof t=="number"?r=`float outputValue = ${t.toFixed(2)};`:r=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${r}
          if(coordX >= 0 && coordX < ${a} && coordY >= 0 && coordY < ${n}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}},Uxe={kernelName:nf,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:a}=e,{radians:r,fillValue:s,center:i}=t,o=n,u=new Pxe(a.shape,s),[d,c]=O.getImageCenter(i,a.shape[1],a.shape[2]),p=[[d,c,Math.sin(r),Math.cos(r)]];return o.runWebGLProgram(u,[a],a.dtype,p)}},jxe=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,Wxe=Ct({opSnippet:jxe}),Vxe={kernelName:Xc,backendName:"webgl",kernelFunc:Wxe},Hxe="return inversesqrt(x);",Gxe=Ct({opSnippet:Hxe,cpuKernelImpl:afe}),qxe={kernelName:Yc,backendName:"webgl",kernelFunc:Gxe},UI=class{constructor(e,t,n,a,r,s,i=!0,o=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=s;let u=Zt(r.length),d=Zt(s.length),c="";n===1?c="i":n===2&&(c="i, j");let p=`getIndices(${c})`,m="";a===1?m="i":a===2&&(m="i, coords[1]");let g=`getUpdates(${m})`,b="";o&&(b="coords[0], coords[1]");let v=`getDefaultValue(${b})`,x=t>1?"strides[j]":"strides";this.userCode=`
        ${u} strides = ${u}(${r});

        void main() {
          ${d} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${p});
              flattenedIndex += index * ${x};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${g};
              found = true;
            }
          }
          setOutput(mix(${v}, sum, float(found)));
        }
      `}},Kxe=class{constructor(e,t,n,a,r,s,i=!0,o=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s;let u=Zt(r.length),d=Zt(s.length),c="";n===1?c="i":n===2&&(c="i, j");let p=`getIndices(${c})`,m="";a===1?m="i":a===2&&(m="i, coords[1]");let g=`getUpdates(${m})`,b="";o&&(b="coords[0], coords[1]");let v=`getDefaultValue(${b})`,x=t>1?"strides[j]":"strides",w=t>1?"strides[j + 1]":"strides";this.userCode=`
        ${u} strides = ${u}(${r});

        void main() {
          ${d} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${t}; j+=2) {
              ivec4 index = round(${p});
              flattenedIndex += index.xz * ${x};
              if (j + 1 < ${t}) {
                flattenedIndex += index.yw * ${w};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${g};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${v}, sum, found));
        }
      `}};function Xxe(e){let{inputs:t,backend:n,attrs:a}=e,{indices:r,updates:s}=t,{shape:i}=a,{sliceRank:o,numUpdates:u,sliceSize:d,strides:c,outputSize:p}=O.calculateShapes(s,r,i),m=[p/d,d];if(p===0)return n.makeTensorInfo(i,r.dtype);let g=Oe({inputs:{x:r},backend:n,attrs:{shape:[u,o]}}),b=Oe({inputs:{x:s},backend:n,attrs:{shape:[u,d]}}),v=n.makeTensorInfo([],"float32",new Float32Array([0])),x;oe().getBool("WEBGL_PACK")?x=new Kxe(u,o,g.shape.length,b.shape.length,c,m):x=new UI(u,o,g.shape.length,b.shape.length,c,m);let w=n.runWebGLProgram(x,[b,g,v],b.dtype),k=Oe({inputs:{x:w},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(w),n.disposeIntermediateTensorInfo(v),k}var Yxe={kernelName:jp,backendName:"webgl",kernelFunc:Xxe},Jxe=class{constructor(e,t,n,a){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];let r="while (left < right) {",s=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,i=oe().getNumber("WEBGL_VERSION")===2?r:s,o=a==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${i}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${o} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}};function Zxe(e){let{inputs:t,backend:n,attrs:a}=e,{sortedSequence:r,values:s}=t,{side:i}=a,o=new Jxe(r.shape[0],r.shape[1],s.shape[1],i),u=[[r.shape[1]]];return n.runWebGLProgram(o,[r,s],"int32",u)}var Qxe={kernelName:Vp,backendName:"webgl",kernelFunc:Zxe},ewe=class{constructor(e,t,n){this.variableNames=["c","a","b"],this.outputShape=t;let a,r;if(n>4)throw Error(`Where for rank ${n} is not yet supported`);if(n===1)r="resRC",a="resRC";else{let i=["resRC.x","resRC.y","resRC.z","resRC.w"],o=[],u=[];for(let d=0;d<t.length;d++)u.push(`${i[d]}`),d<e&&o.push(`${i[d]}`);a=o.join(),r=u.join()}let s=Zt(n);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        float cVal = getC(${a});
        if (cVal >= 1.0) {
          setOutput(getA(${r}));
        } else {
          setOutput(getB(${r}));
        }
      }
    `}};function twe(e){let{inputs:t,backend:n}=e,{condition:a,t:r,e:s}=t,i=new ewe(a.shape.length,r.shape,r.shape.length);return n.runWebGLProgram(i,[a,r,s],Jr(r.dtype,s.dtype))}var nwe={kernelName:Hp,backendName:"webgl",kernelFunc:twe},awe=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${O.SELU_SCALEALPHA};
  float scale = ${O.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,rwe=Ct({opSnippet:awe}),swe={kernelName:Jc,backendName:"webgl",kernelFunc:rwe},iwe=Sf+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,owe=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,lwe=Ct({opSnippet:iwe,packedOpSnippet:owe,cpuKernelImpl:sfe}),uwe={kernelName:td,backendName:"webgl",kernelFunc:lwe},cwe=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,dwe=Ct({opSnippet:cwe}),hwe={kernelName:ed,backendName:"webgl",kernelFunc:dwe},pwe=Sf+`
  return sin(x);
`,fwe=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${vd}
  return result;
`,mwe=Ct({opSnippet:pwe,packedOpSnippet:fwe}),gwe={kernelName:Zc,backendName:"webgl",kernelFunc:mwe},ywe=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,bwe=Ct({opSnippet:ywe}),vwe={kernelName:Qc,backendName:"webgl",kernelFunc:bwe},xwe=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,wwe=Ct({opSnippet:xwe}),Swe={kernelName:nd,backendName:"webgl",kernelFunc:wwe},kwe=e=>{let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,paddings:i}=a;E.assert(r.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");let o=s.reduce((w,k)=>w*k),u=[[0,0]];u.push(...i);for(let w=1+s.length;w<r.shape.length;++w)u.push([0,0]);let d=[],c=E4({inputs:{x:r},backend:n,attrs:{paddings:u,constantValue:0}}),p=O.getReshaped(c.shape,s,o,!1),m=O.getPermuted(p.length,s.length,!1),g=O.getReshapedPermuted(c.shape,s,o,!1),b=Oe({inputs:{x:c},backend:n,attrs:{shape:p}}),v=Xa({inputs:{x:b},backend:n,attrs:{perm:m}}),x=Oe({inputs:{x:v},backend:n,attrs:{shape:g}});return d.push(c),d.push(b),d.push(v),d.forEach(w=>n.disposeIntermediateTensorInfo(w)),x},_we={kernelName:qp,backendName:"webgl",kernelFunc:kwe};function Nwe(e){let{inputs:t,backend:n}=e,{indices:a,values:r,denseShape:s,defaultValue:i}=t;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${s.shape}`);if(a.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${a.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${r.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);let o=n.readSync(a.dataId),u=n.readSync(r.dataId),d=n.readSync(s.dataId),c=n.readSync(i.dataId)[0],[p,m,g,b,v]=ofe(o,a.shape,a.dtype,u,r.dtype,d,c);return[n.makeTensorInfo(m,a.dtype,p),n.makeTensorInfo([m[0]],r.dtype,g),n.makeTensorInfo([b.length],"bool",new Uint8Array(b.map(x=>Number(x)))),n.makeTensorInfo([v.length],a.dtype,new Int32Array(v))]}var Iwe={kernelName:zg,backendName:"webgl",kernelFunc:Nwe};function Twe(e){let{inputs:t,backend:n}=e,{inputIndices:a,inputShape:r,newShape:s}=t;if(a.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${a.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${r.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(n.readSync(r.dataId)),o=n.readSync(a.dataId),u=Array.from(n.readSync(s.dataId)),[d,c,p]=lfe(o,a.shape,a.dtype,i,u);return[n.makeTensorInfo(c,a.dtype,d),n.makeTensorInfo([p.length],s.dtype,new Int32Array(p))]}var Ewe={kernelName:Xp,backendName:"webgl",kernelFunc:Twe};function Cwe(e){let{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:s}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${r.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${s.shape}`);let i=n.readSync(a.dataId),o=n.readSync(r.dataId),u=n.readSync(s.dataId),[d,c]=JB(i,a.shape,a.dtype,o,u,!0);return n.makeTensorInfo(c,a.dtype,d)}var Awe={kernelName:Lg,backendName:"webgl",kernelFunc:Cwe};function $we(e){let{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:s}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${r.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${s.shape}`);let i=n.readSync(a.dataId),o=n.readSync(r.dataId),u=n.readSync(s.dataId),[d,c]=JB(i,a.shape,a.dtype,o,u);return n.makeTensorInfo(c,a.dtype,d)}var Rwe={kernelName:Bg,backendName:"webgl",kernelFunc:$we};function Dwe(e){let{inputs:t,backend:n,attrs:a}=e,{sparseIndices:r,sparseValues:s,defaultValue:i}=t,{outputShape:o}=a,{sliceRank:u,numUpdates:d,sliceSize:c,strides:p,outputSize:m}=O.calculateShapes(s,r,o),g=!1;if(s.dtype==="string"){let w=n.bufferSync(r),k=n.bufferSync(s),N=E.decodeString(n.readSync(i.dataId)[0]),I=rfe(w,k,o,m,c,d,u,p,N,g);return n.makeTensorInfo(o,I.dtype,I.values)}let b=new UI(d,u,r.shape.length,s.shape.length,p,[m,1],g),v=n.runWebGLProgram(b,[s,r,i],s.dtype),x=Oe({inputs:{x:v},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(v),x}var Owe={kernelName:Yp,backendName:"webgl",kernelFunc:Dwe};function Mwe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{numOrSizeSplits:s,axis:i}=a,o=E.parseAxisParam(i,r.shape)[0],u=O.prepareSplitSize(r,s,o),d=r.shape.length,c=new Array(d).fill(0),p=r.shape.slice();return u.map(m=>{let g=[...p];g[o]=m;let b=kf({inputs:{x:r},backend:n,attrs:{begin:c,size:g}});return c[o]+=m,b})}var Fwe={kernelName:Kp,backendName:"webgl",kernelFunc:Mwe},XR="return sqrt(x);",zwe=Ct({opSnippet:XR,packedOpSnippet:XR,cpuKernelImpl:ufe}),Lwe={kernelName:ad,backendName:"webgl",kernelFunc:zwe},Bwe="return x * x;",Pwe=Ct({opSnippet:Bwe}),Uwe={kernelName:Pg,backendName:"webgl",kernelFunc:Pwe},YR="return (a - b) * (a - b);",jwe=Ia({opSnippet:YR,packedOpSnippet:YR}),Wwe={kernelName:id,backendName:"webgl",kernelFunc:jwe};function Vwe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t;if(r.dtype!=="string")throw new Error("Input must be of datatype string");let s=n.readSync(r.dataId),i=O.fromUint8ToStringArray(s),o=cfe(i,"string",a);return n.makeTensorInfo(r.shape,"string",o)}var Hwe={kernelName:Ug,backendName:"webgl",kernelFunc:Vwe};function Gwe({inputs:e,attrs:t,backend:n}){let{x:a}=e,r=ks+`
    return x > 0.0 ? 1.0 : float(${t.alpha});
  `,s=new oi(a.shape,r);return n.runWebGLProgram(s,[a],a.dtype)}var qwe={kernelName:wl,backendName:"webgl",kernelFunc:Gwe},Kwe=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;let a=n.length,r=Zt(n.length),s=Zt(n.length),i="";if(a===1)i="coords * strides + begin";else{let o=0;i=n.map((u,d)=>(o++,n.length===1?`coords * strides[${d}] + begin[${d}]`:`coords[${o-1}] * strides[${d}] + begin[${d}]`)).join(",")}this.userCode=`
      ${r} begin = ${r}(${e});
      ${r} strides = ${r}(${t});

      void main() {
        ${s} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}};function Xwe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:s,end:i,strides:o,beginMask:u,endMask:d,ellipsisMask:c,newAxisMask:p,shrinkAxisMask:m}=a,{finalShapeSparse:g,finalShape:b,isIdentity:v,sliceDim0:x,isSimpleSlice:w,begin:k,end:N,strides:I}=ea.sliceInfo(r.shape,s,i,o,u,d,c,p,m),T;if(v)T=Oe({inputs:{x:r},backend:n,attrs:{shape:b}});else if(x||w){E.assert(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);let D=ea.computeOutShape(k,N,I),M=kf({inputs:{x:r},backend:n,attrs:{begin:k,size:D}});T=Oe({inputs:{x:M},backend:n,attrs:{shape:b}}),n.disposeIntermediateTensorInfo(M)}else if(n.shouldExecuteOnCPU([r])){let D=n.readSync(r.dataId),M=mt(r.shape,r.dtype,D),B=dfe(g,M,I,k);T=n.makeTensorInfo(b,r.dtype,B.values)}else{let D=new Kwe(k,I,g);T=n.runWebGLProgram(D,[r],r.dtype)}let $=Oe({inputs:{x:T},backend:n,attrs:{shape:b}});return n.disposeIntermediateTensorInfo(T),$}var Ywe={kernelName:Jp,backendName:"webgl",kernelFunc:Xwe};function Jwe(e){let{inputs:t,backend:n,attrs:a}=e,{separator:r,nGramWidths:s,leftPad:i,rightPad:o,padWidth:u,preserveShortSequences:d}=a,{data:c,dataSplits:p}=t,m=n.readSync(c.dataId),g=n.readSync(p.dataId),[b,v]=hfe(m,g,r,s,i,o,u,d);return[n.makeTensorInfo([b.length],"string",b),n.makeTensorInfo(p.shape,"int32",v)]}var Zwe={kernelName:jg,backendName:"webgl",kernelFunc:Jwe};function Qwe(e){let{inputs:t,backend:n,attrs:a}=e,{skipEmpty:r}=a,{input:s,delimiter:i}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let o=n.readSync(s.dataId),u=n.readSync(i.dataId)[0],[d,c,p]=pfe(o,u,r),m=c.length;return[n.makeTensorInfo([m,2],"int32",d),n.makeTensorInfo([m],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(p))]}var e1e={kernelName:Wg,backendName:"webgl",kernelFunc:Qwe};function t1e(e){let{inputs:t,backend:n,attrs:a}=e,{numBuckets:r}=a,{input:s}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");let i=n.readSync(s.dataId),o=ffe(i,r);return n.makeTensorInfo(s.shape,"int32",o)}var n1e={kernelName:Vg,backendName:"webgl",kernelFunc:t1e},a1e="return tan(x);",r1e=Ct({opSnippet:a1e}),s1e={kernelName:ld,backendName:"webgl",kernelFunc:r1e},i1e=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,o1e=Ct({opSnippet:i1e}),l1e={kernelName:ud,backendName:"webgl",kernelFunc:o1e};function u1e(e){let{inputs:t,backend:n,attrs:a}=e,{tensor:r,indices:s,updates:i}=t,{sliceRank:o,numUpdates:u,sliceSize:d,strides:c,outputSize:p}=O.calculateShapes(i,s,r.shape),m=[p/d,d];if(p===0)return n.makeTensorInfo(r.shape,s.dtype);let g=Oe({inputs:{x:s},backend:n,attrs:{shape:[u,o]}}),b=Oe({inputs:{x:i},backend:n,attrs:{shape:[u,d]}}),v=Oe({inputs:{x:r},backend:n,attrs:{shape:m}}),x=new UI(u,o,g.shape.length,b.shape.length,c,m,!1,!0),w=n.runWebGLProgram(x,[b,g,v],v.dtype),k=Oe({inputs:{x:w},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(w),k}var c1e={kernelName:Wp,backendName:"webgl",kernelFunc:u1e},d1e=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let s=0;s<n.length;s++)n[s]=e[s]*t[s];this.outputShape=n,this.rank=n.length;let a=Zt(this.rank),r=h1e(e);this.userCode=`
      void main() {
        ${a} resRC = getOutputCoords();
        setOutput(getA(${r}));
      }
    `}};function h1e(e){let t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`imod(resRC, ${e[0]})`;let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],a=[];for(let r=0;r<e.length;r++)a.push(`imod(${n[r]}, ${e[r]})`);return a.join()}function A4(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reps:s}=a;if(r.dtype==="string"||r.shape.length>5){let o=n.readSync(r.dataId),u=r.dtype==="string"?o.map(p=>E.decodeString(p)):o,d=mt(r.shape,r.dtype,u),c=gfe(d,s);return n.makeTensorInfo(c.shape,c.dtype,c.values)}let i=new d1e(r.shape,s);return n.runWebGLProgram(i,[r],r.dtype)}var p1e={kernelName:xl,backendName:"webgl",kernelFunc:A4},f1e=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}},m1e=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}};function au(e,t){t!==null&&e.disposeIntermediateTensorInfo(t)}function JR(e){let t=1;for(;t<e;)t*=2;return t}function g1e(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{k:s,sorted:i}=a,o=oe().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),u=oe().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),d=r.shape,c=d[d.length-1];if(n.shouldExecuteOnCPU([r])||c<o||s>u){let B=n.readSync(r.dataId),[V,W]=yfe(B,d,r.dtype,s,i);return[n.makeTensorInfo(V.shape,V.dtype,V.values),n.makeTensorInfo(W.shape,W.dtype,W.values)]}if(s===0)return d[d.length-1]=0,[n.makeTensorInfo(d,r.dtype,[]),n.makeTensorInfo(d,"int32",[])];if(c===1)return[r,Ny({attrs:{shape:d,dtype:"int32",value:0},backend:n})];let p=n.texData.get(r.dataId),m=p!==null&&p.isPacked,g=m?n.unpackTensor(r):r,b=E.sizeFromShape(d)/c,v=Oe({inputs:{x:g},attrs:{shape:[b,c]},backend:n});m&&au(n,g);let x=JR(s),w=JR(c),k=null,N=()=>k===null?[v,v]:[v,k],I=(B,V,W)=>{let R=N(),H=new f1e(W),Z=[[c],[k===null?1:0],[Number.NEGATIVE_INFINITY],[B],[V]],ae=k;k=n.runWebGLProgram(H,R,"int32",Z),au(n,ae)};for(let B=1;B<x;B*=2){let V=B*2;for(let W=B;W>=1;W/=2)I(V,W,[b,w])}for(let B=w;B>x;B/=2){let V=N(),W=new m1e([b,B/2]),R=[[c],[k===null?1:0],[x]],H=k;k=n.runWebGLProgram(W,V,"int32",R),au(n,H);let Z=x/2,ae=Z*2;for(let j=Z;j>=1;j/=2)I(ae,j,k.shape)}let T=k;k=kf({inputs:{x:k},backend:n,attrs:{begin:0,size:[b,s]}}),au(n,T);let $=S4({inputs:{x:v,indices:k},backend:n,attrs:{axis:1,batchDims:1}});au(n,v);let D=d.slice(0,-1);D.push(s),T=k,k=Oe({inputs:{x:k},attrs:{shape:D},backend:n}),au(n,T);let M=$;return $=Oe({inputs:{x:$},attrs:{shape:D},backend:n}),au(n,M),[$,k]}var y1e={kernelName:Zp,backendName:"webgl",kernelFunc:g1e},b1e=class{constructor(e,t,n,a,r,s){this.variableNames=["Image","Transforms"],this.outputShape=s;let i=n==="nearest"?1:2,o;switch(a){case"constant":o=1;break;case"reflect":o=2;break;case"wrap":o=3;break;case"nearest":o=4;break;default:o=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${o} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${o} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${o} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${r});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${r});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${i} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}};function v1e(e){let{inputs:t,backend:n,attrs:a}=e,{image:r,transforms:s}=t,{interpolation:i,fillMode:o,fillValue:u,outputShape:d}=a,[c,p,m,g]=r.shape,[b,v]=d??[p,m],x=[c,b,v,g],w=new b1e(p,m,i,o,u,x);return n.runWebGLProgram(w,[r,s],"float32")}var x1e={kernelName:Qp,backendName:"webgl",kernelFunc:v1e};function w1e(e){let{inputs:t,attrs:n,backend:a}=e,{axis:r}=n,{x:s}=t;gf(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let i=a.readSync(s.dataId),{outputValues:o,outputShape:u,indices:d}=bfe(i,r,s.shape,s.dtype);return[a.makeTensorInfo(u,s.dtype,o),a.makeTensorInfo([d.length],"int32",d)]}var S1e={kernelName:Hg,backendName:"webgl",kernelFunc:w1e};function k1e(e){let{inputs:t,backend:n,attrs:a}=e,{value:r}=t,{axis:s}=a;s<0&&(s+=r.shape.length);let i=r,o=i.shape.length,u=r.shape[s],d=new Array(o-1),c=0;for(let v=0;v<o;v++)v!==s&&(d[c++]=i.shape[v]);let p=[],m=new Array(o).fill(0),g=i.shape.slice();g[s]=1;let b=new Array(u);for(let v=0;v<b.length;v++){m[s]=v;let x=kf({inputs:{x:i},backend:n,attrs:{begin:m,size:g}}),w=Oe({inputs:{x},backend:n,attrs:{shape:d}});b[v]=w,p.push(x)}return p.forEach(v=>n.disposeIntermediateTensorInfo(v)),b}var _1e={kernelName:ef,backendName:"webgl",kernelFunc:k1e},N1e=class{constructor(e,t){this.variableNames=["x","segmentIds"];let n=e.windowSize,a=e.batchSize,r=e.inSize,s=e.numSegments,i=s*Math.ceil(r/n);this.outputShape=[a,i];let o="0.0",u="sumValue",d=Math.floor(n/4)*4,c=n%4,p=`
        sumValue += dot(values, segFilter);
    `,m="";r%n>0&&(m=`
        if (inIdx < 0 || inIdx >= ${r}) {
          return initializationValue;
        }
      `);let g="";r%n>0&&(g=`
        if (inIdx < 0 || inIdx >= ${r}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${o};

      float getValue(int batch, int inIdx) {
        ${m}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${g}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${s})) * float(${n}));
        int currentSeg = int(mod(float(outIdx), float(${s})));

        float sumValue = 0.0;

        for (int i = 0; i < ${d}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${p}
        }

        int inIdx = inOffset + ${d};
        if (${c===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${p}
        } else if (${c===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${p}
        } else if (${c===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${p}
        }
        setOutput(${u});
      }
    `}};function I1e(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,segmentIds:s}=t,{numSegments:i}=a,o=r.shape.length,u=[],d=0,c=O.getAxesPermutation([d],o),p=r;c!=null&&(p=Xa({inputs:{x:r},backend:n,attrs:{perm:c}}),u.push(p),d=O.getInnerMostAxes(1,o)[0]);let m=O.segment_util.computeOutShape(p.shape,d,i),g=E.sizeFromShape([p.shape[d]]),b=Oe({inputs:{x:p},backend:n,attrs:{shape:[-1,g]}});u.push(b);let v=S0(r.dtype),x=(I,T,$,D,M)=>{let B=I.shape[0],V=I.shape[1],W=O.segment_util.segOpComputeOptimalWindowSize(V,M),R={windowSize:W,inSize:V,batchSize:B,numSegments:M},H=new N1e(R,T),Z=n.compileAndRun(H,[I,$],D);if(u.push(Z),Z.shape[1]===M)return Z;let ae=C4({backend:n,attrs:{start:0,stop:M,step:1,dtype:"float32"}}),j=A4({inputs:{x:ae},backend:n,attrs:{reps:[V/W]}});return u.push(ae),u.push(j),x(Z,T,j,D,M)},w=x(b,"unsortedSegmentSum",s,v,i),k=Oe({inputs:{x:w},backend:n,attrs:{shape:m}}),N=k;if(c!=null){u.push(k);let I=O.getUndoAxesPermutation(c);N=Xa({inputs:{x:N},backend:n,attrs:{perm:I}})}return u.forEach(I=>n.disposeIntermediateTensorInfo(I)),N}var T1e={kernelName:Gg,backendName:"webgl",kernelFunc:I1e},E1e=[dme,pme,gme,vme,wme,_me,Ime,Eme,Rme,Ome,zme,Pme,Wme,qme,Yme,Zme,ege,rge,ige,lge,hge,vge,wge,Nge,Tge,Dge,Mge,Bge,Kfe,jge,qge,Jge,aye,iye,lye,cye,hye,gye,vye,Sye,_ye,Iye,Eye,$ye,Dye,zye,Bye,jye,Hye,qye,Jye,tbe,sbe,lbe,dbe,hbe,fbe,gbe,bbe,xbe,Sbe,Ibe,Cbe,Rbe,Obe,zbe,Pbe,Vbe,Kbe,qfe,Ybe,Hge,Qbe,nve,sve,Yfe,uve,pve,mve,vve,Sve,Ive,Cve,Dve,zve,Pve,jve,Gve,Kve,Yve,e0e,n0e,r0e,i0e,l0e,h0e,g0e,x0e,E0e,Qfe,R0e,M0e,L0e,U0e,Cge,V0e,G0e,K0e,J0e,txe,Zfe,axe,sxe,oxe,uxe,cxe,Age,_0e,pxe,yxe,wxe,tme,Nxe,Exe,Rxe,Mxe,Bxe,Uxe,Vxe,qxe,Yxe,Qxe,nwe,swe,uwe,hwe,gwe,vwe,yge,I0e,Swe,_we,Iwe,Ewe,Awe,Rwe,Owe,Fwe,Lwe,Uwe,Wwe,Hwe,qwe,Ywe,Zwe,e1e,n1e,N0e,lme,s1e,l1e,c1e,p1e,y1e,x1e,ume,S1e,_1e,T1e,H0e];for(let e of E1e)qg(e);var Rt;(function(e){e[e.float32=0]="float32",e[e.int32=1]="int32",e[e.bool=2]="bool",e[e.string=3]="string",e[e.complex64=4]="complex64"})(Rt||(Rt={}));var hg;(function(e){e[e.linear=0]="linear",e[e.relu=1]="relu",e[e.relu6=2]="relu6",e[e.prelu=3]="prelu",e[e.leakyrelu=4]="leakyrelu",e[e.sigmoid=5]="sigmoid",e[e.elu=6]="elu"})(hg||(hg={}));var $4;function C1e(e){$4=e.wasm.cwrap(Nu,null,["number","array","number","number","array","number","number","number","number","number","number","number","number"])}function A1e(e){let{inputs:t,backend:n,attrs:a}=e,{a:r,b:s,bias:i,preluActivationWeights:o}=t;if(r.dtype!=="float32"||s.dtype!=="float32")throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");let{transposeA:u,transposeB:d,activation:c,leakyreluAlpha:p}=a,m=n.dataIdMap.get(r.dataId).id,g=n.dataIdMap.get(s.dataId).id,b=0;if(i!=null){let M=n.dataIdMap.get(i.dataId);if(M.shape.length!==1)throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${M.shape.length}.`);b=M.id}let v=o==null?0:n.dataIdMap.get(o.dataId).id,x=hg[c];if(x==null)throw new Error(`${c} activation not yet supported for FusedConv2D in the wasm backend.`);let w=u?r.shape[2]:r.shape[1],k=d?s.shape[1]:s.shape[2],N=af.assertAndGetBroadcastShape(r.shape.slice(0,-2),s.shape.slice(0,-2)),I=n.makeOutput([...N,w,k],r.dtype),T=n.dataIdMap.get(I.dataId).id,$=new Uint8Array(new Int32Array(r.shape).buffer),D=new Uint8Array(new Int32Array(s.shape).buffer);return $4(m,$,r.shape.length,g,D,s.shape.length,u,d,x,b,v,p||0,T),I}var $1e={kernelName:Nu,backendName:"wasm",setupFunc:C1e,kernelFunc:A1e};function Tt(e,t){let n;function a(s){n=s.wasm.cwrap(e,null,["number","number","number"])}function r(s){let{backend:i,inputs:{x:o}}=s,u=i.dataIdMap.get(o.dataId).id,d=i.makeOutput(o.shape,t||o.dtype),c=i.dataIdMap.get(d.dataId).id;return E.sizeFromShape(d.shape)===0||n(u,Rt[o.dtype],c),d}return{kernelName:e,backendName:"wasm",setupFunc:a,kernelFunc:r}}var R1e=Tt(tp),D1e=Tt(Gu),O1e=Tt(qu);function Vn(e,t,n){let a;function r(i){a=i.wasm.cwrap(e,null,["number","array","number","number","array","number","number","number"])}function s(i){let{backend:o,inputs:u}=i,{a:d,b:c}=u,p=o.dataIdMap.get(d.dataId).id,m=o.dataIdMap.get(c.dataId).id,g=n??d.dtype,b=O.assertAndGetBroadcastShape(d.shape,c.shape),v=o.makeOutput(b,g);if(E.sizeFromShape(b)===0)return v;let x=new Uint8Array(new Int32Array(d.shape).buffer),w=new Uint8Array(new Int32Array(c.shape).buffer),k=o.dataIdMap.get(v.dataId).id;return a(p,x,d.shape.length,m,w,c.shape.length,Rt[d.dtype],k),v}return{kernelName:e,backendName:"wasm",setupFunc:r,kernelFunc:s}}var M1e=Vn(bl),R4;function F1e(e){R4=e.wasm.cwrap(Ku,null,["array","number","number","number"])}function z1e(e){let{inputs:t,backend:n}=e,a=n.makeOutput(t[0].shape,t[0].dtype);if(E.sizeFromShape(a.shape)===0)return a;let r=t.map(o=>n.dataIdMap.get(o.dataId).id),s=new Uint8Array(new Int32Array(r).buffer),i=n.dataIdMap.get(a.dataId).id;return R4(s,r.length,Rt[a.dtype],i),a}var L1e={kernelName:Ku,backendName:"wasm",setupFunc:F1e,kernelFunc:z1e};function $x(e){let{inputs:{x:t},backend:n}=e;if(t.dtype==="string")return qa(n.readSync(t.dataId),t.shape,t.dtype);let a=n.makeOutput(t.shape,t.dtype),r=n.typedArrayFromHeap(t);return n.typedArrayFromHeap(a).set(r),a}var B1e={kernelName:wc,backendName:"wasm",kernelFunc:$x},D4;function P1e(e){D4=e.wasm.cwrap(Hi,null,["number","array","number","number","number","array","number"])}function fl(e){let{inputs:t,backend:n,attrs:a}=e,[r,s]=j1e(t.x.shape,a.perm),i=!0;for(let b=0;b<s.length;b++)s[b]!==b&&(i=!1);let o=U1e(t.x.shape,a.perm),u={dataId:t.x.dataId,shape:r,dtype:t.x.dtype};if(i){let b=$x({inputs:t,backend:n});return b.shape=o,b}let d=n.makeOutput(o,u.dtype),c=n.dataIdMap.get(u.dataId).id,p=n.dataIdMap.get(d.dataId).id,m=new Uint8Array(new Int32Array(s).buffer),g=new Uint8Array(new Int32Array(u.shape).buffer);return D4(c,g,u.shape.length,Rt[u.dtype],p,m,s.length),d}function U1e(e,t){let n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[t[a]];return n}function j1e(e,t){let n=[],a=[];for(let r=0;r<e.length;++r)e[r]!==1&&n.push(e[r]),e[t[r]]!==1&&a.push(t[r]);for(let r=0;r<a.length;++r){let s=-1;for(let i=0;i<a.length;++i)a[i]>=r&&(s===-1||a[s]>a[i])&&(s=i);a[s]=r}return[n,a]}var W1e={kernelName:Hi,backendName:"wasm",kernelFunc:fl,setupFunc:P1e};function Cl(e,t,n){let a=e.shape,r=e.shape.length,s=E.parseAxisParam(t,a),i=s,o=O.getAxesPermutation(i,r),u=null,d=!1;if(o!=null){let c=new Array(r);for(let m=0;m<c.length;m++)c[m]=a[o[m]];i=O.getInnerMostAxes(i.length,r),u=fl({inputs:{x:e},attrs:{perm:o},backend:n});let p=n.dataIdMap.get(e.dataId).id;n.dataIdMap.get(u.dataId).id!==p&&(d=!0)}return{transposed:u,originalAxes:s,axes:i,inputWasTransposed:d}}var O4;function V1e(e){O4=e.wasm.cwrap(np,null,["number, number, number"])}function H1e(e){let{backend:t,inputs:n,attrs:a}=e,{axis:r,keepDims:s}=a,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,u=i,{transposed:d,axes:c,originalAxes:p,inputWasTransposed:m}=Cl(i,r,t);if(m){let k=t.dataIdMap.get(d.dataId).id;u=d,o=k}let g=u.shape.length;O.assertAxesAreInnerMostDims("all",c,g);let[b,v]=O.computeOutAndReduceShapes(u.shape,c),x=E.sizeFromShape(v),w=t.makeOutput(b,i.dtype);if(E.sizeFromShape(u.shape)!==0){let k=t.dataIdMap.get(w.dataId).id;O4(o,x,k)}if(m&&t.disposeData(d.dataId),s){let k=O.expandShapeToKeepDim(w.shape,p);w.shape=k}return w}var G1e={kernelName:np,backendName:"wasm",setupFunc:V1e,kernelFunc:H1e},M4;function q1e(e){M4=e.wasm.cwrap(ap,null,["number, number, number"])}function K1e(e){let{backend:t,inputs:n,attrs:a}=e,{axis:r,keepDims:s}=a,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,u=i,{transposed:d,axes:c,originalAxes:p,inputWasTransposed:m}=Cl(i,r,t);if(m){let k=t.dataIdMap.get(d.dataId).id;u=d,o=k}let g=u.shape.length;O.assertAxesAreInnerMostDims("any",c,g);let[b,v]=O.computeOutAndReduceShapes(u.shape,c),x=E.sizeFromShape(v),w=t.makeOutput(b,i.dtype);if(E.sizeFromShape(u.shape)!==0){let k=t.dataIdMap.get(w.dataId).id;M4(o,x,k)}if(m&&t.disposeData(d.dataId),s){let k=O.expandShapeToKeepDim(w.shape,p);w.shape=k}return w}var X1e={kernelName:ap,backendName:"wasm",setupFunc:q1e,kernelFunc:K1e};function F4(e){let t;function n(r){t=r.wasm.cwrap(e,null,["number","number","number","number","number"])}function a(r){let{backend:s,inputs:i,attrs:o}=r,{axis:u}=o,{x:d}=i,c=s.dataIdMap.get(d.dataId).id,p=c,m=d,{transposed:g,axes:b,inputWasTransposed:v}=Cl(d,u,s);if(v){let T=s.dataIdMap.get(g.dataId).id;T!==c&&(m=g,p=T)}let x=m.shape.slice(0,-1),w=s.makeOutput(x,"int32"),k=s.dataIdMap.get(w.dataId).id,N=E.sizeFromShape(w.shape),I=m.shape[b[0]];return t(p,Rt[m.dtype],N,I,k),v&&s.disposeData(g.dataId),w}return{kernelName:e,backendName:"wasm",setupFunc:n,kernelFunc:a}}var Y1e=F4(rp),J1e=F4(sp),Z1e=Tt(Xu),Q1e=Tt(Yu),eSe=Tt(Ju),tSe=Vn(Qu),nSe=Tt(Zu),z4;function aSe(e){z4=e.wasm.cwrap(ec,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function rSe(e){let{inputs:t,attrs:n,backend:a}=e,r=t.x,s=a.dataIdMap.get(r.dataId).id,{filterSize:i,strides:o,pad:u,dimRoundingMode:d}=n,c=O.computePool2DInfo(r.shape,i,o,1,u,d),p=c.filterHeight,m=c.filterWidth,g=c.padInfo.top,b=c.padInfo.right,v=c.padInfo.bottom,x=c.padInfo.left,w=c.strideHeight,k=c.strideWidth,N=c.inChannels;if(c.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);if(c.dilationWidth!==1||c.dilationHeight!==1)throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${c.dilationHeight}, ${c.dilationWidth}].`);let I=a.makeOutput(c.outShape,"float32"),T=a.dataIdMap.get(I.dataId).id;return z4(s,r.shape[0],r.shape[1],r.shape[2],p,m,g,b,v,x,w,k,N,T),I}var sSe={kernelName:ec,backendName:"wasm",setupFunc:aSe,kernelFunc:rSe},L4;function iSe(e){L4=e.wasm.cwrap("AvgPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function oSe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:u,dataFormat:d}=a,c=O.computePool3DInfo(r.shape,s,i,1,o,u,d),p=n.makeOutput(c.outShape,r.dtype);return L4(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(p.dataId).id,c.batchSize,c.inChannels,c.inDepth,c.inHeight,c.inWidth,c.outDepth,c.outHeight,c.outWidth,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left),p}var lSe={kernelName:ip,backendName:"wasm",setupFunc:iSe,kernelFunc:oSe},B4;function uSe(e){B4=e.wasm.cwrap("AvgPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function cSe(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,{filterSize:i,strides:o,pad:u,dimRoundingMode:d}=a,c=O.computePool3DInfo(s.shape,i,o,1,u,d),p=n.makeOutput(s.shape,s.dtype);return B4(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(p.dataId).id,c.batchSize,c.inChannels,c.inDepth,c.inHeight,c.inWidth,c.outDepth,c.outHeight,c.outWidth,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left,c.filterDepth,c.filterHeight,c.filterWidth),p}var dSe={kernelName:Tg,backendName:"wasm",setupFunc:uSe,kernelFunc:cSe},P4;function hSe(e){P4=e.wasm.cwrap("AvgPoolGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function pSe(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,{filterSize:i,strides:o,pad:u}=a,d=O.computePool2DInfo(s.shape,i,o,1,u),c=n.makeOutput(s.shape,s.dtype);return P4(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(c.dataId).id,d.batchSize,d.inChannels,d.inHeight,d.inWidth,d.outHeight,d.outWidth,d.strideHeight,d.strideWidth,d.dilationHeight,d.dilationWidth,d.effectiveFilterHeight,d.effectiveFilterWidth,d.padInfo.top,d.padInfo.left,d.filterHeight,d.filterWidth),c}var fSe={kernelName:Ig,backendName:"wasm",setupFunc:hSe,kernelFunc:pSe};function ur(e){let{inputs:t,attrs:n}=e,{x:a}=t,{shape:r}=n,s=E.sizeFromShape(a.shape),i=E.inferFromImplicitShape(r,s);return E.assert(s===E.sizeFromShape(i),()=>`new shape: ${i}, old shape: ${a.shape}. New shape and old shape must have the same number of elements.`),e.backend.incRef(a.dataId),{dataId:a.dataId,shape:i,dtype:a.dtype}}var mSe={kernelName:Bp,backendName:"wasm",kernelFunc:ur},U4;function gSe(e){U4=e.wasm.cwrap(tc,null,["number","array","number","number","array","number","number","number","number"])}function ySe(e){let{inputs:t,backend:n,attrs:a}=e,{a:r,b:s}=t,{transposeA:i,transposeB:o}=a;if(r.dtype!=="float32"||s.dtype!=="float32")throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");let u=r.shape.length,d=s.shape.length,c=i?r.shape[u-2]:r.shape[u-1],p=o?s.shape[d-1]:s.shape[d-2],m=i?r.shape[u-1]:r.shape[u-2],g=o?s.shape[d-2]:s.shape[d-1],b=r.shape.slice(0,-2),v=s.shape.slice(0,-2),x=E.sizeFromShape(b),w=E.sizeFromShape(v),k=af.assertAndGetBroadcastShape(r.shape.slice(0,-2),s.shape.slice(0,-2)).concat([m,g]);E.assert(c===p,()=>`Error in matMul: inner shapes (${c}) and (${p}) of Tensors with shapes ${r.shape} and ${s.shape} and transposeA=${i} and transposeB=${o} must match.`);let N=i?[x,c,m]:[x,m,c],I=o?[w,g,p]:[w,p,g],T=ur({inputs:{x:r},backend:n,attrs:{shape:N}}),$=ur({inputs:{x:s},backend:n,attrs:{shape:I}}),D=n.dataIdMap.get(T.dataId).id,M=n.dataIdMap.get($.dataId).id,B=i?T.shape[2]:T.shape[1],V=o?$.shape[1]:$.shape[2],W=Math.max(x,w),R=n.makeOutput([W,B,V],T.dtype),H=n.dataIdMap.get(R.dataId).id,Z=new Uint8Array(new Int32Array(T.shape).buffer),ae=new Uint8Array(new Int32Array($.shape).buffer);return U4(D,Z,T.shape.length,M,ae,$.shape.length,i,o,H),n.disposeData(T.dataId),n.disposeData($.dataId),R.shape=k,R}var bSe={kernelName:tc,backendName:"wasm",setupFunc:gSe,kernelFunc:ySe};function Wu(e){let{inputs:{x:t},attrs:{begin:n,size:a},backend:r}=e,[s,i]=ea.parseSliceParams(t,n,a),o=ea.isSliceContinous(t.shape,s,i),u=r.readSync(t.dataId),d=r.makeOutput(i,t.dtype),c=E.computeStrides(t.shape),p=r.dataIdMap.get(d.dataId);if(o){let b=ea.computeFlatOffset(s,c);return t.dtype==="string"?p.stringBytes=u.slice(b,b+E.sizeFromShape(i)):r.typedArrayFromHeap(d).set(u.subarray(b,b+E.sizeFromShape(i))),d}if(t.dtype==="string"){let b=jv(u,s,i,t.shape,t.dtype);return p.stringBytes=b,d}let m=r.typedArrayFromHeap(d),g=t.shape.length;if(g===2)vSe(u,c[0],m,s,i);else if(g===3)xSe(u,c[0],c[1],m,s,i);else if(g===4)wSe(u,c[0],c[1],c[2],m,s,i);else{let b=jv(u,s,i,t.shape,t.dtype);m.set(b)}return d}function vSe(e,t,n,a,r){let s=0,i=a[0],o=a[1],u=i+r[0];for(let d=i;d<u;d++){let c=d*t+o;n.set(e.subarray(c,c+r[1]),s),s+=r[1]}}function xSe(e,t,n,a,r,s){let i=0,o=r[0],u=r[1],d=r[2],c=o+s[0],p=u+s[1];for(let m=o;m<c;m++)for(let g=u;g<p;g++){let b=m*t+g*n+d;a.set(e.subarray(b,b+s[2]),i),i+=s[2]}}function wSe(e,t,n,a,r,s,i){let o=0,u=s[0],d=s[1],c=s[2],p=u+i[0],m=d+i[1],g=c+i[2],b=s[3];for(let v=u;v<p;v++)for(let x=d;x<m;x++)for(let w=c;w<g;w++){let k=v*t+x*n+w*a+b;r.set(e.subarray(k,k+i[3]),o),o+=i[3]}}var SSe={kernelName:Gp,backendName:"wasm",kernelFunc:Wu};function kSe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,crops:i}=a,o=s.reduce((w,k)=>w*k),u=O.getReshaped(r.shape,s,o),d=O.getPermuted(u.length,s.length),c=O.getReshapedPermuted(r.shape,s,o),p=O.getSliceBeginCoords(i,s.length),m=O.getSliceSize(c,i,s.length),g=ur({inputs:{x:r},backend:n,attrs:{shape:u}}),b=fl({inputs:{x:g},backend:n,attrs:{perm:d}}),v=ur({inputs:{x:b},backend:n,attrs:{shape:c}}),x=Wu({inputs:{x:v},backend:n,attrs:{begin:p,size:m}});return n.disposeData(g.dataId),n.disposeData(b.dataId),n.disposeData(v.dataId),x}var _Se={kernelName:op,backendName:"wasm",kernelFunc:kSe},j4;function NSe(e){j4=e.wasm.cwrap(lp,null,["number","number","boolean","number","number","number"])}function ISe(e){let{backend:t,inputs:n,attrs:a}=e,{x:r,weights:s}=n,{size:i}=a,o=s.shape.reduce((p,m)=>p*m,1)!==0,u=r.shape.length===1?[i]:[r.shape[0],i],d=t.makeOutput(u,s.dtype);function c(p){return t.dataIdMap.get(p.dataId).id}return j4(c(r),i,o,c(s),Rt[s.dtype],c(d)),d}var TSe={kernelName:lp,backendName:"wasm",setupFunc:NSe,kernelFunc:ISe},ESe=Vn(up);function CSe(e){let{inputs:t,backend:n}=e,{s0:a,s1:r}=t,s=n.typedArrayFromHeap(a),i=n.typedArrayFromHeap(r),o=O.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return n.makeOutput([o.length],"int32",void 0,new Int32Array(o))}var ASe={kernelName:Eg,backendName:"wasm",kernelFunc:CSe};function Al(e){let{inputs:{x:t},attrs:{dtype:n},backend:a}=e,r=a.makeOutput(t.shape,n),s=a.typedArrayFromHeap(t);return a.typedArrayFromHeap(r).set(s),r}var $Se={kernelName:nc,backendName:"wasm",kernelFunc:Al},RSe=Tt(ac),W4;function DSe(e){W4=e.wasm.cwrap(vl,null,["number","number","number","number"])}function OSe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{clipValueMin:s,clipValueMax:i}=a,o=n.dataIdMap.get(r.dataId).id,u=n.makeOutput(r.shape,r.dtype),d=n.dataIdMap.get(u.dataId).id;return W4(o,s,i,d),u}var MSe={kernelName:vl,backendName:"wasm",setupFunc:DSe,kernelFunc:OSe};function V4(e){let{inputs:t,backend:n}=e,a=E.parseAxisParam(e.attrs.axis,t[0].shape)[0],r=t.map(g=>g.shape);O.assertParamsConsistent(r,a);let s=O.computeOutShape(t.map(g=>g.shape),a),i=t.filter(g=>E.sizeFromShape(g.shape)>0);if(i.length===1)return $x({inputs:{x:i[0]},backend:n});let o=n.makeOutput(s,t[0].dtype);if(E.sizeFromShape(s)===0)return o;if(i[0].dtype==="string"){let g=i.map(N=>{let I=[-1,E.sizeFromShape(N.shape.slice(a))];return ur({inputs:{x:N},backend:n,attrs:{shape:I}})}),b=g.map(N=>({vals:n.readSync(N.dataId),shape:N.shape}));s=O.computeOutShape(g.map(N=>N.shape),1);let v=g[0].shape[0]===1,x=pI(b,s,t[0].dtype,v),w=O.computeOutShape(i.map(N=>N.shape),a);o.shape=w;let k=n.dataIdMap.get(o.dataId);return k.stringBytes=O.fromStringArrayToUint8(x),g.forEach(N=>n.disposeData(N.dataId)),o}let u=E.sizeFromShape(i[0].shape.slice(0,a)),d=0,c=i.map(g=>{let b=E.sizeFromShape(g.shape.slice(a));return d+=b,b}),p=i.map(g=>n.typedArrayFromHeap(g)),m=n.typedArrayFromHeap(o);for(let g=0;g<u;g++){let b=g*d;for(let v=0;v<p.length;v++){let x=c[v],w=g*x,k=p[v].subarray(w,w+x);m.set(k,b),b+=x}}return o}var FSe={kernelName:cp,backendName:"wasm",kernelFunc:V4},H4;function zSe(e){H4=e.wasm.cwrap(rc,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function LSe(e){let{inputs:t,attrs:n,backend:a}=e,{x:r,filter:s}=t,i=a.dataIdMap.get(r.dataId).id,o=a.dataIdMap.get(s.dataId).id,{strides:u,dilations:d,pad:c,dimRoundingMode:p,dataFormat:m}=n,g=O.convertConv2DDataFormat(m),b=O.computeConv2DInfo(r.shape,s.shape,u,d,c,p,!1,g),v=b.filterHeight,x=b.filterWidth,w=b.padInfo.top,k=b.padInfo.right,N=b.padInfo.bottom,I=b.padInfo.left,T=b.dilationHeight,$=b.dilationWidth,D=b.strideHeight,M=b.strideWidth,B=b.inChannels,V=b.outChannels,W=b.padInfo.type==="SAME"?1:0;if(b.dataFormat!=="channelsLast")throw new Error(`wasm backend Conv2D does not support dataFormat:'${b.dataFormat}'. Please use 'channelsLast'.`);let R=a.makeOutput(b.outShape,"float32"),H=a.dataIdMap.get(R.dataId).id;return H4(i,r.shape[0],r.shape[1],r.shape[2],o,v,x,w,k,N,I,W,T,$,D,M,B,V,H),R}var BSe={kernelName:rc,backendName:"wasm",setupFunc:zSe,kernelFunc:LSe},G4;function PSe(e){G4=e.wasm.cwrap(sc,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function USe(e){let{backend:t,inputs:n,attrs:a}=e,{dy:r,filter:s}=n,{strides:i,pad:o,dataFormat:u,dimRoundingMode:d,inputShape:c}=a,p=1,m=O.convertConv2DDataFormat(u),g=O.computeConv2DInfo(c,s.shape,i,p,o,d,!1,m),{batchSize:b,filterHeight:v,filterWidth:x,inChannels:w,inHeight:k,inWidth:N,outChannels:I,outHeight:T,outWidth:$,strideHeight:D,strideWidth:M}=g,B=v-1-g.padInfo.top,V=x-1-g.padInfo.left,W=g.dataFormat==="channelsLast",R=E.computeStrides(g.inShape),H=E.computeStrides(r.shape),[Z,ae,j]=E.computeStrides(s.shape),K=R[0],Q=W?R[1]:R[2],ce=W?R[2]:1,me=W?1:R[1],L=H[0],ee=W?H[1]:H[2],ie=W?H[2]:1,de=W?1:H[1],we=t.makeOutput(g.inShape,"float32"),Ie=t.dataIdMap.get(we.dataId).id,Ee=t.dataIdMap.get(r.dataId).id,Ce=t.dataIdMap.get(s.dataId).id;return G4(Ee,Ce,b,v,x,k,N,w,T,$,I,D,M,B,V,Z,ae,j,K,Q,ce,me,L,ee,ie,de,Ie),we}var jSe={kernelName:sc,backendName:"wasm",setupFunc:PSe,kernelFunc:USe},q4;function WSe(e){q4=e.wasm.cwrap(ic,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function VSe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dilations:u}=a;if(r.dtype!=="float32")throw new Error(`Tensor x must have dtype float32, got ${r.dtype}`);if(s.dtype!=="float32")throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);let d=O.computeConv3DInfo(r.shape,s.shape,i,u,o),c=n.makeOutput(d.outShape,r.dtype);return q4(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(c.dataId).id,d.batchSize,d.inDepth,d.inHeight,d.inWidth,d.inChannels,d.outDepth,d.outHeight,d.outWidth,d.outChannels,d.strideDepth,d.strideHeight,d.strideWidth,d.dilationDepth,d.dilationHeight,d.dilationWidth,d.filterDepth,d.filterHeight,d.filterWidth,d.padInfo.front,d.padInfo.top,d.padInfo.left),c}var HSe={kernelName:ic,backendName:"wasm",setupFunc:WSe,kernelFunc:VSe},K4;function GSe(e){K4=e.wasm.cwrap(dp,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function qSe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:i,pad:o,filterShape:u}=a;if(r.dtype!=="float32")throw new Error(`Tensor dy must have dtype float32, got ${r.dtype}`);if(s.dtype!=="float32")throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);let d=O.computeConv3DInfo(r.shape,u,i,1,o),c=n.makeOutput(d.filterShape,s.dtype);return K4(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(c.dataId).id,d.batchSize,d.inDepth,d.inHeight,d.inWidth,d.inChannels,d.outDepth,d.outHeight,d.outWidth,d.outChannels,d.strideDepth,d.strideHeight,d.strideWidth,d.dilationDepth,d.dilationHeight,d.dilationWidth,d.filterDepth,d.filterHeight,d.filterWidth,d.padInfo.front,d.padInfo.top,d.padInfo.left),c}var KSe={kernelName:dp,backendName:"wasm",setupFunc:GSe,kernelFunc:qSe},X4;function XSe(e){X4=e.wasm.cwrap(hp,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function YSe(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{pad:i,strides:o,inputShape:u}=a;if(r.dtype!=="float32")throw new Error(`Tensor dy must have dtype float32, got ${r.dtype}`);if(s.dtype!=="float32")throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);let d=O.computeConv3DInfo(u,s.shape,o,1,i),c=n.makeOutput(d.inShape,r.dtype);return X4(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(c.dataId).id,d.batchSize,d.inDepth,d.inHeight,d.inWidth,d.inChannels,d.outDepth,d.outHeight,d.outWidth,d.outChannels,d.strideDepth,d.strideHeight,d.strideWidth,d.dilationDepth,d.dilationHeight,d.dilationWidth,d.filterDepth,d.filterHeight,d.filterWidth,d.padInfo.front,d.padInfo.top,d.padInfo.left),c}var JSe={kernelName:hp,backendName:"wasm",setupFunc:XSe,kernelFunc:YSe},ZSe=Tt(oc),QSe=Tt(lc),Nk;(function(e){e[e.bilinear=0]="bilinear",e[e.nearest=1]="nearest"})(Nk||(Nk={}));var Y4;function eke(e){Y4=e.wasm.cwrap(fp,null,["number","number","number","number","array","number","number","number","number","number"])}function tke(e){let{backend:t,inputs:n,attrs:a}=e,{method:r,extrapolationValue:s,cropSize:i}=a,{image:o,boxes:u,boxInd:d}=n,c=u.shape[0],[p,m]=i,g=[c,p,m,o.shape[3]],b=t.dataIdMap.get(o.dataId),v;o.dtype!=="float32"&&(v=Al({backend:t,inputs:{x:o},attrs:{dtype:"float32"}}),b=t.dataIdMap.get(v.dataId));let x=b.id,w=t.dataIdMap.get(u.dataId).id,k=t.dataIdMap.get(d.dataId).id,N=t.makeOutput(g,"float32"),I=t.dataIdMap.get(N.dataId).id,T=new Uint8Array(new Int32Array(o.shape).buffer);return Y4(x,w,k,c,T,p,m,Nk[r],s,I),v!=null&&t.disposeData(v.dataId),N}var nke={kernelName:fp,backendName:"wasm",setupFunc:eke,kernelFunc:tke},J4;function ake(e){J4=e.wasm.cwrap(pp,null,["number","number","number","number","number","number"])}function rke(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,exclusive:i,reverse:o}=a,u=r.shape.length;E.assert(r.dtype==="float32"||r.dtype==="int32",()=>`cumprod does not support ${r.dtype} tensors in the WASM backend`);let d=O.getAxesPermutation([s],u),c=r;d!==null&&(c=fl({inputs:{x:r},attrs:{perm:d},backend:n}));let p=O.getInnerMostAxes(1,u)[0];O.assertAxesAreInnerMostDims("cumprod",[p],u);let m=n.makeOutput(c.shape,c.dtype),g=c.shape[p],b=n.dataIdMap.get(c.dataId).id,v=n.dataIdMap.get(m.dataId).id;J4(b,i?1:0,o?1:0,g,v,Rt[r.dtype]);let x=m;if(d!==null){let w=O.getUndoAxesPermutation(d);x=fl({inputs:{x:m},attrs:{perm:w},backend:n}),n.disposeData(c.dataId),n.disposeData(m.dataId)}return x}var ske={kernelName:pp,backendName:"wasm",setupFunc:ake,kernelFunc:rke},Z4;function ike(e){Z4=e.wasm.cwrap(uc,null,["number","number","number","number","number","number"])}function oke(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,exclusive:i,reverse:o}=a,u=r.shape.length;E.assert(r.dtype==="float32"||r.dtype==="int32",()=>`cumsum does not support ${r.dtype} tensors in the WASM backend`);let d=O.getAxesPermutation([s],u),c=r;d!==null&&(c=fl({inputs:{x:r},attrs:{perm:d},backend:n}));let p=O.getInnerMostAxes(1,u)[0];O.assertAxesAreInnerMostDims("cumsum",[p],u);let m=n.makeOutput(c.shape,c.dtype),g=c.shape[p],b=n.dataIdMap.get(c.dataId).id,v=n.dataIdMap.get(m.dataId).id;Z4(b,i?1:0,o?1:0,g,v,Rt[r.dtype]);let x=m;if(d!==null){let w=O.getUndoAxesPermutation(d);x=fl({inputs:{x:m},attrs:{perm:w},backend:n}),n.disposeData(c.dataId),n.disposeData(m.dataId)}return x}var lke={kernelName:uc,backendName:"wasm",setupFunc:ike,kernelFunc:oke},Q4;function uke(e){Q4=e.wasm.cwrap("DenseBincount",null,["number","array","number","number","boolean","number","number","boolean","number"])}function cke(e){let{backend:t,inputs:n,attrs:a}=e,{x:r,weights:s}=n,{size:i,binaryOutput:o}=a,u=s.shape.reduce((m,g)=>m*g,1)!==0,d=r.shape.length===1?[i]:[r.shape[0],i],c=t.makeOutput(d,s.dtype);function p(m){return t.dataIdMap.get(m.dataId).id}return Q4(p(r),new Uint8Array(new Int32Array(r.shape).buffer),r.shape.length,i,u,p(s),Rt[s.dtype],o,p(c)),c}var dke={kernelName:Ag,backendName:"wasm",setupFunc:uke,kernelFunc:cke},eP;function hke(e){eP=e.wasm.cwrap(mp,null,["number","number","number","array","number","array","array","number","number"])}function pke(e){let{backend:t,inputs:n,attrs:a}=e,{x:r}=n,{blockSize:s,dataFormat:i}=a,o=r.shape[0],u=i==="NHWC"?r.shape[1]:r.shape[2],d=i==="NHWC"?r.shape[2]:r.shape[3],c=i==="NHWC"?r.shape[3]:r.shape[1],p=u*s,m=d*s,g=c/(s*s),b=i==="NHWC"?[o,p,m,g]:[o,g,p,m],v=t.makeOutput(b,"float32"),x=t.dataIdMap.get(r.dataId).id,w=new Uint8Array(new Int32Array(E.computeStrides(r.shape)).buffer),k=new Uint8Array(new Int32Array(b).buffer),N=new Uint8Array(new Int32Array(E.computeStrides(b)).buffer),I=t.dataIdMap.get(v.dataId).id;return eP(x,s,i==="NHWC"?1:0,w,r.shape.length-1,k,N,b.length,I),v}var fke={kernelName:mp,backendName:"wasm",setupFunc:hke,kernelFunc:pke},tP;function mke(e){tP=e.wasm.cwrap(cc,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function gke(e){let{inputs:t,attrs:n,backend:a}=e,{x:r,filter:s}=t,i=a.dataIdMap.get(r.dataId).id,o=a.dataIdMap.get(s.dataId).id,{strides:u,dilations:d,pad:c,dimRoundingMode:p}=n,m=d??[1,1],g=O.computeConv2DInfo(r.shape,s.shape,u,m,c,p,!0),b=g.filterHeight,v=g.filterWidth,x=g.padInfo.top,w=g.padInfo.right,k=g.padInfo.bottom,N=g.padInfo.left,I=g.dilationHeight,T=g.dilationWidth,$=g.strideHeight,D=g.strideWidth,M=g.inChannels,B=g.outChannels,V=g.padInfo.type==="SAME"?1:0;if(g.dataFormat!=="channelsLast")throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${g.dataFormat}'. Please use 'channelsLast'.`);let W=a.makeOutput(g.outShape,"float32"),R=a.dataIdMap.get(W.dataId).id;return tP(i,r.shape[0],r.shape[1],r.shape[2],o,b,v,x,w,k,N,V,I,T,$,D,M,B,R),W}var yke={kernelName:cc,backendName:"wasm",setupFunc:mke,kernelFunc:gke},nP;function bke(e){nP=e.wasm.cwrap("Diag",null,["number","number","number","number"])}function vke(e){let{inputs:t,backend:n}=e,{x:a}=t,r=E.sizeFromShape(a.shape),s=n.makeOutput([...a.shape,...a.shape],a.dtype);return nP(n.dataIdMap.get(a.dataId).id,Rt[a.dtype],r,n.dataIdMap.get(s.dataId).id),s}var xke={kernelName:$g,backendName:"wasm",setupFunc:bke,kernelFunc:vke},aP;function wke(e){aP=e.wasm.cwrap(dc,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Ske(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dilations:u}=a;if(r.dtype!==s.dtype)throw new Error(`Dilation2D error: x must have the same dtype as filter. Got ${r.dtype} and ${s.dtype}`);let d=O.computeDilation2DInfo(r.shape,s.shape,i,o,"NHWC",u),c=n.makeOutput(d.outShape,r.dtype);return aP(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(c.dataId).id,Rt[r.dtype],d.batchSize,d.inChannels,d.inHeight,d.inWidth,d.outHeight,d.outWidth,d.strideHeight,d.strideWidth,d.dilationHeight,d.dilationWidth,d.filterHeight,d.filterWidth,d.padInfo.top,d.padInfo.left),c}var kke={kernelName:dc,backendName:"wasm",setupFunc:wke,kernelFunc:Ske},rP;function _ke(e){rP=e.wasm.cwrap(Fh,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Nke(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,dy:i}=t,{strides:o,pad:u,dilations:d}=a;if(r.dtype!==s.dtype||r.dtype!==i.dtype)throw new Error(`Dilation2DBackpropFilter error: x must have the same dtype as filter and dy. Got ${r.dtype}, ${s.dtype}, and ${i.dtype}`);let c=O.computeDilation2DInfo(r.shape,s.shape,o,u,"NHWC",d),p=n.makeOutput(s.shape,s.dtype);return rP(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(p.dataId).id,Rt[r.dtype],c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.filterHeight,c.filterWidth,c.padInfo.top,c.padInfo.left),p}var Ike={kernelName:Fh,backendName:"wasm",setupFunc:_ke,kernelFunc:Nke},sP;function Tke(e){sP=e.wasm.cwrap(Mh,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Eke(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,dy:i}=t,{strides:o,pad:u,dilations:d}=a;if(r.dtype!==s.dtype||r.dtype!==i.dtype)throw new Error(`Dilation2DBackpropInput error: x must have the same dtype as filter and dy. Got ${r.dtype}, ${s.dtype}, and ${i.dtype}`);let c=O.computeDilation2DInfo(r.shape,s.shape,o,u,"NHWC",d),p=n.makeOutput(r.shape,r.dtype);return sP(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(p.dataId).id,Rt[r.dtype],c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.filterHeight,c.filterWidth,c.padInfo.top,c.padInfo.left),p}var Cke={kernelName:Mh,backendName:"wasm",setupFunc:Tke,kernelFunc:Eke},Ake=Tt(pc),iP;function $ke(e){iP=e.wasm.cwrap(gp,null,["number","number","number"])}function Rke(e){let{inputs:t,backend:n}=e,{dy:a,y:r}=t,s=n.makeOutput(r.shape,"float32"),i=o=>n.dataIdMap.get(o.dataId).id;return iP(i(r),i(a),i(s)),s}var Dke={kernelName:gp,backendName:"wasm",setupFunc:$ke,kernelFunc:Rke},Oke=!1,Mke=Vn(yp,Oke,"bool"),Fke=Tt(fc),zke=Tt(mc,"float32");function Ik(e){let{inputs:t,attrs:n,backend:a}=e,{input:r}=t,{dim:s}=n,i=r.shape.length,o=r.shape.slice(),u=s;return s<0&&(E.assert(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),u=i+s+1),o.splice(u,0,1),ur({inputs:{x:r},backend:a,attrs:{shape:o}})}var Lke={kernelName:bp,backendName:"wasm",kernelFunc:Ik},Bke=Tt(gc,"float32");function oP(e){let{attrs:{shape:t,value:n},backend:a}=e,{attrs:{dtype:r}}=e;r=r||E.inferDtype(n);let s=a.makeOutput(t,r);return a.typedArrayFromHeap(s).fill(n),s}var Pke={kernelName:Rg,backendName:"wasm",kernelFunc:oP},lP;function Uke(e){lP=e.wasm.cwrap(vp,null,["number","number","number","number","number","number"])}function jke(e){let{inputs:t,backend:n}=e,{image:a}=t,r=n.makeOutput(a.shape,a.dtype),s=n.dataIdMap.get(a.dataId).id,i=n.dataIdMap.get(r.dataId).id,[o,u,d,c]=a.shape;return lP(s,o,u,d,c,i),r}var Wke={kernelName:vp,backendName:"wasm",kernelFunc:jke,setupFunc:Uke},Vke=Tt(yc),Hke=Vn(bc),uP;function Gke(e){uP=e.wasm.cwrap(vc,null,["number","number","number","number","number","number","number"])}function qke(e){let{backend:t,inputs:n,attrs:a}=e,{varianceEpsilon:r}=a,{x:s,mean:i,variance:o,offset:u,scale:d}=n,c=t.dataIdMap.get(s.dataId).id,p=t.dataIdMap.get(i.dataId).id,m=t.dataIdMap.get(o.dataId).id,g=u!=null?t.dataIdMap.get(u.dataId).id:0,b=d!=null?t.dataIdMap.get(d.dataId).id:0,v=t.makeOutput(s.shape,s.dtype);if(E.sizeFromShape(s.shape)===0)return v;let x=t.dataIdMap.get(v.dataId).id;return uP(c,p,m,g,b,r,x),v}var Kke={kernelName:vc,backendName:"wasm",setupFunc:Gke,kernelFunc:qke},cP;function Xke(e){cP=e.wasm.cwrap(Iu,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Yke(e){let{inputs:t,attrs:n,backend:a}=e,{x:r,filter:s,bias:i,preluActivationWeights:o}=t,{strides:u,pad:d,dilations:c,dataFormat:p,dimRoundingMode:m,activation:g,leakyreluAlpha:b}=n,v=O.computeConv2DInfo(r.shape,s.shape,u,c,d,m),x=hg[g];if(x==null)throw new Error(`${g} activation not yet supported for FusedConv2D in the wasm backend.`);let w=a.dataIdMap.get(r.dataId).id,k=a.dataIdMap.get(s.dataId).id,N=v.outChannels,I=0;if(i!=null){let ie=a.dataIdMap.get(i.dataId);if(ie.shape.length!==1)throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${ie.shape.length}.`);if(ie.shape[0]!==N)throw new Error(`FusedConv2D bias shape (${ie.shape}) does not match the number of output channels (${N})`);I=ie.id}let T=v.filterHeight,$=v.filterWidth,D=v.padInfo.top,M=v.padInfo.right,B=v.padInfo.bottom,V=v.padInfo.left,W=v.dilationHeight,R=v.dilationWidth,H=v.strideHeight,Z=v.strideWidth,ae=v.inChannels,j=v.padInfo.type==="SAME"?1:0,K=v.batchSize,Q=v.inHeight,ce=v.inWidth;if(p!=="NHWC")throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${p}'. Please use 'NHWC'.`);let me=a.makeOutput(v.outShape,"float32"),L=a.dataIdMap.get(me.dataId).id,ee=o==null?0:a.dataIdMap.get(o.dataId).id;return cP(w,K,Q,ce,k,T,$,I,D,M,B,V,j,W,R,H,Z,ae,N,x,ee,b||0,L),me}var Jke={kernelName:Iu,backendName:"wasm",setupFunc:Xke,kernelFunc:Yke},dP;function Zke(e){dP=e.wasm.cwrap(Tu,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Qke(e){let{inputs:t,attrs:n,backend:a}=e,{x:r,filter:s,bias:i,preluActivationWeights:o}=t,{strides:u,pad:d,dilations:c,dataFormat:p,dimRoundingMode:m,activation:g,leakyreluAlpha:b}=n,v=O.computeConv2DInfo(r.shape,s.shape,u,c,d,m,!0),x=hg[g];if(x==null)throw new Error(`${g} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);let w=a.dataIdMap.get(r.dataId).id,k=a.dataIdMap.get(s.dataId).id,N=v.outChannels,I=0;if(i!=null){let ie=a.dataIdMap.get(i.dataId);if(ie.shape.length!==1)throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${ie.shape.length}.`);if(ie.shape[0]!==N)throw new Error(`FusedDepthwiseConv2D bias shape (${ie.shape}) does not match the number of output channels (${N})`);I=ie.id}let T=v.filterHeight,$=v.filterWidth,D=v.padInfo.top,M=v.padInfo.right,B=v.padInfo.bottom,V=v.padInfo.left,W=v.dilationHeight,R=v.dilationWidth,H=v.strideHeight,Z=v.strideWidth,ae=v.inChannels,j=v.padInfo.type==="SAME"?1:0,K=v.batchSize,Q=v.inHeight,ce=v.inWidth;if(p!=="NHWC")throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${p}'. Please use 'NHWC'.`);let me=a.makeOutput(v.outShape,"float32"),L=a.dataIdMap.get(me.dataId).id,ee=o==null?0:a.dataIdMap.get(o.dataId).id;return dP(w,K,Q,ce,k,T,$,I,D,M,B,V,j,W,R,H,Z,ae,N,x,ee,b||0,L),me}var e_e={kernelName:Tu,backendName:"wasm",setupFunc:Zke,kernelFunc:Qke},hP;function t_e(e){hP=e.wasm.cwrap(wp,null,["number","number","number","number","number","number","array","number"])}function n_e(e){let{backend:t,inputs:n}=e,{params:a,indices:r}=n,[s,i,o,u]=N2.prepareAndValidate(a,r),d=t.makeOutput(s,a.dtype);if(i===0)return d;let c=r.shape,p=c[c.length-1],m=t.dataIdMap.get(a.dataId).id,g=t.dataIdMap.get(r.dataId).id,b=new Uint8Array(new Int32Array(u).buffer),v=t.dataIdMap.get(d.dataId).id;return hP(m,Rt[a.dtype],g,i,p,o,b,v),d}var a_e={kernelName:wp,backendName:"wasm",setupFunc:t_e,kernelFunc:n_e},pP;function r_e(e){pP=e.wasm.cwrap("Gather",null,["number","number","array","number","number","number","array","number"])}function s_e(e){let{backend:t,inputs:n,attrs:a}=e,{x:r,indices:s}=n,{axis:i,batchDims:o}=a,u=E.parseAxisParam(i,r.shape)[0],d=t.readSync(s.dataId),c=r.shape[u];for(let D=0;D<d.length;++D){let M=d[D];E.assert(M<=c-1&&M>=0,()=>`GatherV2: the index value ${M} is not in [0, ${c-1}]`)}let p=O.segment_util.collectGatherOpShapeInfo(r,s,u,o),m=ur({inputs:{x:r},attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]},backend:t}),g=E.sizeFromShape(s.shape),b=ur({inputs:{x:s},attrs:{shape:[p.batchSize,g/p.batchSize]},backend:t}),v=[p.batchSize,p.outerSize,g/p.batchSize,p.sliceSize],x=t.makeOutput(v,r.dtype);if(E.sizeFromShape(r.shape)===0)return x;let w=m.shape.length-1,k=t.dataIdMap.get(m.dataId).id,N=t.dataIdMap.get(b.dataId).id,I=t.dataIdMap.get(x.dataId).id,T=new Uint8Array(new Int32Array(E.computeStrides(m.shape)).buffer),$=new Uint8Array(new Int32Array(E.computeStrides(v)).buffer);return pP(k,Rt[r.dtype],T,w,N,p.batchSize,$,I),t.disposeData(m.dataId),t.disposeData(b.dataId),x.shape=p.outputShape,x}var i_e={kernelName:xp,backendName:"wasm",setupFunc:r_e,kernelFunc:s_e},o_e=!1,l_e=Vn(Sp,o_e,"bool"),u_e=!1,c_e=Vn(xc,u_e,"bool"),d_e=Tt(Sc,"bool"),h_e=Tt(kc,"bool"),p_e=Tt(_c,"bool"),fP;function f_e(e){fP=e.wasm.cwrap(Nc,null,["number","number","number","number"])}function m_e(e){let{inputs:{x:t},attrs:{alpha:n},backend:a}=e,r=a.dataIdMap.get(t.dataId).id,s=a.makeOutput(t.shape,"float32");if(E.sizeFromShape(t.shape)!==0){let i=a.dataIdMap.get(s.dataId).id;fP(r,Rt[t.dtype],n,i)}return s}var g_e={kernelName:Nc,backendName:"wasm",setupFunc:f_e,kernelFunc:m_e},y_e=!1,b_e=Vn(kp,y_e,"bool"),v_e=!1,x_e=Vn(_p,v_e,"bool"),mP;function w_e(e){mP=e.wasm.cwrap(Np,null,["number","number","number","number"])}function S_e(e){let{attrs:t,backend:n}=e,{start:a,stop:r,num:s}=t,i=Math.floor(s),o=n.makeOutput([i],"float32");return mP(n.dataIdMap.get(o.dataId).id,a,r,i),o}var k_e={kernelName:Np,backendName:"wasm",setupFunc:w_e,kernelFunc:S_e},__e=Tt(Ic),N_e=Tt(Tc),I_e=!1,T_e=Vn(Ip,I_e,"bool"),E_e=Tt(Tp),C_e=!1,A_e=Vn(Ep,C_e,"bool"),$_e=!1,R_e=Vn(fO,$_e,"bool"),gP;function D_e(e){gP=e.wasm.cwrap(Ec,null,["number","number","number","number","number","number","number"])}function O_e(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{depthRadius:s,bias:i,alpha:o,beta:u}=a;if(r.dtype!=="float32")throw new Error("LRN error: x must have dtype float32");let d=n.makeOutput(r.shape,r.dtype);return gP(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(d.dataId).id,r.shape[3],s,i,o,u),d}var M_e={kernelName:Ec,backendName:"wasm",setupFunc:D_e,kernelFunc:O_e},yP;function F_e(e){yP=e.wasm.cwrap(Cp,null,["number","number","number","number","number","number","number","number","number"])}function z_e(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,y:s,dy:i}=t,{depthRadius:o,bias:u,alpha:d,beta:c}=a;if(r.dtype!=="float32"||s.dtype!=="float32"||i.dtype!=="float32")throw new Error("LRNGrad error: x, y, and dy must have dtype float32");let p=n.makeOutput(r.shape,r.dtype);return yP(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(p.dataId).id,i.shape[3],o,u,d,c),p}var L_e={kernelName:Cp,backendName:"wasm",setupFunc:F_e,kernelFunc:z_e},bP;function B_e(e){bP=e.wasm.cwrap(Cc,null,["number","number","number","number"])}function P_e(e){let{backend:t,inputs:n,attrs:a}=e,{reductionIndices:r,keepDims:s}=a,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,u=i,{transposed:d,axes:c,originalAxes:p,inputWasTransposed:m}=Cl(i,r,t);if(m){let k=t.dataIdMap.get(d.dataId).id;u=d,o=k}let g=u.shape.length;O.assertAxesAreInnerMostDims("max",c,g);let[b,v]=O.computeOutAndReduceShapes(u.shape,c),x=E.sizeFromShape(v),w=t.makeOutput(b,i.dtype);if(E.sizeFromShape(u.shape)!==0){let k=t.dataIdMap.get(w.dataId).id;bP(o,Rt[i.dtype],x,k)}if(m&&t.disposeData(d.dataId),s){let k=O.expandShapeToKeepDim(w.shape,p);w.shape=k}return w}var U_e={kernelName:Cc,backendName:"wasm",setupFunc:B_e,kernelFunc:P_e},j_e=Vn(Ac),vP;function W_e(e){vP=e.wasm.cwrap($c,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function V_e(e){let{inputs:t,attrs:n,backend:a}=e,r=t.x,s=a.dataIdMap.get(r.dataId).id;E.assert(r.dtype==="float32",()=>`Error in MaxPool: only float32 input is supported. Got ${r.dtype}.`);let{filterSize:i,strides:o,pad:u,dimRoundingMode:d}=n,c=O.computePool2DInfo(r.shape,i,o,1,u,d),p=c.filterHeight,m=c.filterWidth,g=c.padInfo.top,b=c.padInfo.right,v=c.padInfo.bottom,x=c.padInfo.left,w=c.dilationHeight,k=c.dilationWidth,N=c.strideHeight,I=c.strideWidth,T=c.inChannels,$=c.outChannels;if(c.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);let D=a.makeOutput(c.outShape,"float32"),M=a.dataIdMap.get(D.dataId).id;return vP(s,r.shape[0],r.shape[1],r.shape[2],p,m,g,b,v,x,w,k,N,I,T,$,M),D}var H_e={kernelName:$c,backendName:"wasm",setupFunc:W_e,kernelFunc:V_e},xP;function G_e(e){xP=e.wasm.cwrap("MaxPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function q_e(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:u,dataFormat:d}=a,c=O.computePool3DInfo(r.shape,s,i,1,o,u,d),p=n.makeOutput(c.outShape,r.dtype);return xP(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(p.dataId).id,c.batchSize,c.inChannels,c.inDepth,c.inHeight,c.inWidth,c.outDepth,c.outHeight,c.outWidth,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left),p}var K_e={kernelName:Ap,backendName:"wasm",setupFunc:G_e,kernelFunc:q_e},wP;function X_e(e){wP=e.wasm.cwrap("MaxPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Y_e(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,{filterSize:i,strides:o,pad:u,dimRoundingMode:d}=a,c=O.computePool3DInfo(s.shape,i,o,1,u,d),p=n.makeOutput(s.shape,s.dtype);return wP(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(p.dataId).id,c.batchSize,c.inChannels,c.inDepth,c.inHeight,c.inWidth,c.outDepth,c.outHeight,c.outWidth,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left),p}var J_e={kernelName:Og,backendName:"wasm",setupFunc:X_e,kernelFunc:Y_e},SP;function Z_e(e){SP=e.wasm.cwrap("MaxPoolGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Q_e(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,{filterSize:i,strides:o,pad:u,dimRoundingMode:d}=a,c=O.computePool2DInfo(s.shape,i,o,1,u,d),p=n.makeOutput(s.shape,s.dtype);return SP(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(p.dataId).id,c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.top,c.padInfo.left),p}var e2e={kernelName:Dg,backendName:"wasm",setupFunc:Z_e,kernelFunc:Q_e},kP;function t2e(e){kP=e.wasm.cwrap("MaxPoolWithArgmax",null,["number","number","number","number","boolean","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function n2e(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:i,pad:o,includeBatchInIndex:u}=a;E.assert(r.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);let d=[1,1];E.assert(O.eitherStridesOrDilationsAreOne(i,d),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${d}'`);let c=O.computePool2DInfo(r.shape,s,i,[1,1],o),p=n.makeOutput(c.outShape,r.dtype),m=n.makeOutput(c.outShape,"int32");return kP(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(p.dataId).id,n.dataIdMap.get(m.dataId).id,Rt[r.dtype],u,c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.top,c.padInfo.left),[p,m]}var a2e={kernelName:Mg,backendName:"wasm",setupFunc:t2e,kernelFunc:n2e},_P;function r2e(e){_P=e.wasm.cwrap(Rc,null,["number, number, number"])}function s2e(e){let{backend:t,inputs:n,attrs:a}=e,{axis:r,keepDims:s}=a,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,u=o,d=i,{transposed:c,axes:p,originalAxes:m,inputWasTransposed:g}=Cl(i,r,t),b=p;if(g){let I=t.dataIdMap.get(c.dataId).id;I!==o&&(d=c,u=I,b=O.getInnerMostAxes(b.length,d.shape.length))}O.assertAxesAreInnerMostDims("mean",b,d.shape.length);let[v,x]=O.computeOutAndReduceShapes(d.shape,b),w=E.sizeFromShape(x),k=d;d.dtype!=="float32"&&(k=Al({backend:t,inputs:{x:d},attrs:{dtype:"float32"}}),u=t.dataIdMap.get(k.dataId).id);let N=t.makeOutput(v,"float32");if(E.sizeFromShape(d.shape)!==0){let I=t.dataIdMap.get(N.dataId).id;_P(u,w,I)}if(g&&t.disposeData(c.dataId),s){let I=O.expandShapeToKeepDim(N.shape,m);N.shape=I}return d.dtype!=="float32"&&t.disposeData(k.dataId),N}var i2e={kernelName:Rc,backendName:"wasm",setupFunc:r2e,kernelFunc:s2e},NP;function o2e(e){NP=e.wasm.cwrap(Dc,null,["number","number","number","number"])}function l2e(e){let{backend:t,inputs:n,attrs:a}=e,{axis:r,keepDims:s}=a,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,u=o,d=i,{transposed:c,axes:p,originalAxes:m,inputWasTransposed:g}=Cl(i,r,t);if(g){let N=t.dataIdMap.get(c.dataId).id;N!==o&&(d=c,u=N)}let b=d.shape.length;O.assertAxesAreInnerMostDims("min",p,b);let[v,x]=O.computeOutAndReduceShapes(d.shape,p),w=E.sizeFromShape(x),k=t.makeOutput(v,d.dtype);if(E.sizeFromShape(d.shape)!==0){let N=t.dataIdMap.get(k.dataId).id;NP(u,Rt[i.dtype],w,N)}if(g&&t.disposeData(c.dataId),s){let N=O.expandShapeToKeepDim(k.shape,m);k.shape=N}return k}var u2e={kernelName:Dc,backendName:"wasm",setupFunc:o2e,kernelFunc:l2e},c2e=Vn(Oc),Tk;(function(e){e[e.reflect=0]="reflect",e[e.symmetric=1]="symmetric"})(Tk||(Tk={}));var IP;function d2e(e){IP=e.wasm.cwrap(Mc,null,["number","array","number","number","array","array","number","number"])}function h2e(e){let{inputs:{x:t},backend:n,attrs:{paddings:a,mode:r}}=e,s=a.map((b,v)=>b[0]+t.shape[v]+b[1]),i=n.dataIdMap.get(t.dataId).id,o=n.makeOutput(s,t.dtype),u=n.dataIdMap.get(o.dataId).id,d=new Uint8Array(new Int32Array(t.shape).buffer),c=a.map(b=>b[0]),p=a.map(b=>b[1]),m=new Uint8Array(new Int32Array(c).buffer),g=new Uint8Array(new Int32Array(p).buffer);return IP(i,d,t.shape.length,Rt[t.dtype],m,g,Tk[r],u),o}var p2e={kernelName:Mc,backendName:"wasm",kernelFunc:h2e,setupFunc:d2e},TP;function f2e(e){TP=e.wasm.cwrap(sd,null,["number","number","number","number"])}function EP(e){let{backend:t,inputs:{logits:n},attrs:{dim:a}}=e,r=t.dataIdMap.get(n.dataId).id,s=t.makeOutput(n.shape,n.dtype),i=t.dataIdMap.get(s.dataId).id,o=n.shape[a],u=E.sizeFromShape(n.shape)/o;return E.sizeFromShape(s.shape)===0||TP(r,i,o,u),s}var m2e={kernelName:sd,backendName:"wasm",setupFunc:f2e,kernelFunc:EP},CP;function g2e(e){CP=e.wasm.cwrap($p,null,["number","number","number","number","number","number"])}function y2e(e){let{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{numSamples:s,seed:i,normalized:o}=a;if(r.dtype!=="float32")throw new Error(`Tensor logits must have dtype float32, got ${r.dtype}`);let u=o?r:EP({inputs:{logits:r},backend:n,attrs:{dim:r.shape.length-1}}),[d,c]=u.shape,p=n.makeOutput([d,s],"int32");return CP(n.dataIdMap.get(u.dataId).id,d,c,s,i,n.dataIdMap.get(p.dataId).id),o||n.disposeData(u.dataId),p}var b2e={kernelName:$p,backendName:"wasm",setupFunc:g2e,kernelFunc:y2e},v2e=Vn(Fc),x2e=Vn(zc),w2e=Tt(Rp);function jI(e,t){let n=new Int32Array(e.wasm.HEAPU8.buffer,t,4),a=n[0],r=n[1],s=n[2],i=n[3];return e.wasm._free(t),{pSelectedIndices:a,selectedSize:r,pSelectedScores:s,pValidOutputs:i}}var AP;function S2e(e){AP=e.wasm.cwrap(Op,"number",["number","number","number","number","number"])}function k2e(e){let{backend:t,inputs:n,attrs:a}=e,{iouThreshold:r,maxOutputSize:s,scoreThreshold:i}=a,{boxes:o,scores:u}=n,d=t.dataIdMap.get(o.dataId).id,c=t.dataIdMap.get(u.dataId).id,p=AP(d,c,s,r,i),{pSelectedIndices:m,selectedSize:g,pSelectedScores:b,pValidOutputs:v}=jI(t,p);return t.wasm._free(b),t.wasm._free(v),t.makeOutput([g],"int32",m)}var _2e={kernelName:Op,backendName:"wasm",setupFunc:S2e,kernelFunc:k2e},$P;function N2e(e){$P=e.wasm.cwrap(Mp,"number",["number","number","number","number","number","bool"])}function I2e(e){let{backend:t,inputs:n,attrs:a}=e,{iouThreshold:r,maxOutputSize:s,scoreThreshold:i,padToMaxOutputSize:o}=a,{boxes:u,scores:d}=n,c=t.dataIdMap.get(u.dataId).id,p=t.dataIdMap.get(d.dataId).id,m=$P(c,p,s,r,i,o),{pSelectedIndices:g,selectedSize:b,pSelectedScores:v,pValidOutputs:x}=jI(t,m);t.wasm._free(v);let w=t.makeOutput([b],"int32",g),k=t.makeOutput([],"int32",x);return[w,k]}var T2e={kernelName:Mp,backendName:"wasm",setupFunc:N2e,kernelFunc:I2e},RP;function E2e(e){RP=e.wasm.cwrap(Fp,"number",["number","number","number","number","number","number"])}function C2e(e){let{backend:t,inputs:n,attrs:a}=e,{iouThreshold:r,maxOutputSize:s,scoreThreshold:i,softNmsSigma:o}=a,{boxes:u,scores:d}=n,c=t.dataIdMap.get(u.dataId).id,p=t.dataIdMap.get(d.dataId).id,m=RP(c,p,s,r,i,o),{pSelectedIndices:g,selectedSize:b,pSelectedScores:v,pValidOutputs:x}=jI(t,m);t.wasm._free(x);let w=t.makeOutput([b],"int32",g),k=t.makeOutput([b],"float32",v);return[w,k]}var A2e={kernelName:Fp,backendName:"wasm",setupFunc:E2e,kernelFunc:C2e},$2e=!1,R2e=Vn(Dp,$2e,"bool"),DP;function D2e(e){DP=e.wasm.cwrap(Lc,null,["number","number","number","number","number"])}function O2e(e){let{inputs:t,backend:n,attrs:a}=e,{indices:r}=t,{dtype:s,depth:i,onValue:o,offValue:u}=a,d=n.makeOutput([...r.shape,i],s),c=n.dataIdMap.get(d.dataId).id,p=n.dataIdMap.get(r.dataId).id;return DP(p,i,o,u,c),d}var M2e={kernelName:Lc,backendName:"wasm",setupFunc:D2e,kernelFunc:O2e};function F2e(e){let{inputs:{x:t},backend:n}=e,a=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(a).fill(1),a}var z2e={kernelName:zp,backendName:"wasm",kernelFunc:F2e};function L2e(e){let{inputs:t,backend:n,attrs:a}=e,{axis:r}=a;if(t.length===1)return Ik({inputs:{input:t[0]},backend:n,attrs:{dim:r}});let s=t[0].shape,i=t[0].dtype;t.forEach(c=>{E.assertShapesMatch(s,c.shape,"All tensors passed to stack must have matching shapes"),E.assert(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let o=[],u=t.map(c=>{let p=Ik({inputs:{input:c},backend:n,attrs:{dim:r}});return o.push(p),p}),d=V4({inputs:u,backend:n,attrs:{axis:r}});return o.forEach(c=>n.disposeData(c.dataId)),d}var B2e={kernelName:Lp,backendName:"wasm",kernelFunc:L2e},OP;function P2e(e){OP=e.wasm.cwrap(Bc,null,["number","array","number","number","array","array","number","number"])}function U2e(e){let{inputs:{x:t},backend:n,attrs:{paddings:a,constantValue:r}}=e,s=a.map((b,v)=>b[0]+t.shape[v]+b[1]);if(E.sizeFromShape(t.shape)===0)return oP({backend:n,attrs:{shape:s,value:r,dtype:t.dtype}});let i=n.dataIdMap.get(t.dataId).id,o=n.makeOutput(s,t.dtype),u=n.dataIdMap.get(o.dataId).id,d=new Uint8Array(new Int32Array(t.shape).buffer),c=a.map(b=>b[0]),p=a.map(b=>b[1]),m=new Uint8Array(new Int32Array(c).buffer),g=new Uint8Array(new Int32Array(p).buffer);return OP(i,d,t.shape.length,Rt[t.dtype],m,g,r,u),o}var MP={kernelName:Bc,backendName:"wasm",kernelFunc:U2e,setupFunc:P2e},j2e=Vn(Pc),FP;function W2e(e){FP=e.wasm.cwrap(Uc,null,["number","number","number"])}function V2e(e){let{inputs:t,backend:n}=e,{x:a,alpha:r}=t,s=n.dataIdMap.get(a.dataId).id,i=n.dataIdMap.get(r.dataId).id,o=s,u=a,d=u;u.dtype!=="float32"&&(d=Al({backend:n,inputs:{x:a},attrs:{dtype:"float32"}}),o=n.dataIdMap.get(d.dataId).id);let c=n.makeOutput(a.shape,"float32"),p=n.dataIdMap.get(c.dataId).id;return FP(o,i,p),u.dtype!=="float32"&&n.disposeData(d.dataId),c}var H2e={kernelName:Uc,backendName:"wasm",setupFunc:W2e,kernelFunc:V2e},zP;function G2e(e){zP=e.wasm.cwrap(jc,null,["number","number","number","number"])}function q2e(e){let{backend:t,inputs:n,attrs:a}=e,{axis:r,keepDims:s}=a,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,u=o,d=i,{transposed:c,axes:p,originalAxes:m,inputWasTransposed:g}=Cl(i,r,t),b=p;if(g){let N=t.dataIdMap.get(c.dataId).id;N!==o&&(d=c,u=N,b=O.getInnerMostAxes(b.length,d.shape.length))}O.assertAxesAreInnerMostDims("prod",b,d.shape.length);let[v,x]=O.computeOutAndReduceShapes(d.shape,b),w=E.sizeFromShape(x),k=t.makeOutput(v,d.dtype);if(E.sizeFromShape(d.shape)!==0){let N=t.dataIdMap.get(k.dataId).id;zP(u,w,Rt[k.dtype],N)}if(g&&t.disposeData(c.dataId),s){let N=O.expandShapeToKeepDim(k.shape,m);k.shape=N}return k}var K2e={kernelName:jc,backendName:"wasm",setupFunc:G2e,kernelFunc:q2e},X2e=e=>{let{backend:t,attrs:n}=e,{start:a,stop:r,step:s,dtype:i}=n,o=gI(a,r,s,i),u=t.makeOutput([o.length],i);return t.typedArrayFromHeap(u).set(o),u},Y2e={kernelName:Fg,backendName:"wasm",kernelFunc:X2e},J2e=Vn(hc),Z2e=Tt(Wc),Q2e=Tt(Vc),eNe=Tt(qc),LP;function tNe(e){LP=e.wasm.cwrap(Gc,null,["number","number","number","number","number","number","number","number","number","number"])}function nNe(e){let{backend:t,inputs:n,attrs:a}=e,{images:r}=n,{alignCorners:s,halfPixelCenters:i,size:o}=a,[u,d]=o,[c,p,m,g]=r.shape,b=[c,u,d,g],v=t.dataIdMap.get(r.dataId),x;v.dtype!=="float32"&&(x=Al({backend:t,inputs:{x:r},attrs:{dtype:"float32"}}),v=t.dataIdMap.get(x.dataId));let w=v.id,k=t.makeOutput(b,"float32");if(E.sizeFromShape(r.shape)===0)return k;let N=t.dataIdMap.get(k.dataId).id;return LP(w,c,p,m,g,u,d,s?1:0,i?1:0,N),x!=null&&t.disposeData(x.dataId),k}var aNe={kernelName:Gc,backendName:"wasm",setupFunc:tNe,kernelFunc:nNe},BP;function rNe(e){BP=e.wasm.cwrap(Up,null,["number","number","number","array","array","boolean"])}function sNe(e){let{inputs:t,backend:n,attrs:a}=e,{images:r,dy:s}=t,{alignCorners:i}=a,o=n.makeOutput(r.shape,"float32"),u=n.dataIdMap.get(r.dataId),d;return u.dtype!=="float32"&&(d=Al({backend:n,inputs:{x:r},attrs:{dtype:"float32"}}),u=n.dataIdMap.get(d.dataId)),BP(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(o.dataId).id,new Uint8Array(new Int32Array(r.shape).buffer),new Uint8Array(new Int32Array(s.shape).buffer),i),d!=null&&n.disposeData(d.dataId),o}var iNe={kernelName:Up,backendName:"wasm",setupFunc:rNe,kernelFunc:sNe},PP;function oNe(e){PP=e.wasm.cwrap(Hc,null,["number","number","number","number","number","number","number","number","number","number"])}function lNe(e){let{backend:t,inputs:n,attrs:a}=e,{images:r}=n,{alignCorners:s,halfPixelCenters:i,size:o}=a,[u,d]=o,[c,p,m,g]=r.shape,b=[c,u,d,g],v=t.makeOutput(b,"float32");if(E.sizeFromShape(r.shape)===0)return v;let x=t.dataIdMap.get(r.dataId),w;x.dtype!=="float32"&&(w=Al({backend:t,inputs:{x:r},attrs:{dtype:"float32"}}),x=t.dataIdMap.get(w.dataId));let k=x.id,N=t.dataIdMap.get(v.dataId).id;return PP(k,c,p,m,g,u,d,s?1:0,i?1:0,N),w!=null&&t.disposeData(w.dataId),v}var uNe={kernelName:Hc,backendName:"wasm",setupFunc:oNe,kernelFunc:lNe},UP;function cNe(e){UP=e.wasm.cwrap(Pp,null,["number","number","number","array","array","boolean"])}function dNe(e){let{inputs:t,backend:n,attrs:a}=e,{images:r,dy:s}=t,{alignCorners:i}=a,o=n.makeOutput(r.shape,"float32"),u=n.dataIdMap.get(r.dataId),d;return u.dtype!=="float32"&&(d=Al({backend:n,inputs:{x:r},attrs:{dtype:"float32"}}),u=n.dataIdMap.get(d.dataId)),UP(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(o.dataId).id,new Uint8Array(new Int32Array(r.shape).buffer),new Uint8Array(new Int32Array(s.shape).buffer),i),d!=null&&n.disposeData(d.dataId),o}var hNe={kernelName:Pp,backendName:"wasm",setupFunc:cNe,kernelFunc:dNe},jP;function pNe(e){jP=e.wasm.cwrap(Kc,null,["number","array","number","array","number","number"])}function fNe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dims:s}=a,i=E.parseAxisParam(s,r.shape);if(r.shape.length===0)return $x({inputs:{x:r},backend:n});let o=n.makeOutput(r.shape,r.dtype),u=n.dataIdMap.get(r.dataId).id,d=n.dataIdMap.get(o.dataId).id,c=new Uint8Array(new Int32Array(i).buffer),p=new Uint8Array(new Int32Array(r.shape).buffer);jP(u,c,i.length,p,r.shape.length,d);let m=ur({inputs:{x:o},attrs:{shape:r.shape},backend:n});return n.disposeData(o.dataId),m}var mNe={kernelName:Kc,backendName:"wasm",kernelFunc:fNe,setupFunc:pNe},WP;function gNe(e){WP=e.wasm.cwrap(nf,null,["number","number","number","number","number","number","number","number","array","number","number"])}function yNe(e){let{inputs:t,backend:n,attrs:a}=e,{image:r}=t,{radians:s,fillValue:i,center:o}=a,u=n.makeOutput(r.shape,r.dtype),d=n.dataIdMap.get(r.dataId).id,c=n.dataIdMap.get(u.dataId).id,[p,m,g,b]=r.shape,[v,x]=O.getImageCenter(o,m,g),w=i===0,k=255,N=typeof i=="number"?[i,i,i,w?0:k]:[...i,k],I=new Uint8Array(new Int32Array(N).buffer);return WP(d,p,m,g,b,s,v,x,I,N.length,c),u}var bNe={kernelName:nf,backendName:"wasm",kernelFunc:yNe,setupFunc:gNe},vNe=Tt(Xc),xNe=Tt(Yc),VP;function wNe(e){VP=e.wasm.cwrap(jp,null,["number","number","number","number","number","number","array","number","number"])}function SNe(e){let{backend:t,inputs:n,attrs:a}=e,{indices:r,updates:s}=n,{shape:i}=a,o=t.makeOutput(i,s.dtype);if(E.sizeFromShape(i)===0)return o;let{sliceRank:u,numUpdates:d,sliceSize:c,strides:p,outputSize:m}=q0.calculateShapes(s,r,i),g=t.dataIdMap.get(r.dataId).id,b=t.dataIdMap.get(s.dataId).id,v=new Uint8Array(new Int32Array(p).buffer),x=t.dataIdMap.get(o.dataId).id;return VP(g,b,Rt[s.dtype],u,d,c,v,m,x),o}var kNe={kernelName:jp,backendName:"wasm",setupFunc:wNe,kernelFunc:SNe},HP;function _Ne(e){HP=e.wasm.cwrap(Vp,null,["number","number","number","number","number","number","bool","number"])}function NNe(e){let{inputs:t,backend:n,attrs:a}=e,{sortedSequence:r,values:s}=t,{side:i}=a;if(r.dtype!==s.dtype)throw new Error(`SearchSorted error: sorted_sequence must have the same dtype as values. Got ${r.dtype} and ${s.dtype}`);let o=n.makeOutput(s.shape,"int32");function u(d){return n.dataIdMap.get(d.dataId).id}return HP(u(r),u(s),r.shape[0],r.shape[1],s.shape[1],Rt[r.dtype],i==="left",u(o)),o}var INe={kernelName:Vp,backendName:"wasm",setupFunc:_Ne,kernelFunc:NNe},GP;function TNe(e){GP=e.wasm.cwrap("SelectV2",null,["number","number","number","number","number"])}function ENe(e){let{inputs:t,backend:n}=e,{condition:a,t:r,e:s}=t,i=n.dataIdMap.get(a.dataId).id,o=n.dataIdMap.get(r.dataId).id,u=n.dataIdMap.get(s.dataId).id,d=n.makeOutput(r.shape,r.dtype),c=n.dataIdMap.get(d.dataId).id,p=a.shape.length,m=r.shape.length,g=p===0||p>1||m===1?1:E.sizeFromShape(r.shape.slice(1));return GP(i,o,u,g,c),d}var CNe={kernelName:Hp,backendName:"wasm",kernelFunc:ENe,setupFunc:TNe},ANe=Tt(Jc),qP;function $Ne(e){qP=e.wasm.cwrap(td,null,["number","number"])}function RNe(e){let{backend:t,inputs:{x:n}}=e,a=t.dataIdMap.get(n.dataId).id,r=t.makeOutput(n.shape,n.dtype),s=t.dataIdMap.get(r.dataId).id;return E.sizeFromShape(r.shape)===0||qP(a,s),r}var DNe={kernelName:"Sigmoid",backendName:"wasm",setupFunc:$Ne,kernelFunc:RNe},ONe=Tt(ed),MNe=Tt(Zc),FNe=Tt(Qc),zNe=Tt(nd);function LNe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,paddings:i}=a,o=E.sizeFromShape(s),u=[[0,0]];u.push(...i);for(let x=1+s.length;x<r.shape.length;++x)u.push([0,0]);let d=MP.kernelFunc({inputs:{x:r},backend:n,attrs:{paddings:u,constantValue:0}}),c=O.getReshaped(d.shape,s,o,!1),p=O.getPermuted(c.length,s.length,!1),m=O.getReshapedPermuted(d.shape,s,o,!1),g=ur({inputs:{x:d},backend:n,attrs:{shape:c}}),b=fl({inputs:{x:g},backend:n,attrs:{perm:p}}),v=ur({inputs:{x:b},backend:n,attrs:{shape:m}});return n.disposeData(d.dataId),n.disposeData(g.dataId),n.disposeData(b.dataId),v}var BNe={kernelName:qp,backendName:"wasm",kernelFunc:LNe},KP;function PNe(e){KP=e.wasm.cwrap("SparseFillEmptyRows","number",["number","number","number","number","number","number","number","number","number","number","number","number"])}function UNe(e){let{backend:t,inputs:n}=e,{indices:a,values:r,denseShape:s,defaultValue:i}=n,o=a.shape[0],u=a.shape[1],d=t.readSync(s.dataId)[0],c=[o+d,u],p=t.dataIdMap.get(a.dataId).id,m=t.dataIdMap.get(r.dataId).id,g=t.dataIdMap.get(i.dataId).id,b=t.makeOutput(c,a.dtype),v=t.dataIdMap.get(b.dataId).id,x=t.makeOutput(c.slice(0,1),r.dtype),w=t.dataIdMap.get(x.dataId).id,k=t.makeOutput([d],"bool"),N=t.dataIdMap.get(k.dataId).id,I=t.makeOutput([o],a.dtype),T=t.dataIdMap.get(I.dataId).id,$=t.makeOutput([4],"int32"),D=t.dataIdMap.get($.dataId).id,M=KP(p,m,Rt[r.dtype],o,d,u,g,v,w,N,T,D),B=t.readSync($.dataId),V;switch(B[0]){case 1:{V=O.getSparseFillEmptyRowsIndicesDenseShapeMismatch(B[1]);break}case 2:{V=O.getSparseFillEmptyRowsNegativeIndexErrorMessage(B[1],B[2]);break}case 3:V=O.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(B[1],B[2],B[3]);break;default:V=""}if(t.disposeData($.dataId),V)throw t.disposeData(b.dataId),t.disposeData(x.dataId),t.disposeData(k.dataId),t.disposeData(I.dataId),new Error(V);let W=b,R=x;return M!==c[0]&&(W=Wu({inputs:{x:b},attrs:{begin:0,size:[M,u]},backend:t}),R=Wu({inputs:{x},attrs:{begin:0,size:M},backend:t}),t.disposeData(b.dataId),t.disposeData(x.dataId)),[W,R,k,I]}var jNe={kernelName:zg,backendName:"wasm",setupFunc:PNe,kernelFunc:UNe},XP;function WNe(e){XP=e.wasm.cwrap(Xp,null,["number","number","number","number","number","number","number"])}function VNe(e){let{backend:t,inputs:n}=e,{inputIndices:a,inputShape:r,newShape:s}=n;if(a.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${a.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=t.dataIdMap.get(a.dataId).id,o=t.dataIdMap.get(r.dataId).id,u=t.dataIdMap.get(s.dataId).id,d=a.shape[0],c=E.sizeFromShape(s.shape),p=t.makeOutput([d,c],a.dtype),m=t.dataIdMap.get(p.dataId).id,g=t.makeOutput([c],s.dtype),b=t.dataIdMap.get(g.dataId).id,v=t.makeOutput([3],"int32"),x=t.dataIdMap.get(v.dataId).id;XP(i,o,u,d,m,b,x);let w=t.readSync(v.dataId),k;switch(w[0]){case 0:{k=O.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(w[1],w[2]);break}case 1:{k=O.getSparseReshapeNegativeOutputDimErrorMessage(w[1],w[2]);break}case 2:k=O.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage();break;case 3:{let N=Array.from(t.readSync(r.dataId)),I=Array.from(t.readSync(g.dataId));k=O.getSparseReshapeInputOutputMultipleErrorMessage(N,I);break}case 4:{let N=Array.from(t.readSync(r.dataId)),I=Array.from(t.readSync(g.dataId));k=O.getSparseReshapeInputOutputMismatchErrorMessage(N,I);break}default:k=""}if(t.disposeData(v.dataId),k)throw t.disposeData(p.dataId),t.disposeData(g.dataId),new Error(k);return[p,g]}var HNe={kernelName:Xp,backendName:"wasm",setupFunc:WNe,kernelFunc:VNe},YP;function JP(e){YP=e.wasm.cwrap("SparseSegmentReduction",null,["number","number","number","number","number","number","number","number","number"])}function ZP(e,t){let{backend:n,inputs:a}=e,{data:r,indices:s,segmentIds:i}=a,o=s.shape[0],u=n.readSync(i.dataId,o-1,o)[0],d=o>0?u+1:0;if(d<0)throw new Error(O.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let c=r.shape.slice();c[0]=d;let p=n.dataIdMap.get(r.dataId).id,m=n.dataIdMap.get(s.dataId).id,g=n.dataIdMap.get(i.dataId).id,b=n.makeOutput(c,r.dtype),v=n.dataIdMap.get(b.dataId).id,x=n.makeOutput([4],"int32"),w=n.dataIdMap.get(x.dataId).id;YP(p,Rt[r.dtype],r.shape[0],m,g,v,w,t,0);let k=n.readSync(x.dataId),N;switch(k[0]){case 0:{N=O.getSparseSegmentReductionNegativeSegmentIdsErrorMessage();break}case 1:{N=O.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage();break}case 2:N=O.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(k[1],k[2]);break;case 3:N=O.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(k[1],k[2],k[3]);break;default:N=""}if(n.disposeData(x.dataId),N)throw n.disposeData(b.dataId),new Error(N);return b}function GNe(e){return ZP(e,!0)}var qNe={kernelName:Lg,backendName:"wasm",setupFunc:JP,kernelFunc:GNe};function KNe(e){return ZP(e,!1)}var XNe={kernelName:Bg,backendName:"wasm",setupFunc:JP,kernelFunc:KNe},QP;function YNe(e){QP=e.wasm.cwrap(Yp,null,["number","number","number","number","number","number","number","number","array","number","number"])}function JNe(e){let{backend:t,inputs:n,attrs:a}=e,{sparseIndices:r,sparseValues:s,defaultValue:i}=n,{outputShape:o}=a,u=t.makeOutput(o,i.dtype);if(E.sizeFromShape(o)===0)return u;let{sliceRank:d,numUpdates:c,sliceSize:p,strides:m,outputSize:g}=O.calculateShapes(s,r,o),b=t.dataIdMap.get(r.dataId).id,v=t.dataIdMap.get(s.dataId).id,x=t.dataIdMap.get(i.dataId).id,w=new Uint8Array(new Int32Array(m).buffer),k=t.dataIdMap.get(u.dataId).id;return QP(b,v,s.shape.length,x,Rt[i.dtype],d,c,p,w,g,k),u}var ZNe={kernelName:Yp,backendName:"wasm",setupFunc:YNe,kernelFunc:JNe};function QNe(e){let{inputs:t,attrs:n,backend:a}=e,{x:r}=t,{numOrSizeSplits:s,axis:i}=n,o=E.parseAxisParam(i,r.shape)[0],u=O.prepareSplitSize(r,s,o),d=new Array(r.shape.length).fill(0),c=r.shape.slice();return u.map(p=>{let m=[...c];m[o]=p;let g=Wu({inputs:{x:r},attrs:{begin:d,size:m},backend:a});return d[o]+=p,g})}var eIe={kernelName:Kp,backendName:"wasm",kernelFunc:QNe},tIe=Tt(ad),nIe=Tt(Pg),aIe=Vn(id),eU;function rIe(e){eU=e.wasm.cwrap(wl,null,["number","number","number","number"])}function sIe(e){let{backend:t,inputs:n,attrs:a}=e,{alpha:r}=a,{x:s}=n,i=t.dataIdMap.get(s.dataId).id,o=t.makeOutput(s.shape,s.dtype),u=t.dataIdMap.get(o.dataId).id;return eU(i,r,Rt[s.dtype],u),o}var iIe={kernelName:wl,backendName:"wasm",setupFunc:rIe,kernelFunc:sIe},tU;function oIe(e){tU=e.wasm.cwrap(Jp,null,["number","array","number","array","array","array","array","array","number","number"])}function lIe(e){let{backend:t,inputs:n,attrs:a}=e,{x:r}=n,{begin:s,end:i,strides:o,beginMask:u,endMask:d,ellipsisMask:c,newAxisMask:p,shrinkAxisMask:m}=a,{finalShapeSparse:g,finalShape:b,isIdentity:v,sliceDim0:x,isSimpleSlice:w,begin:k,end:N,strides:I}=ea.sliceInfo(r.shape,s,i,o,u,d,c,p,m),T;if(v)T=ur({inputs:{x:r},backend:t,attrs:{shape:b}});else if(x||w){E.assert(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);let $=ea.computeOutShape(k,N,I),D=Wu({inputs:{x:r},backend:t,attrs:{begin:k,size:$}});T=ur({inputs:{x:D},backend:t,attrs:{shape:b}}),t.disposeData(D.dataId)}else{let $=t.makeOutput(g,"float32"),D=t.dataIdMap.get(r.dataId).id,M=new Uint8Array(new Int32Array(E.computeStrides(r.shape)).buffer),B=new Uint8Array(new Int32Array(k).buffer),V=new Uint8Array(new Int32Array(N).buffer),W=new Uint8Array(new Int32Array(I).buffer),R=new Uint8Array(new Int32Array(g).buffer),H=new Uint8Array(new Int32Array(E.computeStrides(g)).buffer),Z=t.dataIdMap.get($.dataId).id;tU(D,M,r.shape.length,B,V,W,R,H,g.length,Z),T=ur({inputs:{x:$},backend:t,attrs:{shape:b}}),t.disposeData($.dataId)}return T}var uIe={kernelName:Jp,backendName:"wasm",setupFunc:oIe,kernelFunc:lIe};function cIe(e){let{backend:t,inputs:n,attrs:a}=e,{data:r,dataSplits:s}=n,{separator:i,nGramWidths:o,leftPad:u,rightPad:d,padWidth:c,preserveShortSequences:p}=a,m=t.readSync(r.dataId),g=t.readSync(s.dataId),[b,v]=bI(m,g,i,o,u,d,c,p),x=t.makeOutput([b.length],"string"),w=t.dataIdMap.get(x.dataId);w.stringBytes=b;let k=t.makeOutput(s.shape,"int32");return t.typedArrayFromHeap(k).set(v),[x,k]}var dIe={kernelName:jg,backendName:"wasm",kernelFunc:cIe};function hIe(e){let{backend:t,inputs:n,attrs:a}=e,{input:r,delimiter:s}=n,{skipEmpty:i}=a,o=t.readSync(r.dataId),u=t.readSync(s.dataId),[d,c,p]=vI(o,u[0],i),m=c.length,g=t.makeOutput([m,2],"int32");t.typedArrayFromHeap(g).set(d);let b=t.makeOutput([m],"string"),v=t.dataIdMap.get(b.dataId);v.stringBytes=c;let x=t.makeOutput([2],"int32");return t.typedArrayFromHeap(x).set(p),[g,b,x]}var pIe={kernelName:Wg,backendName:"wasm",kernelFunc:hIe};function fIe(e){let{backend:t,inputs:n,attrs:a}=e,{input:r}=n,{numBuckets:s}=a,i=t.readSync(r.dataId),o=xI(i,s),u=t.makeOutput(r.shape,"int32");return t.typedArrayFromHeap(u).set(o),u}var mIe={kernelName:Vg,backendName:"wasm",kernelFunc:fIe},gIe=Vn(od),nU;function yIe(e){nU=e.wasm.cwrap(rd,null,["number","number","number","number"])}function bIe(e){let{backend:t,inputs:n,attrs:a}=e,{axis:r,keepDims:s}=a,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,u=o,d=i,{transposed:c,axes:p,originalAxes:m,inputWasTransposed:g}=Cl(i,r,t),b=p;if(g){let N=t.dataIdMap.get(c.dataId).id;N!==o&&(d=c,u=N,b=O.getInnerMostAxes(b.length,d.shape.length))}O.assertAxesAreInnerMostDims("sum",b,d.shape.length);let[v,x]=O.computeOutAndReduceShapes(d.shape,b),w=E.sizeFromShape(x),k=t.makeOutput(v,d.dtype);if(E.sizeFromShape(d.shape)!==0){let N=t.dataIdMap.get(k.dataId).id;nU(u,w,Rt[k.dtype],N)}if(g&&t.disposeData(c.dataId),s){let N=O.expandShapeToKeepDim(k.shape,m);k.shape=N}return k}var vIe={kernelName:rd,backendName:"wasm",setupFunc:yIe,kernelFunc:bIe},xIe=Tt(ld),wIe=Tt(ud),aU;function SIe(e){aU=e.wasm.cwrap(Wp,null,["number","number","number","number","number","number","array","number","number","number"])}function kIe(e){let{backend:t,inputs:n,attrs:a}=e,{tensor:r,indices:s,updates:i}=n,o=t.makeOutput(r.shape,r.dtype);if(E.sizeFromShape(r.shape)===0)return o;let{sliceRank:u,numUpdates:d,sliceSize:c,strides:p,outputSize:m}=q0.calculateShapes(i,s,r.shape),g=t.dataIdMap.get(s.dataId).id,b=t.dataIdMap.get(i.dataId).id,v=t.dataIdMap.get(r.dataId).id,x=new Uint8Array(new Int32Array(p).buffer),w=t.dataIdMap.get(o.dataId).id;return aU(g,b,Rt[i.dtype],u,d,c,x,m,w,v),o}var _Ie={kernelName:Wp,backendName:"wasm",setupFunc:SIe,kernelFunc:kIe},rU;function NIe(e){rU=e.wasm.cwrap(xl,null,["number","array","number","array","number","number"])}function IIe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,s=n.dataIdMap.get(r.dataId).id,{reps:i}=a,o=new Array(r.shape.length);for(let m=0;m<o.length;m++)o[m]=r.shape[m]*i[m];let u=new Uint8Array(new Int32Array(r.shape).buffer),d=new Uint8Array(new Int32Array(o).buffer),c=n.makeOutput(o,r.dtype),p=n.dataIdMap.get(c.dataId).id;return rU(s,u,r.shape.length,d,o.length,Rt[c.dtype],p),c}var TIe={kernelName:xl,backendName:"wasm",setupFunc:NIe,kernelFunc:IIe},sU;function EIe(e){sU=e.wasm.cwrap(Zp,null,["number","array","number","number","number","bool","number","number"])}var CIe=({inputs:e,backend:t,attrs:n})=>{let{x:a}=e,{k:r,sorted:s}=n,i=t.dataIdMap.get(a.dataId).id,o=new Uint8Array(new Int32Array(a.shape).buffer),u=a.shape.slice();u[u.length-1]=r;let d=t.makeOutput(u,a.dtype),c=t.dataIdMap.get(d.dataId).id,p=t.makeOutput(u,"int32"),m=t.dataIdMap.get(p.dataId).id;return sU(i,o,a.shape.length,Rt[a.dtype],r,s,c,m),[d,p]},AIe={kernelName:Zp,backendName:"wasm",setupFunc:EIe,kernelFunc:CIe},iU;function $Ie(e){iU=e.wasm.cwrap(Qp,null,["number","number","bool","number","number","number","number","number","number","array","number","array","number","number","number","number","number"])}function RIe(e){let{backend:t,inputs:n,attrs:a}=e,{image:r,transforms:s}=n,{interpolation:i,fillMode:o,fillValue:u,outputShape:d}=a,[c,p,m,g]=r.shape,[b,v]=d??[p,m],x=[c,b,v,g],w=new Uint8Array(new Int32Array(E.computeStrides(r.shape)).buffer),k=new Uint8Array(new Int32Array(E.computeStrides(x)).buffer),N=t.makeOutput(x,r.dtype),I=t.dataIdMap.get(N.dataId).id,T=t.dataIdMap.get(r.dataId).id,$=t.dataIdMap.get(s.dataId).id,D=i==="nearest"?1:2,M;switch(o){case"constant":M=1;break;case"reflect":M=2;break;case"wrap":M=3;break;case"nearest":M=4;break;default:M=1;break}return iU(T,$,s.shape[0]>1,c,b,v,g,m,p,w,r.shape.length-1,k,x.length-1,D,M,u,I),N}var DIe={kernelName:Qp,backendName:"wasm",setupFunc:$Ie,kernelFunc:RIe};function OIe(e){let{inputs:t,attrs:n,backend:a}=e,{axis:r}=n,{x:s}=t,{outputValues:i,outputShape:o,indices:u}=SI(a.readSync(s.dataId),r,s.shape,s.dtype);return[a.makeOutput(o,s.dtype,void 0,i),a.makeOutput([u.length],"int32",void 0,u)]}var MIe={kernelName:Hg,backendName:"wasm",kernelFunc:OIe};function FIe(e){let{inputs:t,backend:n,attrs:a}=e,{value:r}=t,{axis:s}=a;s<0&&(s+=r.shape.length);let i=r.shape[s],o=r.shape.length,u=new Array(o-1),d=0;for(let g=0;g<o;g++)g!==s&&(u[d++]=r.shape[g]);let c=new Array(i),p=new Array(o).fill(0),m=r.shape.slice();m[s]=1;for(let g=0;g<c.length;g++)p[s]=g,c[g]=Wu({inputs:{x:r},attrs:{begin:p,size:m},backend:n});return c.map(({dataId:g,dtype:b})=>({dataId:g,dtype:b,shape:u}))}var zIe={kernelName:ef,backendName:"wasm",kernelFunc:FIe};function LIe(e){let{inputs:{x:t},backend:n}=e,a=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(a).fill(0),a}var BIe={kernelName:tf,backendName:"wasm",kernelFunc:LIe},PIe=[$1e,R1e,D1e,O1e,M1e,L1e,G1e,X1e,Y1e,J1e,Z1e,Q1e,eSe,tSe,nSe,sSe,fSe,lSe,dSe,bSe,_Se,TSe,ESe,ASe,$Se,RSe,MSe,FSe,BSe,jSe,HSe,KSe,JSe,ZSe,QSe,nke,ske,lke,dke,fke,yke,xke,kke,Ike,Cke,Ake,Dke,Mke,Fke,zke,Lke,Bke,Pke,Wke,Vke,Hke,Kke,Jke,e_e,a_e,i_e,l_e,c_e,B1e,d_e,h_e,p_e,g_e,b_e,x_e,k_e,N_e,__e,T_e,E_e,A_e,R_e,M_e,L_e,U_e,j_e,H_e,K_e,J_e,e2e,a2e,i2e,u2e,c2e,p2e,b2e,v2e,x2e,w2e,_2e,T2e,A2e,R2e,M2e,z2e,B2e,MP,j2e,H2e,K2e,Y2e,J2e,Z2e,Q2e,eNe,mSe,aNe,iNe,uNe,hNe,mNe,bNe,vNe,xNe,kNe,INe,CNe,ANe,DNe,ONe,MNe,FNe,SSe,m2e,zNe,BNe,jNe,HNe,qNe,XNe,ZNe,eIe,tIe,nIe,aIe,iIe,uIe,dIe,pIe,mIe,gIe,vIe,xIe,wIe,_Ie,TIe,AIe,DIe,W1e,MIe,zIe,BIe];for(let e of PIe)qg(e);var Ek=oe();Ek.registerFlag("WASM_HAS_SIMD_SUPPORT",async()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]))}catch{return!1}});Ek.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT",async()=>{if(Ek.get("IS_NODE"))return!1;try{return new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}});var ZR=yl(wG()),UIe=yl(SG()),QR=yl(kG()),eD=ZR.default||ZR,jIe=QR.default||QR,oU=class extends _g{constructor(e){super(),this.wasm=e,this.dataIdNextNumber=1,this.wasm.tfjs.initWithThreadsCount(lU),Ck=this.wasm.tfjs.getThreadsCount(),this.dataIdMap=new s0(this,ms())}write(e,t,n){let a={id:this.dataIdNextNumber++};return this.move(a,e,t,n,1),a}numDataIds(){return this.dataIdMap.numDataIds()}async time(e){let t=E.now();return e(),{kernelMs:E.now()-t}}move(e,t,n,a,r){let s=this.dataIdNextNumber++;if(a==="string"){let d=t;this.dataIdMap.set(e,{id:s,stringBytes:d,shape:n,dtype:a,memoryOffset:null,refCount:r});return}let i=E.sizeFromShape(n),o=i*E.bytesPerElement(a),u=this.wasm._malloc(o)>>>0;this.dataIdMap.set(e,{id:s,memoryOffset:u,shape:n,dtype:a,refCount:r}),this.wasm.tfjs.registerTensor(s,i,u),t!=null&&this.wasm.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,o),u)}async read(e){return this.readSync(e)}readSync(e,t,n){let{memoryOffset:a,dtype:r,shape:s,stringBytes:i}=this.dataIdMap.get(e);if(r==="string")return(t==null||t===0)&&(n==null||n>=i.length)?i:i.slice(t,n);t=t||0,n=n||E.sizeFromShape(s);let o=E.bytesPerElement(r),u=this.wasm.HEAPU8.slice(a+t*o,a+n*o);return HIe(u.buffer,r)}disposeData(e,t=!1){if(this.dataIdMap.has(e)){let n=this.dataIdMap.get(e);if(n.refCount--,!t&&n.refCount>0)return!1;this.wasm._free(n.memoryOffset),this.wasm.tfjs.disposeData(n.id),this.dataIdMap.delete(e)}return!0}refCount(e){return this.dataIdMap.has(e)?this.dataIdMap.get(e).refCount:0}incRef(e){let t=this.dataIdMap.get(e);t!=null&&t.refCount++}floatPrecision(){return 32}getMemoryOffset(e){return this.dataIdMap.get(e).memoryOffset}dispose(){this.wasm.tfjs.dispose(),"PThread"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(e,t,n,a){let r;if(n==null)r=this.write(a??null,e,t);else{let s=this.dataIdNextNumber++;r={id:s},this.dataIdMap.set(r,{id:s,memoryOffset:n,shape:e,dtype:t,refCount:1});let i=E.sizeFromShape(e);this.wasm.tfjs.registerTensor(s,i,n)}return{dataId:r,shape:e,dtype:t}}typedArrayFromHeap({shape:e,dtype:t,dataId:n}){let a=this.wasm.HEAPU8.buffer,{memoryOffset:r}=this.dataIdMap.get(n),s=E.sizeFromShape(e);switch(t){case"float32":return new Float32Array(a,r,s);case"int32":return new Int32Array(a,r,s);case"bool":return new Uint8Array(a,r,s);default:throw new Error(`Unknown dtype ${t}`)}}};function WIe(e){return(t,n)=>(E.fetch(e,{credentials:"same-origin"}).then(a=>{a.ok||t.env.a(`failed to load wasm binary file at '${e}'`),a.arrayBuffer().then(r=>{WebAssembly.instantiate(r,t).then(s=>{n(s.instance,s.module)})})}),{})}function tD(e,t,n){if(Xv!=null)return Xv;let a="tfjs-backend-wasm.wasm";return e&&t?a="tfjs-backend-wasm-threaded-simd.wasm":e&&(a="tfjs-backend-wasm-simd.wasm"),Wm!=null&&Wm[a]!=null?Wm[a]:n+a}async function VIe(){let[e,t]=await Promise.all([oe().getAsync("WASM_HAS_SIMD_SUPPORT"),oe().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise((n,a)=>{let r={};r.locateFile=(o,u)=>{if(o.endsWith(".worker.js")){let d=UIe.wasmWorkerContents.replace(/\n/g,"\\n"),c=new Blob([d],{type:"application/javascript"});return URL.createObjectURL(c)}return o.endsWith(".wasm")?tD(e,t,zm??u):u+o},WI&&(r.instantiateWasm=WIe(tD(e,t,zm??"")));let s=!1;r.onAbort=()=>{s||Vm||(Vm=!0,a({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"}))};let i;t&&e&&Xv==null?(r.mainScriptUrlOrBlob=new Blob(["var WasmBackendModuleThreadedSimd = "+eD.toString()],{type:"text/javascript"}),i=eD(r)):i=jIe(r),i.then(o=>{s=!0,Vm=!1;let u=null;o.tfjs={init:o.cwrap("init",null,[]),initWithThreadsCount:o.cwrap("init_with_threads_count",null,["number"]),getThreadsCount:o.cwrap("get_threads_count","number",[]),registerTensor:o.cwrap("register_tensor",null,["number","number","number"]),disposeData:o.cwrap("dispose_data",u,["number"]),dispose:o.cwrap("dispose",u,[])},n({wasm:o})}).catch(a)})}function HIe(e,t){switch(t){case"float32":return new Float32Array(e);case"int32":return new Int32Array(e);case"bool":return new Uint8Array(e);default:throw new Error(`Unknown dtype ${t}`)}}var GIe=["tfjs-backend-wasm.wasm","tfjs-backend-wasm-simd.wasm","tfjs-backend-wasm-threaded-simd.wasm"],Xv=null,zm=null,Wm={},Vm=!1,WI=!1;function qIe(e,t=!1){if(CO("setWasmPath has been deprecated in favor of setWasmPaths and will be removed in a future release."),Vm)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`");Xv=e,WI=t}function KIe(e,t=!1){if(Vm)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");if(typeof e=="string")zm=e;else{Wm=e;let n=GIe.filter(a=>Wm[a]==null);if(n.length>0)throw new Error(`There were no entries found for the following binaries: ${n.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`)}WI=t}var lU=-1,Ck=-1;function XIe(e){lU=e}function YIe(){if(Ck===-1)throw new Error("WASM backend not initialized.");return Ck}var JIe="4.22.0",ZIe=2;k0("wasm",async()=>{let{wasm:e}=await VIe();return new oU(e)},ZIe);var nD="4.22.0",QIe="4.22.0",eTe="4.22.0",tTe="4.22.0",nTe="4.22.0",aTe={tfjs:nD,"tfjs-core":nD,"tfjs-converter":QIe,"tfjs-backend-cpu":eTe,"tfjs-backend-webgl":tTe,"tfjs-backend-wasm":nTe},uU={};Jk(uU,{AnchorPosition:()=>NU,DrawBox:()=>EU,DrawBoxOptions:()=>TU,DrawFaceLandmarks:()=>WU,DrawFaceLandmarksOptions:()=>jU,DrawTextField:()=>XI,DrawTextFieldOptions:()=>KI,drawContour:()=>jo,drawDetections:()=>gTe,drawFaceExpressions:()=>CTe,drawFaceLandmarks:()=>$Te});function jo(e,t,n=!1){if(e.beginPath(),t.slice(1).forEach(({x:a,y:r},s)=>{let i=t[s];e.moveTo(i.x,i.y),e.lineTo(a,r)}),n){let a=t[t.length-1],r=t[0];if(!a||!r)return;e.moveTo(a.x,a.y),e.lineTo(r.x,r.y)}e.stroke()}var rTe={};Jk(rTe,{computeReshapedDimensions:()=>pU,getCenterPoint:()=>VI,isDimensions:()=>$k,isEven:()=>Ak,isFloat:()=>hU,isTensor:()=>_f,isTensor1D:()=>sTe,isTensor2D:()=>dU,isTensor3D:()=>Iy,isTensor4D:()=>qi,isValidNumber:()=>_u,isValidProbablitiy:()=>iTe,range:()=>Jh,round:()=>Rx});var ku=class cU{constructor(t,n){if(!_u(t)||!_u(n))throw new Error(`Dimensions.constructor - expected width and height to be valid numbers, instead have ${JSON.stringify({width:t,height:n})}`);this._width=t,this._height=n}get width(){return this._width}get height(){return this._height}reverse(){return new cU(1/this.width,1/this.height)}};function _f(e,t){return e instanceof dt&&e.shape.length===t}function sTe(e){return _f(e,1)}function dU(e){return _f(e,2)}function Iy(e){return _f(e,3)}function qi(e){return _f(e,4)}function hU(e){return e%1!==0}function Ak(e){return e%2===0}function Rx(e,t=2){let n=10**t;return Math.floor(e*n)/n}function $k(e){return e&&e.width&&e.height}function pU({width:e,height:t},n){let a=n/Math.max(t,e);return new ku(Math.round(e*a),Math.round(t*a))}function VI(e){return e.reduce((t,n)=>t.add(n),new Kt(0,0)).div(new Kt(e.length,e.length))}function Jh(e,t,n){return Array(e).fill(0).map((a,r)=>t+r*n)}function _u(e){return!!e&&e!==1/0&&e!==-1/0&&!Number.isNaN(e)||e===0}function iTe(e){return _u(e)&&e>=0&&e<=1}var Kt=class lu{constructor(t,n){this._x=t,this._y=n}get x(){return this._x}get y(){return this._y}add(t){return new lu(this.x+t.x,this.y+t.y)}sub(t){return new lu(this.x-t.x,this.y-t.y)}mul(t){return new lu(this.x*t.x,this.y*t.y)}div(t){return new lu(this.x/t.x,this.y/t.y)}abs(){return new lu(Math.abs(this.x),Math.abs(this.y))}magnitude(){return Math.sqrt(this.x**2+this.y**2)}floor(){return new lu(Math.floor(this.x),Math.floor(this.y))}},Vu=class $s{static isRect(t){return!!t&&[t.x,t.y,t.width,t.height].every(_u)}static assertIsValidBox(t,n,a=!1){if(!$s.isRect(t))throw new Error(`${n} - invalid box: ${JSON.stringify(t)}, expected object with properties x, y, width, height`);if(!a&&(t.width<0||t.height<0))throw new Error(`${n} - width (${t.width}) and height (${t.height}) must be positive numbers`)}constructor(t,n=!0){let a=t||{},r=[a.left,a.top,a.right,a.bottom].every(_u),s=[a.x,a.y,a.width,a.height].every(_u);if(!s&&!r)throw new Error(`Box.constructor - expected box to be IBoundingBox | IRect, instead have ${JSON.stringify(a)}`);let[i,o,u,d]=s?[a.x,a.y,a.width,a.height]:[a.left,a.top,a.right-a.left,a.bottom-a.top];$s.assertIsValidBox({x:i,y:o,width:u,height:d},"Box.constructor",n),this._x=i,this._y=o,this._width=u,this._height=d}get x(){return this._x}get y(){return this._y}get width(){return this._width}get height(){return this._height}get left(){return this.x}get top(){return this.y}get right(){return this.x+this.width}get bottom(){return this.y+this.height}get area(){return this.width*this.height}get topLeft(){return new Kt(this.left,this.top)}get topRight(){return new Kt(this.right,this.top)}get bottomLeft(){return new Kt(this.left,this.bottom)}get bottomRight(){return new Kt(this.right,this.bottom)}round(){let[t,n,a,r]=[this.x,this.y,this.width,this.height].map(s=>Math.round(s));return new $s({x:t,y:n,width:a,height:r})}floor(){let[t,n,a,r]=[this.x,this.y,this.width,this.height].map(s=>Math.floor(s));return new $s({x:t,y:n,width:a,height:r})}toSquare(){let{x:t,y:n,width:a,height:r}=this,s=Math.abs(a-r);return a<r&&(t-=s/2,a+=s),r<a&&(n-=s/2,r+=s),new $s({x:t,y:n,width:a,height:r})}rescale(t){let n=$k(t)?t.width:t,a=$k(t)?t.height:t;return new $s({x:this.x*n,y:this.y*a,width:this.width*n,height:this.height*a})}pad(t,n){let[a,r,s,i]=[this.x-t/2,this.y-n/2,this.width+t,this.height+n];return new $s({x:a,y:r,width:s,height:i})}clipAtImageBorders(t,n){let{x:a,y:r,right:s,bottom:i}=this,o=Math.max(a,0),u=Math.max(r,0),d=s-o,c=i-u,p=Math.min(d,t-o),m=Math.min(c,n-u);return new $s({x:o,y:u,width:p,height:m}).floor()}shift(t,n){let{width:a,height:r}=this,s=this.x+t,i=this.y+n;return new $s({x:s,y:i,width:a,height:r})}padAtBorders(t,n){let a=this.width+1,r=this.height+1,s=1,i=1,o=a,u=r,d=this.left,c=this.top,p=this.right,m=this.bottom;return p>n&&(o=-p+n+a,p=n),m>t&&(u=-m+t+r,m=t),d<1&&(u=2-d,d=1),c<1&&(u=2-c,c=1),{dy:i,edy:u,dx:s,edx:o,y:c,ey:m,x:d,ex:p,w:a,h:r}}calibrate(t){return new $s({left:this.left+t.left*this.width,top:this.top+t.top*this.height,right:this.right+t.right*this.width,bottom:this.bottom+t.bottom*this.height}).toSquare().round()}},fU=class extends Vu{constructor(e,t,n,a,r=!1){super({left:e,top:t,right:n,bottom:a},r)}},mU=class gU{constructor(t,n,a,r,s){this._imageDims=new ku(s.width,s.height),this._score=t,this._classScore=n,this._className=a,this._box=new Vu(r).rescale(this._imageDims)}get score(){return this._score}get classScore(){return this._classScore}get className(){return this._className}get box(){return this._box}get imageDims(){return this._imageDims}get imageWidth(){return this.imageDims.width}get imageHeight(){return this.imageDims.height}get relativeBox(){return new Vu(this._box).rescale(this.imageDims.reverse())}forSize(t,n){return new gU(this.score,this.classScore,this.className,this.relativeBox,{width:t,height:n})}},vs=class yU extends mU{constructor(t,n,a){super(t,t,"",n,a)}forSize(t,n){let{score:a,relativeBox:r,imageDims:s}=super.forSize(t,n);return new yU(a,r,s)}};function oTe(e,t,n=!0){let a=Math.max(0,Math.min(e.right,t.right)-Math.max(e.left,t.left)),r=Math.max(0,Math.min(e.bottom,t.bottom)-Math.max(e.top,t.top)),s=a*r;return n?s/(e.area+t.area-s):s/Math.min(e.area,t.area)}function lTe(e){let t=e.map(o=>o.x),n=e.map(o=>o.y),a=t.reduce((o,u)=>u<o?u:o,1/0),r=n.reduce((o,u)=>u<o?u:o,1/0),s=t.reduce((o,u)=>o<u?u:o,0),i=n.reduce((o,u)=>o<u?u:o,0);return new fU(a,r,s,i)}function uTe(e,t,n,a=!0){let r=t.map((i,o)=>({score:i,boxIndex:o})).sort((i,o)=>i.score-o.score).map(i=>i.boxIndex),s=[];for(;r.length>0;){let i=r.pop();s.push(i);let o=r,u=[];for(let d=0;d<o.length;d++){let c=o[d],p=e[i],m=e[c];u.push(oTe(p,m,a))}r=r.filter((d,c)=>u[c]<=n)}return s}function Ty(e,t){return ne(()=>{let[n,a,r]=t,s=Cr([...e.shape.slice(0,3),1],n,"float32"),i=Cr([...e.shape.slice(0,3),1],a,"float32"),o=Cr([...e.shape.slice(0,3),1],r,"float32"),u=Yt([s,i,o],3);return Fe(e,u)})}function cTe(e,t=!1){return ne(()=>{let[n,a]=e.shape.slice(1);if(n===a)return e;let r=Math.abs(n-a),s=Math.round(r*(t?.5:1)),i=n>a?2:1,o=p=>{let m=e.shape.slice();return m[i]=p,Cr(m,0,"float32")},u=o(s),d=r-u.shape[i],c=[t&&d?o(d):null,e,u].filter(p=>!!p).map(p=>Te(p,"float32"));return Yt(c,i)})}function cS(e){return 1/(1+Math.exp(-e))}var bU=class extends Vu{constructor(e,t,n,a,r=!1){super({x:e,y:t,width:n,height:a},r)}},dTe=.5,hTe=.43,pTe=.45,pg=class{constructor(e,t,n=new Kt(0,0)){let{width:a,height:r}=t;this._imgDims=new ku(a,r),this._shift=n,this._positions=e.map(s=>s.mul(new Kt(a,r)).add(n))}get shift(){return new Kt(this._shift.x,this._shift.y)}get imageWidth(){return this._imgDims.width}get imageHeight(){return this._imgDims.height}get positions(){return this._positions}get relativePositions(){return this._positions.map(e=>e.sub(this._shift).div(new Kt(this.imageWidth,this.imageHeight)))}forSize(e,t){return new this.constructor(this.relativePositions,{width:e,height:t})}shiftBy(e,t){return new this.constructor(this.relativePositions,this._imgDims,new Kt(e,t))}shiftByPoint(e){return this.shiftBy(e.x,e.y)}align(e,t={}){if(e){let r=e instanceof vs?e.box.floor():new Vu(e);return this.shiftBy(r.x,r.y).align(null,t)}let{useDlibAlignment:n,minBoxPadding:a}={useDlibAlignment:!1,minBoxPadding:.2,...t};return n?this.alignDlib():this.alignMinBbox(a)}alignDlib(){let e=this.getRefPointsForAlignment(),[t,n,a]=e,r=c=>a.sub(c).magnitude(),s=(r(t)+r(n))/2,i=Math.floor(s/pTe),o=VI(e),u=Math.floor(Math.max(0,o.x-dTe*i)),d=Math.floor(Math.max(0,o.y-hTe*i));return new bU(u,d,Math.min(i,this.imageWidth+u),Math.min(i,this.imageHeight+d))}alignMinBbox(e){let t=lTe(this.positions);return t.pad(t.width*e,t.height*e)}getRefPointsForAlignment(){throw new Error("getRefPointsForAlignment not implemented by base class")}},vU=class extends pg{getJawOutline(){return this.positions.slice(0,17)}getLeftEyeBrow(){return this.positions.slice(17,22)}getRightEyeBrow(){return this.positions.slice(22,27)}getNose(){return this.positions.slice(27,36)}getLeftEye(){return this.positions.slice(36,42)}getRightEye(){return this.positions.slice(42,48)}getMouth(){return this.positions.slice(48,68)}getRefPointsForAlignment(){return[this.getLeftEye(),this.getRightEye(),this.getMouth()].map(VI)}},aD=class{constructor(e,t){this._label=e,this._distance=t}get label(){return this._label}get distance(){return this._distance}toString(e=!0){return`${this.label}${e?` (${Rx(this.distance)})`:""}`}},Lm=class xU{constructor(t,n){if(typeof t!="string")throw new Error("LabeledFaceDescriptors - constructor expected label to be a string");if(!Array.isArray(n)||n.some(a=>!(a instanceof Float32Array)))throw new Error("LabeledFaceDescriptors - constructor expected descriptors to be an array of Float32Array");this._label=t,this._descriptors=n}get label(){return this._label}get descriptors(){return this._descriptors}toJSON(){return{label:this.label,descriptors:this.descriptors.map(t=>Array.from(t))}}static fromJSON(t){let n=t.descriptors.map(a=>new Float32Array(a));return new xU(t.label,n)}};function fg(e){return e.detection instanceof vs}function Yv(e,t){return{...e,detection:t}}function wU(){let e=window.fetch;if(!e)throw new Error("fetch - missing fetch implementation for browser environment");return{Canvas:HTMLCanvasElement,CanvasRenderingContext2D,Image:HTMLImageElement,ImageData,Video:HTMLVideoElement,createCanvasElement:()=>document.createElement("canvas"),createImageElement:()=>document.createElement("img"),createVideoElement:()=>document.createElement("video"),fetch:e,readFile:()=>{throw new Error("readFile - filesystem not available for browser environment")}}}function HI(){return typeof global=="object"&&typeof process<"u"&&process.versions!=null&&process.versions.node!=null}function SU(e){let t="";if(!e&&HI())try{e=eG("fs")}catch(n){t=n.toString()}return{readFile:e?n=>new Promise((a,r)=>{e.readFile(n,(s,i)=>s?r(s):a(i))}):()=>{throw new Error(`readFile - failed to require fs in nodejs environment with error: ${t}`)}}}function kU(){let e=global.Canvas||global.HTMLCanvasElement,t=global.Image||global.HTMLImageElement,n=global.Video||global.HTMLVideoElement,a=()=>{if(e)return new e;throw new Error("createCanvasElement - missing Canvas implementation for nodejs environment")},r=()=>{if(t)return new t;throw new Error("createImageElement - missing Image implementation for nodejs environment")},s=()=>{if(n)return new n;throw new Error("createVideoElement - missing Video implementation for nodejs environment")},i=global.fetch,o=SU();return{Canvas:e||class{},CanvasRenderingContext2D:global.CanvasRenderingContext2D||class{},Image:t||class{},ImageData:global.ImageData||class{},Video:global.HTMLVideoElement||class{},createCanvasElement:a,createImageElement:r,createVideoElement:s,fetch:i,...o}}function _U(){return typeof window=="object"&&typeof document<"u"&&typeof HTMLImageElement<"u"&&typeof HTMLCanvasElement<"u"&&typeof HTMLVideoElement<"u"&&typeof ImageData<"u"&&typeof CanvasRenderingContext2D<"u"}var oa;function fTe(){if(!oa)throw new Error("getEnv - environment is not defined, check isNodejs() and isBrowser()");return oa}function Rk(e){oa=e}function GI(){return _U()?Rk(wU()):HI()?Rk(kU()):null}function mTe(e){if(oa||GI(),!oa)throw new Error("monkeyPatch - environment is not defined, check isNodejs() and isBrowser()");let{Canvas:t=oa.Canvas,Image:n=oa.Image}=e;oa.Canvas=t,oa.Image=n,oa.createCanvasElement=e.createCanvasElement||(()=>new t),oa.createImageElement=e.createImageElement||(()=>new n),oa.ImageData=e.ImageData||oa.ImageData,oa.Video=e.Video||oa.Video,oa.fetch=e.fetch||oa.fetch,oa.readFile=e.readFile||oa.readFile}var pr={getEnv:fTe,setEnv:Rk,initialize:GI,createBrowserEnv:wU,createFileSystem:SU,createNodejsEnv:kU,monkeyPatch:mTe,isBrowser:_U,isNodejs:HI};GI();function qI(e){return!pr.isNodejs()&&typeof e=="string"?document.getElementById(e):e}function ml(e){let{Canvas:t,CanvasRenderingContext2D:n}=pr.getEnv();if(e instanceof n)return e;let a=qI(e);if(!(a instanceof t))throw new Error("resolveContext2d - expected canvas to be of instance of Canvas");let r=a.getContext("2d",{willReadFrequently:!0});if(!r)throw new Error("resolveContext2d - canvas 2d context is null");return r}var NU=(e=>(e.TOP_LEFT="TOP_LEFT",e.TOP_RIGHT="TOP_RIGHT",e.BOTTOM_LEFT="BOTTOM_LEFT",e.BOTTOM_RIGHT="BOTTOM_RIGHT",e))(NU||{}),KI=class{constructor(e={}){let{anchorPosition:t,backgroundColor:n,fontColor:a,fontSize:r,fontStyle:s,padding:i}=e;this.anchorPosition=t||"TOP_LEFT",this.backgroundColor=n||"rgba(0, 0, 0, 0.5)",this.fontColor=a||"rgba(255, 255, 255, 1)",this.fontSize=r||14,this.fontStyle=s||"Georgia",this.padding=i||4}},XI=class IU{constructor(t,n,a={}){this.text=typeof t=="string"?[t]:t instanceof IU?t.text:t,this.anchor=n,this.options=new KI(a)}measureWidth(t){let{padding:n}=this.options;return this.text.map(a=>t.measureText(a).width).reduce((a,r)=>a<r?r:a,0)+2*n}measureHeight(){let{fontSize:t,padding:n}=this.options;return this.text.length*t+2*n}getUpperLeft(t,n){let{anchorPosition:a}=this.options,r=a==="BOTTOM_RIGHT"||a==="TOP_RIGHT",s=a==="BOTTOM_LEFT"||a==="BOTTOM_RIGHT",i=this.measureWidth(t),o=this.measureHeight(),u=r?this.anchor.x-i:this.anchor.x,d=s?this.anchor.y-o:this.anchor.y;if(n){let{width:c,height:p}=n,m=Math.max(Math.min(u,c-i),0),g=Math.max(Math.min(d,p-o),0);return{x:m,y:g}}return{x:u,y:d}}draw(t){let n=qI(t),a=ml(n),{backgroundColor:r,fontColor:s,fontSize:i,fontStyle:o,padding:u}=this.options;a.font=`${i}px ${o}`;let d=this.measureWidth(a),c=this.measureHeight();a.fillStyle=r;let p=this.getUpperLeft(a,n);a.fillRect(p.x,p.y,d,c),a.fillStyle=s,this.text.forEach((m,g)=>{let b=u+p.x,v=u+p.y+(g+1)*i;a.fillText(m,b,v)})}},TU=class{constructor(e={}){let{boxColor:t,lineWidth:n,label:a,drawLabelOptions:r}=e;this.boxColor=t||"rgba(0, 0, 255, 1)",this.lineWidth=n||2,this.label=a;let s={anchorPosition:"BOTTOM_LEFT",backgroundColor:this.boxColor};this.drawLabelOptions=new KI({...s,...r})}},EU=class{constructor(e,t={}){this.box=new Vu(e),this.options=new TU(t)}draw(e){let t=ml(e),{boxColor:n,lineWidth:a}=this.options,{x:r,y:s,width:i,height:o}=this.box;t.strokeStyle=n,t.lineWidth=a,t.strokeRect(r,s,i,o);let{label:u}=this.options;u&&new XI([u],{x:r-a/2,y:s},this.options.drawLabelOptions).draw(e)}};function gTe(e,t){(Array.isArray(t)?t:[t]).forEach(n=>{let a=n instanceof vs?n.score:fg(n)?n.detection.score:void 0,r=n instanceof vs?n.box:fg(n)?n.detection.box:new Vu(n),s=a?`${Rx(a)}`:void 0;new EU(r,{label:s}).draw(e)})}function CU(e){let{Image:t,Video:n}=pr.getEnv();return e instanceof t&&e.complete||e instanceof n&&e.readyState>=3}function yTe(e){return new Promise((t,n)=>{if(e instanceof pr.getEnv().Canvas||CU(e)){t(null);return}function a(s){s.currentTarget&&(s.currentTarget.removeEventListener("load",r),s.currentTarget.removeEventListener("error",a),n(s))}function r(s){s.currentTarget&&(s.currentTarget.removeEventListener("load",r),s.currentTarget.removeEventListener("error",a),t(s))}e.addEventListener("load",r),e.addEventListener("error",a)})}function YI(e){let{Image:t,Video:n}=pr.getEnv();return e instanceof t?new ku(e.naturalWidth,e.naturalHeight):e instanceof n?new ku(e.videoWidth,e.videoHeight):new ku(e.width,e.height)}function Jv({width:e,height:t}){let{createCanvasElement:n}=pr.getEnv(),a=n();return a.width=e,a.height=t,a}function AU(e,t){let{ImageData:n}=pr.getEnv();if(!(e instanceof n)&&!CU(e))throw new Error("createCanvasFromMedia - media has not finished loading yet");let{width:a,height:r}=YI(e),s=Jv({width:a,height:r});return e instanceof n?ml(s).putImageData(e,0,0):ml(s).drawImage(e,0,0,a,r),s}async function bTe(e,t){let n=t||pr.getEnv().createCanvasElement(),[a,r,s]=e.shape.slice(qi(e)?1:0),i=ne(()=>e.as3D(a,r,s).toInt());return await hy.toPixels(i,n),i.dispose(),n}function rD(e){let{Image:t,Canvas:n,Video:a}=pr.getEnv();return e instanceof t||e instanceof n||e instanceof a}function vTe(e,t,n=!1){let{Image:a,Canvas:r}=pr.getEnv();if(!(e instanceof a||e instanceof r))throw new Error("imageToSquare - expected arg0 to be HTMLImageElement | HTMLCanvasElement");if(t<=0)return Jv({width:1,height:1});let s=YI(e),i=t/Math.max(s.height,s.width),o=i*s.width,u=i*s.height,d=Jv({width:t,height:t}),c=e instanceof r?e:AU(e),p=Math.abs(o-u)/2,m=n&&o<u?p:0,g=n&&u<o?p:0;return c.width>0&&c.height>0&&ml(d).drawImage(c,m,g,o,u),d}var Zv=class{constructor(e,t=!1){if(this._imageTensors=[],this._canvases=[],this._treatAsBatchInput=!1,this._inputDimensions=[],this._inputSize=0,!Array.isArray(e))throw new Error(`NetInput.constructor - expected inputs to be an Array of TResolvedNetInput or to be instanceof tf.Tensor4D, instead have ${e}`);this._treatAsBatchInput=t,this._batchSize=e.length,e.forEach((n,a)=>{if(Iy(n)){this._imageTensors[a]=n,this._inputDimensions[a]=n.shape;return}if(qi(n)){let s=n.shape[0];if(s!==1)throw new Error(`NetInput - tf.Tensor4D with batchSize ${s} passed, but not supported in input array`);this._imageTensors[a]=n,this._inputDimensions[a]=n.shape.slice(1);return}let r=n instanceof pr.getEnv().Canvas?n:AU(n);this._canvases[a]=r,this._inputDimensions[a]=[r.height,r.width,3]})}get imageTensors(){return this._imageTensors}get canvases(){return this._canvases}get isBatchInput(){return this.batchSize>1||this._treatAsBatchInput}get batchSize(){return this._batchSize}get inputDimensions(){return this._inputDimensions}get inputSize(){return this._inputSize}get reshapedInputDimensions(){return Jh(this.batchSize,0,1).map((e,t)=>this.getReshapedInputDimensions(t))}getInput(e){return this.canvases[e]||this.imageTensors[e]}getInputDimensions(e){return this._inputDimensions[e]}getInputHeight(e){return this._inputDimensions[e][0]}getInputWidth(e){return this._inputDimensions[e][1]}getReshapedInputDimensions(e){if(typeof this.inputSize!="number")throw new Error("getReshapedInputDimensions - inputSize not set, toBatchTensor has not been called yet");let t=this.getInputWidth(e),n=this.getInputHeight(e);return pU({width:t,height:n},this.inputSize)}toBatchTensor(e,t=!0){return this._inputSize=e,ne(()=>{let n=Jh(this.batchSize,0,1).map(a=>{let r=this.getInput(a);if(r instanceof dt){let s=qi(r)?r:da(r);return s=cTe(s,t),(s.shape[1]!==e||s.shape[2]!==e)&&(s=Gr.resizeBilinear(s,[e,e],!1,!1)),s.as3D(e,e,3)}if(r instanceof pr.getEnv().Canvas)return hy.fromPixels(vTe(r,e,t));throw new Error(`toBatchTensor - at batchIdx ${a}, expected input to be instanceof tf.Tensor or instanceof HTMLCanvasElement, instead have ${r}`)});return Un(n.map(a=>Te(a,"float32"))).as4D(this.batchSize,e,e,3)})}};async function Ya(e){if(e instanceof Zv)return e;let t=Array.isArray(e)?e:[e];if(!t.length)throw new Error("toNetInput - empty array passed as input");let n=r=>Array.isArray(e)?` at input index ${r}:`:"",a=t.map(qI);return a.forEach((r,s)=>{if(!rD(r)&&!Iy(r)&&!qi(r))throw typeof t[s]=="string"?new Error(`toNetInput -${n(s)} string passed, but could not resolve HTMLElement for element id ${t[s]}`):new Error(`toNetInput -${n(s)} expected media to be of type HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | tf.Tensor3D, or to be an element id`);if(qi(r)){let i=r.shape[0];if(i!==1)throw new Error(`toNetInput -${n(s)} tf.Tensor4D with batchSize ${i} passed, but not supported in input array`)}}),await Promise.all(a.map(r=>rD(r)&&yTe(r))),new Zv(a,Array.isArray(e))}async function JI(e,t){let{Canvas:n}=pr.getEnv(),a=e;if(!(e instanceof n)){let s=await Ya(e);if(s.batchSize>1)throw new Error("extractFaces - batchSize > 1 not supported");let i=s.getInput(0);a=i instanceof n?i:await bTe(i)}let r=ml(a);return t.map(s=>s instanceof vs?s.forSize(a.width,a.height).box.floor():s).map(s=>s.clipAtImageBorders(a.width,a.height)).map(({x:s,y:i,width:o,height:u})=>{let d=Jv({width:o,height:u});return o>0&&u>0&&ml(d).putImageData(r.getImageData(s,i,o,u),0,0),d})}async function ZI(e,t){if(!Iy(e)&&!qi(e))throw new Error("extractFaceTensors - expected image tensor to be 3D or 4D");if(qi(e)&&e.shape[0]>1)throw new Error("extractFaceTensors - batchSize > 1 not supported");return ne(()=>{let[n,a,r]=e.shape.slice(qi(e)?1:0);return t.map(s=>s instanceof vs?s.forSize(a,n).box:s).map(s=>s.clipAtImageBorders(a,n)).filter(s=>s.width>0&&s.height>0).map(({x:s,y:i,width:o,height:u})=>cf(e.as3D(n,a,r),[i,s,0],[u,o,r]))})}async function xTe(e,t){let{fetch:n}=pr.getEnv(),a=await n(e,t);if(!(a.status<400))throw new Error(`failed to fetch: (${a.status}) ${a.statusText}, from url: ${a.url}`);return a}async function wTe(e){return(await xTe(e)).json()}function $U(e,t){let n=`${t}-weights_manifest.json`;if(!e)return{modelBaseUri:"",manifestUri:n};if(e==="/")return{modelBaseUri:"/",manifestUri:`/${n}`};let a=e.startsWith("http://")?"http://":e.startsWith("https://")?"https://":"";e=e.replace(a,"");let r=e.split("/").filter(o=>o),s=e.endsWith(".json")?r[r.length-1]:n,i=a+(e.endsWith(".json")?r.slice(0,r.length-1):r).join("/");return i=e.startsWith("/")?`/${i}`:i,{modelBaseUri:i,manifestUri:i==="/"?`/${s}`:`${i}/${s}`}}async function STe(e,t){let{manifestUri:n,modelBaseUri:a}=$U(e,t),r=await wTe(n);return Na.loadWeights(r,a)}function RU(e,t,n=!1){let{width:a,height:r}=n?YI(t):t;return e.width=a,e.height=r,{width:a,height:r}}var $l=class{constructor(e){this._params=void 0,this._paramMappings=[],this._name=e}get params(){return this._params}get paramMappings(){return this._paramMappings}get isLoaded(){return!!this.params}getParamFromPath(e){let{obj:t,objProp:n}=this.traversePropertyPath(e);return t[n]}reassignParamFromPath(e,t){let{obj:n,objProp:a}=this.traversePropertyPath(e);n[a].dispose(),n[a]=t}getParamList(){return this._paramMappings.map(({paramPath:e})=>({path:e,tensor:this.getParamFromPath(e)}))}getTrainableParams(){return this.getParamList().filter(e=>e.tensor instanceof Eu)}getFrozenParams(){return this.getParamList().filter(e=>!(e.tensor instanceof Eu))}variable(){this.getFrozenParams().forEach(({path:e,tensor:t})=>{this.reassignParamFromPath(e,t.variable())})}freeze(){this.getTrainableParams().forEach(({path:e,tensor:t})=>{let n=qa(t.dataSync());t.dispose(),this.reassignParamFromPath(e,n)})}dispose(e=!0){this.getParamList().forEach(t=>{if(e&&t.tensor.isDisposed)throw new Error(`param tensor has already been disposed for path ${t.path}`);t.tensor.dispose()}),this._params=void 0}serializeParams(){return new Float32Array(this.getParamList().map(({tensor:e})=>Array.from(e.dataSync())).reduce((e,t)=>e.concat(t)))}async load(e){if(e instanceof Float32Array){this.extractWeights(e);return}await this.loadFromUri(e)}async loadFromUri(e){if(e&&typeof e!="string")throw new Error(`${this._name}.loadFromUri - expected model uri`);let t=await STe(e,this.getDefaultModelName());this.loadFromWeightMap(t)}async loadFromDisk(e){if(e&&typeof e!="string")throw new Error(`${this._name}.loadFromDisk - expected model file path`);let{readFile:t}=pr.getEnv(),{manifestUri:n,modelBaseUri:a}=$U(e,this.getDefaultModelName()),r=u=>Promise.all(u.map(d=>t(d).then(c=>typeof c=="string"?Buffer.from(c):c.buffer))),s=Na.weightsLoaderFactory(r),i=JSON.parse((await t(n)).toString()),o=await s(i,a);this.loadFromWeightMap(o)}loadFromWeightMap(e){let{paramMappings:t,params:n}=this.extractParamsFromWeightMap(e);this._paramMappings=t,this._params=n}extractWeights(e){let{paramMappings:t,params:n}=this.extractParams(e);this._paramMappings=t,this._params=n}traversePropertyPath(e){if(!this.params)throw new Error("traversePropertyPath - model has no loaded params");let t=e.split("/").reduce((r,s)=>{if(!r.nextObj.hasOwnProperty(s))throw new Error(`traversePropertyPath - object does not have property ${s}, for path ${e}`);return{obj:r.nextObj,objProp:s,nextObj:r.nextObj[s]}},{nextObj:this.params}),{obj:n,objProp:a}=t;if(!n||!a||!(n[a]instanceof dt))throw new Error(`traversePropertyPath - parameter is not a tensor, for path ${e}`);return{obj:n,objProp:a}}};function Xr(e,t,n){return ne(()=>{let a=uf(e,t.depthwise_filter,t.pointwise_filter,n,"same");return a=ye(a,t.bias),a})}function dS(e,t,n=!1){return ne(()=>{let a=jt(n?ye(Ka(e,t.conv0.filters,[2,2],"same"),t.conv0.bias):Xr(e,t.conv0,[2,2])),r=Xr(a,t.conv1,[1,1]),s=jt(ye(a,r)),i=Xr(s,t.conv2,[1,1]);return jt(ye(a,ye(r,i)))})}function nv(e,t,n=!1,a=!0){return ne(()=>{let r=jt(n?ye(Ka(e,t.conv0.filters,a?[2,2]:[1,1],"same"),t.conv0.bias):Xr(e,t.conv0,a?[2,2]:[1,1])),s=Xr(r,t.conv1,[1,1]),i=jt(ye(r,s)),o=Xr(i,t.conv2,[1,1]),u=jt(ye(r,ye(s,o))),d=Xr(u,t.conv3,[1,1]);return jt(ye(r,ye(s,ye(o,d))))})}function Hm(e,t,n="same",a=!1){return ne(()=>{let r=ye(Ka(e,t.filters,[1,1],n),t.bias);return a?jt(r):r})}function Rl(e,t){Object.keys(e).forEach(n=>{t.some(a=>a.originalPath===n)||e[n].dispose()})}function QI(e,t){return(n,a,r,s)=>{let i=ll(e(n*a*r*r),[r,r,n,a]),o=Lt(e(a));return t.push({paramPath:`${s}/filters`},{paramPath:`${s}/bias`}),{filters:i,bias:o}}}function DU(e,t){return(n,a,r)=>{let s=ui(e(n*a),[n,a]),i=Lt(e(a));return t.push({paramPath:`${r}/weights`},{paramPath:`${r}/bias`}),{weights:s,bias:i}}}var OU=class{constructor(e,t,n){this.depthwise_filter=e,this.pointwise_filter=t,this.bias=n}};function eT(e,t){return(n,a,r)=>{let s=ll(e(9*n),[3,3,n,1]),i=ll(e(n*a),[1,1,n,a]),o=Lt(e(a));return t.push({paramPath:`${r}/depthwise_filter`},{paramPath:`${r}/pointwise_filter`},{paramPath:`${r}/bias`}),new OU(s,i,o)}}function tT(e){return t=>{let n=e(`${t}/depthwise_filter`,4),a=e(`${t}/pointwise_filter`,4),r=e(`${t}/bias`,1);return new OU(n,a,r)}}function wd(e,t){return(n,a,r)=>{let s=e[n];if(!_f(s,a))throw new Error(`expected weightMap[${n}] to be a Tensor${a}D, instead have ${s}`);return t.push({originalPath:n,paramPath:r||n}),s}}function Dl(e){let t=e;function n(r){let s=t.slice(0,r);return t=t.slice(r),s}function a(){return t}return{extractWeights:n,getRemainingWeights:a}}function MU(e,t){let n=QI(e,t),a=eT(e,t);function r(i,o,u,d=!1){let c=d?n(i,o,3,`${u}/conv0`):a(i,o,`${u}/conv0`),p=a(o,o,`${u}/conv1`),m=a(o,o,`${u}/conv2`);return{conv0:c,conv1:p,conv2:m}}function s(i,o,u,d=!1){let{conv0:c,conv1:p,conv2:m}=r(i,o,u,d),g=a(o,o,`${u}/conv3`);return{conv0:c,conv1:p,conv2:m,conv3:g}}return{extractDenseBlock3Params:r,extractDenseBlock4Params:s}}function kTe(e){let t=[],{extractWeights:n,getRemainingWeights:a}=Dl(e),{extractDenseBlock4Params:r}=MU(n,t),s=r(3,32,"dense0",!0),i=r(32,64,"dense1"),o=r(64,128,"dense2"),u=r(128,256,"dense3");if(a().length!==0)throw new Error(`weights remaing after extract: ${a().length}`);return{paramMappings:t,params:{dense0:s,dense1:i,dense2:o,dense3:u}}}function FU(e){return t=>{let n=e(`${t}/filters`,4),a=e(`${t}/bias`,1);return{filters:n,bias:a}}}function zU(e,t){let n=wd(e,t),a=FU(n),r=tT(n);function s(o,u=!1){let d=u?a(`${o}/conv0`):r(`${o}/conv0`),c=r(`${o}/conv1`),p=r(`${o}/conv2`);return{conv0:d,conv1:c,conv2:p}}function i(o,u=!1){let d=u?a(`${o}/conv0`):r(`${o}/conv0`),c=r(`${o}/conv1`),p=r(`${o}/conv2`),m=r(`${o}/conv3`);return{conv0:d,conv1:c,conv2:p,conv3:m}}return{extractDenseBlock3Params:s,extractDenseBlock4Params:i}}function _Te(e){let t=[],{extractDenseBlock4Params:n}=zU(e,t),a={dense0:n("dense0",!0),dense1:n("dense1"),dense2:n("dense2"),dense3:n("dense3")};return Rl(e,t),{params:a,paramMappings:t}}var LU=class extends $l{constructor(){super("FaceFeatureExtractor")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("FaceFeatureExtractor - load model before inference");return ne(()=>{let n=Te(e.toBatchTensor(112,!0),"float32"),a=Ty(n,[122.782,117.001,104.298]).div(255),r=nv(a,t.dense0,!0);return r=nv(r,t.dense1),r=nv(r,t.dense2),r=nv(r,t.dense3),r=eo(r,[7,7],[2,2],"valid"),r})}async forward(e){return this.forwardInput(await Ya(e))}getDefaultModelName(){return"face_feature_extractor_model"}extractParamsFromWeightMap(e){return _Te(e)}extractParams(e){return kTe(e)}};function Dk(e,t){return ne(()=>ye(pt(e,t.weights),t.bias))}function NTe(e,t,n){let a=[],{extractWeights:r,getRemainingWeights:s}=Dl(e),i=DU(r,a)(t,n,"fc");if(s().length!==0)throw new Error(`weights remaing after extract: ${s().length}`);return{paramMappings:a,params:{fc:i}}}function ITe(e){let t=[],n=wd(e,t);function a(s){let i=n(`${s}/weights`,2),o=n(`${s}/bias`,1);return{weights:i,bias:o}}let r={fc:a("fc")};return Rl(e,t),{params:r,paramMappings:t}}function BU(e){let t={},n={};return Object.keys(e).forEach(a=>{let r=a.startsWith("fc")?n:t;r[a]=e[a]}),{featureExtractorMap:t,classifierMap:n}}var PU=class extends $l{constructor(e,t){super(e),this._faceFeatureExtractor=t}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(e){let{params:t}=this;if(!t)throw new Error(`${this._name} - load model before inference`);return ne(()=>{let n=e instanceof Zv?this.faceFeatureExtractor.forwardInput(e):e;return Dk(n.as2D(n.shape[0],-1),t.fc)})}dispose(e=!0){this.faceFeatureExtractor.dispose(e),super.dispose(e)}loadClassifierParams(e){let{params:t,paramMappings:n}=this.extractClassifierParams(e);this._params=t,this._paramMappings=n}extractClassifierParams(e){return NTe(e,this.getClassifierChannelsIn(),this.getClassifierChannelsOut())}extractParamsFromWeightMap(e){let{featureExtractorMap:t,classifierMap:n}=BU(e);return this.faceFeatureExtractor.loadFromWeightMap(t),ITe(n)}extractParams(e){let t=this.getClassifierChannelsIn(),n=this.getClassifierChannelsOut(),a=n*t+n,r=e.slice(0,e.length-a),s=e.slice(e.length-a);return this.faceFeatureExtractor.extractWeights(r),this.extractClassifierParams(s)}},sD=["neutral","happy","sad","angry","fearful","disgusted","surprised"],nT=class{constructor(e){if(this.neutral=0,this.happy=0,this.sad=0,this.angry=0,this.fearful=0,this.disgusted=0,this.surprised=0,e.length!==7)throw new Error(`FaceExpressions.constructor - expected probabilities.length to be 7, have: ${e.length}`);sD.forEach((t,n)=>{this[t]=e[n]})}asSortedArray(){return sD.map(e=>({expression:e,probability:this[e]})).sort((e,t)=>t.probability-e.probability)}},TTe=class extends PU{constructor(e=new LU){super("FaceExpressionNet",e)}forwardInput(e){return ne(()=>Nl(this.runNet(e)))}async forward(e){return this.forwardInput(await Ya(e))}async predictExpressions(e){let t=await Ya(e),n=await this.forwardInput(t),a=await Promise.all(Nn(n).map(async s=>{let i=s.dataSync();return s.dispose(),i}));n.dispose();let r=a.map(s=>new nT(s));return t.isBatchInput?r:r[0]}getDefaultModelName(){return"face_expression_model"}getClassifierChannelsIn(){return 256}getClassifierChannelsOut(){return 7}};function ETe(e){return e.expressions instanceof nT}function UU(e,t){return{...e,expressions:t}}function CTe(e,t,n=.1,a){(Array.isArray(t)?t:[t]).forEach(r=>{let s=r instanceof nT?r:ETe(r)?r.expressions:void 0;if(!s)throw new Error("drawFaceExpressions - expected faceExpressions to be FaceExpressions | WithFaceExpressions<{}> or array thereof");let i=s.asSortedArray().filter(u=>u.probability>n),o=fg(r)?r.detection.box.bottomLeft:a||new Kt(0,0);new XI(i.map(u=>`${u.expression} (${Rx(u.probability)})`),o).draw(e)})}function aT(e){return fg(e)&&e.landmarks instanceof pg&&e.unshiftedLandmarks instanceof pg&&e.alignedRect instanceof vs}function ATe(e){let t=u=>u*180/Math.PI,n=(u,d)=>Math.sqrt((u.x-d.x)**2+(u.y-d.y)**2),a={roll:void 0,pitch:void 0,yaw:void 0},r=(u,d,c)=>{let p=Math.floor(u.x-d.x),m=Math.floor(d.x-c.x);return p-m},s=(u,d)=>{let c=Math.hypot(d.x-u.x,d.y-u.y),p=d.y-u.y,m=Math.asin(p/c),g=t(m),b=Math.floor(90-g),v=d.x-u.x<0?-1:1;return b*v},i=(u,d,c)=>{let p=n(u,c),m=new Kt((u.x+c.x)/2,(u.y+c.y)/2),g=n(d,m),b=Math.atan(g/p),v=Math.floor(t(b)),x=m.y-d.y<0?-1:1;return v*x};if(!e||!e.positions||e.positions.length!==68)return a;let o=e.positions;return a.roll=s(o[27],o[66]),a.pitch=i(o[14],o[30],o[2]),a.yaw=r(o[14],o[33],o[2]),a}function rT(e,t){let{box:n}=e.detection,a=t.shiftBy(n.x,n.y),r=a.align(),{imageDims:s}=e.detection,i=new vs(e.detection.score,r.rescale(s.reverse()),s),o=ATe(t);return{...e,landmarks:a,unshiftedLandmarks:t,alignedRect:i,angle:o}}var jU=class{constructor(e={}){let{drawLines:t=!0,drawPoints:n=!0,lineWidth:a,lineColor:r,pointSize:s,pointColor:i}=e;this.drawLines=t,this.drawPoints=n,this.lineWidth=a||1,this.pointSize=s||2,this.lineColor=r||"rgba(0, 255, 255, 1)",this.pointColor=i||"rgba(255, 0, 255, 1)"}},WU=class{constructor(e,t={}){this.faceLandmarks=e,this.options=new jU(t)}draw(e){let t=ml(e),{drawLines:n,drawPoints:a,lineWidth:r,lineColor:s,pointSize:i,pointColor:o}=this.options;if(n&&this.faceLandmarks instanceof vU&&(t.strokeStyle=s,t.lineWidth=r,jo(t,this.faceLandmarks.getJawOutline()),jo(t,this.faceLandmarks.getLeftEyeBrow()),jo(t,this.faceLandmarks.getRightEyeBrow()),jo(t,this.faceLandmarks.getNose()),jo(t,this.faceLandmarks.getLeftEye(),!0),jo(t,this.faceLandmarks.getRightEye(),!0),jo(t,this.faceLandmarks.getMouth(),!0)),a){t.strokeStyle=o,t.fillStyle=o;let u=d=>{t.beginPath(),t.arc(d.x,d.y,i,0,2*Math.PI),t.fill()};this.faceLandmarks.positions.forEach(u)}}};function $Te(e,t){(Array.isArray(t)?t:[t]).forEach(n=>{let a=n instanceof pg?n:aT(n)?n.landmarks:void 0;if(!a)throw new Error("drawFaceLandmarks - expected faceExpressions to be FaceLandmarks | WithFaceLandmarks<WithFaceDetection<{}>> or array thereof");new WU(a).draw(e)})}function RTe(e,t){let n=QI(e,t),a=eT(e,t);function r(i,o,u){let d=a(i,o,`${u}/separable_conv0`),c=a(o,o,`${u}/separable_conv1`),p=n(i,o,1,`${u}/expansion_conv`);return{separable_conv0:d,separable_conv1:c,expansion_conv:p}}function s(i,o){let u=a(i,i,`${o}/separable_conv0`),d=a(i,i,`${o}/separable_conv1`),c=a(i,i,`${o}/separable_conv2`);return{separable_conv0:u,separable_conv1:d,separable_conv2:c}}return{extractConvParams:n,extractSeparableConvParams:a,extractReductionBlockParams:r,extractMainBlockParams:s}}function DTe(e,t){let n=[],{extractWeights:a,getRemainingWeights:r}=Dl(e),{extractConvParams:s,extractSeparableConvParams:i,extractReductionBlockParams:o,extractMainBlockParams:u}=RTe(a,n),d=s(3,32,3,"entry_flow/conv_in"),c=o(32,64,"entry_flow/reduction_block_0"),p=o(64,128,"entry_flow/reduction_block_1"),m={conv_in:d,reduction_block_0:c,reduction_block_1:p},g={};Jh(t,0,1).forEach(w=>{g[`main_block_${w}`]=u(128,`middle_flow/main_block_${w}`)});let b=o(128,256,"exit_flow/reduction_block"),v=i(256,512,"exit_flow/separable_conv"),x={reduction_block:b,separable_conv:v};if(r().length!==0)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:n,params:{entry_flow:m,middle_flow:g,exit_flow:x}}}function OTe(e,t){let n=wd(e,t),a=FU(n),r=tT(n);function s(o){let u=r(`${o}/separable_conv0`),d=r(`${o}/separable_conv1`),c=a(`${o}/expansion_conv`);return{separable_conv0:u,separable_conv1:d,expansion_conv:c}}function i(o){let u=r(`${o}/separable_conv0`),d=r(`${o}/separable_conv1`),c=r(`${o}/separable_conv2`);return{separable_conv0:u,separable_conv1:d,separable_conv2:c}}return{extractConvParams:a,extractSeparableConvParams:r,extractReductionBlockParams:s,extractMainBlockParams:i}}function MTe(e,t){let n=[],{extractConvParams:a,extractSeparableConvParams:r,extractReductionBlockParams:s,extractMainBlockParams:i}=OTe(e,n),o=a("entry_flow/conv_in"),u=s("entry_flow/reduction_block_0"),d=s("entry_flow/reduction_block_1"),c={conv_in:o,reduction_block_0:u,reduction_block_1:d},p={};Jh(t,0,1).forEach(v=>{p[`main_block_${v}`]=i(`middle_flow/main_block_${v}`)});let m=s("exit_flow/reduction_block"),g=r("exit_flow/separable_conv"),b={reduction_block:m,separable_conv:g};return Rl(e,n),{params:{entry_flow:c,middle_flow:p,exit_flow:b},paramMappings:n}}function VU(e,t,n){return ye(Ka(e,t.filters,n,"same"),t.bias)}function hS(e,t,n=!0){let a=n?jt(e):e;return a=Xr(a,t.separable_conv0,[1,1]),a=Xr(jt(a),t.separable_conv1,[1,1]),a=la(a,[3,3],[2,2],"same"),a=ye(a,VU(e,t.expansion_conv,[2,2])),a}function FTe(e,t){let n=Xr(jt(e),t.separable_conv0,[1,1]);return n=Xr(jt(n),t.separable_conv1,[1,1]),n=Xr(jt(n),t.separable_conv2,[1,1]),n=ye(n,e),n}var zTe=class extends $l{constructor(e){super("TinyXception"),this._numMainBlocks=e}forwardInput(e){let{params:t}=this;if(!t)throw new Error("TinyXception - load model before inference");return ne(()=>{let n=Te(e.toBatchTensor(112,!0),"float32"),a=Ty(n,[122.782,117.001,104.298]).div(255),r=jt(VU(a,t.entry_flow.conv_in,[2,2]));return r=hS(r,t.entry_flow.reduction_block_0,!1),r=hS(r,t.entry_flow.reduction_block_1),Jh(this._numMainBlocks,0,1).forEach(s=>{r=FTe(r,t.middle_flow[`main_block_${s}`])}),r=hS(r,t.exit_flow.reduction_block),r=jt(Xr(r,t.exit_flow.separable_conv,[1,1])),r})}async forward(e){return this.forwardInput(await Ya(e))}getDefaultModelName(){return"tiny_xception_model"}extractParamsFromWeightMap(e){return MTe(e,this._numMainBlocks)}extractParams(e){return DTe(e,this._numMainBlocks)}};function LTe(e){let t=[],{extractWeights:n,getRemainingWeights:a}=Dl(e),r=DU(n,t),s=r(512,1,"fc/age"),i=r(512,2,"fc/gender");if(a().length!==0)throw new Error(`weights remaing after extract: ${a().length}`);return{paramMappings:t,params:{fc:{age:s,gender:i}}}}function BTe(e){let t=[],n=wd(e,t);function a(s){let i=n(`${s}/weights`,2),o=n(`${s}/bias`,1);return{weights:i,bias:o}}let r={fc:{age:a("fc/age"),gender:a("fc/gender")}};return Rl(e,t),{params:r,paramMappings:t}}var PTe=(e=>(e.FEMALE="female",e.MALE="male",e))(PTe||{}),UTe=class extends $l{constructor(e=new zTe(2)){super("AgeGenderNet"),this._faceFeatureExtractor=e}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(e){let{params:t}=this;if(!t)throw new Error(`${this._name} - load model before inference`);return ne(()=>{let n=e instanceof Zv?this.faceFeatureExtractor.forwardInput(e):e,a=eo(n,[7,7],[2,2],"valid").as2D(n.shape[0],-1),r=Dk(a,t.fc.age).as1D(),s=Dk(a,t.fc.gender);return{age:r,gender:s}})}forwardInput(e){return ne(()=>{let{age:t,gender:n}=this.runNet(e);return{age:t,gender:Nl(n)}})}async forward(e){return this.forwardInput(await Ya(e))}async predictAgeAndGender(e){let t=await Ya(e),n=await this.forwardInput(t),a=Nn(n.age),r=Nn(n.gender),s=a.map((o,u)=>({ageTensor:o,genderTensor:r[u]})),i=await Promise.all(s.map(async({ageTensor:o,genderTensor:u})=>{let d=o.dataSync()[0],c=u.dataSync()[0],p=c>.5,m=p?"male":"female",g=p?c:1-c;return o.dispose(),u.dispose(),{age:d,gender:m,genderProbability:g}}));return n.age.dispose(),n.gender.dispose(),t.isBatchInput?i:i[0]}getDefaultModelName(){return"age_gender_model"}dispose(e=!0){this.faceFeatureExtractor.dispose(e),super.dispose(e)}loadClassifierParams(e){let{params:t,paramMappings:n}=this.extractClassifierParams(e);this._params=t,this._paramMappings=n}extractClassifierParams(e){return LTe(e)}extractParamsFromWeightMap(e){let{featureExtractorMap:t,classifierMap:n}=BU(e);return this.faceFeatureExtractor.loadFromWeightMap(t),BTe(n)}extractParams(e){let t=e.slice(0,e.length-1539),n=e.slice(e.length-1539);return this.faceFeatureExtractor.extractWeights(t),this.extractClassifierParams(n)}},HU=class extends PU{postProcess(e,t,n){let a=n.map(({width:s,height:i})=>{let o=t/Math.max(i,s);return{width:s*o,height:i*o}}),r=a.length;return ne(()=>{let s=(d,c)=>Un([Cr([68],d,"float32"),Cr([68],c,"float32")],1).as2D(1,136).as1D(),i=(d,c)=>{let{width:p,height:m}=a[d];return c(p,m)?Math.abs(p-m)/2:0},o=d=>i(d,(c,p)=>c<p),u=d=>i(d,(c,p)=>p<c);return e.mul(Cr([r,136],t,"float32")).sub(Un(Array.from(Array(r),(d,c)=>s(o(c),u(c))))).div(Un(Array.from(Array(r),(d,c)=>s(a[c].width,a[c].height))))})}forwardInput(e){return ne(()=>{let t=this.runNet(e);return this.postProcess(t,e.inputSize,e.inputDimensions.map(([n,a])=>({height:n,width:a})))})}async forward(e){return this.forwardInput(await Ya(e))}async detectLandmarks(e){let t=await Ya(e),n=ne(()=>Nn(this.forwardInput(t))),a=await Promise.all(n.map(async(r,s)=>{let i=Array.from(r.dataSync()),o=i.filter((d,c)=>Ak(c)),u=i.filter((d,c)=>!Ak(c));return new vU(Array(68).fill(0).map((d,c)=>new Kt(o[c],u[c])),{height:t.getInputHeight(s),width:t.getInputWidth(s)})}));return n.forEach(r=>r.dispose()),t.isBatchInput?a:a[0]}getClassifierChannelsOut(){return 136}},jTe=class extends HU{constructor(e=new LU){super("FaceLandmark68Net",e)}getDefaultModelName(){return"face_landmark_68_model"}getClassifierChannelsIn(){return 256}};function WTe(e){let t=[],{extractDenseBlock3Params:n}=zU(e,t),a={dense0:n("dense0",!0),dense1:n("dense1"),dense2:n("dense2")};return Rl(e,t),{params:a,paramMappings:t}}function VTe(e){let t=[],{extractWeights:n,getRemainingWeights:a}=Dl(e),{extractDenseBlock3Params:r}=MU(n,t),s=r(3,32,"dense0",!0),i=r(32,64,"dense1"),o=r(64,128,"dense2");if(a().length!==0)throw new Error(`weights remaing after extract: ${a().length}`);return{paramMappings:t,params:{dense0:s,dense1:i,dense2:o}}}var HTe=class extends $l{constructor(){super("TinyFaceFeatureExtractor")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("TinyFaceFeatureExtractor - load model before inference");return ne(()=>{let n=Te(e.toBatchTensor(112,!0),"float32"),a=Ty(n,[122.782,117.001,104.298]).div(255),r=dS(a,t.dense0,!0);return r=dS(r,t.dense1),r=dS(r,t.dense2),r=eo(r,[14,14],[2,2],"valid"),r})}async forward(e){return this.forwardInput(await Ya(e))}getDefaultModelName(){return"face_feature_extractor_tiny_model"}extractParamsFromWeightMap(e){return WTe(e)}extractParams(e){return VTe(e)}},GTe=class extends HU{constructor(e=new HTe){super("FaceLandmark68TinyNet",e)}getDefaultModelName(){return"face_landmark_68_tiny_model"}getClassifierChannelsIn(){return 128}};function qTe(e,t){return ye(Y(e,t.weights),t.biases)}function sT(e,t,n,a,r="same"){let{filters:s,bias:i}=t.conv,o=Ka(e,s,n,r);return o=ye(o,i),o=qTe(o,t.scale),a?jt(o):o}function KTe(e,t){return sT(e,t,[1,1],!0)}function GU(e,t){return sT(e,t,[1,1],!1)}function qU(e,t){return sT(e,t,[2,2],!0,"valid")}function XTe(e,t){function n(o,u,d){let c=e(o),p=c.length/(u*d*d);if(hU(p))throw new Error(`depth has to be an integer: ${p}, weights.length: ${c.length}, numFilters: ${u}, filterSize: ${d}`);return ne(()=>ft(ll(c,[u,p,d,d]),[2,3,1,0]))}function a(o,u,d,c){let p=n(o,u,d),m=Lt(e(u));return t.push({paramPath:`${c}/filters`},{paramPath:`${c}/bias`}),{filters:p,bias:m}}function r(o,u){let d=Lt(e(o)),c=Lt(e(o));return t.push({paramPath:`${u}/weights`},{paramPath:`${u}/biases`}),{weights:d,biases:c}}function s(o,u,d,c){let p=a(o,u,d,`${c}/conv`),m=r(u,`${c}/scale`);return{conv:p,scale:m}}function i(o,u,d,c,p=!1){let m=s((p?.5:1)*o,u,d,`${c}/conv1`),g=s(o,u,d,`${c}/conv2`);return{conv1:m,conv2:g}}return{extractConvLayerParams:s,extractResidualLayerParams:i}}function YTe(e){let{extractWeights:t,getRemainingWeights:n}=Dl(e),a=[],{extractConvLayerParams:r,extractResidualLayerParams:s}=XTe(t,a),i=r(4704,32,7,"conv32_down"),o=s(9216,32,3,"conv32_1"),u=s(9216,32,3,"conv32_2"),d=s(9216,32,3,"conv32_3"),c=s(36864,64,3,"conv64_down",!0),p=s(36864,64,3,"conv64_1"),m=s(36864,64,3,"conv64_2"),g=s(36864,64,3,"conv64_3"),b=s(147456,128,3,"conv128_down",!0),v=s(147456,128,3,"conv128_1"),x=s(147456,128,3,"conv128_2"),w=s(589824,256,3,"conv256_down",!0),k=s(589824,256,3,"conv256_1"),N=s(589824,256,3,"conv256_2"),I=s(589824,256,3,"conv256_down_out"),T=ne(()=>ft(ui(t(256*128),[128,256]),[1,0]));if(a.push({paramPath:"fc"}),n().length!==0)throw new Error(`weights remaing after extract: ${n().length}`);return{params:{conv32_down:i,conv32_1:o,conv32_2:u,conv32_3:d,conv64_down:c,conv64_1:p,conv64_2:m,conv64_3:g,conv128_down:b,conv128_1:v,conv128_2:x,conv256_down:w,conv256_1:k,conv256_2:N,conv256_down_out:I,fc:T},paramMappings:a}}function JTe(e,t){let n=wd(e,t);function a(i){let o=n(`${i}/scale/weights`,1),u=n(`${i}/scale/biases`,1);return{weights:o,biases:u}}function r(i){let o=n(`${i}/conv/filters`,4),u=n(`${i}/conv/bias`,1),d=a(i);return{conv:{filters:o,bias:u},scale:d}}function s(i){return{conv1:r(`${i}/conv1`),conv2:r(`${i}/conv2`)}}return{extractConvLayerParams:r,extractResidualLayerParams:s}}function ZTe(e){let t=[],{extractConvLayerParams:n,extractResidualLayerParams:a}=JTe(e,t),r=n("conv32_down"),s=a("conv32_1"),i=a("conv32_2"),o=a("conv32_3"),u=a("conv64_down"),d=a("conv64_1"),c=a("conv64_2"),p=a("conv64_3"),m=a("conv128_down"),g=a("conv128_1"),b=a("conv128_2"),v=a("conv256_down"),x=a("conv256_1"),w=a("conv256_2"),k=a("conv256_down_out"),{fc:N}=e;if(t.push({originalPath:"fc",paramPath:"fc"}),!dU(N))throw new Error(`expected weightMap[fc] to be a Tensor2D, instead have ${N}`);let I={conv32_down:r,conv32_1:s,conv32_2:i,conv32_3:o,conv64_down:u,conv64_1:d,conv64_2:c,conv64_3:p,conv128_down:m,conv128_1:g,conv128_2:b,conv256_down:v,conv256_1:x,conv256_2:w,conv256_down_out:k,fc:N};return Rl(e,t),{params:I,paramMappings:t}}function Qs(e,t){let n=KTe(e,t.conv1);return n=GU(n,t.conv2),n=ye(n,e),n=jt(n),n}function av(e,t){let n=qU(e,t.conv1);n=GU(n,t.conv2);let a=eo(e,2,2,"valid"),r=xn(a.shape),s=a.shape[3]!==n.shape[3];if(a.shape[1]!==n.shape[1]||a.shape[2]!==n.shape[2]){let i=[...n.shape];i[1]=1;let o=xn(i);n=Yt([n,o],1);let u=[...n.shape];u[2]=1;let d=xn(u);n=Yt([n,d],2)}return a=s?Yt([a,r],3):a,n=ye(a,n),n=jt(n),n}var QTe=class extends $l{constructor(){super("FaceRecognitionNet")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("FaceRecognitionNet - load model before inference");return ne(()=>{let n=Te(e.toBatchTensor(150,!0),"float32"),a=Ty(n,[122.782,117.001,104.298]).div(255),r=qU(a,t.conv32_down);r=la(r,3,2,"valid"),r=Qs(r,t.conv32_1),r=Qs(r,t.conv32_2),r=Qs(r,t.conv32_3),r=av(r,t.conv64_down),r=Qs(r,t.conv64_1),r=Qs(r,t.conv64_2),r=Qs(r,t.conv64_3),r=av(r,t.conv128_down),r=Qs(r,t.conv128_1),r=Qs(r,t.conv128_2),r=av(r,t.conv256_down),r=Qs(r,t.conv256_1),r=Qs(r,t.conv256_2),r=av(r,t.conv256_down_out);let s=r.mean([1,2]);return pt(s,t.fc)})}async forward(e){return this.forwardInput(await Ya(e))}async computeFaceDescriptor(e){var t;if((t=e?.shape)!=null&&t.some(s=>s<=0))return new Float32Array(128);let n=await Ya(e),a=ne(()=>Nn(this.forwardInput(n))),r=await Promise.all(a.map(s=>s.data()));return a.forEach(s=>s.dispose()),n.isBatchInput?r:r[0]}getDefaultModelName(){return"face_recognition_model"}extractParamsFromWeightMap(e){return ZTe(e)}extractParams(e){return YTe(e)}};function KU(e,t){return{...e,descriptor:t}}function XU(e,t){return{...e,age:t}}function YU(e,t,n){return{...e,gender:t,genderProbability:n}}function eEe(e,t){function n(u,d){let c=ll(e(9*u),[3,3,u,1]),p=Lt(e(u)),m=Lt(e(u)),g=Lt(e(u)),b=Lt(e(u));return t.push({paramPath:`${d}/filters`},{paramPath:`${d}/batch_norm_scale`},{paramPath:`${d}/batch_norm_offset`},{paramPath:`${d}/batch_norm_mean`},{paramPath:`${d}/batch_norm_variance`}),{filters:c,batch_norm_scale:p,batch_norm_offset:m,batch_norm_mean:g,batch_norm_variance:b}}function a(u,d,c,p,m){let g=ll(e(u*d*c*c),[c,c,u,d]),b=Lt(e(d));return t.push({paramPath:`${p}/filters`},{paramPath:`${p}/${m?"batch_norm_offset":"bias"}`}),{filters:g,bias:b}}function r(u,d,c,p){let{filters:m,bias:g}=a(u,d,c,p,!0);return{filters:m,batch_norm_offset:g}}function s(u,d,c){let p=n(u,`${c}/depthwise_conv`),m=r(u,d,1,`${c}/pointwise_conv`);return{depthwise_conv:p,pointwise_conv:m}}function i(){let u=r(3,32,3,"mobilenetv1/conv_0"),d=s(32,64,"mobilenetv1/conv_1"),c=s(64,128,"mobilenetv1/conv_2"),p=s(128,128,"mobilenetv1/conv_3"),m=s(128,256,"mobilenetv1/conv_4"),g=s(256,256,"mobilenetv1/conv_5"),b=s(256,512,"mobilenetv1/conv_6"),v=s(512,512,"mobilenetv1/conv_7"),x=s(512,512,"mobilenetv1/conv_8"),w=s(512,512,"mobilenetv1/conv_9"),k=s(512,512,"mobilenetv1/conv_10"),N=s(512,512,"mobilenetv1/conv_11"),I=s(512,1024,"mobilenetv1/conv_12"),T=s(1024,1024,"mobilenetv1/conv_13");return{conv_0:u,conv_1:d,conv_2:c,conv_3:p,conv_4:m,conv_5:g,conv_6:b,conv_7:v,conv_8:x,conv_9:w,conv_10:k,conv_11:N,conv_12:I,conv_13:T}}function o(){let u=r(1024,256,1,"prediction_layer/conv_0"),d=r(256,512,3,"prediction_layer/conv_1"),c=r(512,128,1,"prediction_layer/conv_2"),p=r(128,256,3,"prediction_layer/conv_3"),m=r(256,128,1,"prediction_layer/conv_4"),g=r(128,256,3,"prediction_layer/conv_5"),b=r(256,64,1,"prediction_layer/conv_6"),v=r(64,128,3,"prediction_layer/conv_7"),x=a(512,12,1,"prediction_layer/box_predictor_0/box_encoding_predictor"),w=a(512,9,1,"prediction_layer/box_predictor_0/class_predictor"),k=a(1024,24,1,"prediction_layer/box_predictor_1/box_encoding_predictor"),N=a(1024,18,1,"prediction_layer/box_predictor_1/class_predictor"),I=a(512,24,1,"prediction_layer/box_predictor_2/box_encoding_predictor"),T=a(512,18,1,"prediction_layer/box_predictor_2/class_predictor"),$=a(256,24,1,"prediction_layer/box_predictor_3/box_encoding_predictor"),D=a(256,18,1,"prediction_layer/box_predictor_3/class_predictor"),M=a(256,24,1,"prediction_layer/box_predictor_4/box_encoding_predictor"),B=a(256,18,1,"prediction_layer/box_predictor_4/class_predictor"),V=a(128,24,1,"prediction_layer/box_predictor_5/box_encoding_predictor"),W=a(128,18,1,"prediction_layer/box_predictor_5/class_predictor");return{conv_0:u,conv_1:d,conv_2:c,conv_3:p,conv_4:m,conv_5:g,conv_6:b,conv_7:v,box_predictor_0:{box_encoding_predictor:x,class_predictor:w},box_predictor_1:{box_encoding_predictor:k,class_predictor:N},box_predictor_2:{box_encoding_predictor:I,class_predictor:T},box_predictor_3:{box_encoding_predictor:$,class_predictor:D},box_predictor_4:{box_encoding_predictor:M,class_predictor:B},box_predictor_5:{box_encoding_predictor:V,class_predictor:W}}}return{extractMobilenetV1Params:i,extractPredictionLayerParams:o}}function tEe(e){let t=[],{extractWeights:n,getRemainingWeights:a}=Dl(e),{extractMobilenetV1Params:r,extractPredictionLayerParams:s}=eEe(n,t),i=r(),o=s(),u={extra_dim:G0(n(5118*4),[1,5118,4])};if(t.push({paramPath:"output_layer/extra_dim"}),a().length!==0)throw new Error(`weights remaing after extract: ${a().length}`);return{params:{mobilenetv1:i,prediction_layer:o,output_layer:u},paramMappings:t}}function nEe(e,t){let n=wd(e,t);function a(d,c,p){let m=n(`${d}/Conv2d_${c}_pointwise/weights`,4,`${p}/filters`),g=n(`${d}/Conv2d_${c}_pointwise/convolution_bn_offset`,1,`${p}/batch_norm_offset`);return{filters:m,batch_norm_offset:g}}function r(d){let c=`mobilenetv1/conv_${d}`,p=`MobilenetV1/Conv2d_${d}_depthwise`,m=`${c}/depthwise_conv`,g=`${c}/pointwise_conv`,b=n(`${p}/depthwise_weights`,4,`${m}/filters`),v=n(`${p}/BatchNorm/gamma`,1,`${m}/batch_norm_scale`),x=n(`${p}/BatchNorm/beta`,1,`${m}/batch_norm_offset`),w=n(`${p}/BatchNorm/moving_mean`,1,`${m}/batch_norm_mean`),k=n(`${p}/BatchNorm/moving_variance`,1,`${m}/batch_norm_variance`);return{depthwise_conv:{filters:b,batch_norm_scale:v,batch_norm_offset:x,batch_norm_mean:w,batch_norm_variance:k},pointwise_conv:a("MobilenetV1",d,g)}}function s(){return{conv_0:a("MobilenetV1",0,"mobilenetv1/conv_0"),conv_1:r(1),conv_2:r(2),conv_3:r(3),conv_4:r(4),conv_5:r(5),conv_6:r(6),conv_7:r(7),conv_8:r(8),conv_9:r(9),conv_10:r(10),conv_11:r(11),conv_12:r(12),conv_13:r(13)}}function i(d,c){let p=n(`${d}/weights`,4,`${c}/filters`),m=n(`${d}/biases`,1,`${c}/bias`);return{filters:p,bias:m}}function o(d){let c=i(`Prediction/BoxPredictor_${d}/BoxEncodingPredictor`,`prediction_layer/box_predictor_${d}/box_encoding_predictor`),p=i(`Prediction/BoxPredictor_${d}/ClassPredictor`,`prediction_layer/box_predictor_${d}/class_predictor`);return{box_encoding_predictor:c,class_predictor:p}}function u(){return{conv_0:a("Prediction",0,"prediction_layer/conv_0"),conv_1:a("Prediction",1,"prediction_layer/conv_1"),conv_2:a("Prediction",2,"prediction_layer/conv_2"),conv_3:a("Prediction",3,"prediction_layer/conv_3"),conv_4:a("Prediction",4,"prediction_layer/conv_4"),conv_5:a("Prediction",5,"prediction_layer/conv_5"),conv_6:a("Prediction",6,"prediction_layer/conv_6"),conv_7:a("Prediction",7,"prediction_layer/conv_7"),box_predictor_0:o(0),box_predictor_1:o(1),box_predictor_2:o(2),box_predictor_3:o(3),box_predictor_4:o(4),box_predictor_5:o(5)}}return{extractMobilenetV1Params:s,extractPredictionLayerParams:u}}function aEe(e){let t=[],{extractMobilenetV1Params:n,extractPredictionLayerParams:a}=nEe(e,t),r=e["Output/extra_dim"];if(t.push({originalPath:"Output/extra_dim",paramPath:"output_layer/extra_dim"}),!Iy(r))throw new Error(`expected weightMap['Output/extra_dim'] to be a Tensor3D, instead have ${r}`);let s={mobilenetv1:n(),prediction_layer:a(),output_layer:{extra_dim:r}};return Rl(e,t),{params:s,paramMappings:t}}function ni(e,t,n){return ne(()=>{let a=Ka(e,t.filters,n,"same");return a=ye(a,t.batch_norm_offset),za(a,0,6)})}var rEe=.0010000000474974513;function sEe(e,t,n){return ne(()=>{let a=dd(e,t.filters,n,"same");return a=cd(a,t.batch_norm_mean,t.batch_norm_variance,t.batch_norm_offset,t.batch_norm_scale,rEe),za(a,0,6)})}function iEe(e){return[2,4,6,12].some(t=>t===e)?[2,2]:[1,1]}function oEe(e,t){return ne(()=>{let n,a=ni(e,t.conv_0,[2,2]);if([t.conv_1,t.conv_2,t.conv_3,t.conv_4,t.conv_5,t.conv_6,t.conv_7,t.conv_8,t.conv_9,t.conv_10,t.conv_11,t.conv_12,t.conv_13].forEach((r,s)=>{let i=s+1,o=iEe(i);a=sEe(a,r.depthwise_conv,o),a=ni(a,r.pointwise_conv,[1,1]),i===11&&(n=a)}),n===null)throw new Error("mobileNetV1 - output of conv layer 11 is null");return{out:a,conv11:n}})}function lEe(e,t,n){let a=e.arraySync(),r=Math.min(a[t][0],a[t][2]),s=Math.min(a[t][1],a[t][3]),i=Math.max(a[t][0],a[t][2]),o=Math.max(a[t][1],a[t][3]),u=Math.min(a[n][0],a[n][2]),d=Math.min(a[n][1],a[n][3]),c=Math.max(a[n][0],a[n][2]),p=Math.max(a[n][1],a[n][3]),m=(i-r)*(o-s),g=(c-u)*(p-d);if(m<=0||g<=0)return 0;let b=Math.max(r,u),v=Math.max(s,d),x=Math.min(i,c),w=Math.min(o,p),k=Math.max(x-b,0)*Math.max(w-v,0);return k/(m+g-k)}function uEe(e,t,n,a,r){let s=e.shape[0],i=Math.min(n,s),o=t.map((c,p)=>({score:c,boxIndex:p})).filter(c=>c.score>r).sort((c,p)=>p.score-c.score),u=c=>c<=a?1:0,d=[];return o.forEach(c=>{if(d.length>=i)return;let p=c.score;for(let m=d.length-1;m>=0;--m){let g=lEe(e,c.boxIndex,d[m]);if(g!==0&&(c.score*=u(g),c.score<=r))break}p===c.score&&d.push(c.boxIndex)}),d}function cEe(e){let t=Nn(ft(e,[1,0])),n=[Fe(t[2],t[0]),Fe(t[3],t[1])],a=[ye(t[0],Le(n[0],2)),ye(t[1],Le(n[1],2))];return{sizes:n,centers:a}}function dEe(e,t){let{sizes:n,centers:a}=cEe(e),r=Nn(ft(t,[1,0])),s=Le(Y(La(Le(r[2],5)),n[0]),2),i=ye(Y(Le(r[0],10),n[0]),a[0]),o=Le(Y(La(Le(r[3],5)),n[1]),2),u=ye(Y(Le(r[1],10),n[1]),a[1]);return ft(Un([Fe(i,s),Fe(u,o),ye(i,s),ye(u,o)]),[1,0])}function hEe(e,t,n){return ne(()=>{let a=e.shape[0],r=dEe(te(Er(n.extra_dim,[a,1,1]),[-1,4]),te(e,[-1,4]));r=te(r,[a,r.shape[0]/a,4]);let s=ys(wt(t,[0,0,1],[-1,-1,-1])),i=wt(s,[0,0,0],[-1,-1,1]);i=te(i,[a,i.shape[1]]);let o=Nn(r),u=Nn(i);return{boxes:o,scores:u}})}function ph(e,t){return ne(()=>{let n=e.shape[0],a=te(Hm(e,t.box_encoding_predictor),[n,-1,1,4]),r=te(Hm(e,t.class_predictor),[n,-1,3]);return{boxPredictionEncoding:a,classPrediction:r}})}function pEe(e,t,n){return ne(()=>{let a=ni(e,n.conv_0,[1,1]),r=ni(a,n.conv_1,[2,2]),s=ni(r,n.conv_2,[1,1]),i=ni(s,n.conv_3,[2,2]),o=ni(i,n.conv_4,[1,1]),u=ni(o,n.conv_5,[2,2]),d=ni(u,n.conv_6,[1,1]),c=ni(d,n.conv_7,[2,2]),p=ph(t,n.box_predictor_0),m=ph(e,n.box_predictor_1),g=ph(r,n.box_predictor_2),b=ph(i,n.box_predictor_3),v=ph(u,n.box_predictor_4),x=ph(c,n.box_predictor_5),w=Yt([p.boxPredictionEncoding,m.boxPredictionEncoding,g.boxPredictionEncoding,b.boxPredictionEncoding,v.boxPredictionEncoding,x.boxPredictionEncoding],1),k=Yt([p.classPrediction,m.classPrediction,g.classPrediction,b.classPrediction,v.classPrediction,x.classPrediction],1);return{boxPredictions:w,classPredictions:k}})}var Ey=class{constructor({minConfidence:e,maxResults:t}={}){if(this._name="SsdMobilenetv1Options",this._minConfidence=e||.5,this._maxResults=t||100,typeof this._minConfidence!="number"||this._minConfidence<=0||this._minConfidence>=1)throw new Error(`${this._name} - expected minConfidence to be a number between 0 and 1`);if(typeof this._maxResults!="number")throw new Error(`${this._name} - expected maxResults to be a number`)}get minConfidence(){return this._minConfidence}get maxResults(){return this._maxResults}},fEe=class extends $l{constructor(){super("SsdMobilenetv1")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("SsdMobilenetv1 - load model before inference");return ne(()=>{let n=Te(e.toBatchTensor(512,!1),"float32"),a=Fe(Le(n,127.5),1),r=oEe(a,t.mobilenetv1),{boxPredictions:s,classPredictions:i}=pEe(r.out,r.conv11,t.prediction_layer);return hEe(s,i,t.output_layer)})}async forward(e){return this.forwardInput(await Ya(e))}async locateFaces(e,t={}){let{maxResults:n,minConfidence:a}=new Ey(t),r=await Ya(e),{boxes:s,scores:i}=this.forwardInput(r),o=s[0],u=i[0];for(let w=1;w<s.length;w++)s[w].dispose(),i[w].dispose();let d=Array.from(u.dataSync()),c=uEe(o,d,n,.5,a),p=r.getReshapedInputDimensions(0),m=r.inputSize,g=m/p.width,b=m/p.height,v=o.arraySync(),x=c.map(w=>{let[k,N]=[Math.max(0,v[w][0]),Math.min(1,v[w][2])].map($=>$*b),[I,T]=[Math.max(0,v[w][1]),Math.min(1,v[w][3])].map($=>$*g);return new vs(d[w],new bU(I,k,T-I,N-k),{height:r.getInputHeight(0),width:r.getInputWidth(0)})});return o.dispose(),u.dispose(),x}getDefaultModelName(){return"ssd_mobilenetv1_model"}extractParamsFromWeightMap(e){return aEe(e)}extractParams(e){return tEe(e)}},mEe=.4,gEe=[new Kt(.738768,.874946),new Kt(2.42204,2.65704),new Kt(4.30971,7.04493),new Kt(10.246,4.59428),new Kt(12.6868,11.8741)],yEe=[new Kt(1.603231,2.094468),new Kt(6.041143,7.080126),new Kt(2.882459,3.518061),new Kt(4.266906,5.178857),new Kt(9.041765,10.66308)],bEe=[117.001,114.697,97.404],vEe="tiny_yolov2_model",xEe="tiny_yolov2_separable_conv_model",rv=e=>typeof e=="number";function wEe(e){if(!e)throw new Error(`invalid config: ${e}`);if(typeof e.withSeparableConvs!="boolean")throw new Error(`config.withSeparableConvs has to be a boolean, have: ${e.withSeparableConvs}`);if(!rv(e.iouThreshold)||e.iouThreshold<0||e.iouThreshold>1)throw new Error(`config.iouThreshold has to be a number between [0, 1], have: ${e.iouThreshold}`);if(!Array.isArray(e.classes)||!e.classes.length||!e.classes.every(t=>typeof t=="string"))throw new Error(`config.classes has to be an array class names: string[], have: ${JSON.stringify(e.classes)}`);if(!Array.isArray(e.anchors)||!e.anchors.length||!e.anchors.map(t=>t||{}).every(t=>rv(t.x)&&rv(t.y)))throw new Error(`config.anchors has to be an array of { x: number, y: number }, have: ${JSON.stringify(e.anchors)}`);if(e.meanRgb&&(!Array.isArray(e.meanRgb)||e.meanRgb.length!==3||!e.meanRgb.every(rv)))throw new Error(`config.meanRgb has to be an array of shape [number, number, number], have: ${JSON.stringify(e.meanRgb)}`)}function iT(e){return ne(()=>{let t=Y(e,He(.10000000149011612));return ye(jt(Fe(e,t)),t)})}function Lo(e,t){return ne(()=>{let n=Vs(e,[[0,0],[1,1],[1,1],[0,0]]);return n=Ka(n,t.conv.filters,[1,1],"valid"),n=Fe(n,t.bn.sub),n=Y(n,t.bn.truediv),n=ye(n,t.conv.bias),iT(n)})}function Bo(e,t){return ne(()=>{let n=Vs(e,[[0,0],[1,1],[1,1],[0,0]]);return n=uf(n,t.depthwise_filter,t.pointwise_filter,[1,1],"valid"),n=ye(n,t.bias),iT(n)})}function SEe(e,t){let n=QI(e,t);function a(i,o){let u=Lt(e(i)),d=Lt(e(i));return t.push({paramPath:`${o}/sub`},{paramPath:`${o}/truediv`}),{sub:u,truediv:d}}function r(i,o,u){let d=n(i,o,3,`${u}/conv`),c=a(o,`${u}/bn`);return{conv:d,bn:c}}let s=eT(e,t);return{extractConvParams:n,extractConvWithBatchNormParams:r,extractSeparableConvParams:s}}function kEe(e,t,n,a){let{extractWeights:r,getRemainingWeights:s}=Dl(e),i=[],{extractConvParams:o,extractConvWithBatchNormParams:u,extractSeparableConvParams:d}=SEe(r,i),c;if(t.withSeparableConvs){let[p,m,g,b,v,x,w,k,N]=a,I=t.isFirstLayerConv2d?o(p,m,3,"conv0"):d(p,m,"conv0"),T=d(m,g,"conv1"),$=d(g,b,"conv2"),D=d(b,v,"conv3"),M=d(v,x,"conv4"),B=d(x,w,"conv5"),V=k?d(w,k,"conv6"):void 0,W=N?d(k,N,"conv7"):void 0,R=o(N||k||w,5*n,1,"conv8");c={conv0:I,conv1:T,conv2:$,conv3:D,conv4:M,conv5:B,conv6:V,conv7:W,conv8:R}}else{let[p,m,g,b,v,x,w,k,N]=a,I=u(p,m,"conv0"),T=u(m,g,"conv1"),$=u(g,b,"conv2"),D=u(b,v,"conv3"),M=u(v,x,"conv4"),B=u(x,w,"conv5"),V=u(w,k,"conv6"),W=u(k,N,"conv7"),R=o(N,5*n,1,"conv8");c={conv0:I,conv1:T,conv2:$,conv3:D,conv4:M,conv5:B,conv6:V,conv7:W,conv8:R}}if(s().length!==0)throw new Error(`weights remaing after extract: ${s().length}`);return{params:c,paramMappings:i}}function _Ee(e,t){let n=wd(e,t);function a(o){let u=n(`${o}/sub`,1),d=n(`${o}/truediv`,1);return{sub:u,truediv:d}}function r(o){let u=n(`${o}/filters`,4),d=n(`${o}/bias`,1);return{filters:u,bias:d}}function s(o){let u=r(`${o}/conv`),d=a(`${o}/bn`);return{conv:u,bn:d}}let i=tT(n);return{extractConvParams:r,extractConvWithBatchNormParams:s,extractSeparableConvParams:i}}function NEe(e,t){let n=[],{extractConvParams:a,extractConvWithBatchNormParams:r,extractSeparableConvParams:s}=_Ee(e,n),i;if(t.withSeparableConvs){let o=t.filterSizes&&t.filterSizes.length||9;i={conv0:t.isFirstLayerConv2d?a("conv0"):s("conv0"),conv1:s("conv1"),conv2:s("conv2"),conv3:s("conv3"),conv4:s("conv4"),conv5:s("conv5"),conv6:o>7?s("conv6"):void 0,conv7:o>8?s("conv7"):void 0,conv8:a("conv8")}}else i={conv0:r("conv0"),conv1:r("conv1"),conv2:r("conv2"),conv3:r("conv3"),conv4:r("conv4"),conv5:r("conv5"),conv6:r("conv6"),conv7:r("conv7"),conv8:a("conv8")};return Rl(e,n),{params:i,paramMappings:n}}var oT=class{constructor({inputSize:e,scoreThreshold:t}={}){if(this._name="TinyYolov2Options",this._inputSize=e||416,this._scoreThreshold=t||.5,typeof this._inputSize!="number"||this._inputSize%32!==0)throw new Error(`${this._name} - expected inputSize to be a number divisible by 32`);if(typeof this._scoreThreshold!="number"||this._scoreThreshold<=0||this._scoreThreshold>=1)throw new Error(`${this._name} - expected scoreThreshold to be a number between 0 and 1`)}get inputSize(){return this._inputSize}get scoreThreshold(){return this._scoreThreshold}},JU=class ZU extends $l{constructor(t){super("TinyYolov2"),wEe(t),this._config=t}get config(){return this._config}get withClassScores(){return this.config.withClassScores||this.config.classes.length>1}get boxEncodingSize(){return 5+(this.withClassScores?this.config.classes.length:0)}runTinyYolov2(t,n){let a=Lo(t,n.conv0);return a=la(a,[2,2],[2,2],"same"),a=Lo(a,n.conv1),a=la(a,[2,2],[2,2],"same"),a=Lo(a,n.conv2),a=la(a,[2,2],[2,2],"same"),a=Lo(a,n.conv3),a=la(a,[2,2],[2,2],"same"),a=Lo(a,n.conv4),a=la(a,[2,2],[2,2],"same"),a=Lo(a,n.conv5),a=la(a,[2,2],[1,1],"same"),a=Lo(a,n.conv6),a=Lo(a,n.conv7),Hm(a,n.conv8,"valid",!1)}runMobilenet(t,n){let a=this.config.isFirstLayerConv2d?iT(Hm(t,n.conv0,"valid",!1)):Bo(t,n.conv0);return a=la(a,[2,2],[2,2],"same"),a=Bo(a,n.conv1),a=la(a,[2,2],[2,2],"same"),a=Bo(a,n.conv2),a=la(a,[2,2],[2,2],"same"),a=Bo(a,n.conv3),a=la(a,[2,2],[2,2],"same"),a=Bo(a,n.conv4),a=la(a,[2,2],[2,2],"same"),a=Bo(a,n.conv5),a=la(a,[2,2],[1,1],"same"),a=n.conv6?Bo(a,n.conv6):a,a=n.conv7?Bo(a,n.conv7):a,Hm(a,n.conv8,"valid",!1)}forwardInput(t,n){let{params:a}=this;if(!a)throw new Error("TinyYolov2 - load model before inference");return ne(()=>{let r=Te(t.toBatchTensor(n,!1),"float32");return r=this.config.meanRgb?Ty(r,this.config.meanRgb):r,r=r.div(255),this.config.withSeparableConvs?this.runMobilenet(r,a):this.runTinyYolov2(r,a)})}async forward(t,n){return this.forwardInput(await Ya(t),n)}async detect(t,n={}){let{inputSize:a,scoreThreshold:r}=new oT(n),s=await Ya(t),i=await this.forwardInput(s,a),o=ne(()=>Nn(i)[0].expandDims()),u={width:s.getInputWidth(0),height:s.getInputHeight(0)},d=await this.extractBoxes(o,s.getReshapedInputDimensions(0),r);i.dispose(),o.dispose();let c=d.map(b=>b.box),p=d.map(b=>b.score),m=d.map(b=>b.classScore),g=d.map(b=>this.config.classes[b.label]);return uTe(c.map(b=>b.rescale(a)),p,this.config.iouThreshold,!0).map(b=>new mU(p[b],m[b],g[b],c[b],u))}getDefaultModelName(){return""}extractParamsFromWeightMap(t){return NEe(t,this.config)}extractParams(t){let n=this.config.filterSizes||ZU.DEFAULT_FILTER_SIZES,a=n?n.length:void 0;if(a!==7&&a!==8&&a!==9)throw new Error(`TinyYolov2 - expected 7 | 8 | 9 convolutional filters, but found ${a} filterSizes in config`);return kEe(t,this.config,this.boxEncodingSize,n)}async extractBoxes(t,n,a){let{width:r,height:s}=n,i=Math.max(r,s),o=i/r,u=i/s,d=t.shape[1],c=this.config.anchors.length,[p,m,g]=ne(()=>{let w=t.reshape([d,d,c,this.boxEncodingSize]),k=w.slice([0,0,0,0],[d,d,c,4]),N=w.slice([0,0,0,4],[d,d,c,1]),I=this.withClassScores?Nl(w.slice([0,0,0,5],[d,d,c,this.config.classes.length]),3):He(0);return[k,N,I]}),b=[],v=await m.array(),x=await p.array();for(let w=0;w<d;w++)for(let k=0;k<d;k++)for(let N=0;N<c;N++){let I=cS(v[w][k][N][0]);if(!a||I>a){let T=(k+cS(x[w][k][N][0]))/d*o,$=(w+cS(x[w][k][N][1]))/d*u,D=Math.exp(x[w][k][N][2])*this.config.anchors[N].x/d*o,M=Math.exp(x[w][k][N][3])*this.config.anchors[N].y/d*u,B=T-D/2,V=$-M/2,W={row:w,col:k,anchor:N},{classScore:R,label:H}=this.withClassScores?await this.extractPredictedClass(g,W):{classScore:1,label:0};b.push({box:new fU(B,V,B+D,V+M),score:I,classScore:I*R,label:H,...W})}}return p.dispose(),m.dispose(),g.dispose(),b}async extractPredictedClass(t,n){let{row:a,col:r,anchor:s}=n,i=await t.array();return Array(this.config.classes.length).fill(0).map((o,u)=>i[a][r][s][u]).map((o,u)=>({classScore:o,label:u})).reduce((o,u)=>o.classScore>u.classScore?o:u)}};JU.DEFAULT_FILTER_SIZES=[3,16,32,64,128,256,512,1024,1024];var QU=JU,IEe=class extends QU{constructor(e=!0){let t={withSeparableConvs:e,iouThreshold:mEe,classes:["face"],...e?{anchors:yEe,meanRgb:bEe}:{anchors:gEe,withClassScores:!0}};super(t)}get withSeparableConvs(){return this.config.withSeparableConvs}get anchors(){return this.config.anchors}async locateFaces(e,t){return(await this.detect(e,t)).map(n=>new vs(n.score,n.relativeBox,{width:n.imageWidth,height:n.imageHeight}))}getDefaultModelName(){return this.withSeparableConvs?xEe:vEe}extractParamsFromWeightMap(e){return super.extractParamsFromWeightMap(e)}},TEe=class extends oT{constructor(){super(...arguments),this._name="TinyFaceDetectorOptions"}},Cy=class{async then(e){return e(await this.run())}async run(){throw new Error("ComposableTask - run is not implemented")}};async function Dx(e,t,n,a,r=({alignedRect:s})=>s){let s=e.map(u=>aT(u)?r(u):u.detection),i=a||(t instanceof dt?await ZI(t,s):await JI(t,s)),o=await n(i);return i.forEach(u=>u instanceof dt&&u.dispose()),o}async function lT(e,t,n,a,r){return Dx([e],t,async s=>n(s[0]),a,r)}var EEe=.4,CEe=[new Kt(1.603231,2.094468),new Kt(6.041143,7.080126),new Kt(2.882459,3.518061),new Kt(4.266906,5.178857),new Kt(9.041765,10.66308)],AEe=[117.001,114.697,97.404],$Ee=class extends QU{constructor(){let e={withSeparableConvs:!0,iouThreshold:EEe,classes:["face"],anchors:CEe,meanRgb:AEe,isFirstLayerConv2d:!0,filterSizes:[3,16,32,64,128,256,512]};super(e)}get anchors(){return this.config.anchors}async locateFaces(e,t){return(await this.detect(e,t)).map(n=>new vs(n.score,n.relativeBox,{width:n.imageWidth,height:n.imageHeight}))}getDefaultModelName(){return"tiny_face_detector_model"}extractParamsFromWeightMap(e){return super.extractParamsFromWeightMap(e)}},Fa={ssdMobilenetv1:new fEe,tinyFaceDetector:new $Ee,tinyYolov2:new IEe,faceLandmark68Net:new jTe,faceLandmark68TinyNet:new GTe,faceRecognitionNet:new QTe,faceExpressionNet:new TTe,ageGenderNet:new UTe},ej=class extends Cy{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.extractedFaces=n}},uT=class extends ej{async run(){let e=await this.parentTask,t=await Dx(e,this.input,async n=>Promise.all(n.map(a=>Fa.faceExpressionNet.predictExpressions(a))),this.extractedFaces);return e.map((n,a)=>UU(n,t[a]))}withAgeAndGender(){return new pT(this,this.input)}},cT=class extends ej{async run(){let e=await this.parentTask;if(!e)return;let t=await lT(e,this.input,n=>Fa.faceExpressionNet.predictExpressions(n),this.extractedFaces);return UU(e,t)}withAgeAndGender(){return new fT(this,this.input)}},dT=class extends uT{withAgeAndGender(){return new mT(this,this.input)}withFaceDescriptors(){return new yT(this,this.input)}},hT=class extends cT{withAgeAndGender(){return new gT(this,this.input)}withFaceDescriptor(){return new bT(this,this.input)}},tj=class extends Cy{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.extractedFaces=n}},pT=class extends tj{async run(){let e=await this.parentTask,t=await Dx(e,this.input,async n=>Promise.all(n.map(a=>Fa.ageGenderNet.predictAgeAndGender(a))),this.extractedFaces);return e.map((n,a)=>{let{age:r,gender:s,genderProbability:i}=t[a];return XU(YU(n,s,i),r)})}withFaceExpressions(){return new uT(this,this.input)}},fT=class extends tj{async run(){let e=await this.parentTask;if(!e)return;let{age:t,gender:n,genderProbability:a}=await lT(e,this.input,r=>Fa.ageGenderNet.predictAgeAndGender(r),this.extractedFaces);return XU(YU(e,n,a),t)}withFaceExpressions(){return new cT(this,this.input)}},mT=class extends pT{withFaceExpressions(){return new dT(this,this.input)}withFaceDescriptors(){return new yT(this,this.input)}},gT=class extends fT{withFaceExpressions(){return new hT(this,this.input)}withFaceDescriptor(){return new bT(this,this.input)}},nj=class extends Cy{constructor(e,t){super(),this.parentTask=e,this.input=t}},yT=class extends nj{async run(){let e=await this.parentTask;return(await Dx(e,this.input,t=>Promise.all(t.map(n=>Fa.faceRecognitionNet.computeFaceDescriptor(n))),null,t=>t.landmarks.align(null,{useDlibAlignment:!0}))).map((t,n)=>KU(e[n],t))}withFaceExpressions(){return new dT(this,this.input)}withAgeAndGender(){return new mT(this,this.input)}},bT=class extends nj{async run(){let e=await this.parentTask;if(!e)return;let t=await lT(e,this.input,n=>Fa.faceRecognitionNet.computeFaceDescriptor(n),null,n=>n.landmarks.align(null,{useDlibAlignment:!0}));return KU(e,t)}withFaceExpressions(){return new hT(this,this.input)}withAgeAndGender(){return new gT(this,this.input)}},aj=class extends Cy{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.useTinyLandmarkNet=n}get landmarkNet(){return this.useTinyLandmarkNet?Fa.faceLandmark68TinyNet:Fa.faceLandmark68Net}},REe=class extends aj{async run(){let e=await this.parentTask,t=e.map(r=>r.detection),n=this.input instanceof dt?await ZI(this.input,t):await JI(this.input,t),a=await Promise.all(n.map(r=>this.landmarkNet.detectLandmarks(r)));return n.forEach(r=>r instanceof dt&&r.dispose()),e.filter((r,s)=>a[s]).map((r,s)=>rT(r,a[s]))}withFaceExpressions(){return new dT(this,this.input)}withAgeAndGender(){return new mT(this,this.input)}withFaceDescriptors(){return new yT(this,this.input)}},DEe=class extends aj{async run(){let e=await this.parentTask;if(!e)return;let{detection:t}=e,n=this.input instanceof dt?await ZI(this.input,[t]):await JI(this.input,[t]),a=await this.landmarkNet.detectLandmarks(n[0]);return n.forEach(r=>r instanceof dt&&r.dispose()),rT(e,a)}withFaceExpressions(){return new hT(this,this.input)}withAgeAndGender(){return new gT(this,this.input)}withFaceDescriptor(){return new bT(this,this.input)}},rj=class extends Cy{constructor(e,t=new Ey){super(),this.input=e,this.options=t}},OEe=class extends rj{async run(){let{input:e,options:t}=this,n;if(t instanceof TEe)n=Fa.tinyFaceDetector.locateFaces(e,t);else if(t instanceof Ey)n=Fa.ssdMobilenetv1.locateFaces(e,t);else if(t instanceof oT)n=Fa.tinyYolov2.locateFaces(e,t);else throw new Error("detectFaces - expected options to be instance of TinyFaceDetectorOptions | SsdMobilenetv1Options | TinyYolov2Options");return n}runAndExtendWithFaceDetections(){return new Promise((e,t)=>{this.run().then(n=>e(n.map(a=>Yv({},a)))).catch(n=>t(n))})}withFaceLandmarks(e=!1){return new REe(this.runAndExtendWithFaceDetections(),this.input,e)}withFaceExpressions(){return new uT(this.runAndExtendWithFaceDetections(),this.input)}withAgeAndGender(){return new pT(this.runAndExtendWithFaceDetections(),this.input)}},MEe=class extends rj{async run(){let e=await new OEe(this.input,this.options),t=e[0];return e.forEach(n=>{n.score>t.score&&(t=n)}),t}runAndExtendWithFaceDetection(){return new Promise(async e=>{let t=await this.run();e(t?Yv({},t):void 0)})}withFaceLandmarks(e=!1){return new DEe(this.runAndExtendWithFaceDetection(),this.input,e)}withFaceExpressions(){return new cT(this.runAndExtendWithFaceDetection(),this.input)}withAgeAndGender(){return new fT(this.runAndExtendWithFaceDetection(),this.input)}};function sj(e,t=new Ey){return new MEe(e,t)}function FEe(e,t){if(e.length!==t.length)throw new Error("euclideanDistance: arr1.length !== arr2.length");let n=Array.from(e),a=Array.from(t);return Math.sqrt(n.map((r,s)=>r-a[s]).reduce((r,s)=>r+s*s,0))}var zEe=class ij{constructor(t,n=.6){this._distanceThreshold=n;let a=Array.isArray(t)?t:[t];if(!a.length)throw new Error("FaceRecognizer.constructor - expected atleast one input");let r=1,s=()=>`person ${r++}`;this._labeledDescriptors=a.map(i=>{if(i instanceof Lm)return i;if(i instanceof Float32Array)return new Lm(s(),[i]);if(i.descriptor&&i.descriptor instanceof Float32Array)return new Lm(s(),[i.descriptor]);throw new Error("FaceRecognizer.constructor - expected inputs to be of type LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array | Array<LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array>")})}get labeledDescriptors(){return this._labeledDescriptors}get distanceThreshold(){return this._distanceThreshold}computeMeanDistance(t,n){return n.map(a=>FEe(a,t)).reduce((a,r)=>a+r,0)/(n.length||1)}matchDescriptor(t){return this.labeledDescriptors.map(({descriptors:n,label:a})=>new aD(a,this.computeMeanDistance(t,n))).reduce((n,a)=>n.distance<a.distance?n:a)}findBestMatch(t){let n=this.matchDescriptor(t);return n.distance<this._distanceThreshold?n:new aD("unknown",n.distance)}toJSON(){return{distanceThreshold:this._distanceThreshold,labeledDescriptors:this._labeledDescriptors.map(t=>t.toJSON())}}static fromJSON(t){let n=t.labeledDescriptors.map(a=>Lm.fromJSON(a));return new ij(n,t.distanceThreshold)}};function vT(e,t){let{width:n,height:a}=new ku(t.width,t.height);if(n<=0||a<=0)throw new Error(`resizeResults - invalid dimensions: ${JSON.stringify({width:n,height:a})}`);if(Array.isArray(e))return e.map(r=>vT(r,{width:n,height:a}));if(aT(e)){let r=e.detection.forSize(n,a),s=e.unshiftedLandmarks.forSize(r.box.width,r.box.height);return rT(Yv(e,r),s)}return fg(e)?Yv(e,e.detection.forSize(n,a)):e instanceof pg||e instanceof vs?e.forSize(n,a):e}function Ox(e,t){var n={};for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&t.indexOf(a)<0&&(n[a]=e[a]);if(e!=null&&typeof Object.getOwnPropertySymbols=="function")for(var r=0,a=Object.getOwnPropertySymbols(e);r<a.length;r++)t.indexOf(a[r])<0&&Object.prototype.propertyIsEnumerable.call(e,a[r])&&(n[a[r]]=e[a[r]]);return n}function LEe(e,t,n,a){function r(s){return s instanceof n?s:new n(function(i){i(s)})}return new(n||(n=Promise))(function(s,i){function o(c){try{d(a.next(c))}catch(p){i(p)}}function u(c){try{d(a.throw(c))}catch(p){i(p)}}function d(c){c.done?s(c.value):r(c.value).then(o,u)}d((a=a.apply(e,t||[])).next())})}const BEe=e=>e?(...t)=>e(...t):(...t)=>fetch(...t);class xT extends Error{constructor(t,n="FunctionsError",a){super(t),this.name=n,this.context=a}}class PEe extends xT{constructor(t){super("Failed to send a request to the Edge Function","FunctionsFetchError",t)}}class iD extends xT{constructor(t){super("Relay Error invoking the Edge Function","FunctionsRelayError",t)}}class oD extends xT{constructor(t){super("Edge Function returned a non-2xx status code","FunctionsHttpError",t)}}var Ok;(function(e){e.Any="any",e.ApNortheast1="ap-northeast-1",e.ApNortheast2="ap-northeast-2",e.ApSouth1="ap-south-1",e.ApSoutheast1="ap-southeast-1",e.ApSoutheast2="ap-southeast-2",e.CaCentral1="ca-central-1",e.EuCentral1="eu-central-1",e.EuWest1="eu-west-1",e.EuWest2="eu-west-2",e.EuWest3="eu-west-3",e.SaEast1="sa-east-1",e.UsEast1="us-east-1",e.UsWest1="us-west-1",e.UsWest2="us-west-2"})(Ok||(Ok={}));class UEe{constructor(t,{headers:n={},customFetch:a,region:r=Ok.Any}={}){this.url=t,this.headers=n,this.region=r,this.fetch=BEe(a)}setAuth(t){this.headers.Authorization=`Bearer ${t}`}invoke(t){return LEe(this,arguments,void 0,function*(n,a={}){var r;let s,i;try{const{headers:o,method:u,body:d,signal:c,timeout:p}=a;let m={},{region:g}=a;g||(g=this.region);const b=new URL(`${this.url}/${n}`);g&&g!=="any"&&(m["x-region"]=g,b.searchParams.set("forceFunctionRegion",g));let v;d&&(o&&!Object.prototype.hasOwnProperty.call(o,"Content-Type")||!o)?typeof Blob<"u"&&d instanceof Blob||d instanceof ArrayBuffer?(m["Content-Type"]="application/octet-stream",v=d):typeof d=="string"?(m["Content-Type"]="text/plain",v=d):typeof FormData<"u"&&d instanceof FormData?v=d:(m["Content-Type"]="application/json",v=JSON.stringify(d)):v=d;let x=c;p&&(i=new AbortController,s=setTimeout(()=>i.abort(),p),c?(x=i.signal,c.addEventListener("abort",()=>i.abort())):x=i.signal);const w=yield this.fetch(b.toString(),{method:u||"POST",headers:Object.assign(Object.assign(Object.assign({},m),this.headers),o),body:v,signal:x}).catch(T=>{throw new PEe(T)}),k=w.headers.get("x-relay-error");if(k&&k==="true")throw new iD(w);if(!w.ok)throw new oD(w);let N=((r=w.headers.get("Content-Type"))!==null&&r!==void 0?r:"text/plain").split(";")[0].trim(),I;return N==="application/json"?I=yield w.json():N==="application/octet-stream"||N==="application/pdf"?I=yield w.blob():N==="text/event-stream"?I=w:N==="multipart/form-data"?I=yield w.formData():I=yield w.text(),{data:I,error:null,response:w}}catch(o){return{data:null,error:o,response:o instanceof oD||o instanceof iD?o.context:void 0}}finally{s&&clearTimeout(s)}})}}var jEe=class extends Error{constructor(e){super(e.message),this.name="PostgrestError",this.details=e.details,this.hint=e.hint,this.code=e.code}},WEe=class{constructor(e){var t,n;this.shouldThrowOnError=!1,this.method=e.method,this.url=e.url,this.headers=new Headers(e.headers),this.schema=e.schema,this.body=e.body,this.shouldThrowOnError=(t=e.shouldThrowOnError)!==null&&t!==void 0?t:!1,this.signal=e.signal,this.isMaybeSingle=(n=e.isMaybeSingle)!==null&&n!==void 0?n:!1,e.fetch?this.fetch=e.fetch:this.fetch=fetch}throwOnError(){return this.shouldThrowOnError=!0,this}setHeader(e,t){return this.headers=new Headers(this.headers),this.headers.set(e,t),this}then(e,t){var n=this;this.schema===void 0||(["GET","HEAD"].includes(this.method)?this.headers.set("Accept-Profile",this.schema):this.headers.set("Content-Profile",this.schema)),this.method!=="GET"&&this.method!=="HEAD"&&this.headers.set("Content-Type","application/json");const a=this.fetch;let r=a(this.url.toString(),{method:this.method,headers:this.headers,body:JSON.stringify(this.body),signal:this.signal}).then(async s=>{let i=null,o=null,u=null,d=s.status,c=s.statusText;if(s.ok){var p,m;if(n.method!=="HEAD"){var g;const w=await s.text();w===""||(n.headers.get("Accept")==="text/csv"||n.headers.get("Accept")&&(!((g=n.headers.get("Accept"))===null||g===void 0)&&g.includes("application/vnd.pgrst.plan+text"))?o=w:o=JSON.parse(w))}const v=(p=n.headers.get("Prefer"))===null||p===void 0?void 0:p.match(/count=(exact|planned|estimated)/),x=(m=s.headers.get("content-range"))===null||m===void 0?void 0:m.split("/");v&&x&&x.length>1&&(u=parseInt(x[1])),n.isMaybeSingle&&n.method==="GET"&&Array.isArray(o)&&(o.length>1?(i={code:"PGRST116",details:`Results contain ${o.length} rows, application/vnd.pgrst.object+json requires 1 row`,hint:null,message:"JSON object requested, multiple (or no) rows returned"},o=null,u=null,d=406,c="Not Acceptable"):o.length===1?o=o[0]:o=null)}else{var b;const v=await s.text();try{i=JSON.parse(v),Array.isArray(i)&&s.status===404&&(o=[],i=null,d=200,c="OK")}catch{s.status===404&&v===""?(d=204,c="No Content"):i={message:v}}if(i&&n.isMaybeSingle&&(!(i==null||(b=i.details)===null||b===void 0)&&b.includes("0 rows"))&&(i=null,d=200,c="OK"),i&&n.shouldThrowOnError)throw new jEe(i)}return{error:i,data:o,count:u,status:d,statusText:c}});return this.shouldThrowOnError||(r=r.catch(s=>{var i;let o="";const u=s?.cause;if(u){var d,c,p,m;const b=(d=u?.message)!==null&&d!==void 0?d:"",v=(c=u?.code)!==null&&c!==void 0?c:"";o=`${(p=s?.name)!==null&&p!==void 0?p:"FetchError"}: ${s?.message}`,o+=`

Caused by: ${(m=u?.name)!==null&&m!==void 0?m:"Error"}: ${b}`,v&&(o+=` (${v})`),u?.stack&&(o+=`
${u.stack}`)}else{var g;o=(g=s?.stack)!==null&&g!==void 0?g:""}return{error:{message:`${(i=s?.name)!==null&&i!==void 0?i:"FetchError"}: ${s?.message}`,details:o,hint:"",code:""},data:null,count:null,status:0,statusText:""}})),r.then(e,t)}returns(){return this}overrideTypes(){return this}},VEe=class extends WEe{select(e){let t=!1;const n=(e??"*").split("").map(a=>/\s/.test(a)&&!t?"":(a==='"'&&(t=!t),a)).join("");return this.url.searchParams.set("select",n),this.headers.append("Prefer","return=representation"),this}order(e,{ascending:t=!0,nullsFirst:n,foreignTable:a,referencedTable:r=a}={}){const s=r?`${r}.order`:"order",i=this.url.searchParams.get(s);return this.url.searchParams.set(s,`${i?`${i},`:""}${e}.${t?"asc":"desc"}${n===void 0?"":n?".nullsfirst":".nullslast"}`),this}limit(e,{foreignTable:t,referencedTable:n=t}={}){const a=typeof n>"u"?"limit":`${n}.limit`;return this.url.searchParams.set(a,`${e}`),this}range(e,t,{foreignTable:n,referencedTable:a=n}={}){const r=typeof a>"u"?"offset":`${a}.offset`,s=typeof a>"u"?"limit":`${a}.limit`;return this.url.searchParams.set(r,`${e}`),this.url.searchParams.set(s,`${t-e+1}`),this}abortSignal(e){return this.signal=e,this}single(){return this.headers.set("Accept","application/vnd.pgrst.object+json"),this}maybeSingle(){return this.method==="GET"?this.headers.set("Accept","application/json"):this.headers.set("Accept","application/vnd.pgrst.object+json"),this.isMaybeSingle=!0,this}csv(){return this.headers.set("Accept","text/csv"),this}geojson(){return this.headers.set("Accept","application/geo+json"),this}explain({analyze:e=!1,verbose:t=!1,settings:n=!1,buffers:a=!1,wal:r=!1,format:s="text"}={}){var i;const o=[e?"analyze":null,t?"verbose":null,n?"settings":null,a?"buffers":null,r?"wal":null].filter(Boolean).join("|"),u=(i=this.headers.get("Accept"))!==null&&i!==void 0?i:"application/json";return this.headers.set("Accept",`application/vnd.pgrst.plan+${s}; for="${u}"; options=${o};`),s==="json"?this:this}rollback(){return this.headers.append("Prefer","tx=rollback"),this}returns(){return this}maxAffected(e){return this.headers.append("Prefer","handling=strict"),this.headers.append("Prefer",`max-affected=${e}`),this}};const lD=new RegExp("[,()]");var kh=class extends VEe{eq(e,t){return this.url.searchParams.append(e,`eq.${t}`),this}neq(e,t){return this.url.searchParams.append(e,`neq.${t}`),this}gt(e,t){return this.url.searchParams.append(e,`gt.${t}`),this}gte(e,t){return this.url.searchParams.append(e,`gte.${t}`),this}lt(e,t){return this.url.searchParams.append(e,`lt.${t}`),this}lte(e,t){return this.url.searchParams.append(e,`lte.${t}`),this}like(e,t){return this.url.searchParams.append(e,`like.${t}`),this}likeAllOf(e,t){return this.url.searchParams.append(e,`like(all).{${t.join(",")}}`),this}likeAnyOf(e,t){return this.url.searchParams.append(e,`like(any).{${t.join(",")}}`),this}ilike(e,t){return this.url.searchParams.append(e,`ilike.${t}`),this}ilikeAllOf(e,t){return this.url.searchParams.append(e,`ilike(all).{${t.join(",")}}`),this}ilikeAnyOf(e,t){return this.url.searchParams.append(e,`ilike(any).{${t.join(",")}}`),this}regexMatch(e,t){return this.url.searchParams.append(e,`match.${t}`),this}regexIMatch(e,t){return this.url.searchParams.append(e,`imatch.${t}`),this}is(e,t){return this.url.searchParams.append(e,`is.${t}`),this}isDistinct(e,t){return this.url.searchParams.append(e,`isdistinct.${t}`),this}in(e,t){const n=Array.from(new Set(t)).map(a=>typeof a=="string"&&lD.test(a)?`"${a}"`:`${a}`).join(",");return this.url.searchParams.append(e,`in.(${n})`),this}notIn(e,t){const n=Array.from(new Set(t)).map(a=>typeof a=="string"&&lD.test(a)?`"${a}"`:`${a}`).join(",");return this.url.searchParams.append(e,`not.in.(${n})`),this}contains(e,t){return typeof t=="string"?this.url.searchParams.append(e,`cs.${t}`):Array.isArray(t)?this.url.searchParams.append(e,`cs.{${t.join(",")}}`):this.url.searchParams.append(e,`cs.${JSON.stringify(t)}`),this}containedBy(e,t){return typeof t=="string"?this.url.searchParams.append(e,`cd.${t}`):Array.isArray(t)?this.url.searchParams.append(e,`cd.{${t.join(",")}}`):this.url.searchParams.append(e,`cd.${JSON.stringify(t)}`),this}rangeGt(e,t){return this.url.searchParams.append(e,`sr.${t}`),this}rangeGte(e,t){return this.url.searchParams.append(e,`nxl.${t}`),this}rangeLt(e,t){return this.url.searchParams.append(e,`sl.${t}`),this}rangeLte(e,t){return this.url.searchParams.append(e,`nxr.${t}`),this}rangeAdjacent(e,t){return this.url.searchParams.append(e,`adj.${t}`),this}overlaps(e,t){return typeof t=="string"?this.url.searchParams.append(e,`ov.${t}`):this.url.searchParams.append(e,`ov.{${t.join(",")}}`),this}textSearch(e,t,{config:n,type:a}={}){let r="";a==="plain"?r="pl":a==="phrase"?r="ph":a==="websearch"&&(r="w");const s=n===void 0?"":`(${n})`;return this.url.searchParams.append(e,`${r}fts${s}.${t}`),this}match(e){return Object.entries(e).forEach(([t,n])=>{this.url.searchParams.append(t,`eq.${n}`)}),this}not(e,t,n){return this.url.searchParams.append(e,`not.${t}.${n}`),this}or(e,{foreignTable:t,referencedTable:n=t}={}){const a=n?`${n}.or`:"or";return this.url.searchParams.append(a,`(${e})`),this}filter(e,t,n){return this.url.searchParams.append(e,`${t}.${n}`),this}},HEe=class{constructor(e,{headers:t={},schema:n,fetch:a}){this.url=e,this.headers=new Headers(t),this.schema=n,this.fetch=a}select(e,t){const{head:n=!1,count:a}=t??{},r=n?"HEAD":"GET";let s=!1;const i=(e??"*").split("").map(o=>/\s/.test(o)&&!s?"":(o==='"'&&(s=!s),o)).join("");return this.url.searchParams.set("select",i),a&&this.headers.append("Prefer",`count=${a}`),new kh({method:r,url:this.url,headers:this.headers,schema:this.schema,fetch:this.fetch})}insert(e,{count:t,defaultToNull:n=!0}={}){var a;const r="POST";if(t&&this.headers.append("Prefer",`count=${t}`),n||this.headers.append("Prefer","missing=default"),Array.isArray(e)){const s=e.reduce((i,o)=>i.concat(Object.keys(o)),[]);if(s.length>0){const i=[...new Set(s)].map(o=>`"${o}"`);this.url.searchParams.set("columns",i.join(","))}}return new kh({method:r,url:this.url,headers:this.headers,schema:this.schema,body:e,fetch:(a=this.fetch)!==null&&a!==void 0?a:fetch})}upsert(e,{onConflict:t,ignoreDuplicates:n=!1,count:a,defaultToNull:r=!0}={}){var s;const i="POST";if(this.headers.append("Prefer",`resolution=${n?"ignore":"merge"}-duplicates`),t!==void 0&&this.url.searchParams.set("on_conflict",t),a&&this.headers.append("Prefer",`count=${a}`),r||this.headers.append("Prefer","missing=default"),Array.isArray(e)){const o=e.reduce((u,d)=>u.concat(Object.keys(d)),[]);if(o.length>0){const u=[...new Set(o)].map(d=>`"${d}"`);this.url.searchParams.set("columns",u.join(","))}}return new kh({method:i,url:this.url,headers:this.headers,schema:this.schema,body:e,fetch:(s=this.fetch)!==null&&s!==void 0?s:fetch})}update(e,{count:t}={}){var n;const a="PATCH";return t&&this.headers.append("Prefer",`count=${t}`),new kh({method:a,url:this.url,headers:this.headers,schema:this.schema,body:e,fetch:(n=this.fetch)!==null&&n!==void 0?n:fetch})}delete({count:e}={}){var t;const n="DELETE";return e&&this.headers.append("Prefer",`count=${e}`),new kh({method:n,url:this.url,headers:this.headers,schema:this.schema,fetch:(t=this.fetch)!==null&&t!==void 0?t:fetch})}},GEe=class oj{constructor(t,{headers:n={},schema:a,fetch:r}={}){this.url=t,this.headers=new Headers(n),this.schemaName=a,this.fetch=r}from(t){if(!t||typeof t!="string"||t.trim()==="")throw new Error("Invalid relation name: relation must be a non-empty string.");return new HEe(new URL(`${this.url}/${t}`),{headers:new Headers(this.headers),schema:this.schemaName,fetch:this.fetch})}schema(t){return new oj(this.url,{headers:this.headers,schema:t,fetch:this.fetch})}rpc(t,n={},{head:a=!1,get:r=!1,count:s}={}){var i;let o;const u=new URL(`${this.url}/rpc/${t}`);let d;a||r?(o=a?"HEAD":"GET",Object.entries(n).filter(([p,m])=>m!==void 0).map(([p,m])=>[p,Array.isArray(m)?`{${m.join(",")}}`:`${m}`]).forEach(([p,m])=>{u.searchParams.append(p,m)})):(o="POST",d=n);const c=new Headers(this.headers);return s&&c.set("Prefer",`count=${s}`),new kh({method:o,url:u,headers:c,schema:this.schemaName,body:d,fetch:(i=this.fetch)!==null&&i!==void 0?i:fetch})}};class qEe{constructor(){}static detectEnvironment(){var t;if(typeof WebSocket<"u")return{type:"native",constructor:WebSocket};if(typeof globalThis<"u"&&typeof globalThis.WebSocket<"u")return{type:"native",constructor:globalThis.WebSocket};if(typeof global<"u"&&typeof global.WebSocket<"u")return{type:"native",constructor:global.WebSocket};if(typeof globalThis<"u"&&typeof globalThis.WebSocketPair<"u"&&typeof globalThis.WebSocket>"u")return{type:"cloudflare",error:"Cloudflare Workers detected. WebSocket clients are not supported in Cloudflare Workers.",workaround:"Use Cloudflare Workers WebSocket API for server-side WebSocket handling, or deploy to a different runtime."};if(typeof globalThis<"u"&&globalThis.EdgeRuntime||typeof navigator<"u"&&(!((t=navigator.userAgent)===null||t===void 0)&&t.includes("Vercel-Edge")))return{type:"unsupported",error:"Edge runtime detected (Vercel Edge/Netlify Edge). WebSockets are not supported in edge functions.",workaround:"Use serverless functions or a different deployment target for WebSocket functionality."};if(typeof process<"u"){const n=process.versions;if(n&&n.node){const a=n.node,r=parseInt(a.replace(/^v/,"").split(".")[0]);return r>=22?typeof globalThis.WebSocket<"u"?{type:"native",constructor:globalThis.WebSocket}:{type:"unsupported",error:`Node.js ${r} detected but native WebSocket not found.`,workaround:"Provide a WebSocket implementation via the transport option."}:{type:"unsupported",error:`Node.js ${r} detected without native WebSocket support.`,workaround:`For Node.js < 22, install "ws" package and provide it via the transport option:
import ws from "ws"
new RealtimeClient(url, { transport: ws })`}}}return{type:"unsupported",error:"Unknown JavaScript runtime without WebSocket support.",workaround:"Ensure you're running in a supported environment (browser, Node.js, Deno) or provide a custom WebSocket implementation."}}static getWebSocketConstructor(){const t=this.detectEnvironment();if(t.constructor)return t.constructor;let n=t.error||"WebSocket not supported in this environment.";throw t.workaround&&(n+=`

Suggested solution: ${t.workaround}`),new Error(n)}static createWebSocket(t,n){const a=this.getWebSocketConstructor();return new a(t,n)}static isWebSocketSupported(){try{const t=this.detectEnvironment();return t.type==="native"||t.type==="ws"}catch{return!1}}}const KEe="2.89.0",XEe=`realtime-js/${KEe}`,lj="1.0.0",YEe="2.0.0",uD=lj,Mk=1e4,JEe=1e3,ZEe=100;var Ho;(function(e){e[e.connecting=0]="connecting",e[e.open=1]="open",e[e.closing=2]="closing",e[e.closed=3]="closed"})(Ho||(Ho={}));var ia;(function(e){e.closed="closed",e.errored="errored",e.joined="joined",e.joining="joining",e.leaving="leaving"})(ia||(ia={}));var Os;(function(e){e.close="phx_close",e.error="phx_error",e.join="phx_join",e.reply="phx_reply",e.leave="phx_leave",e.access_token="access_token"})(Os||(Os={}));var Fk;(function(e){e.websocket="websocket"})(Fk||(Fk={}));var mu;(function(e){e.Connecting="connecting",e.Open="open",e.Closing="closing",e.Closed="closed"})(mu||(mu={}));class QEe{constructor(t){this.HEADER_LENGTH=1,this.USER_BROADCAST_PUSH_META_LENGTH=6,this.KINDS={userBroadcastPush:3,userBroadcast:4},this.BINARY_ENCODING=0,this.JSON_ENCODING=1,this.BROADCAST_EVENT="broadcast",this.allowedMetadataKeys=[],this.allowedMetadataKeys=t??[]}encode(t,n){if(t.event===this.BROADCAST_EVENT&&!(t.payload instanceof ArrayBuffer)&&typeof t.payload.event=="string")return n(this._binaryEncodeUserBroadcastPush(t));let a=[t.join_ref,t.ref,t.topic,t.event,t.payload];return n(JSON.stringify(a))}_binaryEncodeUserBroadcastPush(t){var n;return this._isArrayBuffer((n=t.payload)===null||n===void 0?void 0:n.payload)?this._encodeBinaryUserBroadcastPush(t):this._encodeJsonUserBroadcastPush(t)}_encodeBinaryUserBroadcastPush(t){var n,a;const r=(a=(n=t.payload)===null||n===void 0?void 0:n.payload)!==null&&a!==void 0?a:new ArrayBuffer(0);return this._encodeUserBroadcastPush(t,this.BINARY_ENCODING,r)}_encodeJsonUserBroadcastPush(t){var n,a;const r=(a=(n=t.payload)===null||n===void 0?void 0:n.payload)!==null&&a!==void 0?a:{},i=new TextEncoder().encode(JSON.stringify(r)).buffer;return this._encodeUserBroadcastPush(t,this.JSON_ENCODING,i)}_encodeUserBroadcastPush(t,n,a){var r,s;const i=t.topic,o=(r=t.ref)!==null&&r!==void 0?r:"",u=(s=t.join_ref)!==null&&s!==void 0?s:"",d=t.payload.event,c=this.allowedMetadataKeys?this._pick(t.payload,this.allowedMetadataKeys):{},p=Object.keys(c).length===0?"":JSON.stringify(c);if(u.length>255)throw new Error(`joinRef length ${u.length} exceeds maximum of 255`);if(o.length>255)throw new Error(`ref length ${o.length} exceeds maximum of 255`);if(i.length>255)throw new Error(`topic length ${i.length} exceeds maximum of 255`);if(d.length>255)throw new Error(`userEvent length ${d.length} exceeds maximum of 255`);if(p.length>255)throw new Error(`metadata length ${p.length} exceeds maximum of 255`);const m=this.USER_BROADCAST_PUSH_META_LENGTH+u.length+o.length+i.length+d.length+p.length,g=new ArrayBuffer(this.HEADER_LENGTH+m);let b=new DataView(g),v=0;b.setUint8(v++,this.KINDS.userBroadcastPush),b.setUint8(v++,u.length),b.setUint8(v++,o.length),b.setUint8(v++,i.length),b.setUint8(v++,d.length),b.setUint8(v++,p.length),b.setUint8(v++,n),Array.from(u,w=>b.setUint8(v++,w.charCodeAt(0))),Array.from(o,w=>b.setUint8(v++,w.charCodeAt(0))),Array.from(i,w=>b.setUint8(v++,w.charCodeAt(0))),Array.from(d,w=>b.setUint8(v++,w.charCodeAt(0))),Array.from(p,w=>b.setUint8(v++,w.charCodeAt(0)));var x=new Uint8Array(g.byteLength+a.byteLength);return x.set(new Uint8Array(g),0),x.set(new Uint8Array(a),g.byteLength),x.buffer}decode(t,n){if(this._isArrayBuffer(t)){let a=this._binaryDecode(t);return n(a)}if(typeof t=="string"){const a=JSON.parse(t),[r,s,i,o,u]=a;return n({join_ref:r,ref:s,topic:i,event:o,payload:u})}return n({})}_binaryDecode(t){const n=new DataView(t),a=n.getUint8(0),r=new TextDecoder;if(a===this.KINDS.userBroadcast)return this._decodeUserBroadcast(t,n,r)}_decodeUserBroadcast(t,n,a){const r=n.getUint8(1),s=n.getUint8(2),i=n.getUint8(3),o=n.getUint8(4);let u=this.HEADER_LENGTH+4;const d=a.decode(t.slice(u,u+r));u=u+r;const c=a.decode(t.slice(u,u+s));u=u+s;const p=a.decode(t.slice(u,u+i));u=u+i;const m=t.slice(u,t.byteLength),g=o===this.JSON_ENCODING?JSON.parse(a.decode(m)):m,b={type:this.BROADCAST_EVENT,event:c,payload:g};return i>0&&(b.meta=JSON.parse(p)),{join_ref:null,ref:null,topic:d,event:this.BROADCAST_EVENT,payload:b}}_isArrayBuffer(t){var n;return t instanceof ArrayBuffer||((n=t?.constructor)===null||n===void 0?void 0:n.name)==="ArrayBuffer"}_pick(t,n){return!t||typeof t!="object"?{}:Object.fromEntries(Object.entries(t).filter(([a])=>n.includes(a)))}}class uj{constructor(t,n){this.callback=t,this.timerCalc=n,this.timer=void 0,this.tries=0,this.callback=t,this.timerCalc=n}reset(){this.tries=0,clearTimeout(this.timer),this.timer=void 0}scheduleTimeout(){clearTimeout(this.timer),this.timer=setTimeout(()=>{this.tries=this.tries+1,this.callback()},this.timerCalc(this.tries+1))}}var hn;(function(e){e.abstime="abstime",e.bool="bool",e.date="date",e.daterange="daterange",e.float4="float4",e.float8="float8",e.int2="int2",e.int4="int4",e.int4range="int4range",e.int8="int8",e.int8range="int8range",e.json="json",e.jsonb="jsonb",e.money="money",e.numeric="numeric",e.oid="oid",e.reltime="reltime",e.text="text",e.time="time",e.timestamp="timestamp",e.timestamptz="timestamptz",e.timetz="timetz",e.tsrange="tsrange",e.tstzrange="tstzrange"})(hn||(hn={}));const cD=(e,t,n={})=>{var a;const r=(a=n.skipTypes)!==null&&a!==void 0?a:[];return t?Object.keys(t).reduce((s,i)=>(s[i]=eCe(i,e,t,r),s),{}):{}},eCe=(e,t,n,a)=>{const r=t.find(o=>o.name===e),s=r?.type,i=n[e];return s&&!a.includes(s)?cj(s,i):zk(i)},cj=(e,t)=>{if(e.charAt(0)==="_"){const n=e.slice(1,e.length);return rCe(t,n)}switch(e){case hn.bool:return tCe(t);case hn.float4:case hn.float8:case hn.int2:case hn.int4:case hn.int8:case hn.numeric:case hn.oid:return nCe(t);case hn.json:case hn.jsonb:return aCe(t);case hn.timestamp:return sCe(t);case hn.abstime:case hn.date:case hn.daterange:case hn.int4range:case hn.int8range:case hn.money:case hn.reltime:case hn.text:case hn.time:case hn.timestamptz:case hn.timetz:case hn.tsrange:case hn.tstzrange:return zk(t);default:return zk(t)}},zk=e=>e,tCe=e=>{switch(e){case"t":return!0;case"f":return!1;default:return e}},nCe=e=>{if(typeof e=="string"){const t=parseFloat(e);if(!Number.isNaN(t))return t}return e},aCe=e=>{if(typeof e=="string")try{return JSON.parse(e)}catch{return e}return e},rCe=(e,t)=>{if(typeof e!="string")return e;const n=e.length-1,a=e[n];if(e[0]==="{"&&a==="}"){let s;const i=e.slice(1,n);try{s=JSON.parse("["+i+"]")}catch{s=i?i.split(","):[]}return s.map(o=>cj(t,o))}return e},sCe=e=>typeof e=="string"?e.replace(" ","T"):e,dj=e=>{const t=new URL(e);return t.protocol=t.protocol.replace(/^ws/i,"http"),t.pathname=t.pathname.replace(/\/+$/,"").replace(/\/socket\/websocket$/i,"").replace(/\/socket$/i,"").replace(/\/websocket$/i,""),t.pathname===""||t.pathname==="/"?t.pathname="/api/broadcast":t.pathname=t.pathname+"/api/broadcast",t.href};class pS{constructor(t,n,a={},r=Mk){this.channel=t,this.event=n,this.payload=a,this.timeout=r,this.sent=!1,this.timeoutTimer=void 0,this.ref="",this.receivedResp=null,this.recHooks=[],this.refEvent=null}resend(t){this.timeout=t,this._cancelRefEvent(),this.ref="",this.refEvent=null,this.receivedResp=null,this.sent=!1,this.send()}send(){this._hasReceived("timeout")||(this.startTimeout(),this.sent=!0,this.channel.socket.push({topic:this.channel.topic,event:this.event,payload:this.payload,ref:this.ref,join_ref:this.channel._joinRef()}))}updatePayload(t){this.payload=Object.assign(Object.assign({},this.payload),t)}receive(t,n){var a;return this._hasReceived(t)&&n((a=this.receivedResp)===null||a===void 0?void 0:a.response),this.recHooks.push({status:t,callback:n}),this}startTimeout(){if(this.timeoutTimer)return;this.ref=this.channel.socket._makeRef(),this.refEvent=this.channel._replyEventName(this.ref);const t=n=>{this._cancelRefEvent(),this._cancelTimeout(),this.receivedResp=n,this._matchReceive(n)};this.channel._on(this.refEvent,{},t),this.timeoutTimer=setTimeout(()=>{this.trigger("timeout",{})},this.timeout)}trigger(t,n){this.refEvent&&this.channel._trigger(this.refEvent,{status:t,response:n})}destroy(){this._cancelRefEvent(),this._cancelTimeout()}_cancelRefEvent(){this.refEvent&&this.channel._off(this.refEvent,{})}_cancelTimeout(){clearTimeout(this.timeoutTimer),this.timeoutTimer=void 0}_matchReceive({status:t,response:n}){this.recHooks.filter(a=>a.status===t).forEach(a=>a.callback(n))}_hasReceived(t){return this.receivedResp&&this.receivedResp.status===t}}var dD;(function(e){e.SYNC="sync",e.JOIN="join",e.LEAVE="leave"})(dD||(dD={}));class Gm{constructor(t,n){this.channel=t,this.state={},this.pendingDiffs=[],this.joinRef=null,this.enabled=!1,this.caller={onJoin:()=>{},onLeave:()=>{},onSync:()=>{}};const a=n?.events||{state:"presence_state",diff:"presence_diff"};this.channel._on(a.state,{},r=>{const{onJoin:s,onLeave:i,onSync:o}=this.caller;this.joinRef=this.channel._joinRef(),this.state=Gm.syncState(this.state,r,s,i),this.pendingDiffs.forEach(u=>{this.state=Gm.syncDiff(this.state,u,s,i)}),this.pendingDiffs=[],o()}),this.channel._on(a.diff,{},r=>{const{onJoin:s,onLeave:i,onSync:o}=this.caller;this.inPendingSyncState()?this.pendingDiffs.push(r):(this.state=Gm.syncDiff(this.state,r,s,i),o())}),this.onJoin((r,s,i)=>{this.channel._trigger("presence",{event:"join",key:r,currentPresences:s,newPresences:i})}),this.onLeave((r,s,i)=>{this.channel._trigger("presence",{event:"leave",key:r,currentPresences:s,leftPresences:i})}),this.onSync(()=>{this.channel._trigger("presence",{event:"sync"})})}static syncState(t,n,a,r){const s=this.cloneDeep(t),i=this.transformState(n),o={},u={};return this.map(s,(d,c)=>{i[d]||(u[d]=c)}),this.map(i,(d,c)=>{const p=s[d];if(p){const m=c.map(x=>x.presence_ref),g=p.map(x=>x.presence_ref),b=c.filter(x=>g.indexOf(x.presence_ref)<0),v=p.filter(x=>m.indexOf(x.presence_ref)<0);b.length>0&&(o[d]=b),v.length>0&&(u[d]=v)}else o[d]=c}),this.syncDiff(s,{joins:o,leaves:u},a,r)}static syncDiff(t,n,a,r){const{joins:s,leaves:i}={joins:this.transformState(n.joins),leaves:this.transformState(n.leaves)};return a||(a=()=>{}),r||(r=()=>{}),this.map(s,(o,u)=>{var d;const c=(d=t[o])!==null&&d!==void 0?d:[];if(t[o]=this.cloneDeep(u),c.length>0){const p=t[o].map(g=>g.presence_ref),m=c.filter(g=>p.indexOf(g.presence_ref)<0);t[o].unshift(...m)}a(o,c,u)}),this.map(i,(o,u)=>{let d=t[o];if(!d)return;const c=u.map(p=>p.presence_ref);d=d.filter(p=>c.indexOf(p.presence_ref)<0),t[o]=d,r(o,d,u),d.length===0&&delete t[o]}),t}static map(t,n){return Object.getOwnPropertyNames(t).map(a=>n(a,t[a]))}static transformState(t){return t=this.cloneDeep(t),Object.getOwnPropertyNames(t).reduce((n,a)=>{const r=t[a];return"metas"in r?n[a]=r.metas.map(s=>(s.presence_ref=s.phx_ref,delete s.phx_ref,delete s.phx_ref_prev,s)):n[a]=r,n},{})}static cloneDeep(t){return JSON.parse(JSON.stringify(t))}onJoin(t){this.caller.onJoin=t}onLeave(t){this.caller.onLeave=t}onSync(t){this.caller.onSync=t}inPendingSyncState(){return!this.joinRef||this.joinRef!==this.channel._joinRef()}}var hD;(function(e){e.ALL="*",e.INSERT="INSERT",e.UPDATE="UPDATE",e.DELETE="DELETE"})(hD||(hD={}));var qm;(function(e){e.BROADCAST="broadcast",e.PRESENCE="presence",e.POSTGRES_CHANGES="postgres_changes",e.SYSTEM="system"})(qm||(qm={}));var Bi;(function(e){e.SUBSCRIBED="SUBSCRIBED",e.TIMED_OUT="TIMED_OUT",e.CLOSED="CLOSED",e.CHANNEL_ERROR="CHANNEL_ERROR"})(Bi||(Bi={}));class Eh{constructor(t,n={config:{}},a){var r,s;if(this.topic=t,this.params=n,this.socket=a,this.bindings={},this.state=ia.closed,this.joinedOnce=!1,this.pushBuffer=[],this.subTopic=t.replace(/^realtime:/i,""),this.params.config=Object.assign({broadcast:{ack:!1,self:!1},presence:{key:"",enabled:!1},private:!1},n.config),this.timeout=this.socket.timeout,this.joinPush=new pS(this,Os.join,this.params,this.timeout),this.rejoinTimer=new uj(()=>this._rejoinUntilConnected(),this.socket.reconnectAfterMs),this.joinPush.receive("ok",()=>{this.state=ia.joined,this.rejoinTimer.reset(),this.pushBuffer.forEach(i=>i.send()),this.pushBuffer=[]}),this._onClose(()=>{this.rejoinTimer.reset(),this.socket.log("channel",`close ${this.topic} ${this._joinRef()}`),this.state=ia.closed,this.socket._remove(this)}),this._onError(i=>{this._isLeaving()||this._isClosed()||(this.socket.log("channel",`error ${this.topic}`,i),this.state=ia.errored,this.rejoinTimer.scheduleTimeout())}),this.joinPush.receive("timeout",()=>{this._isJoining()&&(this.socket.log("channel",`timeout ${this.topic}`,this.joinPush.timeout),this.state=ia.errored,this.rejoinTimer.scheduleTimeout())}),this.joinPush.receive("error",i=>{this._isLeaving()||this._isClosed()||(this.socket.log("channel",`error ${this.topic}`,i),this.state=ia.errored,this.rejoinTimer.scheduleTimeout())}),this._on(Os.reply,{},(i,o)=>{this._trigger(this._replyEventName(o),i)}),this.presence=new Gm(this),this.broadcastEndpointURL=dj(this.socket.endPoint),this.private=this.params.config.private||!1,!this.private&&(!((s=(r=this.params.config)===null||r===void 0?void 0:r.broadcast)===null||s===void 0)&&s.replay))throw`tried to use replay on public channel '${this.topic}'. It must be a private channel.`}subscribe(t,n=this.timeout){var a,r,s;if(this.socket.isConnected()||this.socket.connect(),this.state==ia.closed){const{config:{broadcast:i,presence:o,private:u}}=this.params,d=(r=(a=this.bindings.postgres_changes)===null||a===void 0?void 0:a.map(g=>g.filter))!==null&&r!==void 0?r:[],c=!!this.bindings[qm.PRESENCE]&&this.bindings[qm.PRESENCE].length>0||((s=this.params.config.presence)===null||s===void 0?void 0:s.enabled)===!0,p={},m={broadcast:i,presence:Object.assign(Object.assign({},o),{enabled:c}),postgres_changes:d,private:u};this.socket.accessTokenValue&&(p.access_token=this.socket.accessTokenValue),this._onError(g=>t?.(Bi.CHANNEL_ERROR,g)),this._onClose(()=>t?.(Bi.CLOSED)),this.updateJoinPayload(Object.assign({config:m},p)),this.joinedOnce=!0,this._rejoin(n),this.joinPush.receive("ok",async({postgres_changes:g})=>{var b;if(this.socket._isManualToken()||this.socket.setAuth(),g===void 0){t?.(Bi.SUBSCRIBED);return}else{const v=this.bindings.postgres_changes,x=(b=v?.length)!==null&&b!==void 0?b:0,w=[];for(let k=0;k<x;k++){const N=v[k],{filter:{event:I,schema:T,table:$,filter:D}}=N,M=g&&g[k];if(M&&M.event===I&&Eh.isFilterValueEqual(M.schema,T)&&Eh.isFilterValueEqual(M.table,$)&&Eh.isFilterValueEqual(M.filter,D))w.push(Object.assign(Object.assign({},N),{id:M.id}));else{this.unsubscribe(),this.state=ia.errored,t?.(Bi.CHANNEL_ERROR,new Error("mismatch between server and client bindings for postgres changes"));return}}this.bindings.postgres_changes=w,t&&t(Bi.SUBSCRIBED);return}}).receive("error",g=>{this.state=ia.errored,t?.(Bi.CHANNEL_ERROR,new Error(JSON.stringify(Object.values(g).join(", ")||"error")))}).receive("timeout",()=>{t?.(Bi.TIMED_OUT)})}return this}presenceState(){return this.presence.state}async track(t,n={}){return await this.send({type:"presence",event:"track",payload:t},n.timeout||this.timeout)}async untrack(t={}){return await this.send({type:"presence",event:"untrack"},t)}on(t,n,a){return this.state===ia.joined&&t===qm.PRESENCE&&(this.socket.log("channel",`resubscribe to ${this.topic} due to change in presence callbacks on joined channel`),this.unsubscribe().then(async()=>await this.subscribe())),this._on(t,n,a)}async httpSend(t,n,a={}){var r;if(n==null)return Promise.reject("Payload is required for httpSend()");const s={apikey:this.socket.apiKey?this.socket.apiKey:"","Content-Type":"application/json"};this.socket.accessTokenValue&&(s.Authorization=`Bearer ${this.socket.accessTokenValue}`);const i={method:"POST",headers:s,body:JSON.stringify({messages:[{topic:this.subTopic,event:t,payload:n,private:this.private}]})},o=await this._fetchWithTimeout(this.broadcastEndpointURL,i,(r=a.timeout)!==null&&r!==void 0?r:this.timeout);if(o.status===202)return{success:!0};let u=o.statusText;try{const d=await o.json();u=d.error||d.message||u}catch{}return Promise.reject(new Error(u))}async send(t,n={}){var a,r;if(!this._canPush()&&t.type==="broadcast"){console.warn("Realtime send() is automatically falling back to REST API. This behavior will be deprecated in the future. Please use httpSend() explicitly for REST delivery.");const{event:s,payload:i}=t,o={apikey:this.socket.apiKey?this.socket.apiKey:"","Content-Type":"application/json"};this.socket.accessTokenValue&&(o.Authorization=`Bearer ${this.socket.accessTokenValue}`);const u={method:"POST",headers:o,body:JSON.stringify({messages:[{topic:this.subTopic,event:s,payload:i,private:this.private}]})};try{const d=await this._fetchWithTimeout(this.broadcastEndpointURL,u,(a=n.timeout)!==null&&a!==void 0?a:this.timeout);return await((r=d.body)===null||r===void 0?void 0:r.cancel()),d.ok?"ok":"error"}catch(d){return d.name==="AbortError"?"timed out":"error"}}else return new Promise(s=>{var i,o,u;const d=this._push(t.type,t,n.timeout||this.timeout);t.type==="broadcast"&&!(!((u=(o=(i=this.params)===null||i===void 0?void 0:i.config)===null||o===void 0?void 0:o.broadcast)===null||u===void 0)&&u.ack)&&s("ok"),d.receive("ok",()=>s("ok")),d.receive("error",()=>s("error")),d.receive("timeout",()=>s("timed out"))})}updateJoinPayload(t){this.joinPush.updatePayload(t)}unsubscribe(t=this.timeout){this.state=ia.leaving;const n=()=>{this.socket.log("channel",`leave ${this.topic}`),this._trigger(Os.close,"leave",this._joinRef())};this.joinPush.destroy();let a=null;return new Promise(r=>{a=new pS(this,Os.leave,{},t),a.receive("ok",()=>{n(),r("ok")}).receive("timeout",()=>{n(),r("timed out")}).receive("error",()=>{r("error")}),a.send(),this._canPush()||a.trigger("ok",{})}).finally(()=>{a?.destroy()})}teardown(){this.pushBuffer.forEach(t=>t.destroy()),this.pushBuffer=[],this.rejoinTimer.reset(),this.joinPush.destroy(),this.state=ia.closed,this.bindings={}}async _fetchWithTimeout(t,n,a){const r=new AbortController,s=setTimeout(()=>r.abort(),a),i=await this.socket.fetch(t,Object.assign(Object.assign({},n),{signal:r.signal}));return clearTimeout(s),i}_push(t,n,a=this.timeout){if(!this.joinedOnce)throw`tried to push '${t}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;let r=new pS(this,t,n,a);return this._canPush()?r.send():this._addToPushBuffer(r),r}_addToPushBuffer(t){if(t.startTimeout(),this.pushBuffer.push(t),this.pushBuffer.length>ZEe){const n=this.pushBuffer.shift();n&&(n.destroy(),this.socket.log("channel",`discarded push due to buffer overflow: ${n.event}`,n.payload))}}_onMessage(t,n,a){return n}_isMember(t){return this.topic===t}_joinRef(){return this.joinPush.ref}_trigger(t,n,a){var r,s;const i=t.toLocaleLowerCase(),{close:o,error:u,leave:d,join:c}=Os;if(a&&[o,u,d,c].indexOf(i)>=0&&a!==this._joinRef())return;let m=this._onMessage(i,n,a);if(n&&!m)throw"channel onMessage callbacks must return the payload, modified or unmodified";["insert","update","delete"].includes(i)?(r=this.bindings.postgres_changes)===null||r===void 0||r.filter(g=>{var b,v,x;return((b=g.filter)===null||b===void 0?void 0:b.event)==="*"||((x=(v=g.filter)===null||v===void 0?void 0:v.event)===null||x===void 0?void 0:x.toLocaleLowerCase())===i}).map(g=>g.callback(m,a)):(s=this.bindings[i])===null||s===void 0||s.filter(g=>{var b,v,x,w,k,N;if(["broadcast","presence","postgres_changes"].includes(i))if("id"in g){const I=g.id,T=(b=g.filter)===null||b===void 0?void 0:b.event;return I&&((v=n.ids)===null||v===void 0?void 0:v.includes(I))&&(T==="*"||T?.toLocaleLowerCase()===((x=n.data)===null||x===void 0?void 0:x.type.toLocaleLowerCase()))}else{const I=(k=(w=g?.filter)===null||w===void 0?void 0:w.event)===null||k===void 0?void 0:k.toLocaleLowerCase();return I==="*"||I===((N=n?.event)===null||N===void 0?void 0:N.toLocaleLowerCase())}else return g.type.toLocaleLowerCase()===i}).map(g=>{if(typeof m=="object"&&"ids"in m){const b=m.data,{schema:v,table:x,commit_timestamp:w,type:k,errors:N}=b;m=Object.assign(Object.assign({},{schema:v,table:x,commit_timestamp:w,eventType:k,new:{},old:{},errors:N}),this._getPayloadRecords(b))}g.callback(m,a)})}_isClosed(){return this.state===ia.closed}_isJoined(){return this.state===ia.joined}_isJoining(){return this.state===ia.joining}_isLeaving(){return this.state===ia.leaving}_replyEventName(t){return`chan_reply_${t}`}_on(t,n,a){const r=t.toLocaleLowerCase(),s={type:r,filter:n,callback:a};return this.bindings[r]?this.bindings[r].push(s):this.bindings[r]=[s],this}_off(t,n){const a=t.toLocaleLowerCase();return this.bindings[a]&&(this.bindings[a]=this.bindings[a].filter(r=>{var s;return!(((s=r.type)===null||s===void 0?void 0:s.toLocaleLowerCase())===a&&Eh.isEqual(r.filter,n))})),this}static isEqual(t,n){if(Object.keys(t).length!==Object.keys(n).length)return!1;for(const a in t)if(t[a]!==n[a])return!1;return!0}static isFilterValueEqual(t,n){return(t??void 0)===(n??void 0)}_rejoinUntilConnected(){this.rejoinTimer.scheduleTimeout(),this.socket.isConnected()&&this._rejoin()}_onClose(t){this._on(Os.close,{},t)}_onError(t){this._on(Os.error,{},n=>t(n))}_canPush(){return this.socket.isConnected()&&this._isJoined()}_rejoin(t=this.timeout){this._isLeaving()||(this.socket._leaveOpenTopic(this.topic),this.state=ia.joining,this.joinPush.resend(t))}_getPayloadRecords(t){const n={new:{},old:{}};return(t.type==="INSERT"||t.type==="UPDATE")&&(n.new=cD(t.columns,t.record)),(t.type==="UPDATE"||t.type==="DELETE")&&(n.old=cD(t.columns,t.old_record)),n}}const fS=()=>{},sv={HEARTBEAT_INTERVAL:25e3,RECONNECT_DELAY:10,HEARTBEAT_TIMEOUT_FALLBACK:100},iCe=[1e3,2e3,5e3,1e4],oCe=1e4,lCe=`
  addEventListener("message", (e) => {
    if (e.data.event === "start") {
      setInterval(() => postMessage({ event: "keepAlive" }), e.data.interval);
    }
  });`;class uCe{constructor(t,n){var a;if(this.accessTokenValue=null,this.apiKey=null,this._manuallySetToken=!1,this.channels=new Array,this.endPoint="",this.httpEndpoint="",this.headers={},this.params={},this.timeout=Mk,this.transport=null,this.heartbeatIntervalMs=sv.HEARTBEAT_INTERVAL,this.heartbeatTimer=void 0,this.pendingHeartbeatRef=null,this.heartbeatCallback=fS,this.ref=0,this.reconnectTimer=null,this.vsn=uD,this.logger=fS,this.conn=null,this.sendBuffer=[],this.serializer=new QEe,this.stateChangeCallbacks={open:[],close:[],error:[],message:[]},this.accessToken=null,this._connectionState="disconnected",this._wasManualDisconnect=!1,this._authPromise=null,this._resolveFetch=r=>r?(...s)=>r(...s):(...s)=>fetch(...s),!(!((a=n?.params)===null||a===void 0)&&a.apikey))throw new Error("API key is required to connect to Realtime");this.apiKey=n.params.apikey,this.endPoint=`${t}/${Fk.websocket}`,this.httpEndpoint=dj(t),this._initializeOptions(n),this._setupReconnectionTimer(),this.fetch=this._resolveFetch(n?.fetch)}connect(){if(!(this.isConnecting()||this.isDisconnecting()||this.conn!==null&&this.isConnected())){if(this._setConnectionState("connecting"),this.accessToken&&!this._authPromise&&this._setAuthSafely("connect"),this.transport)this.conn=new this.transport(this.endpointURL());else try{this.conn=qEe.createWebSocket(this.endpointURL())}catch(t){this._setConnectionState("disconnected");const n=t.message;throw n.includes("Node.js")?new Error(`${n}

To use Realtime in Node.js, you need to provide a WebSocket implementation:

Option 1: Use Node.js 22+ which has native WebSocket support
Option 2: Install and provide the "ws" package:

  npm install ws

  import ws from "ws"
  const client = new RealtimeClient(url, {
    ...options,
    transport: ws
  })`):new Error(`WebSocket not available: ${n}`)}this._setupConnectionHandlers()}}endpointURL(){return this._appendParams(this.endPoint,Object.assign({},this.params,{vsn:this.vsn}))}disconnect(t,n){if(!this.isDisconnecting())if(this._setConnectionState("disconnecting",!0),this.conn){const a=setTimeout(()=>{this._setConnectionState("disconnected")},100);this.conn.onclose=()=>{clearTimeout(a),this._setConnectionState("disconnected")},typeof this.conn.close=="function"&&(t?this.conn.close(t,n??""):this.conn.close()),this._teardownConnection()}else this._setConnectionState("disconnected")}getChannels(){return this.channels}async removeChannel(t){const n=await t.unsubscribe();return this.channels.length===0&&this.disconnect(),n}async removeAllChannels(){const t=await Promise.all(this.channels.map(n=>n.unsubscribe()));return this.channels=[],this.disconnect(),t}log(t,n,a){this.logger(t,n,a)}connectionState(){switch(this.conn&&this.conn.readyState){case Ho.connecting:return mu.Connecting;case Ho.open:return mu.Open;case Ho.closing:return mu.Closing;default:return mu.Closed}}isConnected(){return this.connectionState()===mu.Open}isConnecting(){return this._connectionState==="connecting"}isDisconnecting(){return this._connectionState==="disconnecting"}channel(t,n={config:{}}){const a=`realtime:${t}`,r=this.getChannels().find(s=>s.topic===a);if(r)return r;{const s=new Eh(`realtime:${t}`,n,this);return this.channels.push(s),s}}push(t){const{topic:n,event:a,payload:r,ref:s}=t,i=()=>{this.encode(t,o=>{var u;(u=this.conn)===null||u===void 0||u.send(o)})};this.log("push",`${n} ${a} (${s})`,r),this.isConnected()?i():this.sendBuffer.push(i)}async setAuth(t=null){this._authPromise=this._performAuth(t);try{await this._authPromise}finally{this._authPromise=null}}_isManualToken(){return this._manuallySetToken}async sendHeartbeat(){var t;if(!this.isConnected()){try{this.heartbeatCallback("disconnected")}catch(n){this.log("error","error in heartbeat callback",n)}return}if(this.pendingHeartbeatRef){this.pendingHeartbeatRef=null,this.log("transport","heartbeat timeout. Attempting to re-establish connection");try{this.heartbeatCallback("timeout")}catch(n){this.log("error","error in heartbeat callback",n)}this._wasManualDisconnect=!1,(t=this.conn)===null||t===void 0||t.close(JEe,"heartbeat timeout"),setTimeout(()=>{var n;this.isConnected()||(n=this.reconnectTimer)===null||n===void 0||n.scheduleTimeout()},sv.HEARTBEAT_TIMEOUT_FALLBACK);return}this.pendingHeartbeatRef=this._makeRef(),this.push({topic:"phoenix",event:"heartbeat",payload:{},ref:this.pendingHeartbeatRef});try{this.heartbeatCallback("sent")}catch(n){this.log("error","error in heartbeat callback",n)}this._setAuthSafely("heartbeat")}onHeartbeat(t){this.heartbeatCallback=t}flushSendBuffer(){this.isConnected()&&this.sendBuffer.length>0&&(this.sendBuffer.forEach(t=>t()),this.sendBuffer=[])}_makeRef(){let t=this.ref+1;return t===this.ref?this.ref=0:this.ref=t,this.ref.toString()}_leaveOpenTopic(t){let n=this.channels.find(a=>a.topic===t&&(a._isJoined()||a._isJoining()));n&&(this.log("transport",`leaving duplicate topic "${t}"`),n.unsubscribe())}_remove(t){this.channels=this.channels.filter(n=>n.topic!==t.topic)}_onConnMessage(t){this.decode(t.data,n=>{if(n.topic==="phoenix"&&n.event==="phx_reply")try{this.heartbeatCallback(n.payload.status==="ok"?"ok":"error")}catch(d){this.log("error","error in heartbeat callback",d)}n.ref&&n.ref===this.pendingHeartbeatRef&&(this.pendingHeartbeatRef=null);const{topic:a,event:r,payload:s,ref:i}=n,o=i?`(${i})`:"",u=s.status||"";this.log("receive",`${u} ${a} ${r} ${o}`.trim(),s),this.channels.filter(d=>d._isMember(a)).forEach(d=>d._trigger(r,s,i)),this._triggerStateCallbacks("message",n)})}_clearTimer(t){var n;t==="heartbeat"&&this.heartbeatTimer?(clearInterval(this.heartbeatTimer),this.heartbeatTimer=void 0):t==="reconnect"&&((n=this.reconnectTimer)===null||n===void 0||n.reset())}_clearAllTimers(){this._clearTimer("heartbeat"),this._clearTimer("reconnect")}_setupConnectionHandlers(){this.conn&&("binaryType"in this.conn&&(this.conn.binaryType="arraybuffer"),this.conn.onopen=()=>this._onConnOpen(),this.conn.onerror=t=>this._onConnError(t),this.conn.onmessage=t=>this._onConnMessage(t),this.conn.onclose=t=>this._onConnClose(t),this.conn.readyState===Ho.open&&this._onConnOpen())}_teardownConnection(){if(this.conn){if(this.conn.readyState===Ho.open||this.conn.readyState===Ho.connecting)try{this.conn.close()}catch(t){this.log("error","Error closing connection",t)}this.conn.onopen=null,this.conn.onerror=null,this.conn.onmessage=null,this.conn.onclose=null,this.conn=null}this._clearAllTimers(),this._terminateWorker(),this.channels.forEach(t=>t.teardown())}_onConnOpen(){this._setConnectionState("connected"),this.log("transport",`connected to ${this.endpointURL()}`),(this._authPromise||(this.accessToken&&!this.accessTokenValue?this.setAuth():Promise.resolve())).then(()=>{this.flushSendBuffer()}).catch(n=>{this.log("error","error waiting for auth on connect",n),this.flushSendBuffer()}),this._clearTimer("reconnect"),this.worker?this.workerRef||this._startWorkerHeartbeat():this._startHeartbeat(),this._triggerStateCallbacks("open")}_startHeartbeat(){this.heartbeatTimer&&clearInterval(this.heartbeatTimer),this.heartbeatTimer=setInterval(()=>this.sendHeartbeat(),this.heartbeatIntervalMs)}_startWorkerHeartbeat(){this.workerUrl?this.log("worker",`starting worker for from ${this.workerUrl}`):this.log("worker","starting default worker");const t=this._workerObjectUrl(this.workerUrl);this.workerRef=new Worker(t),this.workerRef.onerror=n=>{this.log("worker","worker error",n.message),this._terminateWorker()},this.workerRef.onmessage=n=>{n.data.event==="keepAlive"&&this.sendHeartbeat()},this.workerRef.postMessage({event:"start",interval:this.heartbeatIntervalMs})}_terminateWorker(){this.workerRef&&(this.log("worker","terminating worker"),this.workerRef.terminate(),this.workerRef=void 0)}_onConnClose(t){var n;this._setConnectionState("disconnected"),this.log("transport","close",t),this._triggerChanError(),this._clearTimer("heartbeat"),this._wasManualDisconnect||(n=this.reconnectTimer)===null||n===void 0||n.scheduleTimeout(),this._triggerStateCallbacks("close",t)}_onConnError(t){this._setConnectionState("disconnected"),this.log("transport",`${t}`),this._triggerChanError(),this._triggerStateCallbacks("error",t)}_triggerChanError(){this.channels.forEach(t=>t._trigger(Os.error))}_appendParams(t,n){if(Object.keys(n).length===0)return t;const a=t.match(/\?/)?"&":"?",r=new URLSearchParams(n);return`${t}${a}${r}`}_workerObjectUrl(t){let n;if(t)n=t;else{const a=new Blob([lCe],{type:"application/javascript"});n=URL.createObjectURL(a)}return n}_setConnectionState(t,n=!1){this._connectionState=t,t==="connecting"?this._wasManualDisconnect=!1:t==="disconnecting"&&(this._wasManualDisconnect=n)}async _performAuth(t=null){let n,a=!1;if(t)n=t,a=!0;else if(this.accessToken)try{n=await this.accessToken()}catch(r){this.log("error","Error fetching access token from callback",r),n=this.accessTokenValue}else n=this.accessTokenValue;a?this._manuallySetToken=!0:this.accessToken&&(this._manuallySetToken=!1),this.accessTokenValue!=n&&(this.accessTokenValue=n,this.channels.forEach(r=>{const s={access_token:n,version:XEe};n&&r.updateJoinPayload(s),r.joinedOnce&&r._isJoined()&&r._push(Os.access_token,{access_token:n})}))}async _waitForAuthIfNeeded(){this._authPromise&&await this._authPromise}_setAuthSafely(t="general"){this._isManualToken()||this.setAuth().catch(n=>{this.log("error",`Error setting auth in ${t}`,n)})}_triggerStateCallbacks(t,n){try{this.stateChangeCallbacks[t].forEach(a=>{try{a(n)}catch(r){this.log("error",`error in ${t} callback`,r)}})}catch(a){this.log("error",`error triggering ${t} callbacks`,a)}}_setupReconnectionTimer(){this.reconnectTimer=new uj(async()=>{setTimeout(async()=>{await this._waitForAuthIfNeeded(),this.isConnected()||this.connect()},sv.RECONNECT_DELAY)},this.reconnectAfterMs)}_initializeOptions(t){var n,a,r,s,i,o,u,d,c,p,m,g;switch(this.transport=(n=t?.transport)!==null&&n!==void 0?n:null,this.timeout=(a=t?.timeout)!==null&&a!==void 0?a:Mk,this.heartbeatIntervalMs=(r=t?.heartbeatIntervalMs)!==null&&r!==void 0?r:sv.HEARTBEAT_INTERVAL,this.worker=(s=t?.worker)!==null&&s!==void 0?s:!1,this.accessToken=(i=t?.accessToken)!==null&&i!==void 0?i:null,this.heartbeatCallback=(o=t?.heartbeatCallback)!==null&&o!==void 0?o:fS,this.vsn=(u=t?.vsn)!==null&&u!==void 0?u:uD,t?.params&&(this.params=t.params),t?.logger&&(this.logger=t.logger),(t?.logLevel||t?.log_level)&&(this.logLevel=t.logLevel||t.log_level,this.params=Object.assign(Object.assign({},this.params),{log_level:this.logLevel})),this.reconnectAfterMs=(d=t?.reconnectAfterMs)!==null&&d!==void 0?d:(b=>iCe[b-1]||oCe),this.vsn){case lj:this.encode=(c=t?.encode)!==null&&c!==void 0?c:((b,v)=>v(JSON.stringify(b))),this.decode=(p=t?.decode)!==null&&p!==void 0?p:((b,v)=>v(JSON.parse(b)));break;case YEe:this.encode=(m=t?.encode)!==null&&m!==void 0?m:this.serializer.encode.bind(this.serializer),this.decode=(g=t?.decode)!==null&&g!==void 0?g:this.serializer.decode.bind(this.serializer);break;default:throw new Error(`Unsupported serializer version: ${this.vsn}`)}if(this.worker){if(typeof window<"u"&&!window.Worker)throw new Error("Web Worker is not supported");this.workerUrl=t?.workerUrl}}}var mg=class extends Error{constructor(e,t){super(e),this.name="IcebergError",this.status=t.status,this.icebergType=t.icebergType,this.icebergCode=t.icebergCode,this.details=t.details,this.isCommitStateUnknown=t.icebergType==="CommitStateUnknownException"||[500,502,504].includes(t.status)&&t.icebergType?.includes("CommitState")===!0}isNotFound(){return this.status===404}isConflict(){return this.status===409}isAuthenticationTimeout(){return this.status===419}};function cCe(e,t,n){const a=new URL(t,e);if(n)for(const[r,s]of Object.entries(n))s!==void 0&&a.searchParams.set(r,s);return a.toString()}async function dCe(e){return!e||e.type==="none"?{}:e.type==="bearer"?{Authorization:`Bearer ${e.token}`}:e.type==="header"?{[e.name]:e.value}:e.type==="custom"?await e.getHeaders():{}}function hCe(e){const t=e.fetchImpl??globalThis.fetch;return{async request({method:n,path:a,query:r,body:s,headers:i}){const o=cCe(e.baseUrl,a,r),u=await dCe(e.auth),d=await t(o,{method:n,headers:{...s?{"Content-Type":"application/json"}:{},...u,...i},body:s?JSON.stringify(s):void 0}),c=await d.text(),p=(d.headers.get("content-type")||"").includes("application/json"),m=p&&c?JSON.parse(c):c;if(!d.ok){const g=p?m:void 0,b=g?.error;throw new mg(b?.message??`Request failed with status ${d.status}`,{status:d.status,icebergType:b?.type,icebergCode:b?.code,details:g})}return{status:d.status,headers:d.headers,data:m}}}}function iv(e){return e.join("")}var pCe=class{constructor(e,t=""){this.client=e,this.prefix=t}async listNamespaces(e){const t=e?{parent:iv(e.namespace)}:void 0;return(await this.client.request({method:"GET",path:`${this.prefix}/namespaces`,query:t})).data.namespaces.map(a=>({namespace:a}))}async createNamespace(e,t){const n={namespace:e.namespace,properties:t?.properties};return(await this.client.request({method:"POST",path:`${this.prefix}/namespaces`,body:n})).data}async dropNamespace(e){await this.client.request({method:"DELETE",path:`${this.prefix}/namespaces/${iv(e.namespace)}`})}async loadNamespaceMetadata(e){return{properties:(await this.client.request({method:"GET",path:`${this.prefix}/namespaces/${iv(e.namespace)}`})).data.properties}}async namespaceExists(e){try{return await this.client.request({method:"HEAD",path:`${this.prefix}/namespaces/${iv(e.namespace)}`}),!0}catch(t){if(t instanceof mg&&t.status===404)return!1;throw t}}async createNamespaceIfNotExists(e,t){try{return await this.createNamespace(e,t)}catch(n){if(n instanceof mg&&n.status===409)return;throw n}}};function fh(e){return e.join("")}var fCe=class{constructor(e,t="",n){this.client=e,this.prefix=t,this.accessDelegation=n}async listTables(e){return(await this.client.request({method:"GET",path:`${this.prefix}/namespaces/${fh(e.namespace)}/tables`})).data.identifiers}async createTable(e,t){const n={};return this.accessDelegation&&(n["X-Iceberg-Access-Delegation"]=this.accessDelegation),(await this.client.request({method:"POST",path:`${this.prefix}/namespaces/${fh(e.namespace)}/tables`,body:t,headers:n})).data.metadata}async updateTable(e,t){const n=await this.client.request({method:"POST",path:`${this.prefix}/namespaces/${fh(e.namespace)}/tables/${e.name}`,body:t});return{"metadata-location":n.data["metadata-location"],metadata:n.data.metadata}}async dropTable(e,t){await this.client.request({method:"DELETE",path:`${this.prefix}/namespaces/${fh(e.namespace)}/tables/${e.name}`,query:{purgeRequested:String(t?.purge??!1)}})}async loadTable(e){const t={};return this.accessDelegation&&(t["X-Iceberg-Access-Delegation"]=this.accessDelegation),(await this.client.request({method:"GET",path:`${this.prefix}/namespaces/${fh(e.namespace)}/tables/${e.name}`,headers:t})).data.metadata}async tableExists(e){const t={};this.accessDelegation&&(t["X-Iceberg-Access-Delegation"]=this.accessDelegation);try{return await this.client.request({method:"HEAD",path:`${this.prefix}/namespaces/${fh(e.namespace)}/tables/${e.name}`,headers:t}),!0}catch(n){if(n instanceof mg&&n.status===404)return!1;throw n}}async createTableIfNotExists(e,t){try{return await this.createTable(e,t)}catch(n){if(n instanceof mg&&n.status===409)return await this.loadTable({namespace:e.namespace,name:t.name});throw n}}},mCe=class{constructor(e){let t="v1";e.catalogName&&(t+=`/${e.catalogName}`);const n=e.baseUrl.endsWith("/")?e.baseUrl:`${e.baseUrl}/`;this.client=hCe({baseUrl:n,auth:e.auth,fetchImpl:e.fetch}),this.accessDelegation=e.accessDelegation?.join(","),this.namespaceOps=new pCe(this.client,t),this.tableOps=new fCe(this.client,t,this.accessDelegation)}async listNamespaces(e){return this.namespaceOps.listNamespaces(e)}async createNamespace(e,t){return this.namespaceOps.createNamespace(e,t)}async dropNamespace(e){await this.namespaceOps.dropNamespace(e)}async loadNamespaceMetadata(e){return this.namespaceOps.loadNamespaceMetadata(e)}async listTables(e){return this.tableOps.listTables(e)}async createTable(e,t){return this.tableOps.createTable(e,t)}async updateTable(e,t){return this.tableOps.updateTable(e,t)}async dropTable(e,t){await this.tableOps.dropTable(e,t)}async loadTable(e){return this.tableOps.loadTable(e)}async namespaceExists(e){return this.namespaceOps.namespaceExists(e)}async tableExists(e){return this.tableOps.tableExists(e)}async createNamespaceIfNotExists(e,t){return this.namespaceOps.createNamespaceIfNotExists(e,t)}async createTableIfNotExists(e,t){return this.tableOps.createTableIfNotExists(e,t)}},Mx=class extends Error{constructor(e){super(e),this.__isStorageError=!0,this.name="StorageError"}};function kn(e){return typeof e=="object"&&e!==null&&"__isStorageError"in e}var gCe=class extends Mx{constructor(e,t,n){super(e),this.name="StorageApiError",this.status=t,this.statusCode=n}toJSON(){return{name:this.name,message:this.message,status:this.status,statusCode:this.statusCode}}},Lk=class extends Mx{constructor(e,t){super(e),this.name="StorageUnknownError",this.originalError=t}};const wT=e=>e?(...t)=>e(...t):(...t)=>fetch(...t),yCe=()=>Response,Bk=e=>{if(Array.isArray(e))return e.map(n=>Bk(n));if(typeof e=="function"||e!==Object(e))return e;const t={};return Object.entries(e).forEach(([n,a])=>{const r=n.replace(/([-_][a-z])/gi,s=>s.toUpperCase().replace(/[-_]/g,""));t[r]=Bk(a)}),t},bCe=e=>{if(typeof e!="object"||e===null)return!1;const t=Object.getPrototypeOf(e);return(t===null||t===Object.prototype||Object.getPrototypeOf(t)===null)&&!(Symbol.toStringTag in e)&&!(Symbol.iterator in e)},vCe=e=>!e||typeof e!="string"||e.length===0||e.length>100||e.trim()!==e||e.includes("/")||e.includes("\\")?!1:/^[\w!.\*'() &$@=;:+,?-]+$/.test(e);function gg(e){"@babel/helpers - typeof";return gg=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(t){return typeof t}:function(t){return t&&typeof Symbol=="function"&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},gg(e)}function xCe(e,t){if(gg(e)!="object"||!e)return e;var n=e[Symbol.toPrimitive];if(n!==void 0){var a=n.call(e,t);if(gg(a)!="object")return a;throw new TypeError("@@toPrimitive must return a primitive value.")}return(t==="string"?String:Number)(e)}function wCe(e){var t=xCe(e,"string");return gg(t)=="symbol"?t:t+""}function SCe(e,t,n){return(t=wCe(t))in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function pD(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter(function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable})),n.push.apply(n,a)}return n}function Qe(e){for(var t=1;t<arguments.length;t++){var n=arguments[t]!=null?arguments[t]:{};t%2?pD(Object(n),!0).forEach(function(a){SCe(e,a,n[a])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):pD(Object(n)).forEach(function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(n,a))})}return e}const mS=e=>{var t;return e.msg||e.message||e.error_description||(typeof e.error=="string"?e.error:(t=e.error)===null||t===void 0?void 0:t.message)||JSON.stringify(e)},kCe=async(e,t,n)=>{e instanceof await yCe()&&!n?.noResolveJson?e.json().then(a=>{const r=e.status||500,s=a?.statusCode||r+"";t(new gCe(mS(a),r,s))}).catch(a=>{t(new Lk(mS(a),a))}):t(new Lk(mS(e),e))},_Ce=(e,t,n,a)=>{const r={method:e,headers:t?.headers||{}};return e==="GET"||!a?r:(bCe(a)?(r.headers=Qe({"Content-Type":"application/json"},t?.headers),r.body=JSON.stringify(a)):r.body=a,t?.duplex&&(r.duplex=t.duplex),Qe(Qe({},r),n))};async function Ay(e,t,n,a,r,s){return new Promise((i,o)=>{e(n,_Ce(t,a,r,s)).then(u=>{if(!u.ok)throw u;return a?.noResolveJson?u:u.json()}).then(u=>i(u)).catch(u=>kCe(u,o,a))})}async function yg(e,t,n,a){return Ay(e,"GET",t,n,a)}async function Ds(e,t,n,a,r){return Ay(e,"POST",t,a,r,n)}async function Pk(e,t,n,a,r){return Ay(e,"PUT",t,a,r,n)}async function NCe(e,t,n,a){return Ay(e,"HEAD",t,Qe(Qe({},n),{},{noResolveJson:!0}),a)}async function ST(e,t,n,a,r){return Ay(e,"DELETE",t,a,r,n)}var ICe=class{constructor(e,t){this.downloadFn=e,this.shouldThrowOnError=t}then(e,t){return this.execute().then(e,t)}async execute(){var e=this;try{return{data:(await e.downloadFn()).body,error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(kn(t))return{data:null,error:t};throw t}}};let hj;hj=Symbol.toStringTag;var TCe=class{constructor(e,t){this.downloadFn=e,this.shouldThrowOnError=t,this[hj]="BlobDownloadBuilder",this.promise=null}asStream(){return new ICe(this.downloadFn,this.shouldThrowOnError)}then(e,t){return this.getPromise().then(e,t)}catch(e){return this.getPromise().catch(e)}finally(e){return this.getPromise().finally(e)}getPromise(){return this.promise||(this.promise=this.execute()),this.promise}async execute(){var e=this;try{return{data:await(await e.downloadFn()).blob(),error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(kn(t))return{data:null,error:t};throw t}}};const ECe={limit:100,offset:0,sortBy:{column:"name",order:"asc"}},fD={cacheControl:"3600",contentType:"text/plain;charset=UTF-8",upsert:!1};var CCe=class{constructor(e,t={},n,a){this.shouldThrowOnError=!1,this.url=e,this.headers=t,this.bucketId=n,this.fetch=wT(a)}throwOnError(){return this.shouldThrowOnError=!0,this}async uploadOrUpdate(e,t,n,a){var r=this;try{let s;const i=Qe(Qe({},fD),a);let o=Qe(Qe({},r.headers),e==="POST"&&{"x-upsert":String(i.upsert)});const u=i.metadata;typeof Blob<"u"&&n instanceof Blob?(s=new FormData,s.append("cacheControl",i.cacheControl),u&&s.append("metadata",r.encodeMetadata(u)),s.append("",n)):typeof FormData<"u"&&n instanceof FormData?(s=n,s.has("cacheControl")||s.append("cacheControl",i.cacheControl),u&&!s.has("metadata")&&s.append("metadata",r.encodeMetadata(u))):(s=n,o["cache-control"]=`max-age=${i.cacheControl}`,o["content-type"]=i.contentType,u&&(o["x-metadata"]=r.toBase64(r.encodeMetadata(u))),(typeof ReadableStream<"u"&&s instanceof ReadableStream||s&&typeof s=="object"&&"pipe"in s&&typeof s.pipe=="function")&&!i.duplex&&(i.duplex="half")),a?.headers&&(o=Qe(Qe({},o),a.headers));const d=r._removeEmptyFolders(t),c=r._getFinalPath(d),p=await(e=="PUT"?Pk:Ds)(r.fetch,`${r.url}/object/${c}`,s,Qe({headers:o},i?.duplex?{duplex:i.duplex}:{}));return{data:{path:d,id:p.Id,fullPath:p.Key},error:null}}catch(s){if(r.shouldThrowOnError)throw s;if(kn(s))return{data:null,error:s};throw s}}async upload(e,t,n){return this.uploadOrUpdate("POST",e,t,n)}async uploadToSignedUrl(e,t,n,a){var r=this;const s=r._removeEmptyFolders(e),i=r._getFinalPath(s),o=new URL(r.url+`/object/upload/sign/${i}`);o.searchParams.set("token",t);try{let u;const d=Qe({upsert:fD.upsert},a),c=Qe(Qe({},r.headers),{"x-upsert":String(d.upsert)});return typeof Blob<"u"&&n instanceof Blob?(u=new FormData,u.append("cacheControl",d.cacheControl),u.append("",n)):typeof FormData<"u"&&n instanceof FormData?(u=n,u.append("cacheControl",d.cacheControl)):(u=n,c["cache-control"]=`max-age=${d.cacheControl}`,c["content-type"]=d.contentType),{data:{path:s,fullPath:(await Pk(r.fetch,o.toString(),u,{headers:c})).Key},error:null}}catch(u){if(r.shouldThrowOnError)throw u;if(kn(u))return{data:null,error:u};throw u}}async createSignedUploadUrl(e,t){var n=this;try{let a=n._getFinalPath(e);const r=Qe({},n.headers);t?.upsert&&(r["x-upsert"]="true");const s=await Ds(n.fetch,`${n.url}/object/upload/sign/${a}`,{},{headers:r}),i=new URL(n.url+s.url),o=i.searchParams.get("token");if(!o)throw new Mx("No token returned by API");return{data:{signedUrl:i.toString(),path:e,token:o},error:null}}catch(a){if(n.shouldThrowOnError)throw a;if(kn(a))return{data:null,error:a};throw a}}async update(e,t,n){return this.uploadOrUpdate("PUT",e,t,n)}async move(e,t,n){var a=this;try{return{data:await Ds(a.fetch,`${a.url}/object/move`,{bucketId:a.bucketId,sourceKey:e,destinationKey:t,destinationBucket:n?.destinationBucket},{headers:a.headers}),error:null}}catch(r){if(a.shouldThrowOnError)throw r;if(kn(r))return{data:null,error:r};throw r}}async copy(e,t,n){var a=this;try{return{data:{path:(await Ds(a.fetch,`${a.url}/object/copy`,{bucketId:a.bucketId,sourceKey:e,destinationKey:t,destinationBucket:n?.destinationBucket},{headers:a.headers})).Key},error:null}}catch(r){if(a.shouldThrowOnError)throw r;if(kn(r))return{data:null,error:r};throw r}}async createSignedUrl(e,t,n){var a=this;try{let r=a._getFinalPath(e),s=await Ds(a.fetch,`${a.url}/object/sign/${r}`,Qe({expiresIn:t},n?.transform?{transform:n.transform}:{}),{headers:a.headers});const i=n?.download?`&download=${n.download===!0?"":n.download}`:"";return s={signedUrl:encodeURI(`${a.url}${s.signedURL}${i}`)},{data:s,error:null}}catch(r){if(a.shouldThrowOnError)throw r;if(kn(r))return{data:null,error:r};throw r}}async createSignedUrls(e,t,n){var a=this;try{const r=await Ds(a.fetch,`${a.url}/object/sign/${a.bucketId}`,{expiresIn:t,paths:e},{headers:a.headers}),s=n?.download?`&download=${n.download===!0?"":n.download}`:"";return{data:r.map(i=>Qe(Qe({},i),{},{signedUrl:i.signedURL?encodeURI(`${a.url}${i.signedURL}${s}`):null})),error:null}}catch(r){if(a.shouldThrowOnError)throw r;if(kn(r))return{data:null,error:r};throw r}}download(e,t){const n=typeof t?.transform<"u"?"render/image/authenticated":"object",a=this.transformOptsToQueryString(t?.transform||{}),r=a?`?${a}`:"",s=this._getFinalPath(e),i=()=>yg(this.fetch,`${this.url}/${n}/${s}${r}`,{headers:this.headers,noResolveJson:!0});return new TCe(i,this.shouldThrowOnError)}async info(e){var t=this;const n=t._getFinalPath(e);try{return{data:Bk(await yg(t.fetch,`${t.url}/object/info/${n}`,{headers:t.headers})),error:null}}catch(a){if(t.shouldThrowOnError)throw a;if(kn(a))return{data:null,error:a};throw a}}async exists(e){var t=this;const n=t._getFinalPath(e);try{return await NCe(t.fetch,`${t.url}/object/${n}`,{headers:t.headers}),{data:!0,error:null}}catch(a){if(t.shouldThrowOnError)throw a;if(kn(a)&&a instanceof Lk){const r=a.originalError;if([400,404].includes(r?.status))return{data:!1,error:a}}throw a}}getPublicUrl(e,t){const n=this._getFinalPath(e),a=[],r=t?.download?`download=${t.download===!0?"":t.download}`:"";r!==""&&a.push(r);const s=typeof t?.transform<"u"?"render/image":"object",i=this.transformOptsToQueryString(t?.transform||{});i!==""&&a.push(i);let o=a.join("&");return o!==""&&(o=`?${o}`),{data:{publicUrl:encodeURI(`${this.url}/${s}/public/${n}${o}`)}}}async remove(e){var t=this;try{return{data:await ST(t.fetch,`${t.url}/object/${t.bucketId}`,{prefixes:e},{headers:t.headers}),error:null}}catch(n){if(t.shouldThrowOnError)throw n;if(kn(n))return{data:null,error:n};throw n}}async list(e,t,n){var a=this;try{const r=Qe(Qe(Qe({},ECe),t),{},{prefix:e||""});return{data:await Ds(a.fetch,`${a.url}/object/list/${a.bucketId}`,r,{headers:a.headers},n),error:null}}catch(r){if(a.shouldThrowOnError)throw r;if(kn(r))return{data:null,error:r};throw r}}async listV2(e,t){var n=this;try{const a=Qe({},e);return{data:await Ds(n.fetch,`${n.url}/object/list-v2/${n.bucketId}`,a,{headers:n.headers},t),error:null}}catch(a){if(n.shouldThrowOnError)throw a;if(kn(a))return{data:null,error:a};throw a}}encodeMetadata(e){return JSON.stringify(e)}toBase64(e){return typeof Buffer<"u"?Buffer.from(e).toString("base64"):btoa(e)}_getFinalPath(e){return`${this.bucketId}/${e.replace(/^\/+/,"")}`}_removeEmptyFolders(e){return e.replace(/^\/|\/$/g,"").replace(/\/+/g,"/")}transformOptsToQueryString(e){const t=[];return e.width&&t.push(`width=${e.width}`),e.height&&t.push(`height=${e.height}`),e.resize&&t.push(`resize=${e.resize}`),e.format&&t.push(`format=${e.format}`),e.quality&&t.push(`quality=${e.quality}`),t.join("&")}};const pj="2.89.0",fj={"X-Client-Info":`storage-js/${pj}`};var ACe=class{constructor(e,t={},n,a){this.shouldThrowOnError=!1;const r=new URL(e);a?.useNewHostname&&/supabase\.(co|in|red)$/.test(r.hostname)&&!r.hostname.includes("storage.supabase.")&&(r.hostname=r.hostname.replace("supabase.","storage.supabase.")),this.url=r.href.replace(/\/$/,""),this.headers=Qe(Qe({},fj),t),this.fetch=wT(n)}throwOnError(){return this.shouldThrowOnError=!0,this}async listBuckets(e){var t=this;try{const n=t.listBucketOptionsToQueryString(e);return{data:await yg(t.fetch,`${t.url}/bucket${n}`,{headers:t.headers}),error:null}}catch(n){if(t.shouldThrowOnError)throw n;if(kn(n))return{data:null,error:n};throw n}}async getBucket(e){var t=this;try{return{data:await yg(t.fetch,`${t.url}/bucket/${e}`,{headers:t.headers}),error:null}}catch(n){if(t.shouldThrowOnError)throw n;if(kn(n))return{data:null,error:n};throw n}}async createBucket(e,t={public:!1}){var n=this;try{return{data:await Ds(n.fetch,`${n.url}/bucket`,{id:e,name:e,type:t.type,public:t.public,file_size_limit:t.fileSizeLimit,allowed_mime_types:t.allowedMimeTypes},{headers:n.headers}),error:null}}catch(a){if(n.shouldThrowOnError)throw a;if(kn(a))return{data:null,error:a};throw a}}async updateBucket(e,t){var n=this;try{return{data:await Pk(n.fetch,`${n.url}/bucket/${e}`,{id:e,name:e,public:t.public,file_size_limit:t.fileSizeLimit,allowed_mime_types:t.allowedMimeTypes},{headers:n.headers}),error:null}}catch(a){if(n.shouldThrowOnError)throw a;if(kn(a))return{data:null,error:a};throw a}}async emptyBucket(e){var t=this;try{return{data:await Ds(t.fetch,`${t.url}/bucket/${e}/empty`,{},{headers:t.headers}),error:null}}catch(n){if(t.shouldThrowOnError)throw n;if(kn(n))return{data:null,error:n};throw n}}async deleteBucket(e){var t=this;try{return{data:await ST(t.fetch,`${t.url}/bucket/${e}`,{},{headers:t.headers}),error:null}}catch(n){if(t.shouldThrowOnError)throw n;if(kn(n))return{data:null,error:n};throw n}}listBucketOptionsToQueryString(e){const t={};return e&&("limit"in e&&(t.limit=String(e.limit)),"offset"in e&&(t.offset=String(e.offset)),e.search&&(t.search=e.search),e.sortColumn&&(t.sortColumn=e.sortColumn),e.sortOrder&&(t.sortOrder=e.sortOrder)),Object.keys(t).length>0?"?"+new URLSearchParams(t).toString():""}},$Ce=class{constructor(e,t={},n){this.shouldThrowOnError=!1,this.url=e.replace(/\/$/,""),this.headers=Qe(Qe({},fj),t),this.fetch=wT(n)}throwOnError(){return this.shouldThrowOnError=!0,this}async createBucket(e){var t=this;try{return{data:await Ds(t.fetch,`${t.url}/bucket`,{name:e},{headers:t.headers}),error:null}}catch(n){if(t.shouldThrowOnError)throw n;if(kn(n))return{data:null,error:n};throw n}}async listBuckets(e){var t=this;try{const n=new URLSearchParams;e?.limit!==void 0&&n.set("limit",e.limit.toString()),e?.offset!==void 0&&n.set("offset",e.offset.toString()),e?.sortColumn&&n.set("sortColumn",e.sortColumn),e?.sortOrder&&n.set("sortOrder",e.sortOrder),e?.search&&n.set("search",e.search);const a=n.toString(),r=a?`${t.url}/bucket?${a}`:`${t.url}/bucket`;return{data:await yg(t.fetch,r,{headers:t.headers}),error:null}}catch(n){if(t.shouldThrowOnError)throw n;if(kn(n))return{data:null,error:n};throw n}}async deleteBucket(e){var t=this;try{return{data:await ST(t.fetch,`${t.url}/bucket/${e}`,{},{headers:t.headers}),error:null}}catch(n){if(t.shouldThrowOnError)throw n;if(kn(n))return{data:null,error:n};throw n}}from(e){var t=this;if(!vCe(e))throw new Mx("Invalid bucket name: File, folder, and bucket names must follow AWS object key naming guidelines and should avoid the use of any other characters.");const n=new mCe({baseUrl:this.url,catalogName:e,auth:{type:"custom",getHeaders:async()=>t.headers},fetch:this.fetch}),a=this.shouldThrowOnError;return new Proxy(n,{get(r,s){const i=r[s];return typeof i!="function"?i:async(...o)=>{try{return{data:await i.apply(r,o),error:null}}catch(u){if(a)throw u;return{data:null,error:u}}}}})}};const kT={"X-Client-Info":`storage-js/${pj}`,"Content-Type":"application/json"};var mj=class extends Error{constructor(e){super(e),this.__isStorageVectorsError=!0,this.name="StorageVectorsError"}};function Vr(e){return typeof e=="object"&&e!==null&&"__isStorageVectorsError"in e}var gS=class extends mj{constructor(e,t,n){super(e),this.name="StorageVectorsApiError",this.status=t,this.statusCode=n}toJSON(){return{name:this.name,message:this.message,status:this.status,statusCode:this.statusCode}}},RCe=class extends mj{constructor(e,t){super(e),this.name="StorageVectorsUnknownError",this.originalError=t}};const _T=e=>e?(...t)=>e(...t):(...t)=>fetch(...t),DCe=e=>{if(typeof e!="object"||e===null)return!1;const t=Object.getPrototypeOf(e);return(t===null||t===Object.prototype||Object.getPrototypeOf(t)===null)&&!(Symbol.toStringTag in e)&&!(Symbol.iterator in e)},mD=e=>e.msg||e.message||e.error_description||e.error||JSON.stringify(e),OCe=async(e,t,n)=>{if(e&&typeof e=="object"&&"status"in e&&"ok"in e&&typeof e.status=="number"&&!n?.noResolveJson){const a=e.status||500,r=e;if(typeof r.json=="function")r.json().then(s=>{const i=s?.statusCode||s?.code||a+"";t(new gS(mD(s),a,i))}).catch(()=>{const s=a+"";t(new gS(r.statusText||`HTTP ${a} error`,a,s))});else{const s=a+"";t(new gS(r.statusText||`HTTP ${a} error`,a,s))}}else t(new RCe(mD(e),e))},MCe=(e,t,n,a)=>{const r={method:e,headers:t?.headers||{}};return a?(DCe(a)?(r.headers=Qe({"Content-Type":"application/json"},t?.headers),r.body=JSON.stringify(a)):r.body=a,Qe(Qe({},r),n)):r};async function FCe(e,t,n,a,r,s){return new Promise((i,o)=>{e(n,MCe(t,a,r,s)).then(u=>{if(!u.ok)throw u;if(a?.noResolveJson)return u;const d=u.headers.get("content-type");return!d||!d.includes("application/json")?{}:u.json()}).then(u=>i(u)).catch(u=>OCe(u,o,a))})}async function Hr(e,t,n,a,r){return FCe(e,"POST",t,a,r,n)}var zCe=class{constructor(e,t={},n){this.shouldThrowOnError=!1,this.url=e.replace(/\/$/,""),this.headers=Qe(Qe({},kT),t),this.fetch=_T(n)}throwOnError(){return this.shouldThrowOnError=!0,this}async createIndex(e){var t=this;try{return{data:await Hr(t.fetch,`${t.url}/CreateIndex`,e,{headers:t.headers})||{},error:null}}catch(n){if(t.shouldThrowOnError)throw n;if(Vr(n))return{data:null,error:n};throw n}}async getIndex(e,t){var n=this;try{return{data:await Hr(n.fetch,`${n.url}/GetIndex`,{vectorBucketName:e,indexName:t},{headers:n.headers}),error:null}}catch(a){if(n.shouldThrowOnError)throw a;if(Vr(a))return{data:null,error:a};throw a}}async listIndexes(e){var t=this;try{return{data:await Hr(t.fetch,`${t.url}/ListIndexes`,e,{headers:t.headers}),error:null}}catch(n){if(t.shouldThrowOnError)throw n;if(Vr(n))return{data:null,error:n};throw n}}async deleteIndex(e,t){var n=this;try{return{data:await Hr(n.fetch,`${n.url}/DeleteIndex`,{vectorBucketName:e,indexName:t},{headers:n.headers})||{},error:null}}catch(a){if(n.shouldThrowOnError)throw a;if(Vr(a))return{data:null,error:a};throw a}}},LCe=class{constructor(e,t={},n){this.shouldThrowOnError=!1,this.url=e.replace(/\/$/,""),this.headers=Qe(Qe({},kT),t),this.fetch=_T(n)}throwOnError(){return this.shouldThrowOnError=!0,this}async putVectors(e){var t=this;try{if(e.vectors.length<1||e.vectors.length>500)throw new Error("Vector batch size must be between 1 and 500 items");return{data:await Hr(t.fetch,`${t.url}/PutVectors`,e,{headers:t.headers})||{},error:null}}catch(n){if(t.shouldThrowOnError)throw n;if(Vr(n))return{data:null,error:n};throw n}}async getVectors(e){var t=this;try{return{data:await Hr(t.fetch,`${t.url}/GetVectors`,e,{headers:t.headers}),error:null}}catch(n){if(t.shouldThrowOnError)throw n;if(Vr(n))return{data:null,error:n};throw n}}async listVectors(e){var t=this;try{if(e.segmentCount!==void 0){if(e.segmentCount<1||e.segmentCount>16)throw new Error("segmentCount must be between 1 and 16");if(e.segmentIndex!==void 0&&(e.segmentIndex<0||e.segmentIndex>=e.segmentCount))throw new Error(`segmentIndex must be between 0 and ${e.segmentCount-1}`)}return{data:await Hr(t.fetch,`${t.url}/ListVectors`,e,{headers:t.headers}),error:null}}catch(n){if(t.shouldThrowOnError)throw n;if(Vr(n))return{data:null,error:n};throw n}}async queryVectors(e){var t=this;try{return{data:await Hr(t.fetch,`${t.url}/QueryVectors`,e,{headers:t.headers}),error:null}}catch(n){if(t.shouldThrowOnError)throw n;if(Vr(n))return{data:null,error:n};throw n}}async deleteVectors(e){var t=this;try{if(e.keys.length<1||e.keys.length>500)throw new Error("Keys batch size must be between 1 and 500 items");return{data:await Hr(t.fetch,`${t.url}/DeleteVectors`,e,{headers:t.headers})||{},error:null}}catch(n){if(t.shouldThrowOnError)throw n;if(Vr(n))return{data:null,error:n};throw n}}},BCe=class{constructor(e,t={},n){this.shouldThrowOnError=!1,this.url=e.replace(/\/$/,""),this.headers=Qe(Qe({},kT),t),this.fetch=_T(n)}throwOnError(){return this.shouldThrowOnError=!0,this}async createBucket(e){var t=this;try{return{data:await Hr(t.fetch,`${t.url}/CreateVectorBucket`,{vectorBucketName:e},{headers:t.headers})||{},error:null}}catch(n){if(t.shouldThrowOnError)throw n;if(Vr(n))return{data:null,error:n};throw n}}async getBucket(e){var t=this;try{return{data:await Hr(t.fetch,`${t.url}/GetVectorBucket`,{vectorBucketName:e},{headers:t.headers}),error:null}}catch(n){if(t.shouldThrowOnError)throw n;if(Vr(n))return{data:null,error:n};throw n}}async listBuckets(e={}){var t=this;try{return{data:await Hr(t.fetch,`${t.url}/ListVectorBuckets`,e,{headers:t.headers}),error:null}}catch(n){if(t.shouldThrowOnError)throw n;if(Vr(n))return{data:null,error:n};throw n}}async deleteBucket(e){var t=this;try{return{data:await Hr(t.fetch,`${t.url}/DeleteVectorBucket`,{vectorBucketName:e},{headers:t.headers})||{},error:null}}catch(n){if(t.shouldThrowOnError)throw n;if(Vr(n))return{data:null,error:n};throw n}}},PCe=class extends BCe{constructor(e,t={}){super(e,t.headers||{},t.fetch)}from(e){return new UCe(this.url,this.headers,e,this.fetch)}async createBucket(e){var t=()=>super.createBucket,n=this;return t().call(n,e)}async getBucket(e){var t=()=>super.getBucket,n=this;return t().call(n,e)}async listBuckets(e={}){var t=()=>super.listBuckets,n=this;return t().call(n,e)}async deleteBucket(e){var t=()=>super.deleteBucket,n=this;return t().call(n,e)}},UCe=class extends zCe{constructor(e,t,n,a){super(e,t,a),this.vectorBucketName=n}async createIndex(e){var t=()=>super.createIndex,n=this;return t().call(n,Qe(Qe({},e),{},{vectorBucketName:n.vectorBucketName}))}async listIndexes(e={}){var t=()=>super.listIndexes,n=this;return t().call(n,Qe(Qe({},e),{},{vectorBucketName:n.vectorBucketName}))}async getIndex(e){var t=()=>super.getIndex,n=this;return t().call(n,n.vectorBucketName,e)}async deleteIndex(e){var t=()=>super.deleteIndex,n=this;return t().call(n,n.vectorBucketName,e)}index(e){return new jCe(this.url,this.headers,this.vectorBucketName,e,this.fetch)}},jCe=class extends LCe{constructor(e,t,n,a,r){super(e,t,r),this.vectorBucketName=n,this.indexName=a}async putVectors(e){var t=()=>super.putVectors,n=this;return t().call(n,Qe(Qe({},e),{},{vectorBucketName:n.vectorBucketName,indexName:n.indexName}))}async getVectors(e){var t=()=>super.getVectors,n=this;return t().call(n,Qe(Qe({},e),{},{vectorBucketName:n.vectorBucketName,indexName:n.indexName}))}async listVectors(e={}){var t=()=>super.listVectors,n=this;return t().call(n,Qe(Qe({},e),{},{vectorBucketName:n.vectorBucketName,indexName:n.indexName}))}async queryVectors(e){var t=()=>super.queryVectors,n=this;return t().call(n,Qe(Qe({},e),{},{vectorBucketName:n.vectorBucketName,indexName:n.indexName}))}async deleteVectors(e){var t=()=>super.deleteVectors,n=this;return t().call(n,Qe(Qe({},e),{},{vectorBucketName:n.vectorBucketName,indexName:n.indexName}))}},WCe=class extends ACe{constructor(e,t={},n,a){super(e,t,n,a)}from(e){return new CCe(this.url,this.headers,e,this.fetch)}get vectors(){return new PCe(this.url+"/vector",{headers:this.headers,fetch:this.fetch})}get analytics(){return new $Ce(this.url+"/iceberg",this.headers,this.fetch)}};const gj="2.89.0",_h=30*1e3,Uk=3,yS=Uk*_h,VCe="http://localhost:9999",HCe="supabase.auth.token",GCe={"X-Client-Info":`gotrue-js/${gj}`},jk="X-Supabase-Api-Version",yj={"2024-01-01":{timestamp:Date.parse("2024-01-01T00:00:00.0Z"),name:"2024-01-01"}},qCe=/^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}$|[a-z0-9_-]{2}$)$/i,KCe=600*1e3;class bg extends Error{constructor(t,n,a){super(t),this.__isAuthError=!0,this.name="AuthError",this.status=n,this.code=a}}function qe(e){return typeof e=="object"&&e!==null&&"__isAuthError"in e}class XCe extends bg{constructor(t,n,a){super(t,n,a),this.name="AuthApiError",this.status=n,this.code=a}}function YCe(e){return qe(e)&&e.name==="AuthApiError"}class gu extends bg{constructor(t,n){super(t),this.name="AuthUnknownError",this.originalError=n}}class io extends bg{constructor(t,n,a,r){super(t,a,r),this.name=n,this.status=a}}class Wr extends io{constructor(){super("Auth session missing!","AuthSessionMissingError",400,void 0)}}function JCe(e){return qe(e)&&e.name==="AuthSessionMissingError"}class mh extends io{constructor(){super("Auth session or user missing","AuthInvalidTokenResponseError",500,void 0)}}class ov extends io{constructor(t){super(t,"AuthInvalidCredentialsError",400,void 0)}}class lv extends io{constructor(t,n=null){super(t,"AuthImplicitGrantRedirectError",500,void 0),this.details=null,this.details=n}toJSON(){return{name:this.name,message:this.message,status:this.status,details:this.details}}}function ZCe(e){return qe(e)&&e.name==="AuthImplicitGrantRedirectError"}class gD extends io{constructor(t,n=null){super(t,"AuthPKCEGrantCodeExchangeError",500,void 0),this.details=null,this.details=n}toJSON(){return{name:this.name,message:this.message,status:this.status,details:this.details}}}class QCe extends io{constructor(){super("PKCE code verifier not found in storage. This can happen if the auth flow was initiated in a different browser or device, or if the storage was cleared. For SSR frameworks (Next.js, SvelteKit, etc.), use @supabase/ssr on both the server and client to store the code verifier in cookies.","AuthPKCECodeVerifierMissingError",400,"pkce_code_verifier_not_found")}}class Wk extends io{constructor(t,n){super(t,"AuthRetryableFetchError",n,void 0)}}function bS(e){return qe(e)&&e.name==="AuthRetryableFetchError"}class yD extends io{constructor(t,n,a){super(t,"AuthWeakPasswordError",n,"weak_password"),this.reasons=a}}class Vk extends io{constructor(t){super(t,"AuthInvalidJwtError",400,"invalid_jwt")}}const Qv="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_".split(""),bD=` 	
\r=`.split(""),eAe=(()=>{const e=new Array(128);for(let t=0;t<e.length;t+=1)e[t]=-1;for(let t=0;t<bD.length;t+=1)e[bD[t].charCodeAt(0)]=-2;for(let t=0;t<Qv.length;t+=1)e[Qv[t].charCodeAt(0)]=t;return e})();function vD(e,t,n){if(e!==null)for(t.queue=t.queue<<8|e,t.queuedBits+=8;t.queuedBits>=6;){const a=t.queue>>t.queuedBits-6&63;n(Qv[a]),t.queuedBits-=6}else if(t.queuedBits>0)for(t.queue=t.queue<<6-t.queuedBits,t.queuedBits=6;t.queuedBits>=6;){const a=t.queue>>t.queuedBits-6&63;n(Qv[a]),t.queuedBits-=6}}function bj(e,t,n){const a=eAe[e];if(a>-1)for(t.queue=t.queue<<6|a,t.queuedBits+=6;t.queuedBits>=8;)n(t.queue>>t.queuedBits-8&255),t.queuedBits-=8;else{if(a===-2)return;throw new Error(`Invalid Base64-URL character "${String.fromCharCode(e)}"`)}}function xD(e){const t=[],n=i=>{t.push(String.fromCodePoint(i))},a={utf8seq:0,codepoint:0},r={queue:0,queuedBits:0},s=i=>{aAe(i,a,n)};for(let i=0;i<e.length;i+=1)bj(e.charCodeAt(i),r,s);return t.join("")}function tAe(e,t){if(e<=127){t(e);return}else if(e<=2047){t(192|e>>6),t(128|e&63);return}else if(e<=65535){t(224|e>>12),t(128|e>>6&63),t(128|e&63);return}else if(e<=1114111){t(240|e>>18),t(128|e>>12&63),t(128|e>>6&63),t(128|e&63);return}throw new Error(`Unrecognized Unicode codepoint: ${e.toString(16)}`)}function nAe(e,t){for(let n=0;n<e.length;n+=1){let a=e.charCodeAt(n);if(a>55295&&a<=56319){const r=(a-55296)*1024&65535;a=(e.charCodeAt(n+1)-56320&65535|r)+65536,n+=1}tAe(a,t)}}function aAe(e,t,n){if(t.utf8seq===0){if(e<=127){n(e);return}for(let a=1;a<6;a+=1)if((e>>7-a&1)===0){t.utf8seq=a;break}if(t.utf8seq===2)t.codepoint=e&31;else if(t.utf8seq===3)t.codepoint=e&15;else if(t.utf8seq===4)t.codepoint=e&7;else throw new Error("Invalid UTF-8 sequence");t.utf8seq-=1}else if(t.utf8seq>0){if(e<=127)throw new Error("Invalid UTF-8 sequence");t.codepoint=t.codepoint<<6|e&63,t.utf8seq-=1,t.utf8seq===0&&n(t.codepoint)}}function Dh(e){const t=[],n={queue:0,queuedBits:0},a=r=>{t.push(r)};for(let r=0;r<e.length;r+=1)bj(e.charCodeAt(r),n,a);return new Uint8Array(t)}function rAe(e){const t=[];return nAe(e,n=>t.push(n)),new Uint8Array(t)}function vu(e){const t=[],n={queue:0,queuedBits:0},a=r=>{t.push(r)};return e.forEach(r=>vD(r,n,a)),vD(null,n,a),t.join("")}function sAe(e){return Math.round(Date.now()/1e3)+e}function iAe(){return Symbol("auth-callback")}const Ma=()=>typeof window<"u"&&typeof document<"u",ru={tested:!1,writable:!1},vj=()=>{if(!Ma())return!1;try{if(typeof globalThis.localStorage!="object")return!1}catch{return!1}if(ru.tested)return ru.writable;const e=`lswt-${Math.random()}${Math.random()}`;try{globalThis.localStorage.setItem(e,e),globalThis.localStorage.removeItem(e),ru.tested=!0,ru.writable=!0}catch{ru.tested=!0,ru.writable=!1}return ru.writable};function oAe(e){const t={},n=new URL(e);if(n.hash&&n.hash[0]==="#")try{new URLSearchParams(n.hash.substring(1)).forEach((r,s)=>{t[s]=r})}catch{}return n.searchParams.forEach((a,r)=>{t[r]=a}),t}const xj=e=>e?(...t)=>e(...t):(...t)=>fetch(...t),lAe=e=>typeof e=="object"&&e!==null&&"status"in e&&"ok"in e&&"json"in e&&typeof e.json=="function",Nh=async(e,t,n)=>{await e.setItem(t,JSON.stringify(n))},su=async(e,t)=>{const n=await e.getItem(t);if(!n)return null;try{return JSON.parse(n)}catch{return n}},Oa=async(e,t)=>{await e.removeItem(t)};class Fx{constructor(){this.promise=new Fx.promiseConstructor((t,n)=>{this.resolve=t,this.reject=n})}}Fx.promiseConstructor=Promise;function vS(e){const t=e.split(".");if(t.length!==3)throw new Vk("Invalid JWT structure");for(let a=0;a<t.length;a++)if(!qCe.test(t[a]))throw new Vk("JWT not in base64url format");return{header:JSON.parse(xD(t[0])),payload:JSON.parse(xD(t[1])),signature:Dh(t[2]),raw:{header:t[0],payload:t[1]}}}async function uAe(e){return await new Promise(t=>{setTimeout(()=>t(null),e)})}function cAe(e,t){return new Promise((a,r)=>{(async()=>{for(let s=0;s<1/0;s++)try{const i=await e(s);if(!t(s,null,i)){a(i);return}}catch(i){if(!t(s,i)){r(i);return}}})()})}function dAe(e){return("0"+e.toString(16)).substr(-2)}function hAe(){const t=new Uint32Array(56);if(typeof crypto>"u"){const n="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~",a=n.length;let r="";for(let s=0;s<56;s++)r+=n.charAt(Math.floor(Math.random()*a));return r}return crypto.getRandomValues(t),Array.from(t,dAe).join("")}async function pAe(e){const n=new TextEncoder().encode(e),a=await crypto.subtle.digest("SHA-256",n),r=new Uint8Array(a);return Array.from(r).map(s=>String.fromCharCode(s)).join("")}async function fAe(e){if(!(typeof crypto<"u"&&typeof crypto.subtle<"u"&&typeof TextEncoder<"u"))return console.warn("WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256."),e;const n=await pAe(e);return btoa(n).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}async function gh(e,t,n=!1){const a=hAe();let r=a;n&&(r+="/PASSWORD_RECOVERY"),await Nh(e,`${t}-code-verifier`,r);const s=await fAe(a);return[s,a===s?"plain":"s256"]}const mAe=/^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i;function gAe(e){const t=e.headers.get(jk);if(!t||!t.match(mAe))return null;try{return new Date(`${t}T00:00:00.0Z`)}catch{return null}}function yAe(e){if(!e)throw new Error("Missing exp claim");const t=Math.floor(Date.now()/1e3);if(e<=t)throw new Error("JWT has expired")}function bAe(e){switch(e){case"RS256":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}};case"ES256":return{name:"ECDSA",namedCurve:"P-256",hash:{name:"SHA-256"}};default:throw new Error("Invalid alg claim")}}const vAe=/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;function yh(e){if(!vAe.test(e))throw new Error("@supabase/auth-js: Expected parameter to be UUID but is not")}function xS(){const e={};return new Proxy(e,{get:(t,n)=>{if(n==="__isUserNotAvailableProxy")return!0;if(typeof n=="symbol"){const a=n.toString();if(a==="Symbol(Symbol.toPrimitive)"||a==="Symbol(Symbol.toStringTag)"||a==="Symbol(util.inspect.custom)")return}throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Accessing the "${n}" property of the session object is not supported. Please use getUser() instead.`)},set:(t,n)=>{throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Setting the "${n}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`)},deleteProperty:(t,n)=>{throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Deleting the "${n}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`)}})}function xAe(e,t){return new Proxy(e,{get:(n,a,r)=>{if(a==="__isInsecureUserWarningProxy")return!0;if(typeof a=="symbol"){const s=a.toString();if(s==="Symbol(Symbol.toPrimitive)"||s==="Symbol(Symbol.toStringTag)"||s==="Symbol(util.inspect.custom)"||s==="Symbol(nodejs.util.inspect.custom)")return Reflect.get(n,a,r)}return!t.value&&typeof a=="string"&&(console.warn("Using the user object as returned from supabase.auth.getSession() or from some supabase.auth.onAuthStateChange() events could be insecure! This value comes directly from the storage medium (usually cookies on the server) and may not be authentic. Use supabase.auth.getUser() instead which authenticates the data by contacting the Supabase Auth server."),t.value=!0),Reflect.get(n,a,r)}})}function wD(e){return JSON.parse(JSON.stringify(e))}const uu=e=>e.msg||e.message||e.error_description||e.error||JSON.stringify(e),wAe=[502,503,504];async function SD(e){var t;if(!lAe(e))throw new Wk(uu(e),0);if(wAe.includes(e.status))throw new Wk(uu(e),e.status);let n;try{n=await e.json()}catch(s){throw new gu(uu(s),s)}let a;const r=gAe(e);if(r&&r.getTime()>=yj["2024-01-01"].timestamp&&typeof n=="object"&&n&&typeof n.code=="string"?a=n.code:typeof n=="object"&&n&&typeof n.error_code=="string"&&(a=n.error_code),a){if(a==="weak_password")throw new yD(uu(n),e.status,((t=n.weak_password)===null||t===void 0?void 0:t.reasons)||[]);if(a==="session_not_found")throw new Wr}else if(typeof n=="object"&&n&&typeof n.weak_password=="object"&&n.weak_password&&Array.isArray(n.weak_password.reasons)&&n.weak_password.reasons.length&&n.weak_password.reasons.reduce((s,i)=>s&&typeof i=="string",!0))throw new yD(uu(n),e.status,n.weak_password.reasons);throw new XCe(uu(n),e.status||500,a)}const SAe=(e,t,n,a)=>{const r={method:e,headers:t?.headers||{}};return e==="GET"?r:(r.headers=Object.assign({"Content-Type":"application/json;charset=UTF-8"},t?.headers),r.body=JSON.stringify(a),Object.assign(Object.assign({},r),n))};async function Ze(e,t,n,a){var r;const s=Object.assign({},a?.headers);s[jk]||(s[jk]=yj["2024-01-01"].name),a?.jwt&&(s.Authorization=`Bearer ${a.jwt}`);const i=(r=a?.query)!==null&&r!==void 0?r:{};a?.redirectTo&&(i.redirect_to=a.redirectTo);const o=Object.keys(i).length?"?"+new URLSearchParams(i).toString():"",u=await kAe(e,t,n+o,{headers:s,noResolveJson:a?.noResolveJson},{},a?.body);return a?.xform?a?.xform(u):{data:Object.assign({},u),error:null}}async function kAe(e,t,n,a,r,s){const i=SAe(t,a,r,s);let o;try{o=await e(n,Object.assign({},i))}catch(u){throw console.error(u),new Wk(uu(u),0)}if(o.ok||await SD(o),a?.noResolveJson)return o;try{return await o.json()}catch(u){await SD(u)}}function Rs(e){var t;let n=null;IAe(e)&&(n=Object.assign({},e),e.expires_at||(n.expires_at=sAe(e.expires_in)));const a=(t=e.user)!==null&&t!==void 0?t:e;return{data:{session:n,user:a},error:null}}function kD(e){const t=Rs(e);return!t.error&&e.weak_password&&typeof e.weak_password=="object"&&Array.isArray(e.weak_password.reasons)&&e.weak_password.reasons.length&&e.weak_password.message&&typeof e.weak_password.message=="string"&&e.weak_password.reasons.reduce((n,a)=>n&&typeof a=="string",!0)&&(t.data.weak_password=e.weak_password),t}function qo(e){var t;return{data:{user:(t=e.user)!==null&&t!==void 0?t:e},error:null}}function _Ae(e){return{data:e,error:null}}function NAe(e){const{action_link:t,email_otp:n,hashed_token:a,redirect_to:r,verification_type:s}=e,i=Ox(e,["action_link","email_otp","hashed_token","redirect_to","verification_type"]),o={action_link:t,email_otp:n,hashed_token:a,redirect_to:r,verification_type:s},u=Object.assign({},i);return{data:{properties:o,user:u},error:null}}function _D(e){return e}function IAe(e){return e.access_token&&e.refresh_token&&e.expires_in}const wS=["global","local","others"];class TAe{constructor({url:t="",headers:n={},fetch:a}){this.url=t,this.headers=n,this.fetch=xj(a),this.mfa={listFactors:this._listFactors.bind(this),deleteFactor:this._deleteFactor.bind(this)},this.oauth={listClients:this._listOAuthClients.bind(this),createClient:this._createOAuthClient.bind(this),getClient:this._getOAuthClient.bind(this),updateClient:this._updateOAuthClient.bind(this),deleteClient:this._deleteOAuthClient.bind(this),regenerateClientSecret:this._regenerateOAuthClientSecret.bind(this)}}async signOut(t,n=wS[0]){if(wS.indexOf(n)<0)throw new Error(`@supabase/auth-js: Parameter scope must be one of ${wS.join(", ")}`);try{return await Ze(this.fetch,"POST",`${this.url}/logout?scope=${n}`,{headers:this.headers,jwt:t,noResolveJson:!0}),{data:null,error:null}}catch(a){if(qe(a))return{data:null,error:a};throw a}}async inviteUserByEmail(t,n={}){try{return await Ze(this.fetch,"POST",`${this.url}/invite`,{body:{email:t,data:n.data},headers:this.headers,redirectTo:n.redirectTo,xform:qo})}catch(a){if(qe(a))return{data:{user:null},error:a};throw a}}async generateLink(t){try{const{options:n}=t,a=Ox(t,["options"]),r=Object.assign(Object.assign({},a),n);return"newEmail"in a&&(r.new_email=a?.newEmail,delete r.newEmail),await Ze(this.fetch,"POST",`${this.url}/admin/generate_link`,{body:r,headers:this.headers,xform:NAe,redirectTo:n?.redirectTo})}catch(n){if(qe(n))return{data:{properties:null,user:null},error:n};throw n}}async createUser(t){try{return await Ze(this.fetch,"POST",`${this.url}/admin/users`,{body:t,headers:this.headers,xform:qo})}catch(n){if(qe(n))return{data:{user:null},error:n};throw n}}async listUsers(t){var n,a,r,s,i,o,u;try{const d={nextPage:null,lastPage:0,total:0},c=await Ze(this.fetch,"GET",`${this.url}/admin/users`,{headers:this.headers,noResolveJson:!0,query:{page:(a=(n=t?.page)===null||n===void 0?void 0:n.toString())!==null&&a!==void 0?a:"",per_page:(s=(r=t?.perPage)===null||r===void 0?void 0:r.toString())!==null&&s!==void 0?s:""},xform:_D});if(c.error)throw c.error;const p=await c.json(),m=(i=c.headers.get("x-total-count"))!==null&&i!==void 0?i:0,g=(u=(o=c.headers.get("link"))===null||o===void 0?void 0:o.split(","))!==null&&u!==void 0?u:[];return g.length>0&&(g.forEach(b=>{const v=parseInt(b.split(";")[0].split("=")[1].substring(0,1)),x=JSON.parse(b.split(";")[1].split("=")[1]);d[`${x}Page`]=v}),d.total=parseInt(m)),{data:Object.assign(Object.assign({},p),d),error:null}}catch(d){if(qe(d))return{data:{users:[]},error:d};throw d}}async getUserById(t){yh(t);try{return await Ze(this.fetch,"GET",`${this.url}/admin/users/${t}`,{headers:this.headers,xform:qo})}catch(n){if(qe(n))return{data:{user:null},error:n};throw n}}async updateUserById(t,n){yh(t);try{return await Ze(this.fetch,"PUT",`${this.url}/admin/users/${t}`,{body:n,headers:this.headers,xform:qo})}catch(a){if(qe(a))return{data:{user:null},error:a};throw a}}async deleteUser(t,n=!1){yh(t);try{return await Ze(this.fetch,"DELETE",`${this.url}/admin/users/${t}`,{headers:this.headers,body:{should_soft_delete:n},xform:qo})}catch(a){if(qe(a))return{data:{user:null},error:a};throw a}}async _listFactors(t){yh(t.userId);try{const{data:n,error:a}=await Ze(this.fetch,"GET",`${this.url}/admin/users/${t.userId}/factors`,{headers:this.headers,xform:r=>({data:{factors:r},error:null})});return{data:n,error:a}}catch(n){if(qe(n))return{data:null,error:n};throw n}}async _deleteFactor(t){yh(t.userId),yh(t.id);try{return{data:await Ze(this.fetch,"DELETE",`${this.url}/admin/users/${t.userId}/factors/${t.id}`,{headers:this.headers}),error:null}}catch(n){if(qe(n))return{data:null,error:n};throw n}}async _listOAuthClients(t){var n,a,r,s,i,o,u;try{const d={nextPage:null,lastPage:0,total:0},c=await Ze(this.fetch,"GET",`${this.url}/admin/oauth/clients`,{headers:this.headers,noResolveJson:!0,query:{page:(a=(n=t?.page)===null||n===void 0?void 0:n.toString())!==null&&a!==void 0?a:"",per_page:(s=(r=t?.perPage)===null||r===void 0?void 0:r.toString())!==null&&s!==void 0?s:""},xform:_D});if(c.error)throw c.error;const p=await c.json(),m=(i=c.headers.get("x-total-count"))!==null&&i!==void 0?i:0,g=(u=(o=c.headers.get("link"))===null||o===void 0?void 0:o.split(","))!==null&&u!==void 0?u:[];return g.length>0&&(g.forEach(b=>{const v=parseInt(b.split(";")[0].split("=")[1].substring(0,1)),x=JSON.parse(b.split(";")[1].split("=")[1]);d[`${x}Page`]=v}),d.total=parseInt(m)),{data:Object.assign(Object.assign({},p),d),error:null}}catch(d){if(qe(d))return{data:{clients:[]},error:d};throw d}}async _createOAuthClient(t){try{return await Ze(this.fetch,"POST",`${this.url}/admin/oauth/clients`,{body:t,headers:this.headers,xform:n=>({data:n,error:null})})}catch(n){if(qe(n))return{data:null,error:n};throw n}}async _getOAuthClient(t){try{return await Ze(this.fetch,"GET",`${this.url}/admin/oauth/clients/${t}`,{headers:this.headers,xform:n=>({data:n,error:null})})}catch(n){if(qe(n))return{data:null,error:n};throw n}}async _updateOAuthClient(t,n){try{return await Ze(this.fetch,"PUT",`${this.url}/admin/oauth/clients/${t}`,{body:n,headers:this.headers,xform:a=>({data:a,error:null})})}catch(a){if(qe(a))return{data:null,error:a};throw a}}async _deleteOAuthClient(t){try{return await Ze(this.fetch,"DELETE",`${this.url}/admin/oauth/clients/${t}`,{headers:this.headers,noResolveJson:!0}),{data:null,error:null}}catch(n){if(qe(n))return{data:null,error:n};throw n}}async _regenerateOAuthClientSecret(t){try{return await Ze(this.fetch,"POST",`${this.url}/admin/oauth/clients/${t}/regenerate_secret`,{headers:this.headers,xform:n=>({data:n,error:null})})}catch(n){if(qe(n))return{data:null,error:n};throw n}}}function ND(e={}){return{getItem:t=>e[t]||null,setItem:(t,n)=>{e[t]=n},removeItem:t=>{delete e[t]}}}const bh={debug:!!(globalThis&&vj()&&globalThis.localStorage&&globalThis.localStorage.getItem("supabase.gotrue-js.locks.debug")==="true")};class wj extends Error{constructor(t){super(t),this.isAcquireTimeout=!0}}class EAe extends wj{}async function CAe(e,t,n){bh.debug&&console.log("@supabase/gotrue-js: navigatorLock: acquire lock",e,t);const a=new globalThis.AbortController;return t>0&&setTimeout(()=>{a.abort(),bh.debug&&console.log("@supabase/gotrue-js: navigatorLock acquire timed out",e)},t),await Promise.resolve().then(()=>globalThis.navigator.locks.request(e,t===0?{mode:"exclusive",ifAvailable:!0}:{mode:"exclusive",signal:a.signal},async r=>{if(r){bh.debug&&console.log("@supabase/gotrue-js: navigatorLock: acquired",e,r.name);try{return await n()}finally{bh.debug&&console.log("@supabase/gotrue-js: navigatorLock: released",e,r.name)}}else{if(t===0)throw bh.debug&&console.log("@supabase/gotrue-js: navigatorLock: not immediately available",e),new EAe(`Acquiring an exclusive Navigator LockManager lock "${e}" immediately failed`);if(bh.debug)try{const s=await globalThis.navigator.locks.query();console.log("@supabase/gotrue-js: Navigator LockManager state",JSON.stringify(s,null,"  "))}catch(s){console.warn("@supabase/gotrue-js: Error when querying Navigator LockManager state",s)}return console.warn("@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request"),await n()}}))}function AAe(){if(typeof globalThis!="object")try{Object.defineProperty(Object.prototype,"__magic__",{get:function(){return this},configurable:!0}),__magic__.globalThis=__magic__,delete Object.prototype.__magic__}catch{typeof self<"u"&&(self.globalThis=self)}}function Sj(e){if(!/^0x[a-fA-F0-9]{40}$/.test(e))throw new Error(`@supabase/auth-js: Address "${e}" is invalid.`);return e.toLowerCase()}function $Ae(e){return parseInt(e,16)}function RAe(e){const t=new TextEncoder().encode(e);return"0x"+Array.from(t,a=>a.toString(16).padStart(2,"0")).join("")}function DAe(e){var t;const{chainId:n,domain:a,expirationTime:r,issuedAt:s=new Date,nonce:i,notBefore:o,requestId:u,resources:d,scheme:c,uri:p,version:m}=e;{if(!Number.isInteger(n))throw new Error(`@supabase/auth-js: Invalid SIWE message field "chainId". Chain ID must be a EIP-155 chain ID. Provided value: ${n}`);if(!a)throw new Error('@supabase/auth-js: Invalid SIWE message field "domain". Domain must be provided.');if(i&&i.length<8)throw new Error(`@supabase/auth-js: Invalid SIWE message field "nonce". Nonce must be at least 8 characters. Provided value: ${i}`);if(!p)throw new Error('@supabase/auth-js: Invalid SIWE message field "uri". URI must be provided.');if(m!=="1")throw new Error(`@supabase/auth-js: Invalid SIWE message field "version". Version must be '1'. Provided value: ${m}`);if(!((t=e.statement)===null||t===void 0)&&t.includes(`
`))throw new Error(`@supabase/auth-js: Invalid SIWE message field "statement". Statement must not include '\\n'. Provided value: ${e.statement}`)}const g=Sj(e.address),b=c?`${c}://${a}`:a,v=e.statement?`${e.statement}
`:"",x=`${b} wants you to sign in with your Ethereum account:
${g}

${v}`;let w=`URI: ${p}
Version: ${m}
Chain ID: ${n}${i?`
Nonce: ${i}`:""}
Issued At: ${s.toISOString()}`;if(r&&(w+=`
Expiration Time: ${r.toISOString()}`),o&&(w+=`
Not Before: ${o.toISOString()}`),u&&(w+=`
Request ID: ${u}`),d){let k=`
Resources:`;for(const N of d){if(!N||typeof N!="string")throw new Error(`@supabase/auth-js: Invalid SIWE message field "resources". Every resource must be a valid string. Provided value: ${N}`);k+=`
- ${N}`}w+=k}return`${x}
${w}`}class Jn extends Error{constructor({message:t,code:n,cause:a,name:r}){var s;super(t,{cause:a}),this.__isWebAuthnError=!0,this.name=(s=r??(a instanceof Error?a.name:void 0))!==null&&s!==void 0?s:"Unknown Error",this.code=n}}class e0 extends Jn{constructor(t,n){super({code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:n,message:t}),this.name="WebAuthnUnknownError",this.originalError=n}}function OAe({error:e,options:t}){var n,a,r;const{publicKey:s}=t;if(!s)throw Error("options was missing required publicKey property");if(e.name==="AbortError"){if(t.signal instanceof AbortSignal)return new Jn({message:"Registration ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:e})}else if(e.name==="ConstraintError"){if(((n=s.authenticatorSelection)===null||n===void 0?void 0:n.requireResidentKey)===!0)return new Jn({message:"Discoverable credentials were required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT",cause:e});if(t.mediation==="conditional"&&((a=s.authenticatorSelection)===null||a===void 0?void 0:a.userVerification)==="required")return new Jn({message:"User verification was required during automatic registration but it could not be performed",code:"ERROR_AUTO_REGISTER_USER_VERIFICATION_FAILURE",cause:e});if(((r=s.authenticatorSelection)===null||r===void 0?void 0:r.userVerification)==="required")return new Jn({message:"User verification was required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT",cause:e})}else{if(e.name==="InvalidStateError")return new Jn({message:"The authenticator was previously registered",code:"ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED",cause:e});if(e.name==="NotAllowedError")return new Jn({message:e.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:e});if(e.name==="NotSupportedError")return s.pubKeyCredParams.filter(o=>o.type==="public-key").length===0?new Jn({message:'No entry in pubKeyCredParams was of type "public-key"',code:"ERROR_MALFORMED_PUBKEYCREDPARAMS",cause:e}):new Jn({message:"No available authenticator supported any of the specified pubKeyCredParams algorithms",code:"ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG",cause:e});if(e.name==="SecurityError"){const i=window.location.hostname;if(kj(i)){if(s.rp.id!==i)return new Jn({message:`The RP ID "${s.rp.id}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:e})}else return new Jn({message:`${window.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:e})}else if(e.name==="TypeError"){if(s.user.id.byteLength<1||s.user.id.byteLength>64)return new Jn({message:"User ID was not between 1 and 64 characters",code:"ERROR_INVALID_USER_ID_LENGTH",cause:e})}else if(e.name==="UnknownError")return new Jn({message:"The authenticator was unable to process the specified options, or could not create a new credential",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:e})}return new Jn({message:"a Non-Webauthn related error has occurred",code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:e})}function MAe({error:e,options:t}){const{publicKey:n}=t;if(!n)throw Error("options was missing required publicKey property");if(e.name==="AbortError"){if(t.signal instanceof AbortSignal)return new Jn({message:"Authentication ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:e})}else{if(e.name==="NotAllowedError")return new Jn({message:e.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:e});if(e.name==="SecurityError"){const a=window.location.hostname;if(kj(a)){if(n.rpId!==a)return new Jn({message:`The RP ID "${n.rpId}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:e})}else return new Jn({message:`${window.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:e})}else if(e.name==="UnknownError")return new Jn({message:"The authenticator was unable to process the specified options, or could not create a new assertion signature",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:e})}return new Jn({message:"a Non-Webauthn related error has occurred",code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:e})}class FAe{createNewAbortSignal(){if(this.controller){const n=new Error("Cancelling existing WebAuthn API call for new one");n.name="AbortError",this.controller.abort(n)}const t=new AbortController;return this.controller=t,t.signal}cancelCeremony(){if(this.controller){const t=new Error("Manually cancelling existing WebAuthn API call");t.name="AbortError",this.controller.abort(t),this.controller=void 0}}}const zAe=new FAe;function LAe(e){if(!e)throw new Error("Credential creation options are required");if(typeof PublicKeyCredential<"u"&&"parseCreationOptionsFromJSON"in PublicKeyCredential&&typeof PublicKeyCredential.parseCreationOptionsFromJSON=="function")return PublicKeyCredential.parseCreationOptionsFromJSON(e);const{challenge:t,user:n,excludeCredentials:a}=e,r=Ox(e,["challenge","user","excludeCredentials"]),s=Dh(t).buffer,i=Object.assign(Object.assign({},n),{id:Dh(n.id).buffer}),o=Object.assign(Object.assign({},r),{challenge:s,user:i});if(a&&a.length>0){o.excludeCredentials=new Array(a.length);for(let u=0;u<a.length;u++){const d=a[u];o.excludeCredentials[u]=Object.assign(Object.assign({},d),{id:Dh(d.id).buffer,type:d.type||"public-key",transports:d.transports})}}return o}function BAe(e){if(!e)throw new Error("Credential request options are required");if(typeof PublicKeyCredential<"u"&&"parseRequestOptionsFromJSON"in PublicKeyCredential&&typeof PublicKeyCredential.parseRequestOptionsFromJSON=="function")return PublicKeyCredential.parseRequestOptionsFromJSON(e);const{challenge:t,allowCredentials:n}=e,a=Ox(e,["challenge","allowCredentials"]),r=Dh(t).buffer,s=Object.assign(Object.assign({},a),{challenge:r});if(n&&n.length>0){s.allowCredentials=new Array(n.length);for(let i=0;i<n.length;i++){const o=n[i];s.allowCredentials[i]=Object.assign(Object.assign({},o),{id:Dh(o.id).buffer,type:o.type||"public-key",transports:o.transports})}}return s}function PAe(e){var t;if("toJSON"in e&&typeof e.toJSON=="function")return e.toJSON();const n=e;return{id:e.id,rawId:e.id,response:{attestationObject:vu(new Uint8Array(e.response.attestationObject)),clientDataJSON:vu(new Uint8Array(e.response.clientDataJSON))},type:"public-key",clientExtensionResults:e.getClientExtensionResults(),authenticatorAttachment:(t=n.authenticatorAttachment)!==null&&t!==void 0?t:void 0}}function UAe(e){var t;if("toJSON"in e&&typeof e.toJSON=="function")return e.toJSON();const n=e,a=e.getClientExtensionResults(),r=e.response;return{id:e.id,rawId:e.id,response:{authenticatorData:vu(new Uint8Array(r.authenticatorData)),clientDataJSON:vu(new Uint8Array(r.clientDataJSON)),signature:vu(new Uint8Array(r.signature)),userHandle:r.userHandle?vu(new Uint8Array(r.userHandle)):void 0},type:"public-key",clientExtensionResults:a,authenticatorAttachment:(t=n.authenticatorAttachment)!==null&&t!==void 0?t:void 0}}function kj(e){return e==="localhost"||/^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(e)}function ID(){var e,t;return!!(Ma()&&"PublicKeyCredential"in window&&window.PublicKeyCredential&&"credentials"in navigator&&typeof((e=navigator?.credentials)===null||e===void 0?void 0:e.create)=="function"&&typeof((t=navigator?.credentials)===null||t===void 0?void 0:t.get)=="function")}async function jAe(e){try{const t=await navigator.credentials.create(e);return t?t instanceof PublicKeyCredential?{data:t,error:null}:{data:null,error:new e0("Browser returned unexpected credential type",t)}:{data:null,error:new e0("Empty credential response",t)}}catch(t){return{data:null,error:OAe({error:t,options:e})}}}async function WAe(e){try{const t=await navigator.credentials.get(e);return t?t instanceof PublicKeyCredential?{data:t,error:null}:{data:null,error:new e0("Browser returned unexpected credential type",t)}:{data:null,error:new e0("Empty credential response",t)}}catch(t){return{data:null,error:MAe({error:t,options:e})}}}const VAe={hints:["security-key"],authenticatorSelection:{authenticatorAttachment:"cross-platform",requireResidentKey:!1,userVerification:"preferred",residentKey:"discouraged"},attestation:"direct"},HAe={userVerification:"preferred",hints:["security-key"],attestation:"direct"};function t0(...e){const t=r=>r!==null&&typeof r=="object"&&!Array.isArray(r),n=r=>r instanceof ArrayBuffer||ArrayBuffer.isView(r),a={};for(const r of e)if(r)for(const s in r){const i=r[s];if(i!==void 0)if(Array.isArray(i))a[s]=i;else if(n(i))a[s]=i;else if(t(i)){const o=a[s];t(o)?a[s]=t0(o,i):a[s]=t0(i)}else a[s]=i}return a}function GAe(e,t){return t0(VAe,e,t||{})}function qAe(e,t){return t0(HAe,e,t||{})}class KAe{constructor(t){this.client=t,this.enroll=this._enroll.bind(this),this.challenge=this._challenge.bind(this),this.verify=this._verify.bind(this),this.authenticate=this._authenticate.bind(this),this.register=this._register.bind(this)}async _enroll(t){return this.client.mfa.enroll(Object.assign(Object.assign({},t),{factorType:"webauthn"}))}async _challenge({factorId:t,webauthn:n,friendlyName:a,signal:r},s){try{const{data:i,error:o}=await this.client.mfa.challenge({factorId:t,webauthn:n});if(!i)return{data:null,error:o};const u=r??zAe.createNewAbortSignal();if(i.webauthn.type==="create"){const{user:d}=i.webauthn.credential_options.publicKey;d.name||(d.name=`${d.id}:${a}`),d.displayName||(d.displayName=d.name)}switch(i.webauthn.type){case"create":{const d=GAe(i.webauthn.credential_options.publicKey,s?.create),{data:c,error:p}=await jAe({publicKey:d,signal:u});return c?{data:{factorId:t,challengeId:i.id,webauthn:{type:i.webauthn.type,credential_response:c}},error:null}:{data:null,error:p}}case"request":{const d=qAe(i.webauthn.credential_options.publicKey,s?.request),{data:c,error:p}=await WAe(Object.assign(Object.assign({},i.webauthn.credential_options),{publicKey:d,signal:u}));return c?{data:{factorId:t,challengeId:i.id,webauthn:{type:i.webauthn.type,credential_response:c}},error:null}:{data:null,error:p}}}}catch(i){return qe(i)?{data:null,error:i}:{data:null,error:new gu("Unexpected error in challenge",i)}}}async _verify({challengeId:t,factorId:n,webauthn:a}){return this.client.mfa.verify({factorId:n,challengeId:t,webauthn:a})}async _authenticate({factorId:t,webauthn:{rpId:n=typeof window<"u"?window.location.hostname:void 0,rpOrigins:a=typeof window<"u"?[window.location.origin]:void 0,signal:r}={}},s){if(!n)return{data:null,error:new bg("rpId is required for WebAuthn authentication")};try{if(!ID())return{data:null,error:new gu("Browser does not support WebAuthn",null)};const{data:i,error:o}=await this.challenge({factorId:t,webauthn:{rpId:n,rpOrigins:a},signal:r},{request:s});if(!i)return{data:null,error:o};const{webauthn:u}=i;return this._verify({factorId:t,challengeId:i.challengeId,webauthn:{type:u.type,rpId:n,rpOrigins:a,credential_response:u.credential_response}})}catch(i){return qe(i)?{data:null,error:i}:{data:null,error:new gu("Unexpected error in authenticate",i)}}}async _register({friendlyName:t,webauthn:{rpId:n=typeof window<"u"?window.location.hostname:void 0,rpOrigins:a=typeof window<"u"?[window.location.origin]:void 0,signal:r}={}},s){if(!n)return{data:null,error:new bg("rpId is required for WebAuthn registration")};try{if(!ID())return{data:null,error:new gu("Browser does not support WebAuthn",null)};const{data:i,error:o}=await this._enroll({friendlyName:t});if(!i)return await this.client.mfa.listFactors().then(c=>{var p;return(p=c.data)===null||p===void 0?void 0:p.all.find(m=>m.factor_type==="webauthn"&&m.friendly_name===t&&m.status!=="unverified")}).then(c=>c?this.client.mfa.unenroll({factorId:c?.id}):void 0),{data:null,error:o};const{data:u,error:d}=await this._challenge({factorId:i.id,friendlyName:i.friendly_name,webauthn:{rpId:n,rpOrigins:a},signal:r},{create:s});return u?this._verify({factorId:i.id,challengeId:u.challengeId,webauthn:{rpId:n,rpOrigins:a,type:u.webauthn.type,credential_response:u.webauthn.credential_response}}):{data:null,error:d}}catch(i){return qe(i)?{data:null,error:i}:{data:null,error:new gu("Unexpected error in register",i)}}}}AAe();const XAe={url:VCe,storageKey:HCe,autoRefreshToken:!0,persistSession:!0,detectSessionInUrl:!0,headers:GCe,flowType:"implicit",debug:!1,hasCustomAuthorizationHeader:!1,throwOnError:!1};async function TD(e,t,n){return await n()}const vh={};class vg{get jwks(){var t,n;return(n=(t=vh[this.storageKey])===null||t===void 0?void 0:t.jwks)!==null&&n!==void 0?n:{keys:[]}}set jwks(t){vh[this.storageKey]=Object.assign(Object.assign({},vh[this.storageKey]),{jwks:t})}get jwks_cached_at(){var t,n;return(n=(t=vh[this.storageKey])===null||t===void 0?void 0:t.cachedAt)!==null&&n!==void 0?n:Number.MIN_SAFE_INTEGER}set jwks_cached_at(t){vh[this.storageKey]=Object.assign(Object.assign({},vh[this.storageKey]),{cachedAt:t})}constructor(t){var n,a,r;this.userStorage=null,this.memoryStorage=null,this.stateChangeEmitters=new Map,this.autoRefreshTicker=null,this.visibilityChangedCallback=null,this.refreshingDeferred=null,this.initializePromise=null,this.detectSessionInUrl=!0,this.hasCustomAuthorizationHeader=!1,this.suppressGetSessionWarning=!1,this.lockAcquired=!1,this.pendingInLock=[],this.broadcastChannel=null,this.logger=console.log;const s=Object.assign(Object.assign({},XAe),t);if(this.storageKey=s.storageKey,this.instanceID=(n=vg.nextInstanceID[this.storageKey])!==null&&n!==void 0?n:0,vg.nextInstanceID[this.storageKey]=this.instanceID+1,this.logDebugMessages=!!s.debug,typeof s.debug=="function"&&(this.logger=s.debug),this.instanceID>0&&Ma()){const i=`${this._logPrefix()} Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.`;console.warn(i),this.logDebugMessages&&console.trace(i)}if(this.persistSession=s.persistSession,this.autoRefreshToken=s.autoRefreshToken,this.admin=new TAe({url:s.url,headers:s.headers,fetch:s.fetch}),this.url=s.url,this.headers=s.headers,this.fetch=xj(s.fetch),this.lock=s.lock||TD,this.detectSessionInUrl=s.detectSessionInUrl,this.flowType=s.flowType,this.hasCustomAuthorizationHeader=s.hasCustomAuthorizationHeader,this.throwOnError=s.throwOnError,s.lock?this.lock=s.lock:this.persistSession&&Ma()&&(!((a=globalThis?.navigator)===null||a===void 0)&&a.locks)?this.lock=CAe:this.lock=TD,this.jwks||(this.jwks={keys:[]},this.jwks_cached_at=Number.MIN_SAFE_INTEGER),this.mfa={verify:this._verify.bind(this),enroll:this._enroll.bind(this),unenroll:this._unenroll.bind(this),challenge:this._challenge.bind(this),listFactors:this._listFactors.bind(this),challengeAndVerify:this._challengeAndVerify.bind(this),getAuthenticatorAssuranceLevel:this._getAuthenticatorAssuranceLevel.bind(this),webauthn:new KAe(this)},this.oauth={getAuthorizationDetails:this._getAuthorizationDetails.bind(this),approveAuthorization:this._approveAuthorization.bind(this),denyAuthorization:this._denyAuthorization.bind(this),listGrants:this._listOAuthGrants.bind(this),revokeGrant:this._revokeOAuthGrant.bind(this)},this.persistSession?(s.storage?this.storage=s.storage:vj()?this.storage=globalThis.localStorage:(this.memoryStorage={},this.storage=ND(this.memoryStorage)),s.userStorage&&(this.userStorage=s.userStorage)):(this.memoryStorage={},this.storage=ND(this.memoryStorage)),Ma()&&globalThis.BroadcastChannel&&this.persistSession&&this.storageKey){try{this.broadcastChannel=new globalThis.BroadcastChannel(this.storageKey)}catch(i){console.error("Failed to create a new BroadcastChannel, multi-tab state changes will not be available",i)}(r=this.broadcastChannel)===null||r===void 0||r.addEventListener("message",async i=>{this._debug("received broadcast notification from other tab or client",i),await this._notifyAllSubscribers(i.data.event,i.data.session,!1)})}this.initialize()}isThrowOnErrorEnabled(){return this.throwOnError}_returnResult(t){if(this.throwOnError&&t&&t.error)throw t.error;return t}_logPrefix(){return`GoTrueClient@${this.storageKey}:${this.instanceID} (${gj}) ${new Date().toISOString()}`}_debug(...t){return this.logDebugMessages&&this.logger(this._logPrefix(),...t),this}async initialize(){return this.initializePromise?await this.initializePromise:(this.initializePromise=(async()=>await this._acquireLock(-1,async()=>await this._initialize()))(),await this.initializePromise)}async _initialize(){var t;try{let n={},a="none";if(Ma()&&(n=oAe(window.location.href),this._isImplicitGrantCallback(n)?a="implicit":await this._isPKCECallback(n)&&(a="pkce")),Ma()&&this.detectSessionInUrl&&a!=="none"){const{data:r,error:s}=await this._getSessionFromURL(n,a);if(s){if(this._debug("#_initialize()","error detecting session from URL",s),ZCe(s)){const u=(t=s.details)===null||t===void 0?void 0:t.code;if(u==="identity_already_exists"||u==="identity_not_found"||u==="single_identity_not_deletable")return{error:s}}return await this._removeSession(),{error:s}}const{session:i,redirectType:o}=r;return this._debug("#_initialize()","detected session in URL",i,"redirect type",o),await this._saveSession(i),setTimeout(async()=>{o==="recovery"?await this._notifyAllSubscribers("PASSWORD_RECOVERY",i):await this._notifyAllSubscribers("SIGNED_IN",i)},0),{error:null}}return await this._recoverAndRefresh(),{error:null}}catch(n){return qe(n)?this._returnResult({error:n}):this._returnResult({error:new gu("Unexpected error during initialization",n)})}finally{await this._handleVisibilityChange(),this._debug("#_initialize()","end")}}async signInAnonymously(t){var n,a,r;try{const s=await Ze(this.fetch,"POST",`${this.url}/signup`,{headers:this.headers,body:{data:(a=(n=t?.options)===null||n===void 0?void 0:n.data)!==null&&a!==void 0?a:{},gotrue_meta_security:{captcha_token:(r=t?.options)===null||r===void 0?void 0:r.captchaToken}},xform:Rs}),{data:i,error:o}=s;if(o||!i)return this._returnResult({data:{user:null,session:null},error:o});const u=i.session,d=i.user;return i.session&&(await this._saveSession(i.session),await this._notifyAllSubscribers("SIGNED_IN",u)),this._returnResult({data:{user:d,session:u},error:null})}catch(s){if(qe(s))return this._returnResult({data:{user:null,session:null},error:s});throw s}}async signUp(t){var n,a,r;try{let s;if("email"in t){const{email:c,password:p,options:m}=t;let g=null,b=null;this.flowType==="pkce"&&([g,b]=await gh(this.storage,this.storageKey)),s=await Ze(this.fetch,"POST",`${this.url}/signup`,{headers:this.headers,redirectTo:m?.emailRedirectTo,body:{email:c,password:p,data:(n=m?.data)!==null&&n!==void 0?n:{},gotrue_meta_security:{captcha_token:m?.captchaToken},code_challenge:g,code_challenge_method:b},xform:Rs})}else if("phone"in t){const{phone:c,password:p,options:m}=t;s=await Ze(this.fetch,"POST",`${this.url}/signup`,{headers:this.headers,body:{phone:c,password:p,data:(a=m?.data)!==null&&a!==void 0?a:{},channel:(r=m?.channel)!==null&&r!==void 0?r:"sms",gotrue_meta_security:{captcha_token:m?.captchaToken}},xform:Rs})}else throw new ov("You must provide either an email or phone number and a password");const{data:i,error:o}=s;if(o||!i)return await Oa(this.storage,`${this.storageKey}-code-verifier`),this._returnResult({data:{user:null,session:null},error:o});const u=i.session,d=i.user;return i.session&&(await this._saveSession(i.session),await this._notifyAllSubscribers("SIGNED_IN",u)),this._returnResult({data:{user:d,session:u},error:null})}catch(s){if(await Oa(this.storage,`${this.storageKey}-code-verifier`),qe(s))return this._returnResult({data:{user:null,session:null},error:s});throw s}}async signInWithPassword(t){try{let n;if("email"in t){const{email:s,password:i,options:o}=t;n=await Ze(this.fetch,"POST",`${this.url}/token?grant_type=password`,{headers:this.headers,body:{email:s,password:i,gotrue_meta_security:{captcha_token:o?.captchaToken}},xform:kD})}else if("phone"in t){const{phone:s,password:i,options:o}=t;n=await Ze(this.fetch,"POST",`${this.url}/token?grant_type=password`,{headers:this.headers,body:{phone:s,password:i,gotrue_meta_security:{captcha_token:o?.captchaToken}},xform:kD})}else throw new ov("You must provide either an email or phone number and a password");const{data:a,error:r}=n;if(r)return this._returnResult({data:{user:null,session:null},error:r});if(!a||!a.session||!a.user){const s=new mh;return this._returnResult({data:{user:null,session:null},error:s})}return a.session&&(await this._saveSession(a.session),await this._notifyAllSubscribers("SIGNED_IN",a.session)),this._returnResult({data:Object.assign({user:a.user,session:a.session},a.weak_password?{weakPassword:a.weak_password}:null),error:r})}catch(n){if(qe(n))return this._returnResult({data:{user:null,session:null},error:n});throw n}}async signInWithOAuth(t){var n,a,r,s;return await this._handleProviderSignIn(t.provider,{redirectTo:(n=t.options)===null||n===void 0?void 0:n.redirectTo,scopes:(a=t.options)===null||a===void 0?void 0:a.scopes,queryParams:(r=t.options)===null||r===void 0?void 0:r.queryParams,skipBrowserRedirect:(s=t.options)===null||s===void 0?void 0:s.skipBrowserRedirect})}async exchangeCodeForSession(t){return await this.initializePromise,this._acquireLock(-1,async()=>this._exchangeCodeForSession(t))}async signInWithWeb3(t){const{chain:n}=t;switch(n){case"ethereum":return await this.signInWithEthereum(t);case"solana":return await this.signInWithSolana(t);default:throw new Error(`@supabase/auth-js: Unsupported chain "${n}"`)}}async signInWithEthereum(t){var n,a,r,s,i,o,u,d,c,p,m;let g,b;if("message"in t)g=t.message,b=t.signature;else{const{chain:v,wallet:x,statement:w,options:k}=t;let N;if(Ma())if(typeof x=="object")N=x;else{const B=window;if("ethereum"in B&&typeof B.ethereum=="object"&&"request"in B.ethereum&&typeof B.ethereum.request=="function")N=B.ethereum;else throw new Error("@supabase/auth-js: No compatible Ethereum wallet interface on the window object (window.ethereum) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'ethereum', wallet: resolvedUserWallet }) instead.")}else{if(typeof x!="object"||!k?.url)throw new Error("@supabase/auth-js: Both wallet and url must be specified in non-browser environments.");N=x}const I=new URL((n=k?.url)!==null&&n!==void 0?n:window.location.href),T=await N.request({method:"eth_requestAccounts"}).then(B=>B).catch(()=>{throw new Error("@supabase/auth-js: Wallet method eth_requestAccounts is missing or invalid")});if(!T||T.length===0)throw new Error("@supabase/auth-js: No accounts available. Please ensure the wallet is connected.");const $=Sj(T[0]);let D=(a=k?.signInWithEthereum)===null||a===void 0?void 0:a.chainId;if(!D){const B=await N.request({method:"eth_chainId"});D=$Ae(B)}const M={domain:I.host,address:$,statement:w,uri:I.href,version:"1",chainId:D,nonce:(r=k?.signInWithEthereum)===null||r===void 0?void 0:r.nonce,issuedAt:(i=(s=k?.signInWithEthereum)===null||s===void 0?void 0:s.issuedAt)!==null&&i!==void 0?i:new Date,expirationTime:(o=k?.signInWithEthereum)===null||o===void 0?void 0:o.expirationTime,notBefore:(u=k?.signInWithEthereum)===null||u===void 0?void 0:u.notBefore,requestId:(d=k?.signInWithEthereum)===null||d===void 0?void 0:d.requestId,resources:(c=k?.signInWithEthereum)===null||c===void 0?void 0:c.resources};g=DAe(M),b=await N.request({method:"personal_sign",params:[RAe(g),$]})}try{const{data:v,error:x}=await Ze(this.fetch,"POST",`${this.url}/token?grant_type=web3`,{headers:this.headers,body:Object.assign({chain:"ethereum",message:g,signature:b},!((p=t.options)===null||p===void 0)&&p.captchaToken?{gotrue_meta_security:{captcha_token:(m=t.options)===null||m===void 0?void 0:m.captchaToken}}:null),xform:Rs});if(x)throw x;if(!v||!v.session||!v.user){const w=new mh;return this._returnResult({data:{user:null,session:null},error:w})}return v.session&&(await this._saveSession(v.session),await this._notifyAllSubscribers("SIGNED_IN",v.session)),this._returnResult({data:Object.assign({},v),error:x})}catch(v){if(qe(v))return this._returnResult({data:{user:null,session:null},error:v});throw v}}async signInWithSolana(t){var n,a,r,s,i,o,u,d,c,p,m,g;let b,v;if("message"in t)b=t.message,v=t.signature;else{const{chain:x,wallet:w,statement:k,options:N}=t;let I;if(Ma())if(typeof w=="object")I=w;else{const $=window;if("solana"in $&&typeof $.solana=="object"&&("signIn"in $.solana&&typeof $.solana.signIn=="function"||"signMessage"in $.solana&&typeof $.solana.signMessage=="function"))I=$.solana;else throw new Error("@supabase/auth-js: No compatible Solana wallet interface on the window object (window.solana) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'solana', wallet: resolvedUserWallet }) instead.")}else{if(typeof w!="object"||!N?.url)throw new Error("@supabase/auth-js: Both wallet and url must be specified in non-browser environments.");I=w}const T=new URL((n=N?.url)!==null&&n!==void 0?n:window.location.href);if("signIn"in I&&I.signIn){const $=await I.signIn(Object.assign(Object.assign(Object.assign({issuedAt:new Date().toISOString()},N?.signInWithSolana),{version:"1",domain:T.host,uri:T.href}),k?{statement:k}:null));let D;if(Array.isArray($)&&$[0]&&typeof $[0]=="object")D=$[0];else if($&&typeof $=="object"&&"signedMessage"in $&&"signature"in $)D=$;else throw new Error("@supabase/auth-js: Wallet method signIn() returned unrecognized value");if("signedMessage"in D&&"signature"in D&&(typeof D.signedMessage=="string"||D.signedMessage instanceof Uint8Array)&&D.signature instanceof Uint8Array)b=typeof D.signedMessage=="string"?D.signedMessage:new TextDecoder().decode(D.signedMessage),v=D.signature;else throw new Error("@supabase/auth-js: Wallet method signIn() API returned object without signedMessage and signature fields")}else{if(!("signMessage"in I)||typeof I.signMessage!="function"||!("publicKey"in I)||typeof I!="object"||!I.publicKey||!("toBase58"in I.publicKey)||typeof I.publicKey.toBase58!="function")throw new Error("@supabase/auth-js: Wallet does not have a compatible signMessage() and publicKey.toBase58() API");b=[`${T.host} wants you to sign in with your Solana account:`,I.publicKey.toBase58(),...k?["",k,""]:[""],"Version: 1",`URI: ${T.href}`,`Issued At: ${(r=(a=N?.signInWithSolana)===null||a===void 0?void 0:a.issuedAt)!==null&&r!==void 0?r:new Date().toISOString()}`,...!((s=N?.signInWithSolana)===null||s===void 0)&&s.notBefore?[`Not Before: ${N.signInWithSolana.notBefore}`]:[],...!((i=N?.signInWithSolana)===null||i===void 0)&&i.expirationTime?[`Expiration Time: ${N.signInWithSolana.expirationTime}`]:[],...!((o=N?.signInWithSolana)===null||o===void 0)&&o.chainId?[`Chain ID: ${N.signInWithSolana.chainId}`]:[],...!((u=N?.signInWithSolana)===null||u===void 0)&&u.nonce?[`Nonce: ${N.signInWithSolana.nonce}`]:[],...!((d=N?.signInWithSolana)===null||d===void 0)&&d.requestId?[`Request ID: ${N.signInWithSolana.requestId}`]:[],...!((p=(c=N?.signInWithSolana)===null||c===void 0?void 0:c.resources)===null||p===void 0)&&p.length?["Resources",...N.signInWithSolana.resources.map(D=>`- ${D}`)]:[]].join(`
`);const $=await I.signMessage(new TextEncoder().encode(b),"utf8");if(!$||!($ instanceof Uint8Array))throw new Error("@supabase/auth-js: Wallet signMessage() API returned an recognized value");v=$}}try{const{data:x,error:w}=await Ze(this.fetch,"POST",`${this.url}/token?grant_type=web3`,{headers:this.headers,body:Object.assign({chain:"solana",message:b,signature:vu(v)},!((m=t.options)===null||m===void 0)&&m.captchaToken?{gotrue_meta_security:{captcha_token:(g=t.options)===null||g===void 0?void 0:g.captchaToken}}:null),xform:Rs});if(w)throw w;if(!x||!x.session||!x.user){const k=new mh;return this._returnResult({data:{user:null,session:null},error:k})}return x.session&&(await this._saveSession(x.session),await this._notifyAllSubscribers("SIGNED_IN",x.session)),this._returnResult({data:Object.assign({},x),error:w})}catch(x){if(qe(x))return this._returnResult({data:{user:null,session:null},error:x});throw x}}async _exchangeCodeForSession(t){const n=await su(this.storage,`${this.storageKey}-code-verifier`),[a,r]=(n??"").split("/");try{if(!a&&this.flowType==="pkce")throw new QCe;const{data:s,error:i}=await Ze(this.fetch,"POST",`${this.url}/token?grant_type=pkce`,{headers:this.headers,body:{auth_code:t,code_verifier:a},xform:Rs});if(await Oa(this.storage,`${this.storageKey}-code-verifier`),i)throw i;if(!s||!s.session||!s.user){const o=new mh;return this._returnResult({data:{user:null,session:null,redirectType:null},error:o})}return s.session&&(await this._saveSession(s.session),await this._notifyAllSubscribers("SIGNED_IN",s.session)),this._returnResult({data:Object.assign(Object.assign({},s),{redirectType:r??null}),error:i})}catch(s){if(await Oa(this.storage,`${this.storageKey}-code-verifier`),qe(s))return this._returnResult({data:{user:null,session:null,redirectType:null},error:s});throw s}}async signInWithIdToken(t){try{const{options:n,provider:a,token:r,access_token:s,nonce:i}=t,o=await Ze(this.fetch,"POST",`${this.url}/token?grant_type=id_token`,{headers:this.headers,body:{provider:a,id_token:r,access_token:s,nonce:i,gotrue_meta_security:{captcha_token:n?.captchaToken}},xform:Rs}),{data:u,error:d}=o;if(d)return this._returnResult({data:{user:null,session:null},error:d});if(!u||!u.session||!u.user){const c=new mh;return this._returnResult({data:{user:null,session:null},error:c})}return u.session&&(await this._saveSession(u.session),await this._notifyAllSubscribers("SIGNED_IN",u.session)),this._returnResult({data:u,error:d})}catch(n){if(qe(n))return this._returnResult({data:{user:null,session:null},error:n});throw n}}async signInWithOtp(t){var n,a,r,s,i;try{if("email"in t){const{email:o,options:u}=t;let d=null,c=null;this.flowType==="pkce"&&([d,c]=await gh(this.storage,this.storageKey));const{error:p}=await Ze(this.fetch,"POST",`${this.url}/otp`,{headers:this.headers,body:{email:o,data:(n=u?.data)!==null&&n!==void 0?n:{},create_user:(a=u?.shouldCreateUser)!==null&&a!==void 0?a:!0,gotrue_meta_security:{captcha_token:u?.captchaToken},code_challenge:d,code_challenge_method:c},redirectTo:u?.emailRedirectTo});return this._returnResult({data:{user:null,session:null},error:p})}if("phone"in t){const{phone:o,options:u}=t,{data:d,error:c}=await Ze(this.fetch,"POST",`${this.url}/otp`,{headers:this.headers,body:{phone:o,data:(r=u?.data)!==null&&r!==void 0?r:{},create_user:(s=u?.shouldCreateUser)!==null&&s!==void 0?s:!0,gotrue_meta_security:{captcha_token:u?.captchaToken},channel:(i=u?.channel)!==null&&i!==void 0?i:"sms"}});return this._returnResult({data:{user:null,session:null,messageId:d?.message_id},error:c})}throw new ov("You must provide either an email or phone number.")}catch(o){if(await Oa(this.storage,`${this.storageKey}-code-verifier`),qe(o))return this._returnResult({data:{user:null,session:null},error:o});throw o}}async verifyOtp(t){var n,a;try{let r,s;"options"in t&&(r=(n=t.options)===null||n===void 0?void 0:n.redirectTo,s=(a=t.options)===null||a===void 0?void 0:a.captchaToken);const{data:i,error:o}=await Ze(this.fetch,"POST",`${this.url}/verify`,{headers:this.headers,body:Object.assign(Object.assign({},t),{gotrue_meta_security:{captcha_token:s}}),redirectTo:r,xform:Rs});if(o)throw o;if(!i)throw new Error("An error occurred on token verification.");const u=i.session,d=i.user;return u?.access_token&&(await this._saveSession(u),await this._notifyAllSubscribers(t.type=="recovery"?"PASSWORD_RECOVERY":"SIGNED_IN",u)),this._returnResult({data:{user:d,session:u},error:null})}catch(r){if(qe(r))return this._returnResult({data:{user:null,session:null},error:r});throw r}}async signInWithSSO(t){var n,a,r,s,i;try{let o=null,u=null;this.flowType==="pkce"&&([o,u]=await gh(this.storage,this.storageKey));const d=await Ze(this.fetch,"POST",`${this.url}/sso`,{body:Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},"providerId"in t?{provider_id:t.providerId}:null),"domain"in t?{domain:t.domain}:null),{redirect_to:(a=(n=t.options)===null||n===void 0?void 0:n.redirectTo)!==null&&a!==void 0?a:void 0}),!((r=t?.options)===null||r===void 0)&&r.captchaToken?{gotrue_meta_security:{captcha_token:t.options.captchaToken}}:null),{skip_http_redirect:!0,code_challenge:o,code_challenge_method:u}),headers:this.headers,xform:_Ae});return!((s=d.data)===null||s===void 0)&&s.url&&Ma()&&!(!((i=t.options)===null||i===void 0)&&i.skipBrowserRedirect)&&window.location.assign(d.data.url),this._returnResult(d)}catch(o){if(await Oa(this.storage,`${this.storageKey}-code-verifier`),qe(o))return this._returnResult({data:null,error:o});throw o}}async reauthenticate(){return await this.initializePromise,await this._acquireLock(-1,async()=>await this._reauthenticate())}async _reauthenticate(){try{return await this._useSession(async t=>{const{data:{session:n},error:a}=t;if(a)throw a;if(!n)throw new Wr;const{error:r}=await Ze(this.fetch,"GET",`${this.url}/reauthenticate`,{headers:this.headers,jwt:n.access_token});return this._returnResult({data:{user:null,session:null},error:r})})}catch(t){if(qe(t))return this._returnResult({data:{user:null,session:null},error:t});throw t}}async resend(t){try{const n=`${this.url}/resend`;if("email"in t){const{email:a,type:r,options:s}=t,{error:i}=await Ze(this.fetch,"POST",n,{headers:this.headers,body:{email:a,type:r,gotrue_meta_security:{captcha_token:s?.captchaToken}},redirectTo:s?.emailRedirectTo});return this._returnResult({data:{user:null,session:null},error:i})}else if("phone"in t){const{phone:a,type:r,options:s}=t,{data:i,error:o}=await Ze(this.fetch,"POST",n,{headers:this.headers,body:{phone:a,type:r,gotrue_meta_security:{captcha_token:s?.captchaToken}}});return this._returnResult({data:{user:null,session:null,messageId:i?.message_id},error:o})}throw new ov("You must provide either an email or phone number and a type")}catch(n){if(qe(n))return this._returnResult({data:{user:null,session:null},error:n});throw n}}async getSession(){return await this.initializePromise,await this._acquireLock(-1,async()=>this._useSession(async n=>n))}async _acquireLock(t,n){this._debug("#_acquireLock","begin",t);try{if(this.lockAcquired){const a=this.pendingInLock.length?this.pendingInLock[this.pendingInLock.length-1]:Promise.resolve(),r=(async()=>(await a,await n()))();return this.pendingInLock.push((async()=>{try{await r}catch{}})()),r}return await this.lock(`lock:${this.storageKey}`,t,async()=>{this._debug("#_acquireLock","lock acquired for storage key",this.storageKey);try{this.lockAcquired=!0;const a=n();for(this.pendingInLock.push((async()=>{try{await a}catch{}})()),await a;this.pendingInLock.length;){const r=[...this.pendingInLock];await Promise.all(r),this.pendingInLock.splice(0,r.length)}return await a}finally{this._debug("#_acquireLock","lock released for storage key",this.storageKey),this.lockAcquired=!1}})}finally{this._debug("#_acquireLock","end")}}async _useSession(t){this._debug("#_useSession","begin");try{const n=await this.__loadSession();return await t(n)}finally{this._debug("#_useSession","end")}}async __loadSession(){this._debug("#__loadSession()","begin"),this.lockAcquired||this._debug("#__loadSession()","used outside of an acquired lock!",new Error().stack);try{let t=null;const n=await su(this.storage,this.storageKey);if(this._debug("#getSession()","session from storage",n),n!==null&&(this._isValidSession(n)?t=n:(this._debug("#getSession()","session from storage is not valid"),await this._removeSession())),!t)return{data:{session:null},error:null};const a=t.expires_at?t.expires_at*1e3-Date.now()<yS:!1;if(this._debug("#__loadSession()",`session has${a?"":" not"} expired`,"expires_at",t.expires_at),!a){if(this.userStorage){const i=await su(this.userStorage,this.storageKey+"-user");i?.user?t.user=i.user:t.user=xS()}if(this.storage.isServer&&t.user&&!t.user.__isUserNotAvailableProxy){const i={value:this.suppressGetSessionWarning};t.user=xAe(t.user,i),i.value&&(this.suppressGetSessionWarning=!0)}return{data:{session:t},error:null}}const{data:r,error:s}=await this._callRefreshToken(t.refresh_token);return s?this._returnResult({data:{session:null},error:s}):this._returnResult({data:{session:r},error:null})}finally{this._debug("#__loadSession()","end")}}async getUser(t){if(t)return await this._getUser(t);await this.initializePromise;const n=await this._acquireLock(-1,async()=>await this._getUser());return n.data.user&&(this.suppressGetSessionWarning=!0),n}async _getUser(t){try{return t?await Ze(this.fetch,"GET",`${this.url}/user`,{headers:this.headers,jwt:t,xform:qo}):await this._useSession(async n=>{var a,r,s;const{data:i,error:o}=n;if(o)throw o;return!(!((a=i.session)===null||a===void 0)&&a.access_token)&&!this.hasCustomAuthorizationHeader?{data:{user:null},error:new Wr}:await Ze(this.fetch,"GET",`${this.url}/user`,{headers:this.headers,jwt:(s=(r=i.session)===null||r===void 0?void 0:r.access_token)!==null&&s!==void 0?s:void 0,xform:qo})})}catch(n){if(qe(n))return JCe(n)&&(await this._removeSession(),await Oa(this.storage,`${this.storageKey}-code-verifier`)),this._returnResult({data:{user:null},error:n});throw n}}async updateUser(t,n={}){return await this.initializePromise,await this._acquireLock(-1,async()=>await this._updateUser(t,n))}async _updateUser(t,n={}){try{return await this._useSession(async a=>{const{data:r,error:s}=a;if(s)throw s;if(!r.session)throw new Wr;const i=r.session;let o=null,u=null;this.flowType==="pkce"&&t.email!=null&&([o,u]=await gh(this.storage,this.storageKey));const{data:d,error:c}=await Ze(this.fetch,"PUT",`${this.url}/user`,{headers:this.headers,redirectTo:n?.emailRedirectTo,body:Object.assign(Object.assign({},t),{code_challenge:o,code_challenge_method:u}),jwt:i.access_token,xform:qo});if(c)throw c;return i.user=d.user,await this._saveSession(i),await this._notifyAllSubscribers("USER_UPDATED",i),this._returnResult({data:{user:i.user},error:null})})}catch(a){if(await Oa(this.storage,`${this.storageKey}-code-verifier`),qe(a))return this._returnResult({data:{user:null},error:a});throw a}}async setSession(t){return await this.initializePromise,await this._acquireLock(-1,async()=>await this._setSession(t))}async _setSession(t){try{if(!t.access_token||!t.refresh_token)throw new Wr;const n=Date.now()/1e3;let a=n,r=!0,s=null;const{payload:i}=vS(t.access_token);if(i.exp&&(a=i.exp,r=a<=n),r){const{data:o,error:u}=await this._callRefreshToken(t.refresh_token);if(u)return this._returnResult({data:{user:null,session:null},error:u});if(!o)return{data:{user:null,session:null},error:null};s=o}else{const{data:o,error:u}=await this._getUser(t.access_token);if(u)throw u;s={access_token:t.access_token,refresh_token:t.refresh_token,user:o.user,token_type:"bearer",expires_in:a-n,expires_at:a},await this._saveSession(s),await this._notifyAllSubscribers("SIGNED_IN",s)}return this._returnResult({data:{user:s.user,session:s},error:null})}catch(n){if(qe(n))return this._returnResult({data:{session:null,user:null},error:n});throw n}}async refreshSession(t){return await this.initializePromise,await this._acquireLock(-1,async()=>await this._refreshSession(t))}async _refreshSession(t){try{return await this._useSession(async n=>{var a;if(!t){const{data:i,error:o}=n;if(o)throw o;t=(a=i.session)!==null&&a!==void 0?a:void 0}if(!t?.refresh_token)throw new Wr;const{data:r,error:s}=await this._callRefreshToken(t.refresh_token);return s?this._returnResult({data:{user:null,session:null},error:s}):r?this._returnResult({data:{user:r.user,session:r},error:null}):this._returnResult({data:{user:null,session:null},error:null})})}catch(n){if(qe(n))return this._returnResult({data:{user:null,session:null},error:n});throw n}}async _getSessionFromURL(t,n){try{if(!Ma())throw new lv("No browser detected.");if(t.error||t.error_description||t.error_code)throw new lv(t.error_description||"Error in URL with unspecified error_description",{error:t.error||"unspecified_error",code:t.error_code||"unspecified_code"});switch(n){case"implicit":if(this.flowType==="pkce")throw new gD("Not a valid PKCE flow url.");break;case"pkce":if(this.flowType==="implicit")throw new lv("Not a valid implicit grant flow url.");break;default:}if(n==="pkce"){if(this._debug("#_initialize()","begin","is PKCE flow",!0),!t.code)throw new gD("No code detected.");const{data:k,error:N}=await this._exchangeCodeForSession(t.code);if(N)throw N;const I=new URL(window.location.href);return I.searchParams.delete("code"),window.history.replaceState(window.history.state,"",I.toString()),{data:{session:k.session,redirectType:null},error:null}}const{provider_token:a,provider_refresh_token:r,access_token:s,refresh_token:i,expires_in:o,expires_at:u,token_type:d}=t;if(!s||!o||!i||!d)throw new lv("No session defined in URL");const c=Math.round(Date.now()/1e3),p=parseInt(o);let m=c+p;u&&(m=parseInt(u));const g=m-c;g*1e3<=_h&&console.warn(`@supabase/gotrue-js: Session as retrieved from URL expires in ${g}s, should have been closer to ${p}s`);const b=m-p;c-b>=120?console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued over 120s ago, URL could be stale",b,m,c):c-b<0&&console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued in the future? Check the device clock for skew",b,m,c);const{data:v,error:x}=await this._getUser(s);if(x)throw x;const w={provider_token:a,provider_refresh_token:r,access_token:s,expires_in:p,expires_at:m,refresh_token:i,token_type:d,user:v.user};return window.location.hash="",this._debug("#_getSessionFromURL()","clearing window.location.hash"),this._returnResult({data:{session:w,redirectType:t.type},error:null})}catch(a){if(qe(a))return this._returnResult({data:{session:null,redirectType:null},error:a});throw a}}_isImplicitGrantCallback(t){return typeof this.detectSessionInUrl=="function"?this.detectSessionInUrl(new URL(window.location.href),t):!!(t.access_token||t.error_description)}async _isPKCECallback(t){const n=await su(this.storage,`${this.storageKey}-code-verifier`);return!!(t.code&&n)}async signOut(t={scope:"global"}){return await this.initializePromise,await this._acquireLock(-1,async()=>await this._signOut(t))}async _signOut({scope:t}={scope:"global"}){return await this._useSession(async n=>{var a;const{data:r,error:s}=n;if(s)return this._returnResult({error:s});const i=(a=r.session)===null||a===void 0?void 0:a.access_token;if(i){const{error:o}=await this.admin.signOut(i,t);if(o&&!(YCe(o)&&(o.status===404||o.status===401||o.status===403)))return this._returnResult({error:o})}return t!=="others"&&(await this._removeSession(),await Oa(this.storage,`${this.storageKey}-code-verifier`)),this._returnResult({error:null})})}onAuthStateChange(t){const n=iAe(),a={id:n,callback:t,unsubscribe:()=>{this._debug("#unsubscribe()","state change callback with id removed",n),this.stateChangeEmitters.delete(n)}};return this._debug("#onAuthStateChange()","registered callback with id",n),this.stateChangeEmitters.set(n,a),(async()=>(await this.initializePromise,await this._acquireLock(-1,async()=>{this._emitInitialSession(n)})))(),{data:{subscription:a}}}async _emitInitialSession(t){return await this._useSession(async n=>{var a,r;try{const{data:{session:s},error:i}=n;if(i)throw i;await((a=this.stateChangeEmitters.get(t))===null||a===void 0?void 0:a.callback("INITIAL_SESSION",s)),this._debug("INITIAL_SESSION","callback id",t,"session",s)}catch(s){await((r=this.stateChangeEmitters.get(t))===null||r===void 0?void 0:r.callback("INITIAL_SESSION",null)),this._debug("INITIAL_SESSION","callback id",t,"error",s),console.error(s)}})}async resetPasswordForEmail(t,n={}){let a=null,r=null;this.flowType==="pkce"&&([a,r]=await gh(this.storage,this.storageKey,!0));try{return await Ze(this.fetch,"POST",`${this.url}/recover`,{body:{email:t,code_challenge:a,code_challenge_method:r,gotrue_meta_security:{captcha_token:n.captchaToken}},headers:this.headers,redirectTo:n.redirectTo})}catch(s){if(await Oa(this.storage,`${this.storageKey}-code-verifier`),qe(s))return this._returnResult({data:null,error:s});throw s}}async getUserIdentities(){var t;try{const{data:n,error:a}=await this.getUser();if(a)throw a;return this._returnResult({data:{identities:(t=n.user.identities)!==null&&t!==void 0?t:[]},error:null})}catch(n){if(qe(n))return this._returnResult({data:null,error:n});throw n}}async linkIdentity(t){return"token"in t?this.linkIdentityIdToken(t):this.linkIdentityOAuth(t)}async linkIdentityOAuth(t){var n;try{const{data:a,error:r}=await this._useSession(async s=>{var i,o,u,d,c;const{data:p,error:m}=s;if(m)throw m;const g=await this._getUrlForProvider(`${this.url}/user/identities/authorize`,t.provider,{redirectTo:(i=t.options)===null||i===void 0?void 0:i.redirectTo,scopes:(o=t.options)===null||o===void 0?void 0:o.scopes,queryParams:(u=t.options)===null||u===void 0?void 0:u.queryParams,skipBrowserRedirect:!0});return await Ze(this.fetch,"GET",g,{headers:this.headers,jwt:(c=(d=p.session)===null||d===void 0?void 0:d.access_token)!==null&&c!==void 0?c:void 0})});if(r)throw r;return Ma()&&!(!((n=t.options)===null||n===void 0)&&n.skipBrowserRedirect)&&window.location.assign(a?.url),this._returnResult({data:{provider:t.provider,url:a?.url},error:null})}catch(a){if(qe(a))return this._returnResult({data:{provider:t.provider,url:null},error:a});throw a}}async linkIdentityIdToken(t){return await this._useSession(async n=>{var a;try{const{error:r,data:{session:s}}=n;if(r)throw r;const{options:i,provider:o,token:u,access_token:d,nonce:c}=t,p=await Ze(this.fetch,"POST",`${this.url}/token?grant_type=id_token`,{headers:this.headers,jwt:(a=s?.access_token)!==null&&a!==void 0?a:void 0,body:{provider:o,id_token:u,access_token:d,nonce:c,link_identity:!0,gotrue_meta_security:{captcha_token:i?.captchaToken}},xform:Rs}),{data:m,error:g}=p;return g?this._returnResult({data:{user:null,session:null},error:g}):!m||!m.session||!m.user?this._returnResult({data:{user:null,session:null},error:new mh}):(m.session&&(await this._saveSession(m.session),await this._notifyAllSubscribers("USER_UPDATED",m.session)),this._returnResult({data:m,error:g}))}catch(r){if(await Oa(this.storage,`${this.storageKey}-code-verifier`),qe(r))return this._returnResult({data:{user:null,session:null},error:r});throw r}})}async unlinkIdentity(t){try{return await this._useSession(async n=>{var a,r;const{data:s,error:i}=n;if(i)throw i;return await Ze(this.fetch,"DELETE",`${this.url}/user/identities/${t.identity_id}`,{headers:this.headers,jwt:(r=(a=s.session)===null||a===void 0?void 0:a.access_token)!==null&&r!==void 0?r:void 0})})}catch(n){if(qe(n))return this._returnResult({data:null,error:n});throw n}}async _refreshAccessToken(t){const n=`#_refreshAccessToken(${t.substring(0,5)}...)`;this._debug(n,"begin");try{const a=Date.now();return await cAe(async r=>(r>0&&await uAe(200*Math.pow(2,r-1)),this._debug(n,"refreshing attempt",r),await Ze(this.fetch,"POST",`${this.url}/token?grant_type=refresh_token`,{body:{refresh_token:t},headers:this.headers,xform:Rs})),(r,s)=>{const i=200*Math.pow(2,r);return s&&bS(s)&&Date.now()+i-a<_h})}catch(a){if(this._debug(n,"error",a),qe(a))return this._returnResult({data:{session:null,user:null},error:a});throw a}finally{this._debug(n,"end")}}_isValidSession(t){return typeof t=="object"&&t!==null&&"access_token"in t&&"refresh_token"in t&&"expires_at"in t}async _handleProviderSignIn(t,n){const a=await this._getUrlForProvider(`${this.url}/authorize`,t,{redirectTo:n.redirectTo,scopes:n.scopes,queryParams:n.queryParams});return this._debug("#_handleProviderSignIn()","provider",t,"options",n,"url",a),Ma()&&!n.skipBrowserRedirect&&window.location.assign(a),{data:{provider:t,url:a},error:null}}async _recoverAndRefresh(){var t,n;const a="#_recoverAndRefresh()";this._debug(a,"begin");try{const r=await su(this.storage,this.storageKey);if(r&&this.userStorage){let i=await su(this.userStorage,this.storageKey+"-user");!this.storage.isServer&&Object.is(this.storage,this.userStorage)&&!i&&(i={user:r.user},await Nh(this.userStorage,this.storageKey+"-user",i)),r.user=(t=i?.user)!==null&&t!==void 0?t:xS()}else if(r&&!r.user&&!r.user){const i=await su(this.storage,this.storageKey+"-user");i&&i?.user?(r.user=i.user,await Oa(this.storage,this.storageKey+"-user"),await Nh(this.storage,this.storageKey,r)):r.user=xS()}if(this._debug(a,"session from storage",r),!this._isValidSession(r)){this._debug(a,"session is not valid"),r!==null&&await this._removeSession();return}const s=((n=r.expires_at)!==null&&n!==void 0?n:1/0)*1e3-Date.now()<yS;if(this._debug(a,`session has${s?"":" not"} expired with margin of ${yS}s`),s){if(this.autoRefreshToken&&r.refresh_token){const{error:i}=await this._callRefreshToken(r.refresh_token);i&&(console.error(i),bS(i)||(this._debug(a,"refresh failed with a non-retryable error, removing the session",i),await this._removeSession()))}}else if(r.user&&r.user.__isUserNotAvailableProxy===!0)try{const{data:i,error:o}=await this._getUser(r.access_token);!o&&i?.user?(r.user=i.user,await this._saveSession(r),await this._notifyAllSubscribers("SIGNED_IN",r)):this._debug(a,"could not get user data, skipping SIGNED_IN notification")}catch(i){console.error("Error getting user data:",i),this._debug(a,"error getting user data, skipping SIGNED_IN notification",i)}else await this._notifyAllSubscribers("SIGNED_IN",r)}catch(r){this._debug(a,"error",r),console.error(r);return}finally{this._debug(a,"end")}}async _callRefreshToken(t){var n,a;if(!t)throw new Wr;if(this.refreshingDeferred)return this.refreshingDeferred.promise;const r=`#_callRefreshToken(${t.substring(0,5)}...)`;this._debug(r,"begin");try{this.refreshingDeferred=new Fx;const{data:s,error:i}=await this._refreshAccessToken(t);if(i)throw i;if(!s.session)throw new Wr;await this._saveSession(s.session),await this._notifyAllSubscribers("TOKEN_REFRESHED",s.session);const o={data:s.session,error:null};return this.refreshingDeferred.resolve(o),o}catch(s){if(this._debug(r,"error",s),qe(s)){const i={data:null,error:s};return bS(s)||await this._removeSession(),(n=this.refreshingDeferred)===null||n===void 0||n.resolve(i),i}throw(a=this.refreshingDeferred)===null||a===void 0||a.reject(s),s}finally{this.refreshingDeferred=null,this._debug(r,"end")}}async _notifyAllSubscribers(t,n,a=!0){const r=`#_notifyAllSubscribers(${t})`;this._debug(r,"begin",n,`broadcast = ${a}`);try{this.broadcastChannel&&a&&this.broadcastChannel.postMessage({event:t,session:n});const s=[],i=Array.from(this.stateChangeEmitters.values()).map(async o=>{try{await o.callback(t,n)}catch(u){s.push(u)}});if(await Promise.all(i),s.length>0){for(let o=0;o<s.length;o+=1)console.error(s[o]);throw s[0]}}finally{this._debug(r,"end")}}async _saveSession(t){this._debug("#_saveSession()",t),this.suppressGetSessionWarning=!0,await Oa(this.storage,`${this.storageKey}-code-verifier`);const n=Object.assign({},t),a=n.user&&n.user.__isUserNotAvailableProxy===!0;if(this.userStorage){!a&&n.user&&await Nh(this.userStorage,this.storageKey+"-user",{user:n.user});const r=Object.assign({},n);delete r.user;const s=wD(r);await Nh(this.storage,this.storageKey,s)}else{const r=wD(n);await Nh(this.storage,this.storageKey,r)}}async _removeSession(){this._debug("#_removeSession()"),this.suppressGetSessionWarning=!1,await Oa(this.storage,this.storageKey),await Oa(this.storage,this.storageKey+"-code-verifier"),await Oa(this.storage,this.storageKey+"-user"),this.userStorage&&await Oa(this.userStorage,this.storageKey+"-user"),await this._notifyAllSubscribers("SIGNED_OUT",null)}_removeVisibilityChangedCallback(){this._debug("#_removeVisibilityChangedCallback()");const t=this.visibilityChangedCallback;this.visibilityChangedCallback=null;try{t&&Ma()&&window?.removeEventListener&&window.removeEventListener("visibilitychange",t)}catch(n){console.error("removing visibilitychange callback failed",n)}}async _startAutoRefresh(){await this._stopAutoRefresh(),this._debug("#_startAutoRefresh()");const t=setInterval(()=>this._autoRefreshTokenTick(),_h);this.autoRefreshTicker=t,t&&typeof t=="object"&&typeof t.unref=="function"?t.unref():typeof Deno<"u"&&typeof Deno.unrefTimer=="function"&&Deno.unrefTimer(t),setTimeout(async()=>{await this.initializePromise,await this._autoRefreshTokenTick()},0)}async _stopAutoRefresh(){this._debug("#_stopAutoRefresh()");const t=this.autoRefreshTicker;this.autoRefreshTicker=null,t&&clearInterval(t)}async startAutoRefresh(){this._removeVisibilityChangedCallback(),await this._startAutoRefresh()}async stopAutoRefresh(){this._removeVisibilityChangedCallback(),await this._stopAutoRefresh()}async _autoRefreshTokenTick(){this._debug("#_autoRefreshTokenTick()","begin");try{await this._acquireLock(0,async()=>{try{const t=Date.now();try{return await this._useSession(async n=>{const{data:{session:a}}=n;if(!a||!a.refresh_token||!a.expires_at){this._debug("#_autoRefreshTokenTick()","no session");return}const r=Math.floor((a.expires_at*1e3-t)/_h);this._debug("#_autoRefreshTokenTick()",`access token expires in ${r} ticks, a tick lasts ${_h}ms, refresh threshold is ${Uk} ticks`),r<=Uk&&await this._callRefreshToken(a.refresh_token)})}catch(n){console.error("Auto refresh tick failed with error. This is likely a transient error.",n)}}finally{this._debug("#_autoRefreshTokenTick()","end")}})}catch(t){if(t.isAcquireTimeout||t instanceof wj)this._debug("auto refresh token tick lock not available");else throw t}}async _handleVisibilityChange(){if(this._debug("#_handleVisibilityChange()"),!Ma()||!window?.addEventListener)return this.autoRefreshToken&&this.startAutoRefresh(),!1;try{this.visibilityChangedCallback=async()=>await this._onVisibilityChanged(!1),window?.addEventListener("visibilitychange",this.visibilityChangedCallback),await this._onVisibilityChanged(!0)}catch(t){console.error("_handleVisibilityChange",t)}}async _onVisibilityChanged(t){const n=`#_onVisibilityChanged(${t})`;this._debug(n,"visibilityState",document.visibilityState),document.visibilityState==="visible"?(this.autoRefreshToken&&this._startAutoRefresh(),t||(await this.initializePromise,await this._acquireLock(-1,async()=>{if(document.visibilityState!=="visible"){this._debug(n,"acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting");return}await this._recoverAndRefresh()}))):document.visibilityState==="hidden"&&this.autoRefreshToken&&this._stopAutoRefresh()}async _getUrlForProvider(t,n,a){const r=[`provider=${encodeURIComponent(n)}`];if(a?.redirectTo&&r.push(`redirect_to=${encodeURIComponent(a.redirectTo)}`),a?.scopes&&r.push(`scopes=${encodeURIComponent(a.scopes)}`),this.flowType==="pkce"){const[s,i]=await gh(this.storage,this.storageKey),o=new URLSearchParams({code_challenge:`${encodeURIComponent(s)}`,code_challenge_method:`${encodeURIComponent(i)}`});r.push(o.toString())}if(a?.queryParams){const s=new URLSearchParams(a.queryParams);r.push(s.toString())}return a?.skipBrowserRedirect&&r.push(`skip_http_redirect=${a.skipBrowserRedirect}`),`${t}?${r.join("&")}`}async _unenroll(t){try{return await this._useSession(async n=>{var a;const{data:r,error:s}=n;return s?this._returnResult({data:null,error:s}):await Ze(this.fetch,"DELETE",`${this.url}/factors/${t.factorId}`,{headers:this.headers,jwt:(a=r?.session)===null||a===void 0?void 0:a.access_token})})}catch(n){if(qe(n))return this._returnResult({data:null,error:n});throw n}}async _enroll(t){try{return await this._useSession(async n=>{var a,r;const{data:s,error:i}=n;if(i)return this._returnResult({data:null,error:i});const o=Object.assign({friendly_name:t.friendlyName,factor_type:t.factorType},t.factorType==="phone"?{phone:t.phone}:t.factorType==="totp"?{issuer:t.issuer}:{}),{data:u,error:d}=await Ze(this.fetch,"POST",`${this.url}/factors`,{body:o,headers:this.headers,jwt:(a=s?.session)===null||a===void 0?void 0:a.access_token});return d?this._returnResult({data:null,error:d}):(t.factorType==="totp"&&u.type==="totp"&&(!((r=u?.totp)===null||r===void 0)&&r.qr_code)&&(u.totp.qr_code=`data:image/svg+xml;utf-8,${u.totp.qr_code}`),this._returnResult({data:u,error:null}))})}catch(n){if(qe(n))return this._returnResult({data:null,error:n});throw n}}async _verify(t){return this._acquireLock(-1,async()=>{try{return await this._useSession(async n=>{var a;const{data:r,error:s}=n;if(s)return this._returnResult({data:null,error:s});const i=Object.assign({challenge_id:t.challengeId},"webauthn"in t?{webauthn:Object.assign(Object.assign({},t.webauthn),{credential_response:t.webauthn.type==="create"?PAe(t.webauthn.credential_response):UAe(t.webauthn.credential_response)})}:{code:t.code}),{data:o,error:u}=await Ze(this.fetch,"POST",`${this.url}/factors/${t.factorId}/verify`,{body:i,headers:this.headers,jwt:(a=r?.session)===null||a===void 0?void 0:a.access_token});return u?this._returnResult({data:null,error:u}):(await this._saveSession(Object.assign({expires_at:Math.round(Date.now()/1e3)+o.expires_in},o)),await this._notifyAllSubscribers("MFA_CHALLENGE_VERIFIED",o),this._returnResult({data:o,error:u}))})}catch(n){if(qe(n))return this._returnResult({data:null,error:n});throw n}})}async _challenge(t){return this._acquireLock(-1,async()=>{try{return await this._useSession(async n=>{var a;const{data:r,error:s}=n;if(s)return this._returnResult({data:null,error:s});const i=await Ze(this.fetch,"POST",`${this.url}/factors/${t.factorId}/challenge`,{body:t,headers:this.headers,jwt:(a=r?.session)===null||a===void 0?void 0:a.access_token});if(i.error)return i;const{data:o}=i;if(o.type!=="webauthn")return{data:o,error:null};switch(o.webauthn.type){case"create":return{data:Object.assign(Object.assign({},o),{webauthn:Object.assign(Object.assign({},o.webauthn),{credential_options:Object.assign(Object.assign({},o.webauthn.credential_options),{publicKey:LAe(o.webauthn.credential_options.publicKey)})})}),error:null};case"request":return{data:Object.assign(Object.assign({},o),{webauthn:Object.assign(Object.assign({},o.webauthn),{credential_options:Object.assign(Object.assign({},o.webauthn.credential_options),{publicKey:BAe(o.webauthn.credential_options.publicKey)})})}),error:null}}})}catch(n){if(qe(n))return this._returnResult({data:null,error:n});throw n}})}async _challengeAndVerify(t){const{data:n,error:a}=await this._challenge({factorId:t.factorId});return a?this._returnResult({data:null,error:a}):await this._verify({factorId:t.factorId,challengeId:n.id,code:t.code})}async _listFactors(){var t;const{data:{user:n},error:a}=await this.getUser();if(a)return{data:null,error:a};const r={all:[],phone:[],totp:[],webauthn:[]};for(const s of(t=n?.factors)!==null&&t!==void 0?t:[])r.all.push(s),s.status==="verified"&&r[s.factor_type].push(s);return{data:r,error:null}}async _getAuthenticatorAssuranceLevel(){var t,n;const{data:{session:a},error:r}=await this.getSession();if(r)return this._returnResult({data:null,error:r});if(!a)return{data:{currentLevel:null,nextLevel:null,currentAuthenticationMethods:[]},error:null};const{payload:s}=vS(a.access_token);let i=null;s.aal&&(i=s.aal);let o=i;((n=(t=a.user.factors)===null||t===void 0?void 0:t.filter(c=>c.status==="verified"))!==null&&n!==void 0?n:[]).length>0&&(o="aal2");const d=s.amr||[];return{data:{currentLevel:i,nextLevel:o,currentAuthenticationMethods:d},error:null}}async _getAuthorizationDetails(t){try{return await this._useSession(async n=>{const{data:{session:a},error:r}=n;return r?this._returnResult({data:null,error:r}):a?await Ze(this.fetch,"GET",`${this.url}/oauth/authorizations/${t}`,{headers:this.headers,jwt:a.access_token,xform:s=>({data:s,error:null})}):this._returnResult({data:null,error:new Wr})})}catch(n){if(qe(n))return this._returnResult({data:null,error:n});throw n}}async _approveAuthorization(t,n){try{return await this._useSession(async a=>{const{data:{session:r},error:s}=a;if(s)return this._returnResult({data:null,error:s});if(!r)return this._returnResult({data:null,error:new Wr});const i=await Ze(this.fetch,"POST",`${this.url}/oauth/authorizations/${t}/consent`,{headers:this.headers,jwt:r.access_token,body:{action:"approve"},xform:o=>({data:o,error:null})});return i.data&&i.data.redirect_url&&Ma()&&!n?.skipBrowserRedirect&&window.location.assign(i.data.redirect_url),i})}catch(a){if(qe(a))return this._returnResult({data:null,error:a});throw a}}async _denyAuthorization(t,n){try{return await this._useSession(async a=>{const{data:{session:r},error:s}=a;if(s)return this._returnResult({data:null,error:s});if(!r)return this._returnResult({data:null,error:new Wr});const i=await Ze(this.fetch,"POST",`${this.url}/oauth/authorizations/${t}/consent`,{headers:this.headers,jwt:r.access_token,body:{action:"deny"},xform:o=>({data:o,error:null})});return i.data&&i.data.redirect_url&&Ma()&&!n?.skipBrowserRedirect&&window.location.assign(i.data.redirect_url),i})}catch(a){if(qe(a))return this._returnResult({data:null,error:a});throw a}}async _listOAuthGrants(){try{return await this._useSession(async t=>{const{data:{session:n},error:a}=t;return a?this._returnResult({data:null,error:a}):n?await Ze(this.fetch,"GET",`${this.url}/user/oauth/grants`,{headers:this.headers,jwt:n.access_token,xform:r=>({data:r,error:null})}):this._returnResult({data:null,error:new Wr})})}catch(t){if(qe(t))return this._returnResult({data:null,error:t});throw t}}async _revokeOAuthGrant(t){try{return await this._useSession(async n=>{const{data:{session:a},error:r}=n;return r?this._returnResult({data:null,error:r}):a?(await Ze(this.fetch,"DELETE",`${this.url}/user/oauth/grants`,{headers:this.headers,jwt:a.access_token,query:{client_id:t.clientId},noResolveJson:!0}),{data:{},error:null}):this._returnResult({data:null,error:new Wr})})}catch(n){if(qe(n))return this._returnResult({data:null,error:n});throw n}}async fetchJwk(t,n={keys:[]}){let a=n.keys.find(o=>o.kid===t);if(a)return a;const r=Date.now();if(a=this.jwks.keys.find(o=>o.kid===t),a&&this.jwks_cached_at+KCe>r)return a;const{data:s,error:i}=await Ze(this.fetch,"GET",`${this.url}/.well-known/jwks.json`,{headers:this.headers});if(i)throw i;return!s.keys||s.keys.length===0||(this.jwks=s,this.jwks_cached_at=r,a=s.keys.find(o=>o.kid===t),!a)?null:a}async getClaims(t,n={}){try{let a=t;if(!a){const{data:g,error:b}=await this.getSession();if(b||!g.session)return this._returnResult({data:null,error:b});a=g.session.access_token}const{header:r,payload:s,signature:i,raw:{header:o,payload:u}}=vS(a);n?.allowExpired||yAe(s.exp);const d=!r.alg||r.alg.startsWith("HS")||!r.kid||!("crypto"in globalThis&&"subtle"in globalThis.crypto)?null:await this.fetchJwk(r.kid,n?.keys?{keys:n.keys}:n?.jwks);if(!d){const{error:g}=await this.getUser(a);if(g)throw g;return{data:{claims:s,header:r,signature:i},error:null}}const c=bAe(r.alg),p=await crypto.subtle.importKey("jwk",d,c,!0,["verify"]);if(!await crypto.subtle.verify(c,p,i,rAe(`${o}.${u}`)))throw new Vk("Invalid JWT signature");return{data:{claims:s,header:r,signature:i},error:null}}catch(a){if(qe(a))return this._returnResult({data:null,error:a});throw a}}}vg.nextInstanceID={};const YAe=vg,JAe="2.89.0";let Bm="";typeof Deno<"u"?Bm="deno":typeof document<"u"?Bm="web":typeof navigator<"u"&&navigator.product==="ReactNative"?Bm="react-native":Bm="node";const ZAe={"X-Client-Info":`supabase-js-${Bm}/${JAe}`},QAe={headers:ZAe},e$e={schema:"public"},t$e={autoRefreshToken:!0,persistSession:!0,detectSessionInUrl:!0,flowType:"implicit"},n$e={};function xg(e){"@babel/helpers - typeof";return xg=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(t){return typeof t}:function(t){return t&&typeof Symbol=="function"&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},xg(e)}function a$e(e,t){if(xg(e)!="object"||!e)return e;var n=e[Symbol.toPrimitive];if(n!==void 0){var a=n.call(e,t);if(xg(a)!="object")return a;throw new TypeError("@@toPrimitive must return a primitive value.")}return(t==="string"?String:Number)(e)}function r$e(e){var t=a$e(e,"string");return xg(t)=="symbol"?t:t+""}function s$e(e,t,n){return(t=r$e(t))in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function ED(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter(function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable})),n.push.apply(n,a)}return n}function $n(e){for(var t=1;t<arguments.length;t++){var n=arguments[t]!=null?arguments[t]:{};t%2?ED(Object(n),!0).forEach(function(a){s$e(e,a,n[a])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):ED(Object(n)).forEach(function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(n,a))})}return e}const i$e=e=>e?(...t)=>e(...t):(...t)=>fetch(...t),o$e=()=>Headers,l$e=(e,t,n)=>{const a=i$e(n),r=o$e();return async(s,i)=>{var o;const u=(o=await t())!==null&&o!==void 0?o:e;let d=new r(i?.headers);return d.has("apikey")||d.set("apikey",e),d.has("Authorization")||d.set("Authorization",`Bearer ${u}`),a(s,$n($n({},i),{},{headers:d}))}};function u$e(e){return e.endsWith("/")?e:e+"/"}function c$e(e,t){var n,a;const{db:r,auth:s,realtime:i,global:o}=e,{db:u,auth:d,realtime:c,global:p}=t,m={db:$n($n({},u),r),auth:$n($n({},d),s),realtime:$n($n({},c),i),storage:{},global:$n($n($n({},p),o),{},{headers:$n($n({},(n=p?.headers)!==null&&n!==void 0?n:{}),(a=o?.headers)!==null&&a!==void 0?a:{})}),accessToken:async()=>""};return e.accessToken?m.accessToken=e.accessToken:delete m.accessToken,m}function d$e(e){const t=e?.trim();if(!t)throw new Error("supabaseUrl is required.");if(!t.match(/^https?:\/\//i))throw new Error("Invalid supabaseUrl: Must be a valid HTTP or HTTPS URL.");try{return new URL(u$e(t))}catch{throw Error("Invalid supabaseUrl: Provided URL is malformed.")}}var h$e=class extends YAe{constructor(e){super(e)}},p$e=class{constructor(e,t,n){var a,r;this.supabaseUrl=e,this.supabaseKey=t;const s=d$e(e);if(!t)throw new Error("supabaseKey is required.");this.realtimeUrl=new URL("realtime/v1",s),this.realtimeUrl.protocol=this.realtimeUrl.protocol.replace("http","ws"),this.authUrl=new URL("auth/v1",s),this.storageUrl=new URL("storage/v1",s),this.functionsUrl=new URL("functions/v1",s);const i=`sb-${s.hostname.split(".")[0]}-auth-token`,o={db:e$e,realtime:n$e,auth:$n($n({},t$e),{},{storageKey:i}),global:QAe},u=c$e(n??{},o);if(this.storageKey=(a=u.auth.storageKey)!==null&&a!==void 0?a:"",this.headers=(r=u.global.headers)!==null&&r!==void 0?r:{},u.accessToken)this.accessToken=u.accessToken,this.auth=new Proxy({},{get:(c,p)=>{throw new Error(`@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(p)} is not possible`)}});else{var d;this.auth=this._initSupabaseAuthClient((d=u.auth)!==null&&d!==void 0?d:{},this.headers,u.global.fetch)}this.fetch=l$e(t,this._getAccessToken.bind(this),u.global.fetch),this.realtime=this._initRealtimeClient($n({headers:this.headers,accessToken:this._getAccessToken.bind(this)},u.realtime)),this.accessToken&&this.accessToken().then(c=>this.realtime.setAuth(c)).catch(c=>console.warn("Failed to set initial Realtime auth token:",c)),this.rest=new GEe(new URL("rest/v1",s).href,{headers:this.headers,schema:u.db.schema,fetch:this.fetch}),this.storage=new WCe(this.storageUrl.href,this.headers,this.fetch,n?.storage),u.accessToken||this._listenForAuthEvents()}get functions(){return new UEe(this.functionsUrl.href,{headers:this.headers,customFetch:this.fetch})}from(e){return this.rest.from(e)}schema(e){return this.rest.schema(e)}rpc(e,t={},n={head:!1,get:!1,count:void 0}){return this.rest.rpc(e,t,n)}channel(e,t={config:{}}){return this.realtime.channel(e,t)}getChannels(){return this.realtime.getChannels()}removeChannel(e){return this.realtime.removeChannel(e)}removeAllChannels(){return this.realtime.removeAllChannels()}async _getAccessToken(){var e=this,t,n;if(e.accessToken)return await e.accessToken();const{data:a}=await e.auth.getSession();return(t=(n=a.session)===null||n===void 0?void 0:n.access_token)!==null&&t!==void 0?t:e.supabaseKey}_initSupabaseAuthClient({autoRefreshToken:e,persistSession:t,detectSessionInUrl:n,storage:a,userStorage:r,storageKey:s,flowType:i,lock:o,debug:u,throwOnError:d},c,p){const m={Authorization:`Bearer ${this.supabaseKey}`,apikey:`${this.supabaseKey}`};return new h$e({url:this.authUrl.href,headers:$n($n({},m),c),storageKey:s,autoRefreshToken:e,persistSession:t,detectSessionInUrl:n,storage:a,userStorage:r,flowType:i,lock:o,debug:u,throwOnError:d,fetch:p,hasCustomAuthorizationHeader:Object.keys(this.headers).some(g=>g.toLowerCase()==="authorization")})}_initRealtimeClient(e){return new uCe(this.realtimeUrl.href,$n($n({},e),{},{params:$n($n({},{apikey:this.supabaseKey}),e?.params)}))}_listenForAuthEvents(){return this.auth.onAuthStateChange((e,t)=>{this._handleTokenChanged(e,"CLIENT",t?.access_token)})}_handleTokenChanged(e,t,n){(e==="TOKEN_REFRESHED"||e==="SIGNED_IN")&&this.changedAccessToken!==n?(this.changedAccessToken=n,this.realtime.setAuth(n)):e==="SIGNED_OUT"&&(this.realtime.setAuth(),t=="STORAGE"&&this.auth.signOut(),this.changedAccessToken=void 0)}};const f$e=(e,t,n)=>new p$e(e,t,n);function m$e(){if(typeof window<"u"||typeof process>"u")return!1;const e=process.version;if(e==null)return!1;const t=e.match(/^v(\d+)\./);return t?parseInt(t[1],10)<=18:!1}m$e()&&console.warn("  Node.js 18 and below are deprecated and will no longer be supported in future versions of @supabase/supabase-js. Please upgrade to Node.js 20 or later. For more information, visit: https://github.com/orgs/supabase/discussions/37217");const g$e="https://gpjmlbrtfqouqskbbjdw.supabase.co",y$e="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imdwam1sYnJ0ZnFvdXFza2JiamR3Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njc2Njc3MDksImV4cCI6MjA4MzI0MzcwOX0.Hn3zwqwEevz8KP9chXYs9wRwwhdxYw6hrKtAgM-NZ5w",ir=f$e(g$e,y$e),b$e=()=>{const[e,t]=he.useState(!1),[n,a]=he.useState(null),[r,s]=he.useState(null),[i,o]=he.useState(null),[u,d]=he.useState(null),c=he.useRef(),p=he.useRef(),m=he.useRef(!1),g=he.useRef({});he.useEffect(()=>{(async()=>{try{await IS.setBackend("webgl"),await IS.ready();const k="/kap-academic-admin/models";await Promise.all([Fa.ssdMobilenetv1.loadFromUri(k),Fa.faceLandmark68Net.loadFromUri(k),Fa.faceRecognitionNet.loadFromUri(k)]);const{data:N}=await ir.from("students").select("full_name, roll_number, face_descriptor").not("face_descriptor","is",null);if(N&&N.length>0){const I=N.map(T=>{const $=new Float32Array(JSON.parse(T.face_descriptor));return new Lm(`${T.full_name} (${T.roll_number})`,[$])});a(new zEe(I,.45)),t(!0)}}catch(k){console.error("AI Error:",k)}})()},[]),he.useEffect(()=>{e&&navigator.mediaDevices.getUserMedia({video:{width:{ideal:1280},height:{ideal:720},facingMode:"user"}}).then(w=>{c.current&&(c.current.srcObject=w)}).catch(w=>console.error(w))},[e]);const b=async w=>{if(m.current)return;const k=w.split(" (")[0],N=w.split(" (")[1]?.replace(")",""),I=Date.now(),T=g.current[N];if(!(T&&I-T<1800*1e3)){m.current=!0;try{const $=new Date().toISOString().split("T")[0],{data:D}=await ir.from("gate_logs").select("*").eq("roll_number",N).eq("date_only",$).order("scan_time",{ascending:!1}).limit(1);let M="IN";D&&D.length>0&&D[0].scan_type==="IN"&&(M="OUT"),await ir.from("gate_logs").insert([{roll_number:N,student_name:k,scan_type:M}]),s({name:k,status:M,time:new Date().toLocaleTimeString("en-IN",{hour:"2-digit",minute:"2-digit"})}),new Audio("https://actions.google.com/sounds/v1/science_fiction/beep_short.ogg").play(),g.current[N]=I,setTimeout(()=>{s(null),m.current=!1,o(null)},4e3)}catch($){console.error($),m.current=!1}}},v=(w,k,N,I=2)=>{w.strokeStyle=N,w.lineWidth=I,w.beginPath(),w.rect(k.x,k.y,k.width,k.height),w.stroke()},x=()=>{setInterval(async()=>{if(c.current&&p.current&&n&&!m.current){const w=new Ey({minConfidence:.8}),k=await sj(c.current,w).withFaceLandmarks().withFaceDescriptor(),N={width:c.current.videoWidth,height:c.current.videoHeight};RU(p.current,N);const I=p.current.getContext("2d");if(I.clearRect(0,0,p.current.width,p.current.height),k){const T=vT(k,N),{box:$}=T.detection,{score:D}=k.detection,M=N.width*.2;if($.width<M){d("Please Step Closer"),v(I,$,"yellow"),o(null);return}if(D<.9){d("Lighting Poor / Face Unclear"),v(I,$,"orange"),o(null);return}const B=$.x+$.width/2,V=N.width/2;if(Math.abs(B-V)>N.width*.25){d("Stand in Center"),v(I,$,"blue"),o(null);return}d(null);const R=n.findBestMatch(T.descriptor);if(R.label!=="unknown"){const H=R.label.split(" (")[0];o(H),I.font="bold 24px sans-serif",I.fillStyle="#00ff9d",I.fillText(H,$.x,$.y-10),v(I,$,"#00ff9d",4),b(R.label)}else o(null),v(I,$,"red",2)}else{d(null),o(null);const T=p.current?.getContext("2d");T&&T.clearRect(0,0,p.current.width,p.current.height)}}},150)};return P.jsx("div",{className:"min-h-screen bg-black flex items-center justify-center font-sans overflow-hidden",children:P.jsxs("div",{className:`
         relative w-full h-screen 
         md:h-auto md:w-auto md:max-w-[1100px] md:aspect-video 
         md:rounded-[2.5rem] md:border md:border-white/10 md:shadow-2xl 
         bg-black overflow-hidden flex flex-col md:flex-row
      `,children:[P.jsxs("div",{className:"relative flex-1 h-full bg-black",children:[P.jsx("div",{className:"absolute top-6 left-6 z-20",children:P.jsxs("div",{className:"bg-black/60 backdrop-blur px-4 py-2 rounded-full border border-white/10 flex items-center gap-2",children:[P.jsx("div",{className:`w-2.5 h-2.5 rounded-full ${e?"bg-green-500 shadow-[0_0_10px_#22c55e]":"bg-yellow-500"}`}),P.jsx("span",{className:"text-white text-[10px] md:text-xs font-bold tracking-widest",children:e?"SECURE AI ACTIVE":"INITIALIZING..."})]})}),P.jsx("video",{ref:c,autoPlay:!0,muted:!0,playsInline:!0,onPlay:x,className:"w-full h-full object-cover transform scale-x-[-1] filter brightness-110 contrast-110"}),P.jsx("canvas",{ref:p,className:"absolute top-0 left-0 w-full h-full transform scale-x-[-1]"}),u&&!r&&P.jsx("div",{className:"absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 z-30 w-max max-w-[90%]",children:P.jsxs("div",{className:"bg-yellow-500/90 text-black px-6 py-3 rounded-full font-bold shadow-lg animate-pulse flex items-center gap-2 text-sm md:text-base",children:[P.jsx(_S,{className:"w-5 h-5"})," ",u]})}),!r&&i&&!u&&P.jsx("div",{className:"absolute bottom-32 md:bottom-8 left-0 right-0 flex justify-center z-20 pointer-events-none",children:P.jsxs("div",{className:"bg-black/70 backdrop-blur-md text-white px-6 py-2 rounded-full border border-green-500/50 flex items-center gap-2 animate-bounce-short shadow-lg",children:[P.jsx(wv,{className:"w-4 h-4 text-green-400 animate-spin"}),P.jsxs("span",{className:"font-bold text-sm",children:["Verifying: ",i]})]})})]}),P.jsxs("div",{className:`
            absolute bottom-0 left-0 right-0 z-30
            md:relative md:w-96 md:h-auto
            bg-gradient-to-t from-black via-black/90 to-transparent md:bg-neutral-900/95 
            md:border-l md:border-white/5 
            p-6 md:p-8 flex flex-col justify-end md:justify-between
            transition-all duration-300
        `,children:[P.jsx("div",{className:"hidden md:block",children:P.jsxs("div",{className:"flex items-center gap-3 mb-8",children:[P.jsx(g$,{className:"w-8 h-8 text-blue-500"}),P.jsx("h1",{className:"text-white font-bold text-xl tracking-tight",children:"Smart Gate"})]})}),r?P.jsxs("div",{className:`
              w-full p-6 rounded-3xl border shadow-xl animate-scale-in
              ${r.status==="IN"?"bg-green-900/40 border-green-500/50 backdrop-blur-md":"bg-red-900/40 border-red-500/50 backdrop-blur-md"}
            `,children:[P.jsxs("div",{className:"flex justify-between items-start mb-2",children:[P.jsx("span",{className:`text-[10px] font-black px-2 py-1 rounded text-white ${r.status==="IN"?"bg-green-600":"bg-red-600"}`,children:r.status==="IN"?"ENTRY":"EXIT"}),P.jsx("span",{className:"text-white/80 text-xs font-mono",children:r.time})]}),P.jsx("h2",{className:"text-2xl md:text-3xl font-bold text-white leading-tight truncate",children:r.name}),P.jsx("p",{className:`text-sm mt-1 font-medium ${r.status==="IN"?"text-green-300":"text-red-300"}`,children:r.status==="IN"?"Welcome Back!":"Goodbye!"})]}):P.jsxs("div",{className:"text-center md:text-left",children:[P.jsxs("div",{className:"md:hidden flex flex-col items-center pb-4",children:[P.jsx("div",{className:"w-12 h-12 bg-white/10 rounded-full flex items-center justify-center mb-2 animate-pulse",children:P.jsx(g$,{className:"w-6 h-6 text-white"})}),P.jsx("p",{className:"text-white font-bold",children:"Ready to Scan"})]}),P.jsxs("div",{className:"hidden md:block p-6 rounded-2xl bg-white/5 border border-white/10 text-center",children:[P.jsx(PH,{className:"w-10 h-10 text-slate-500 mx-auto mb-3"}),P.jsx("p",{className:"text-white text-sm font-bold",children:"Secure Access"}),P.jsxs("p",{className:"text-neutral-500 text-xs mt-2 leading-relaxed",children:["Anti-Spoofing Enabled.",P.jsx("br",{}),"Please stand 2 feet away."]})]})]}),P.jsx("div",{className:"hidden md:block pt-6 border-t border-white/5 text-center",children:P.jsx("p",{className:"text-neutral-600 text-[10px] uppercase font-bold tracking-widest",children:"KAP EDUTECH AI"})})]})]})})},v$e=()=>{const[e,t]=he.useState([]),[n,a]=he.useState([]),[r,s]=he.useState(!0),[i,o]=he.useState(""),[u,d]=he.useState(!1),[c,p]=he.useState(null),[m,g]=he.useState({full_name:"",roll_number:"",phone:"",email:"",batch:"",face_descriptor:null});he.useEffect(()=>{b()},[]),he.useEffect(()=>{if(i.trim()==="")a(e);else{const T=e.filter($=>$.full_name.toLowerCase().includes(i.toLowerCase())||$.roll_number.toLowerCase().includes(i.toLowerCase())||$.batch.toLowerCase().includes(i.toLowerCase()));a(T)}},[e,i]);const b=async()=>{try{const{data:T,error:$}=await ir.from("students").select("*").order("id",{ascending:!1});if($)throw $;t(T||[])}catch(T){console.error("Error loading students:",T),alert("Failed to load students")}finally{s(!1)}},v=async T=>{T.preventDefault(),s(!0);try{if(c){const{error:$}=await ir.from("students").update(m).eq("id",c.id);if($)throw $}else{const{error:$}=await ir.from("students").insert([m]);if($)throw $}await b(),d(!1),p(null),k()}catch($){console.error("Error saving student:",$),alert("Failed to save student: "+$.message)}finally{s(!1)}},x=T=>{p(T),g({full_name:T.full_name,roll_number:T.roll_number,phone:T.phone||"",email:T.email||"",batch:T.batch||"",face_descriptor:T.face_descriptor}),d(!0)},w=async T=>{if(confirm(`Are you sure you want to delete ${T.full_name}?`))try{const{error:$}=await ir.from("gate_logs").delete().eq("roll_number",T.roll_number);$&&console.error("Error removing logs:",$);const{error:D}=await ir.from("students").delete().eq("id",T.id);if(D)throw D;await b()}catch($){console.error("Error deleting student:",$),alert("Failed to delete student: "+$.message)}},k=()=>{g({full_name:"",roll_number:"",phone:"",email:"",batch:"",face_descriptor:null})},N=e.filter(T=>T.face_descriptor).length,I=e.length;return r&&e.length===0?P.jsx("div",{className:"flex items-center justify-center h-96",children:P.jsxs("div",{className:"text-center",children:[P.jsx(wv,{className:"w-12 h-12 animate-spin text-indigo-600 mx-auto mb-4"}),P.jsx("p",{className:"text-slate-600 font-medium",children:"Loading students..."})]})}):P.jsxs("div",{className:"max-w-7xl mx-auto",children:[P.jsxs("div",{className:"mb-8 flex flex-col lg:flex-row lg:justify-between lg:items-end gap-6",children:[P.jsxs("div",{children:[P.jsx("h1",{className:"text-4xl font-bold bg-gradient-to-r from-indigo-600 via-blue-600 to-indigo-600 bg-clip-text text-transparent filter drop-shadow-sm",children:"Student Management"}),P.jsx("p",{className:"text-slate-600 mt-2",children:"Manage student records and enrollment status"})]}),P.jsxs("div",{className:"flex flex-col sm:flex-row gap-4",children:[P.jsx("div",{className:"bg-white rounded-2xl p-6 shadow-lg border border-slate-200",children:P.jsxs("div",{className:"flex items-center gap-4",children:[P.jsx("div",{className:"bg-gradient-to-r from-indigo-500 to-purple-600 p-3 rounded-xl",children:P.jsx(NS,{className:"w-6 h-6 text-white"})}),P.jsxs("div",{children:[P.jsx("p",{className:"text-2xl font-bold text-slate-800",children:I}),P.jsx("p",{className:"text-sm text-slate-500",children:"Total Students"})]})]})}),P.jsx("div",{className:"bg-white rounded-2xl p-6 shadow-lg border border-slate-200",children:P.jsxs("div",{className:"flex items-center gap-4",children:[P.jsx("div",{className:"bg-gradient-to-r from-green-500 to-emerald-600 p-3 rounded-xl",children:P.jsx(Pm,{className:"w-6 h-6 text-white"})}),P.jsxs("div",{children:[P.jsx("p",{className:"text-2xl font-bold text-slate-800",children:N}),P.jsx("p",{className:"text-sm text-slate-500",children:"Face Enrolled"})]})]})}),P.jsxs("button",{onClick:()=>{p(null),k(),d(!0)},className:"bg-gradient-to-r from-indigo-600 to-purple-600 text-white px-6 py-3 rounded-xl font-bold shadow-lg hover:shadow-xl transition-all duration-200 flex items-center gap-2 hover:scale-105",children:[P.jsx(DH,{className:"w-5 h-5"}),"Add Student"]})]})]}),P.jsx("div",{className:"bg-white rounded-2xl p-6 shadow-lg border border-slate-200 mb-8",children:P.jsx("div",{className:"flex flex-col sm:flex-row gap-4",children:P.jsxs("div",{className:"flex-1 relative",children:[P.jsx(ZD,{className:"absolute left-3 top-1/2 transform -translate-y-1/2 text-slate-400 w-5 h-5"}),P.jsx("input",{type:"text",placeholder:"Search by name, roll number, or batch...",value:i,onChange:T=>o(T.target.value),className:"w-full pl-10 pr-4 py-3 border border-slate-300 rounded-xl focus:ring-2 focus:ring-indigo-500 focus:border-transparent outline-none transition-all"})]})})}),P.jsx("div",{className:"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6",children:n.map(T=>P.jsxs("div",{className:"bg-white rounded-2xl p-6 shadow-lg border border-slate-200 hover:shadow-xl transition-all duration-200 group",children:[P.jsxs("div",{className:"flex justify-between items-start mb-4",children:[P.jsxs("div",{className:"flex items-center gap-3",children:[P.jsx("div",{className:`w-12 h-12 rounded-xl flex items-center justify-center font-bold text-white ${T.face_descriptor?"bg-gradient-to-r from-green-500 to-emerald-600":"bg-gradient-to-r from-slate-400 to-slate-500"}`,children:T.face_descriptor?P.jsx(Pm,{className:"w-6 h-6"}):P.jsx(y$,{className:"w-6 h-6"})}),P.jsxs("div",{children:[P.jsx("h3",{className:"font-bold text-lg text-slate-800",children:T.full_name}),P.jsxs("p",{className:"text-sm text-slate-500",children:["Roll: ",T.roll_number]})]})]}),P.jsxs("div",{className:"opacity-0 group-hover:opacity-100 transition-opacity flex gap-2",children:[P.jsx("button",{onClick:()=>x(T),className:"p-2 bg-blue-100 text-blue-600 rounded-lg hover:bg-blue-200 transition-colors",children:P.jsx(jH,{className:"w-4 h-4"})}),P.jsx("button",{onClick:()=>w(T),className:"p-2 bg-red-100 text-red-600 rounded-lg hover:bg-red-200 transition-colors",children:P.jsx(VH,{className:"w-4 h-4"})})]})]}),P.jsxs("div",{className:"space-y-2",children:[P.jsxs("div",{className:"flex items-center gap-2 text-sm",children:[P.jsx(AH,{className:"w-4 h-4 text-slate-400"}),P.jsx("span",{className:"text-slate-600",children:T.email||"No email"})]}),P.jsxs("div",{className:"flex items-center gap-2 text-sm",children:[P.jsx(YD,{className:"w-4 h-4 text-slate-400"}),P.jsx("span",{className:"text-slate-600",children:T.phone||"No phone"})]}),P.jsxs("div",{className:"flex items-center gap-2 text-sm",children:[P.jsx(vH,{className:"w-4 h-4 text-slate-400"}),P.jsx("span",{className:"text-slate-600",children:T.batch||"No batch"})]})]}),P.jsx("div",{className:"mt-4 pt-4 border-t border-slate-100",children:P.jsx("div",{className:`inline-flex items-center gap-2 px-3 py-1 rounded-full text-xs font-bold ${T.face_descriptor?"bg-green-100 text-green-800":"bg-yellow-100 text-yellow-800"}`,children:T.face_descriptor?P.jsxs(P.Fragment,{children:[P.jsx(Pm,{className:"w-3 h-3"}),"Face Enrolled"]}):P.jsxs(P.Fragment,{children:[P.jsx(y$,{className:"w-3 h-3"}),"Not Enrolled"]})})})]},T.id))}),n.length===0&&!r&&P.jsxs("div",{className:"text-center py-16",children:[P.jsx(NS,{className:"w-16 h-16 text-slate-300 mx-auto mb-4"}),P.jsx("h3",{className:"text-xl font-bold text-slate-600 mb-2",children:"No students found"}),P.jsx("p",{className:"text-slate-500",children:i?"Try adjusting your search terms":"Add your first student to get started"})]}),u&&P.jsx("div",{className:"fixed inset-0 bg-black/50 backdrop-blur-sm z-50 flex items-center justify-center p-4",children:P.jsxs("div",{className:"bg-white rounded-2xl shadow-2xl max-w-md w-full max-h-[90vh] overflow-y-auto",children:[P.jsx("div",{className:"p-6 border-b border-slate-200",children:P.jsxs("div",{className:"flex justify-between items-center",children:[P.jsx("h2",{className:"text-2xl font-bold text-slate-800",children:c?"Edit Student":"Add New Student"}),P.jsx("button",{onClick:()=>d(!1),className:"p-2 hover:bg-slate-100 rounded-lg transition-colors",children:P.jsx(ZH,{className:"w-5 h-5"})})]})}),P.jsxs("form",{onSubmit:v,className:"p-6 space-y-4",children:[P.jsxs("div",{children:[P.jsx("label",{className:"block text-sm font-bold text-slate-700 mb-2",children:"Full Name *"}),P.jsx("input",{type:"text",required:!0,value:m.full_name,onChange:T=>g({...m,full_name:T.target.value}),className:"w-full p-3 border border-slate-300 rounded-xl focus:ring-2 focus:ring-indigo-500 focus:border-transparent outline-none",placeholder:"Enter full name"})]}),P.jsxs("div",{children:[P.jsx("label",{className:"block text-sm font-bold text-slate-700 mb-2",children:"Roll Number *"}),P.jsx("input",{type:"text",required:!0,value:m.roll_number,onChange:T=>g({...m,roll_number:T.target.value}),className:"w-full p-3 border border-slate-300 rounded-xl focus:ring-2 focus:ring-indigo-500 focus:border-transparent outline-none",placeholder:"Enter roll number"})]}),P.jsxs("div",{children:[P.jsx("label",{className:"block text-sm font-bold text-slate-700 mb-2",children:"Phone"}),P.jsx("input",{type:"tel",value:m.phone,onChange:T=>g({...m,phone:T.target.value}),className:"w-full p-3 border border-slate-300 rounded-xl focus:ring-2 focus:ring-indigo-500 focus:border-transparent outline-none",placeholder:"Enter phone number"})]}),P.jsxs("div",{children:[P.jsx("label",{className:"block text-sm font-bold text-slate-700 mb-2",children:"Email"}),P.jsx("input",{type:"email",value:m.email,onChange:T=>g({...m,email:T.target.value}),className:"w-full p-3 border border-slate-300 rounded-xl focus:ring-2 focus:ring-indigo-500 focus:border-transparent outline-none",placeholder:"Enter email address"})]}),P.jsxs("div",{children:[P.jsx("label",{className:"block text-sm font-bold text-slate-700 mb-2",children:"Batch"}),P.jsx("input",{type:"text",value:m.batch,onChange:T=>g({...m,batch:T.target.value}),className:"w-full p-3 border border-slate-300 rounded-xl focus:ring-2 focus:ring-indigo-500 focus:border-transparent outline-none",placeholder:"Enter batch/class"})]}),P.jsxs("div",{className:"flex gap-3 pt-4",children:[P.jsx("button",{type:"button",onClick:()=>d(!1),className:"flex-1 bg-slate-100 text-slate-700 py-3 rounded-xl font-bold hover:bg-slate-200 transition-colors",children:"Cancel"}),P.jsxs("button",{type:"submit",disabled:r,className:"flex-1 bg-gradient-to-r from-indigo-600 to-purple-600 text-white py-3 rounded-xl font-bold hover:shadow-lg transition-all duration-200 flex items-center justify-center gap-2",children:[r?P.jsx(wv,{className:"w-4 h-4 animate-spin"}):P.jsx(JD,{className:"w-4 h-4"}),c?"Update":"Save"]})]})]})]})})]})},x$e=()=>{const[e,t]=he.useState(!1),[n,a]=he.useState([]),[r,s]=he.useState(""),[i,o]=he.useState(null),[u,d]=he.useState(null),[c,p]=he.useState(null),m=he.useRef(),g=he.useRef(),b=n.filter(w=>w.full_name.toLowerCase().includes(r.toLowerCase())||w.roll_number.toLowerCase().includes(r.toLowerCase()));he.useEffect(()=>{(async()=>{try{const k="/kap-academic-admin/models";await Promise.all([Fa.ssdMobilenetv1.loadFromUri(k),Fa.faceLandmark68Net.loadFromUri(k),Fa.faceRecognitionNet.loadFromUri(k)]);const{data:N}=await ir.from("students").select("*").order("id",{ascending:!1});a(N||[]),t(!0)}catch(k){console.error("Model Load Error:",k)}})()},[]),he.useEffect(()=>{e&&navigator.mediaDevices.getUserMedia({video:{}}).then(w=>{m.current&&(m.current.srcObject=w)}).catch(w=>{console.error("Camera Error:",w),p("Camera Access Denied. Please allow permission.")})},[e]);const v=()=>{setInterval(async()=>{if(m.current&&g.current){const w=await sj(m.current).withFaceLandmarks().withFaceDescriptor();if(w){d(w);const k={width:m.current.videoWidth,height:m.current.videoHeight};RU(g.current,k);const N=vT(w,k);g.current.getContext("2d").clearRect(0,0,g.current.width,g.current.height),uU.drawDetections(g.current,N)}else d(null),g.current.getContext("2d").clearRect(0,0,g.current.width,g.current.height)}},500)},x=async()=>{if(!u||!i)return alert("Select student & Ensure face is visible");const w=JSON.stringify(Array.from(u.descriptor)),{error:k}=await ir.from("students").update({face_descriptor:w}).eq("id",i.id);k?alert("Error saving data: "+k.message):(alert(` Face Enrolled for ${i.full_name}!`),a(n.filter(N=>N.id!==i.id)),o(null))};return P.jsxs("div",{className:"max-w-7xl mx-auto p-6 flex gap-8 h-screen",children:[P.jsxs("div",{className:"w-1/3 bg-white p-6 rounded-2xl shadow-xl border border-slate-200 flex flex-col ring-1 ring-slate-100/50",children:[P.jsxs("div",{className:"mb-6",children:[P.jsx("h2",{className:"font-bold text-2xl mb-2 bg-gradient-to-r from-slate-800 to-slate-600 bg-clip-text text-transparent",children:"Face Enrollment"}),P.jsx("p",{className:"text-slate-600 text-sm",children:"Students awaiting AI training"}),P.jsxs("div",{className:"relative mb-4",children:[P.jsx(ZD,{className:"absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-gray-400"}),P.jsx("input",{type:"text",placeholder:"Search student...",value:r,onChange:w=>s(w.target.value),className:"w-full pl-10 pr-4 py-2 bg-slate-50 border border-slate-200 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-blue-500/20 focus:border-blue-500 transition-all"})]})]}),P.jsx("div",{className:"overflow-y-auto flex-1 space-y-2",children:b.length===0?P.jsx("p",{className:"text-gray-400 text-sm p-4 text-center",children:r?"No matching students.":"No pending students found."}):b.map(w=>P.jsxs("div",{onClick:()=>o(w),className:`p-4 rounded-xl cursor-pointer transition border flex justify-between items-center ${i?.id===w.id?"bg-blue-600 text-white border-blue-600 shadow-md":"bg-gray-50 text-gray-700 border-transparent hover:bg-gray-100"}`,children:[P.jsxs("div",{children:[P.jsx("p",{className:"font-bold",children:w.full_name}),P.jsx("p",{className:`text-xs ${i?.id===w.id?"text-blue-100":"text-gray-400"}`,children:w.roll_number})]}),w.face_descriptor&&P.jsx(Pm,{className:`w-5 h-5 ${i?.id===w.id?"text-blue-200":"text-green-500"}`})]},w.id))})]}),P.jsxs("div",{className:"flex-1 flex flex-col",children:[P.jsxs("div",{className:"mb-8",children:[P.jsx("h1",{className:"text-4xl font-bold mb-2 bg-gradient-to-r from-slate-800 to-slate-600 bg-clip-text text-transparent",children:"AI Face Training"}),P.jsx("p",{className:"text-slate-600",children:"Train the neural network with student faces"})]}),P.jsxs("div",{className:"flex-1 bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 rounded-3xl overflow-hidden relative shadow-2xl border border-slate-700/50 ring-1 ring-white/10",children:[e?c?P.jsxs("div",{className:"absolute inset-0 flex flex-col items-center justify-center text-red-500",children:[P.jsx(_S,{className:"w-12 h-12 mb-4"}),P.jsx("p",{children:c})]}):P.jsxs(P.Fragment,{children:[P.jsx("video",{ref:m,autoPlay:!0,muted:!0,onPlay:v,width:"100%",height:"100%",className:"object-cover w-full h-full"}),P.jsx("canvas",{ref:g,className:"absolute top-0 left-0 w-full h-full"})]}):P.jsxs("div",{className:"absolute inset-0 flex flex-col items-center justify-center text-white",children:[P.jsx(wv,{className:"w-10 h-10 animate-spin mb-4 text-blue-500"}),P.jsx("p",{children:"Loading Neural Networks..."})]}),P.jsx("div",{className:"absolute bottom-8 left-0 right-0 flex justify-center",children:u?P.jsxs("button",{onClick:x,className:"bg-green-500 hover:bg-green-600 text-white px-8 py-4 rounded-full font-bold flex items-center gap-3 shadow-xl transform hover:scale-105 transition",children:[P.jsx(JD,{className:"w-6 h-6"})," Save Face Data"]}):P.jsxs("div",{className:"bg-white/10 backdrop-blur-md text-white px-6 py-3 rounded-full text-sm font-bold flex items-center gap-2 border border-white/20",children:[P.jsx(_S,{className:"w-4 h-4 text-yellow-400"})," Face Not Detected"]})})]}),i&&P.jsxs("div",{className:"mt-6 p-5 bg-blue-50 border border-blue-200 rounded-2xl flex items-center gap-4 animate-fade-in",children:[P.jsx("div",{className:"bg-blue-600 p-3 rounded-full text-white shadow-lg",children:P.jsx(Pm,{className:"w-6 h-6"})}),P.jsxs("div",{children:[P.jsx("p",{className:"text-xs text-blue-600 uppercase font-bold tracking-wider",children:"Ready to Train"}),P.jsx("h3",{className:"text-2xl font-bold text-gray-900",children:i.full_name})]})]})]})]})},w$e=()=>{const[e,t]=he.useState([]),[n,a]=he.useState(""),[r,s]=he.useState(null),[i,o]=he.useState(!1),[u,d]=he.useState("overview"),[c,p]=he.useState(new Date().toISOString().split("T")[0]),[m,g]=he.useState([]),[b,v]=he.useState(null);he.useEffect(()=>{(async()=>{const{data:T}=await ir.from("students").select("batch");if(T){const $=[...new Set(T.map(D=>D.batch).filter(Boolean))];t($)}})()},[]);const x=async()=>{if(!n)return;o(!0);const I=new Date().toISOString().split("T")[0];try{const{data:T}=await ir.from("students").select("*").eq("batch",n),{data:$}=await ir.from("gate_logs").select("roll_number").eq("date_only",I).eq("scan_type","IN"),D=$.map(V=>V.roll_number),M=[],B=[];T.forEach(V=>{D.includes(V.roll_number)?M.push(V):B.push(V)}),s({total:T.length,present:M,absent:B,percentage:Math.round(M.length/T.length*100)||0})}catch(T){console.error(T)}o(!1)},w=()=>{if(!r||r.absent.length===0)return alert("No absent students to export.");const I=["Roll Number","Student Name","Parent Phone","Batch"],T=r.absent.map(B=>[B.roll_number,B.full_name,B.phone,B.batch]);let $="data:text/csv;charset=utf-8,"+I.join(",")+`
`+T.map(B=>B.join(",")).join(`
`);const D=encodeURI($),M=document.createElement("a");M.setAttribute("href",D),M.setAttribute("download",`Absent_List_${n}_${new Date().toISOString().split("T")[0]}.csv`),document.body.appendChild(M),M.click()};he.useEffect(()=>{u==="logs"&&k()},[c,u]);const k=async()=>{o(!0);try{const{data:I}=await ir.from("gate_logs").select("*").eq("date_only",c).order("scan_time",{ascending:!1});g(I||[])}catch(I){console.error(I)}o(!1)},N=async(I,T)=>{o(!0);try{const{data:$}=await ir.from("gate_logs").select("*").eq("roll_number",I).order("date_only",{ascending:!1}).order("scan_time",{ascending:!1});v({name:T,logs:$||[]}),d("student_history")}catch($){console.error($)}o(!1)};return P.jsxs("div",{className:"max-w-6xl mx-auto pb-20",children:[P.jsxs("div",{className:"mb-8 flex justify-between items-end",children:[P.jsxs("div",{children:[P.jsx("h1",{className:"text-4xl font-bold bg-gradient-to-r from-slate-800 to-slate-600 bg-clip-text text-transparent",children:"Attendance Analytics"}),P.jsx("p",{className:"text-slate-600 mt-2",children:"Real-time batch performance insights"})]}),P.jsxs("div",{className:"flex bg-slate-100 p-1 rounded-xl",children:[P.jsx("button",{onClick:()=>d("overview"),className:`px-6 py-2 rounded-lg text-sm font-bold transition ${u==="overview"?"bg-white text-indigo-600 shadow-sm":"text-slate-500 hover:text-slate-700"}`,children:"Overview"}),P.jsx("button",{onClick:()=>d("logs"),className:`px-6 py-2 rounded-lg text-sm font-bold transition ${u==="logs"?"bg-white text-indigo-600 shadow-sm":"text-slate-500 hover:text-slate-700"}`,children:"Daily Logs"})]})]}),u==="overview"?P.jsxs(P.Fragment,{children:[P.jsxs("div",{className:"bg-white p-8 rounded-2xl shadow-lg border border-slate-200 mb-8 flex gap-6 items-end ring-1 ring-slate-100/50",children:[P.jsxs("div",{className:"flex-1",children:[P.jsx("label",{className:"block text-xs font-bold text-slate-500 uppercase mb-2",children:"Select Batch"}),P.jsxs("select",{className:"w-full p-3 border rounded-lg bg-slate-50 font-bold text-slate-700 outline-none focus:ring-2 focus:ring-indigo-500",value:n,onChange:I=>a(I.target.value),children:[P.jsx("option",{value:"",children:"-- Choose Batch --"}),e.map(I=>P.jsx("option",{value:I,children:I},I))]})]}),P.jsx("button",{onClick:x,className:"bg-gradient-to-r from-indigo-600 to-purple-600 text-white px-8 py-3 rounded-xl font-bold hover:shadow-xl transition-all duration-200 h-[50px] shadow-lg hover:scale-105",children:i?"Analyzing...":"Get Report"})]}),r&&P.jsxs("div",{className:"grid grid-cols-1 lg:grid-cols-3 gap-8",children:[P.jsxs("div",{className:"bg-white p-6 rounded-2xl shadow-lg border border-slate-100 text-center lg:col-span-1",children:[P.jsx("h3",{className:"text-gray-500 font-bold uppercase text-xs mb-6",children:"Attendance Overview"}),P.jsxs("div",{className:"relative w-48 h-48 mx-auto mb-6 rounded-full border-[16px] border-slate-100 flex items-center justify-center",children:[P.jsx("div",{className:"absolute inset-0 rounded-full border-[16px] border-green-500",style:{clipPath:`polygon(0 0, 100% 0, 100% ${r.percentage}%, 0 ${r.percentage}%)`}}),P.jsxs("div",{children:[P.jsxs("span",{className:"text-4xl font-extrabold text-slate-800",children:[r.percentage,"%"]}),P.jsx("p",{className:"text-xs text-slate-400",children:"Present"})]})]}),P.jsxs("div",{className:"flex justify-between px-4",children:[P.jsxs("div",{className:"text-center",children:[P.jsx("p",{className:"text-2xl font-bold text-green-600",children:r.present.length}),P.jsx("p",{className:"text-xs font-bold text-gray-400",children:"PRESENT"})]}),P.jsxs("div",{className:"text-center",children:[P.jsx("p",{className:"text-2xl font-bold text-red-500",children:r.absent.length}),P.jsx("p",{className:"text-xs font-bold text-gray-400",children:"ABSENT"})]})]})]}),P.jsxs("div",{className:"bg-white rounded-2xl shadow-lg border border-red-100 lg:col-span-2 overflow-hidden flex flex-col h-[400px]",children:[P.jsxs("div",{className:"bg-red-50 px-6 py-4 border-b border-red-100 flex justify-between items-center",children:[P.jsxs("h3",{className:"font-bold text-red-800 flex items-center gap-2",children:[P.jsx(kH,{className:"w-5 h-5"})," Absent Students (",r.absent.length,")"]}),P.jsxs("button",{onClick:w,className:"text-xs bg-white text-red-600 px-3 py-2 rounded-lg font-bold shadow-sm flex items-center gap-2 hover:bg-red-100 transition",children:[P.jsx(NH,{className:"w-4 h-4"})," Export CSV"]})]}),P.jsx("div",{className:"overflow-y-auto flex-1 divide-y divide-slate-100",children:r.absent.map(I=>P.jsxs("div",{className:"p-4 flex justify-between items-center hover:bg-red-50/30 transition",children:[P.jsxs("div",{className:"cursor-pointer",onClick:()=>N(I.roll_number,I.full_name),children:[P.jsx("p",{className:"font-bold text-slate-800 hover:text-blue-600 underline decoration-dotted underline-offset-4",children:I.full_name}),P.jsxs("p",{className:"text-xs text-slate-400",children:["Roll: ",I.roll_number]})]}),P.jsx("div",{className:"text-right",children:P.jsxs("p",{className:"text-sm font-bold text-slate-600 flex items-center justify-end gap-2",children:[P.jsx(YD,{className:"w-3 h-3 text-slate-400"})," ",I.phone]})})]},I.id))})]})]})]}):u==="logs"?P.jsxs("div",{className:"bg-white rounded-2xl shadow-lg border border-slate-200 overflow-hidden",children:[P.jsxs("div",{className:"p-6 border-b border-slate-100 flex justify-between items-center bg-slate-50/50",children:[P.jsxs("div",{children:[P.jsx("h2",{className:"text-lg font-bold text-slate-800",children:"Daily Logs"}),P.jsx("p",{className:"text-xs text-slate-500",children:"Full timeline of student entries/exits"})]}),P.jsx("div",{children:P.jsx("input",{type:"date",value:c,onChange:I=>p(I.target.value),className:"p-2 border rounded-lg bg-white font-bold text-slate-600 text-sm shadow-sm outline-none focus:ring-2 focus:ring-indigo-500"})})]}),P.jsx("div",{className:"overflow-x-auto",children:P.jsxs("table",{className:"w-full text-sm text-left",children:[P.jsx("thead",{className:"bg-slate-50 text-slate-500 font-bold uppercase text-xs",children:P.jsxs("tr",{children:[P.jsx("th",{className:"px-6 py-4",children:"Time"}),P.jsx("th",{className:"px-6 py-4",children:"Student Name"}),P.jsx("th",{className:"px-6 py-4",children:"Roll Number"}),P.jsx("th",{className:"px-6 py-4",children:"Status"})]})}),P.jsx("tbody",{className:"divide-y divide-slate-100",children:m.length===0?P.jsx("tr",{children:P.jsx("td",{colSpan:"4",className:"p-8 text-center text-slate-400",children:"No logs found for this date."})}):m.map(I=>P.jsxs("tr",{className:"hover:bg-slate-50/50 transition",children:[P.jsx("td",{className:"px-6 py-4 font-mono text-slate-500",children:I.scan_time}),P.jsx("td",{className:"px-6 py-4 font-bold text-slate-800 cursor-pointer hover:text-blue-600 underline decoration-dotted underline-offset-4",onClick:()=>N(I.roll_number,I.student_name),children:I.student_name}),P.jsx("td",{className:"px-6 py-4 text-slate-500",children:I.roll_number}),P.jsx("td",{className:"px-6 py-4",children:P.jsx("span",{className:`px-3 py-1 rounded-full text-[10px] font-bold tracking-wider ${I.scan_type==="IN"?"bg-green-100 text-green-700":"bg-red-100 text-red-700"}`,children:I.scan_type})})]},I.id))})]})})]}):P.jsxs("div",{className:"bg-white rounded-2xl shadow-lg border border-slate-200 overflow-hidden",children:[P.jsx("div",{className:"p-6 border-b border-slate-100 flex justify-between items-center bg-slate-50/50",children:P.jsxs("div",{children:[P.jsxs("div",{className:"flex items-center gap-2 mb-1",children:[P.jsx("button",{onClick:()=>d("logs"),className:"text-xs bg-white border px-2 py-1 rounded hover:bg-gray-50",children:" Back"}),P.jsx("h2",{className:"text-lg font-bold text-slate-800",children:"Student History"})]}),P.jsx("h3",{className:"text-2xl font-black text-blue-600",children:b?.name})]})}),P.jsx("div",{className:"overflow-x-auto",children:P.jsxs("table",{className:"w-full text-sm text-left",children:[P.jsx("thead",{className:"bg-slate-50 text-slate-500 font-bold uppercase text-xs",children:P.jsxs("tr",{children:[P.jsx("th",{className:"px-6 py-4",children:"Date"}),P.jsx("th",{className:"px-6 py-4",children:"Time"}),P.jsx("th",{className:"px-6 py-4",children:"Status"})]})}),P.jsx("tbody",{className:"divide-y divide-slate-100",children:b?.logs.length===0?P.jsx("tr",{children:P.jsx("td",{colSpan:"3",className:"p-8 text-center text-slate-400",children:"No history found."})}):b?.logs.map(I=>P.jsxs("tr",{className:"hover:bg-slate-50/50 transition",children:[P.jsx("td",{className:"px-6 py-4 font-mono text-slate-600 bg-slate-50/30",children:I.date_only}),P.jsx("td",{className:"px-6 py-4 font-mono text-slate-500",children:I.scan_time}),P.jsx("td",{className:"px-6 py-4",children:P.jsx("span",{className:`px-3 py-1 rounded-full text-[10px] font-bold tracking-wider ${I.scan_type==="IN"?"bg-green-100 text-green-700":"bg-red-100 text-red-700"}`,children:I.scan_type})})]},I.id))})]})})]})]})},S$e=()=>{const e=gl(),t=a=>e.pathname===a,n=a=>`
    flex items-center gap-2 px-4 py-2 rounded-full transition-all duration-300 font-medium text-sm
    ${t(a)?"bg-blue-600/10 text-blue-400 border border-blue-600/20 shadow-[0_0_15px_rgba(37,99,235,0.15)]":"text-neutral-400 hover:bg-white/5 hover:text-white border border-transparent"}
  `;return P.jsxs("div",{className:"fixed top-0 left-0 right-0 h-20 bg-gradient-to-r from-slate-950 via-[#0a1020] to-[#0f172a] backdrop-blur-md border-b border-white/5 z-50 px-8 flex items-center justify-between shadow-2xl",children:[P.jsx("div",{className:"flex items-center gap-4",children:P.jsx("div",{className:"bg-white rounded-lg p-1.5 shadow-lg border border-white/10 w-32 h-12 flex items-center justify-center",children:P.jsx("img",{src:"/kap-academic-admin/kap-logo.png",alt:"KAP Edutech",className:"w-full h-full object-contain"})})}),P.jsxs("nav",{className:"flex items-center gap-2 bg-white/5 p-1 rounded-full border border-white/5",children:[P.jsxs(Ih,{to:"/",className:n("/"),children:[P.jsx(zH,{className:"w-4 h-4"}),P.jsx("span",{children:"Smart Gate"})]}),P.jsxs(Ih,{to:"/students",className:n("/students"),children:[P.jsx(NS,{className:"w-4 h-4"}),P.jsx("span",{children:"Students & IDs"})]}),P.jsxs(Ih,{to:"/enroll",className:n("/enroll"),children:[P.jsx(KH,{className:"w-4 h-4"}),P.jsx("span",{children:"AI Enrollment"})]}),P.jsxs(Ih,{to:"/reports",className:n("/reports"),children:[P.jsx(wH,{className:"w-4 h-4"}),P.jsx("span",{children:"Reports"})]})]}),P.jsxs("div",{className:"flex items-center gap-3",children:[P.jsxs("div",{className:"flex flex-col items-end",children:[P.jsx("span",{className:"text-white font-bold text-sm tracking-wide",children:"Admin Portal"}),P.jsxs("div",{className:"flex items-center gap-1.5",children:[P.jsx("div",{className:"w-1.5 h-1.5 rounded-full bg-emerald-500 animate-pulse"}),P.jsx("span",{className:"text-[10px] text-emerald-500 font-medium uppercase tracking-wider",children:"System Online"})]})]}),P.jsx("div",{className:"w-10 h-10 bg-indigo-600 rounded-full flex items-center justify-center border border-white/10 shadow-lg",children:P.jsx(TH,{className:"w-5 h-5 text-white"})})]})]})};function k$e(){return P.jsx(aH,{basename:"/kap-academic-admin/",children:P.jsxs("div",{className:"min-h-screen bg-slate-50",children:[P.jsx(S$e,{}),P.jsx("div",{className:"pt-20 px-4 pb-4 md:pt-24 md:px-8 md:pb-8",children:P.jsxs(D6,{children:[P.jsx(Tm,{path:"/",element:P.jsx(b$e,{})}),P.jsx(Tm,{path:"/students",element:P.jsx(v$e,{})}),P.jsx(Tm,{path:"/enroll",element:P.jsx(x$e,{})}),P.jsx(Tm,{path:"/reports",element:P.jsx(w$e,{})})," "]})})]})})}MV.createRoot(document.getElementById("root")).render(P.jsx(he.StrictMode,{children:P.jsx(k$e,{})}));
